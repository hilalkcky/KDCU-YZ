python,cpp
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
         left = 0
         right = len(nums)
         while left < right:
             if target-nums[left] in nums and nums.index(target-nums[left]) != left:
                 return [left,nums.index(target-nums[left])]
             else:
                 left+=1","class Solution {
 public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* curr = &dummy;
    int carry = 0;

    while (l1 || l2 || carry) {
      if (l1 != nullptr) {
        carry += l1->val;
        l1 = l1->next;
      }
      if (l2 != nullptr) {
        carry += l2->val;
        l2 = l2->next;
      }
      curr->next = new ListNode(carry % 10);
      carry /= 10;
      curr = curr->next;
    }

    return dummy.next;
  }
};"
"class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        i, j = 0, 0
        n = len(s)
        frequencyArray = [0]*(5 * 10**4)
        maxSize = 0
        while j < n:
            frequencyArray[ord(s[j]) - ord('a')] += 1
            mapSize = (5*10**4) - frequencyArray.count(0)
            
            if mapSize == j - i + 1:
                maxSize = max(maxSize, j - i + 1)
                j += 1
            
            elif mapSize < j - i + 1:
                while mapSize < j - i + 1:
                    frequencyArray[ord(s[i]) - ord('a')] -= 1
                    mapSize = (5*10**4) - frequencyArray.count(0)
                    i += 1
                j += 1
        return maxSize","class Solution {
 public:
  int lengthOfLongestSubstring(string s) {
    int ans = 0;
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      ++count[s[r]];
      while (count[s[r]] > 1)
        --count[s[l++]];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};"
"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        sum_list = nums1 + nums2
        sum_list.sort()
        sum_size = len(sum_list)

        if sum_size % 2 == 0:
            x = (sum_list[int(sum_size/2)] + sum_list[int((sum_size/2) - 1)]) / 2
        else:
            x = sum_list[int(sum_size/2)]

        return x","class Solution {
 public:
  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    const int n1 = nums1.size();
    const int n2 = nums2.size();
    if (n1 > n2)
      return findMedianSortedArrays(nums2, nums1);

    int l = 0;
    int r = n1;

    while (l <= r) {
      const int partition1 = (l + r) / 2;
      const int partition2 = (n1 + n2 + 1) / 2 - partition1;
      const int maxLeft1 = partition1 == 0 ? INT_MIN : nums1[partition1 - 1];
      const int maxLeft2 = partition2 == 0 ? INT_MIN : nums2[partition2 - 1];
      const int minRight1 = partition1 == n1 ? INT_MAX : nums1[partition1];
      const int minRight2 = partition2 == n2 ? INT_MAX : nums2[partition2];
      if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1)
        return (n1 + n2) % 2 == 0
                   ? (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5
                   : max(maxLeft1, maxLeft2);
      else if (maxLeft1 > minRight2)
        r = partition1 - 1;
      else
        l = partition1 + 1;
    }

    throw;
  }
};"
"class Solution:
    def longestPalindrome(self, s: str) -> str:
        self.res = """";
        self.resLen = 0;
        for i in range(len(s)):
            self.getPalindrome(s,i,i);
            self.getPalindrome(s,i,i+1);
        return self.res;
    def getPalindrome(self,s,l,r):
        while l >= 0 and r < len(s) and s[l] == s[r]:
            if (r - l + 1) > self.resLen:
                self.res = s[l:r+1];
                self.resLen = len(self.res);
            l -= 1;
            r += 1;","class Solution {
 public:
  string longestPalindrome(string s) {
    if (s.empty())
      return """";

    // [start, end] indices of the longest palindrome in s
    pair<int, int> indices{0, 0};

    for (int i = 0; i < s.length(); ++i) {
      const auto [l1, r1] = extend(s, i, i);
      if (r1 - l1 > indices.second - indices.first)
        indices = {l1, r1};
      if (i + 1 < s.length() && s[i] == s[i + 1]) {
        const auto [l2, r2] = extend(s, i, i + 1);
        if (r2 - l2 > indices.second - indices.first)
          indices = {l2, r2};
      }
    }

    return s.substr(indices.first, indices.second - indices.first + 1);
  }

 private:
  // Returns [start, end] indices of the longest palindrome extended from
  // s[i..j]
  pair<int, int> extend(const string& s, int i, int j) {
    for (; i >= 0 && j < s.length(); --i, ++j)
      if (s[i] != s[j])
        break;
    return {i + 1, j - 1};
  }
};"
"class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        a = ['' for i in range(numRows)]
        c = numRows
        inc = False
        for i in s:
            a[numRows-c] += i # If numRows = 3, the range of numRows-c is [0, 2] as c is in the range of [1, 3]
            if not inc:
                c -= 1
                if c == 1:
                    inc = True
            else:
                c += 1
                if c == numRows:
                    inc = False
        return ''.join(a)","class Solution {
 public:
  string convert(string s, int numRows) {
    string ans;
    vector<vector<char>> rows(numRows);
    int k = 0;
    int direction = (numRows == 1) - 1;

    for (const char c : s) {
      rows[k].push_back(c);
      if (k == 0 || k == numRows - 1)
        direction *= -1;
      k += direction;
    }

    for (const vector<char>& row : rows)
      for (const char c : row)
        ans += c;

    return ans;
  }
};"
"class Solution:
    def reverse(self, x: int) -> int:
        reverse = 0
        num, x = x, abs(x)
        while x:
            last = x % 10
            x //= 10
            reverse = reverse * 10 + last
            if not (reverse <= 2 ** 31 and reverse >= -2 ** 31):
                return 0
            
        return reverse if num > 0 else -reverse","class Solution {
 public:
  int reverse(int x) {
    long ans = 0;

    while (x) {
      ans = ans * 10 + x % 10;
      x /= 10;
    }

    return (ans < INT_MIN || ans > INT_MAX) ? 0 : ans;
  }
};"
"class Solution:
    def myAtoi(self, s: str) -> int:
        s= s.strip("" "")
        if len(s) == 0:return 0
        s = list(s)
        sign = 1
        
        if s[0] == ""-"":
            sign = -1
            s.pop(0) # Removing the sign from the first term 
        elif s[0] == ""+"":
            sign = 1
            s.pop(0)
        else:
            pass
        
        if len(s) > 2 and not s[0].isdigit():
            return 0
        _ = ""0""
        
        for i in s:
            if i.isdigit():
                _+=i
            else:
                break
                
        return_val = int(_) * sign
        
        if return_val < -2147483648:
            return -2147483648
        
        elif return_val > 2147483647:
            return 2147483647
        
        else:
            return return_val","class Solution {
 public:
  int myAtoi(string s) {
    trim(s);
    if (s.empty())
      return 0;

    const int sign = s[0] == '-' ? -1 : 1;
    if (s[0] == '+' || s[0] == '-')
      s = s.substr(1);

    long num = 0;

    for (const char c : s) {
      if (!isdigit(c))
        break;
      num = num * 10 + (c - '0');
      if (sign * num < INT_MIN)
        return INT_MIN;
      if (sign * num > INT_MAX)
        return INT_MAX;
    }

    return sign * num;
  }

 private:
  void trim(string& s) {
    s.erase(0, s.find_first_not_of(' '));
    s.erase(s.find_last_not_of(' ') + 1);
  }
};"
"class Solution:
    def isPalindrome(self, x: int) -> bool:
        y = list(str(x))
        return y== list(reversed(y))","class Solution {
 public:
  bool isPalindrome(int x) {
    if (x < 0)
      return false;

    long reversed = 0;
    int y = x;

    while (y) {
      reversed = reversed * 10 + y % 10;
      y /= 10;
    }

    return reversed == x;
  }
};"
"class Solution:
    @lru_cache
    def isMatch(self, s, p):
        if not p:   return not s
        if p[-1] == '*':
            return (self.isMatch(s, p[:-2])) or (s and (s[-1] == p[-2] or p[-2] == '.') and self.isMatch(s[:-1], p))
        return s and (p[-1] == s[-1] or p[-1] == '.') and self.isMatch(s[:-1], p[:-1])","class Solution {
 public:
  bool isMatch(string s, string p) {
    const int m = s.length();
    const int n = p.length();
    // dp[i][j] := true if s[0..i) matches p[0..j)
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
    dp[0][0] = true;

    auto isMatch = [&](int i, int j) -> bool {
      return j >= 0 && p[j] == '.' || s[i] == p[j];
    };

    for (int j = 0; j < p.length(); ++j)
      if (p[j] == '*' && dp[0][j - 1])
        dp[0][j + 1] = true;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (p[j] == '*') {
          const bool noRepeat = dp[i + 1][j - 1];  // Min index of '*' is 1
          const bool doRepeat = isMatch(i, j - 1) && dp[i][j + 1];
          dp[i + 1][j + 1] = noRepeat || doRepeat;
        } else if (isMatch(i, j)) {
          dp[i + 1][j + 1] = dp[i][j];
        }

    return dp[m][n];
  }
};"
"class Solution:
    def maxArea(self, height: List[int]) -> int:
        """"""Uses two pointers. 
        Left pointer starts with 0th index and
        Right pointer starts at last index.
        Calculate the area and update if greater than
        area variable.
        If heigh[right] is greater than heigh[left], increment
        left, otherwise decrement right.
        """"""
        area = 0
        left = 0
        right = len(height) -1
        while left < right:
            side = min(height[left], height[right])
            width = right - left
            area = max(side * width, area)
            if height[right] > height[left]:
                left += 1
            else:
                right -= 1
        return area","class Solution {
 public:
  int maxArea(vector<int>& height) {
    int ans = 0;
    int l = 0;
    int r = height.size() - 1;

    while (l < r) {
      const int minHeight = min(height[l], height[r]);
      ans = max(ans, minHeight * (r - l));
      if (height[l] < height[r])
        ++l;
      else
        --r;
    }

    return ans;
  }
};"
"class Solution:
    def intToRoman(self, num: int) -> str:
        """"""
        Symbol       Value
        I             1     ones
        V             5     ones
        X             10    tens
        L             50    tens
        C             100   hundreds
        D             500   hundreds
        M             1000  thousands
        """"""
        # mode the number to get digits
        # based on the digits, append the letter to the ans
        # reverse the ans or use dequeue()
        letters = [[""I"", ""IV"", ""V"", ""IX""],
                  [""X"", ""XL"", ""L"", ""XC""],
                  [""C"", ""CD"", ""D"", ""CM""],
                  [""M"","""","""",""""]]
        place = 0 # value place. 0-> ones, 1->tens
        ans = deque()
        while num > 0:
            digit = num % 10            
            num //= 10
            lt = letters[place]
            if digit < 4:
                ans.appendleft(lt[0]*digit)
            elif digit == 4:
                ans.appendleft(lt[1])
            elif digit < 9:
                ans.appendleft(lt[2]+lt[0]*(digit-5))      
            elif digit == 9:
                ans.appendleft(lt[3])
            place += 1
        return """".join(ans)","class Solution {
 public:
  string intToRoman(int num) {
    const vector<pair<int, string>> valueSymbols{
        {1000, ""M""}, {900, ""CM""}, {500, ""D""}, {400, ""CD""}, {100, ""C""},
        {90, ""XC""},  {50, ""L""},   {40, ""XL""}, {10, ""X""},   {9, ""IX""},
        {5, ""V""},    {4, ""IV""},   {1, ""I""}};
    string ans;

    for (const auto& [value, symbol] : valueSymbols) {
      if (num == 0)
        break;
      while (num >= value) {
        num -= value;
        ans += symbol;
      }
    }

    return ans;
  }
};"
"class Solution:
    def romanToInt(self, s: str) -> int:
        dic={""I"":1, ""V"":5, ""X"":10, ""L"":50, ""C"":100, ""D"":500, ""M"":1000 }
        m,total=dic[s[0]],0
        for i in s:
            n=dic[i]
            total = (total- 2*m + n) if(m<n) else (total+ n)
            m=n
        return total","class Solution {
 public:
  int romanToInt(string s) {
    int ans = 0;
    vector<int> roman(128);

    roman['I'] = 1;
    roman['V'] = 5;
    roman['X'] = 10;
    roman['L'] = 50;
    roman['C'] = 100;
    roman['D'] = 500;
    roman['M'] = 1000;

    for (int i = 0; i + 1 < s.length(); ++i)
      if (roman[s[i]] < roman[s[i + 1]])
        ans -= roman[s[i]];
      else
        ans += roman[s[i]];

    return ans + roman[s.back()];
  }
};"
"class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        result = """"
        
        strs.sort()
        
		# Loop over the characters in the first index of the array
        for char in range(len(strs[0])):
		
			#If the character is the same in both the first and last string at the same index, append to result and continue with the loop.
            if strs[0][char] == strs[-1][char]:
                result += strs[0][char]
                continue
            else:
				# Break out of the loop here.  Personally, I find this this easier to read, could also just return the result.
                break
                
        return result","class Solution {
 public:
  string longestCommonPrefix(vector<string>& strs) {
    if (strs.empty())
      return """";

    for (int i = 0; i < strs[0].length(); ++i)
      for (int j = 1; j < strs.size(); ++j)
        if (i == strs[j].length() || strs[j][i] != strs[0][i])
          return strs[0].substr(0, i);

    return strs[0];
  }
};"
"class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        levels = []
        
        def order(node, level):
            if level >= len(levels):
                levels.append([])
            
            if node:
                levels[level].append(node.val)
            
                if node.left:
                    order(node.left, level + 1)
                
                if node.right:
                    order(node.right, level + 1)
        
        if not root:
            return []
        
        order(root, 0)
        return levels","class Solution {
 public:
  vector<vector<int>> threeSum(vector<int>& nums) {
    if (nums.size() < 3)
      return {};

    vector<vector<int>> ans;

    sort(begin(nums), end(nums));

    for (int i = 0; i + 2 < nums.size(); ++i) {
      if (i > 0 && nums[i] == nums[i - 1])
        continue;
      // Choose nums[i] as the first num in the triplet,
      // and search the remaining nums in [i + 1, n - 1]
      int l = i + 1;
      int r = nums.size() - 1;
      while (l < r) {
        const int sum = nums[i] + nums[l] + nums[r];
        if (sum == 0) {
          ans.push_back({nums[i], nums[l++], nums[r--]});
          while (l < r && nums[l] == nums[l - 1])
            ++l;
          while (l < r && nums[r] == nums[r + 1])
            --r;
        } else if (sum < 0) {
          ++l;
        } else {
          --r;
        }
      }
    }

    return ans;
  }
};"
"class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return root
        q = [root]
        level = []
        res = [[root.val]]
        x = 0
        while q and root:
            for node in q:
                if node.left:
                    level.append(node.left)
                if node.right:
                    level.append(node.right)
            temp = []
            for i in level:
                temp.append(i.val)
            x += 1
            if temp:
                if x % 2 != 0:
                    res.append(temp[::-1])
                else:
                    res.append(temp)
            q = level
            level = []
        return res","class Solution {
 public:
  int threeSumClosest(vector<int>& nums, int target) {
    int ans = nums[0] + nums[1] + nums[2];

    sort(begin(nums), end(nums));

    for (int i = 0; i + 2 < nums.size(); ++i) {
      if (i > 0 && nums[i] == nums[i - 1])
        continue;
      // Choose nums[i] as the first num in the triplet,
      // and search the remaining nums in [i + 1, n - 1]
      int l = i + 1;
      int r = nums.size() - 1;
      while (l < r) {
        const int sum = nums[i] + nums[l] + nums[r];
        if (sum == target)
          return sum;
        if (abs(sum - target) < abs(ans - target))
          ans = sum;
        if (sum < target)
          ++l;
        else
          --r;
      }
    }

    return ans;
  }
};"
"class Solution:

    def maxDepth(self, root: Optional[TreeNode]):
        queue = []
        height = 0
        if not root:
            return 0
        queue.append(root)

        while queue:
            current_length = len(queue)
            height += 1
            for _ in range(0, current_length):
                popped_elem = queue.pop(0)
                if popped_elem.left:
                    queue.append(popped_elem.left)
                if popped_elem.right:
                    queue.append(popped_elem.right)

        return height","class Solution {
 public:
  vector<string> letterCombinations(string digits) {
    if (digits.empty())
      return {};

    vector<string> ans;

    dfs(digits, 0, """", ans);
    return ans;
  }

 private:
  const vector<string> digitToLetters{"""",    """",    ""abc"",  ""def"", ""ghi"",
                                      ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""};

  void dfs(const string& digits, int i, string&& path, vector<string>& ans) {
    if (i == digits.length()) {
      ans.push_back(path);
      return;
    }

    for (const char letter : digitToLetters[digits[i] - '0']) {
      path.push_back(letter);
      dfs(digits, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};"
"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        def buildTree(preorder, inorder):
            if inorder:
                root = TreeNode(preorder.pop(0))
                root_index = inorder.index(root.val)
                root.left = buildTree(preorder,inorder[:root_index])
                root.right = buildTree(preorder,inorder[root_index+1:])
                return root
        return buildTree(preorder, inorder)","class Solution {
 public:
  vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> ans;
    vector<int> path;
    sort(begin(nums), end(nums));
    nSum(nums, 4, target, 0, nums.size() - 1, path, ans);
    return ans;
  }

 private:
  // In [l, r], find n numbers add up to the target
  void nSum(const vector<int>& nums, long n, long target, int l, int r,
            vector<int>& path, vector<vector<int>>& ans) {
    if (r - l + 1 < n || target < nums[l] * n || target > nums[r] * n)
      return;
    if (n == 2) {
      // Similar to the sub procedure in 15. 3Sum
      while (l < r) {
        const int sum = nums[l] + nums[r];
        if (sum == target) {
          path.push_back(nums[l]);
          path.push_back(nums[r]);
          ans.push_back(path);
          path.pop_back();
          path.pop_back();
          ++l;
          --r;
          while (l < r && nums[l] == nums[l - 1])
            ++l;
          while (l < r && nums[r] == nums[r + 1])
            --r;
        } else if (sum < target) {
          ++l;
        } else {
          --r;
        }
      }
      return;
    }

    for (int i = l; i <= r; ++i) {
      if (i > l && nums[i] == nums[i - 1])
        continue;
      path.push_back(nums[i]);
      nSum(nums, n - 1, target - nums[i], i + 1, r, path, ans);
      path.pop_back();
    }
  }
};"
"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        m = {}
        for i in range(len(inorder)):
            m[inorder[i]] = i
            
        def helper(in_l, in_r, inorder, po_l, po_r, postorder):
            if po_l >= po_r:
                return TreeNode(postorder[po_r])
            curr = TreeNode(postorder[po_r])
            idx = m[postorder[po_r]]
            num_right_tree = in_r - idx
            num_left_tree = idx - in_l
            if num_right_tree > 0:
                curr.right = helper(idx+1, in_r, inorder, po_r-num_right_tree, po_r-1, postorder)
            if num_left_tree > 0:
                curr.left = helper(in_l, idx-1, inorder, po_l, po_l+num_left_tree-1, postorder)
            return curr
        
        return helper(0, len(inorder)-1, inorder, 0, len(postorder)-1, postorder)","class Solution {
 public:
  ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (n--)
      fast = fast->next;
    if (fast == nullptr)
      return head->next;

    while (fast->next) {
      slow = slow->next;
      fast = fast->next;
    }
    slow->next = slow->next->next;

    return head;
  }
};"
"class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if root is None: return
        queue = deque([root])
        op = []
        while queue:
            level = []
            for i in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            op.append(level)
        return op[::-1]","class Solution {
 public:
  bool isValid(string s) {
    stack<char> stack;

    for (const char c : s)
      if (c == '(')
        stack.push(')');
      else if (c == '{')
        stack.push('}');
      else if (c == '[')
        stack.push(']');
      else if (stack.empty() || pop(stack) != c)
        return false;

    return stack.empty();
  }

 private:
  int pop(stack<char>& stack) {
    const int c = stack.top();
    stack.pop();
    return c;
  }
};"
"class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:

        def recur(start, end):
            if end < start:
                return None
            mid = floor((start+end)/2)
            node = TreeNode(nums[mid])
            node.left = recur(start, mid-1)
            node.right = recur(mid+1, end)
            return node
        
        return recur(0, len(nums)-1)","class Solution {
 public:
  ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if (!list1 || !list2)
      return list1 ? list1 : list2;
    if (list1->val > list2->val)
      swap(list1, list2);
    list1->next = mergeTwoLists(list1->next, list2);
    return list1;
  }
};"
"class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        if not head or not head.next:
            return TreeNode(head.val) if head else None
			
        slow, fast = head, head.next
        while fast.next and fast.next.next:
            slow, fast = slow.next, fast.next.next
        fast, slow.next = slow.next, None
		
        node = TreeNode(fast.val)
        node.left = self.sortedListToBST(head)
        node.right = self.sortedListToBST(fast.next)
        return node","class Solution {
 public:
  vector<string> generateParenthesis(int n) {
    vector<string> ans;
    dfs(n, n, """", ans);
    return ans;
  }

 private:
  void dfs(int l, int r, string&& path, vector<string>& ans) {
    if (l == 0 && r == 0) {
      ans.push_back(path);
      return;
    }

    if (l > 0) {
      path.push_back('(');
      dfs(l - 1, r, move(path), ans);
      path.pop_back();
    }
    if (l < r) {
      path.push_back(')');
      dfs(l, r - 1, move(path), ans);
      path.pop_back();
    }
  }
};"
"class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        
        if not root:
            return True
        
        def recur(node, level):
            if not node:
                return level-1
            left = recur(node.left, level+1)
            right = recur(node.right, level+1)
            if not left or not right:
                return 0
            if abs(left-right) > 1:
                return 0
            return max(left, right)
        
        level = recur(root, 1)
        
        if not level:
            return False
        return True","class Solution {
 public:
  ListNode* mergeKLists(vector<ListNode*>& lists) {
    ListNode dummy(0);
    ListNode* curr = &dummy;
    auto compare = [](ListNode* a, ListNode* b) { return a->val > b->val; };
    priority_queue<ListNode*, vector<ListNode*>, decltype(compare)> minHeap(
        compare);

    for (ListNode* list : lists)
      if (list != nullptr)
        minHeap.push(list);

    while (!minHeap.empty()) {
      ListNode* minNode = minHeap.top();
      minHeap.pop();
      if (minNode->next)
        minHeap.push(minNode->next);
      curr->next = minNode;
      curr = curr->next;
    }

    return dummy.next;
  }
};"
"class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        import queue
        if not root:
            return 0

        q = queue.Queue()
        q.put((1, root))
        while not q.empty():
            level, node = q.get()
            if not node.left and not node.right:
                return level
            
            if node.left:
                q.put((level+1, node.left))
                
            if node.right:
                q.put((level+1, node.right))","class Solution {
 public:
  ListNode* swapPairs(ListNode* head) {
    const int length = getLength(head);
    ListNode dummy(0, head);
    ListNode* prev = &dummy;
    ListNode* curr = head;

    for (int i = 0; i < length / 2; ++i) {
      ListNode* next = curr->next;
      curr->next = next->next;
      next->next = prev->next;
      prev->next = next;
      prev = curr;
      curr = curr->next;
    }

    return dummy.next;
  }

 private:
  int getLength(ListNode* head) {
    int length = 0;
    for (ListNode* curr = head; curr; curr = curr->next)
      ++length;
    return length;
  }
};"
"class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        f = False
        def util(root, c):
            nonlocal f
            if root:
                c += root.val
                util(root.left, c)
                util(root.right, c)
                if not root.left and not root.right and c == targetSum:
                    f= True
        util(root, 0)
        return f","class Solution {
 public:
  ListNode* reverseKGroup(ListNode* head, int k) {
    if (head == nullptr)
      return nullptr;

    ListNode* tail = head;

    for (int i = 0; i < k; ++i) {
      if (tail == nullptr)  // Less than k nodes, do nothing
        return head;
      tail = tail->next;
    }

    ListNode* newHead = reverse(head, tail);
    head->next = reverseKGroup(tail, k);
    return newHead;
  }

 private:
  // Reverses [head, tail)
  ListNode* reverse(ListNode* head, ListNode* tail) {
    ListNode* prev = nullptr;
    ListNode* curr = head;

    while (curr != tail) {
      ListNode* next = curr->next;
      curr->next = prev;
      prev = curr;
      curr = next;
    }

    return prev;
  }
};"
"class Solution:
    def solve(self, root, S , curr , res):
        if(not root):
            return
        curr.append(root.val)
        
        
        if(root.val == S and not root.left and not root.right):
            res.append(list(curr))
            #remeber that when append lisi of list convert into a list
        self.solve(root.left, S - root.val , curr , res)
        
        self.solve(root.right, S - root.val , curr , res)
        
        #del curr[-1]
        curr.pop()
        
        
        
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        curr = []
        self.solve(root , targetSum , curr , res)
        return res","class Solution {
 public:
  int removeDuplicates(vector<int>& nums) {
    int i = 0;

    for (const int num : nums)
      if (i < 1 || num > nums[i - 1])
        nums[i++] = num;

    return i;
  }
};"
"class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """"""
        Do not return anything, modify root in-place instead.
        """"""
        if not root:
            return None
        
        # left is the last node of the left subtree.
        # and similarly right is the last node of the right subtree
        left = self.flatten(root.left)
        right = self.flatten(root.right)
        
        if left:
            # First, we join the last node of left subtree to first node in right subtree
            # Then we move the left subtree to the right of the node, and delete the left subtree pointer
            left.right = root.right
            root.right = root.left
            root.left = None
        
        # if theres a right subtree, we return its last node, failing which the last node of the left subtree,
		# and if none are present (i.e. its a leaf node), we return the node itself.
        return right or left or root","class Solution {
 public:
  int removeElement(vector<int>& nums, int val) {
    int i = 0;

    for (const int num : nums)
      if (num != val)
        nums[i++] = num;

    return i;
  }
};"
"class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        dp = [[0 for i in range(m + 1)] for i in range(n + 1)]
        
        for i in range(0, m + 1):
            dp[i][0] = 1
        for i in range(1,m + 1):
            for j in range(1,n + 1):
                dp[i][j] += dp[i - 1][j] + (dp[i - 1][j - 1] if s[i - 1] == t[j - 1] else 0)
        return dp[m][n]","class Solution {
 public:
  int strStr(string haystack, string needle) {
    const int m = haystack.length();
    const int n = needle.length();

    for (int i = 0; i < m - n + 1; i++)
      if (haystack.substr(i, n) == needle)
        return i;

    return -1;
  }
};"
"class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if root == None:
            return None
        q = collections.deque([root])
        while len(q) > 0:
            size = len(q)
            prev = None
            for _ in range(size):
                node = q.popleft()
                if prev:
                    prev.next = node
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                prev = node
            prev.next = None
        return root","class Solution {
 public:
  int divide(int dividend, int divisor) {
    // -2^{31} / -1 = 2^31 -> overflow so return 2^31 - 1
    if (dividend == INT_MIN && divisor == -1)
      return INT_MAX;

    const int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;
    long ans = 0;
    long dvd = labs(dividend);
    long dvs = labs(divisor);

    while (dvd >= dvs) {
      long k = 1;
      while (k * 2 * dvs <= dvd)
        k *= 2;
      dvd -= k * dvs;
      ans += k;
    }

    return sign * ans;
  }
};"
"class Solution(object):
    def generate(self, numRows):
        """"""
        :type numRows: int
        :rtype: List[List[int]]
        """"""
        response = [[1]*i for i in range(1, numRows+1)]
        
        for i in range(2, numRows):
            for j in range(1,i):
                response[i][j] = response[i-1][j] + response[i-1][j-1]
                
        return response","class Solution {
 public:
  vector<int> findSubstring(string s, vector<string>& words) {
    if (s.empty() || words.empty())
      return {};

    const int k = words.size();
    const int n = words[0].length();
    vector<int> ans;
    unordered_map<string, int> count;

    for (const string& word : words)
      ++count[word];

    for (int i = 0; i < s.length() - k * n + 1; ++i) {
      unordered_map<string, int> seen;
      int j;
      for (j = 0; j < k; ++j) {
        const string& word = s.substr(i + j * n, n);
        if (++seen[word] > count[word])
          break;
      }
      if (j == k)
        ans.push_back(i);
    }

    return ans;
  }
};"
"class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        l=[[1]*(i+1) for i in range(rowIndex+1)]
        
        if(rowIndex==0):
            l[0]=[1]
        
        else:
            l[0]=[1]
            l[1]=[1,1]
        
            for i in range(2,len(l)):
                for j in range(0,len(l[i])):
                    if(j==0 or j==len(l[i])+1):
                        continue
                    else:
                        l[i][j]=sum(l[i-1][j-1:j+1])
        return l[-1]","class Solution {
 public:
  void nextPermutation(vector<int>& nums) {
    const int n = nums.size();

    // From back to front, find the first num < nums[i + 1]
    int i;
    for (i = n - 2; i >= 0; --i)
      if (nums[i] < nums[i + 1])
        break;

    // From back to front, find the first num > nums[i], swap it with nums[i]
    if (i >= 0)
      for (int j = n - 1; j > i; --j)
        if (nums[j] > nums[i]) {
          swap(nums[i], nums[j]);
          break;
        }

    // Reverse nums[i + 1..n - 1]
    reverse(nums, i + 1, n - 1);
  }

 private:
  void reverse(vector<int>& nums, int l, int r) {
    while (l < r)
      swap(nums[l++], nums[r--]);
  }
};"
"class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        dp = [[-1] * n for x in range(n)]
        
        for j in range(n):
            dp[n-1][j] = triangle[n-1][j]
        i = n-2
        while(i>=0):
            j = i
            while(j>=0):
                down = triangle[i][j] + dp[i+1][j]
                dia = triangle[i][j] + dp[i+1][j+1]
                dp[i][j] = min(down,dia)
                j -= 1
            i -= 1
        return dp[0][0]","class Solution {
 public:
  int longestValidParentheses(string s) {
    const string s2 = "")"" + s;
    // dp[i] := Length of longest valid parentheses substring of s2[1..i]
    vector<int> dp(s2.length());

    for (int i = 1; i < s2.length(); ++i)
      if (s2[i] == ')' && s2[i - dp[i - 1] - 1] == '(')
        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;

    return *max_element(begin(dp), end(dp));
  }
};"
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price, max_profit = math.inf, 0
        for p in prices:
            if p < min_price:
                min_price = p
            elif p-min_price > max_profit:
                max_profit = p-min_price
        return max_profit","class Solution {
 public:
  int search(vector<int>& nums, int target) {
    int l = 0;
    int r = nums.size() - 1;

    while (l <= r) {
      const int m = (l + r) / 2;
      if (nums[m] == target)
        return m;
      if (nums[l] <= nums[m]) {  // nums[l..m] are sorted
        if (nums[l] <= target && target < nums[m])
          r = m - 1;
        else
          l = m + 1;
      } else {  // nums[m..n - 1] are sorted
        if (nums[m] < target && target <= nums[r])
          l = m + 1;
        else
          r = m - 1;
      }
    }

    return -1;
  }
};"
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        @cache
        def trade(day_d):
            
            if day_d == 0:
                
                # Hold on day_#0 = buy stock at the price of day_#0
                # Not-hold on day_#0 = doing nothing on day_#0
                return -prices[day_d], 0
            
            prev_hold, prev_not_hold = trade(day_d-1)
            
            hold = max(prev_hold, prev_not_hold - prices[day_d] )
            not_hold = max(prev_not_hold, prev_hold + prices[day_d] )
            
            return hold, not_hold
        
        # --------------------------------------------------
        last_day= len(prices)-1
        
        # Max profit must come from not_hold state (i.e., no stock position) on last day
        return trade(last_day)[1]","class Solution {
 public:
  vector<int> searchRange(vector<int>& nums, int target) {
    const int l = lower_bound(begin(nums), end(nums), target) - begin(nums);
    if (l == nums.size() || nums[l] != target)
      return {-1, -1};
    const int r = upper_bound(begin(nums), end(nums), target) - begin(nums) - 1;
    return {l, r};
  }
};"
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        @cache
        def dfs(i, hasBought, transactions):
            if (i >= len(prices) or transactions >= 2):
                return 0
            maxProfit = 0
            if (hasBought):
                maxProfit = prices[i] + dfs(i + 1, False, transactions + 1)
            else:
                maxProfit = -prices[i] + dfs(i + 1, True, transactions)     
            return max(maxProfit, dfs(i + 1, hasBought, transactions))
        return dfs(0, False, 0)","class Solution {
 public:
  int searchInsert(vector<int>& nums, int target) {
    int l = 0;
    int r = nums.size();

    while (l < r) {
      const int m = (l + r) / 2;
      if (nums[m] == target)
        return m;
      if (nums[m] < target)
        l = m + 1;
      else
        r = m;
    }

    return l;
  }
};"
"class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        return self.maxPathSumHelper(root)[2]

    def maxPathSumHelper(self, root: TreeNode):
        """"""
            (alo, connected, sum)
        """"""
        if root == None:
            return (False, False, 0)
        
        (l_alo, l_connected, l_subtree) = self.maxPathSumHelper(root.left)
        (r_alo, r_connected, r_subtree) = self.maxPathSumHelper(root.right)
        
        max_sum = max( \
            (root.val + l_subtree + r_subtree) if r_connected and l_connected else root.val, \
            (root.val + l_subtree) if l_connected else root.val, \
            (root.val + r_subtree) if r_connected else root.val, \
            root.val
         )
        
        
        if (l_alo and l_subtree > max_sum) or (r_alo and r_subtree > max_sum):
            if l_alo and not r_alo:
                return (True, False, l_subtree)
            elif not l_alo and r_alo:
                return (True, False, r_subtree)
            else:
                return (True, False, max(l_subtree, r_subtree))
        else:","class Solution {
 public:
  bool isValidSudoku(vector<vector<char>>& board) {
    unordered_set<string> seen;

    for (int i = 0; i < 9; ++i)
      for (int j = 0; j < 9; ++j) {
        if (board[i][j] == '.')
          continue;
        const string c(1, board[i][j]);
        if (!seen.insert(c + ""@row"" + to_string(i)).second ||
            !seen.insert(c + ""@col"" + to_string(j)).second ||
            !seen.insert(c + ""@box"" + to_string(i / 3) + to_string(j / 3))
                 .second)
          return false;
      }

    return true;
  }
};"
"class Solution:
    def isPalindrome(self, s: str) -> bool:
        Snew = """"
        for char in s:
            if char.isalnum():
                Snew += char.lower()
        return Snew == Snew[::-1]","class Solution {
 public:
  void solveSudoku(vector<vector<char>>& board) {
    solve(board, 0);
  }

 private:
  bool solve(vector<vector<char>>& board, int s) {
    if (s == 81)
      return true;

    const int i = s / 9;
    const int j = s % 9;

    if (board[i][j] != '.')
      return solve(board, s + 1);

    for (char c = '1'; c <= '9'; ++c)
      if (isValid(board, i, j, c)) {
        board[i][j] = c;
        if (solve(board, s + 1))
          return true;
        board[i][j] = '.';
      }

    return false;
  }

  bool isValid(vector<vector<char>>& board, int row, int col, char c) {
    for (int i = 0; i < 9; ++i)
      if (board[i][col] == c || board[row][i] == c ||
          board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)
        return false;
    return true;
  }
};"
"class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        """"""
        cog
        + log
          + 
        + dog
        """"""
        def ppath(p):
            if d.get(p):
                path.append(p)
                if d[p][1]==-1:
                    print(path[::-1])
                    ans.append([v for v in path[::-1]])
                else:
                    for v in d:
                        if d[v][0]+1==d[p][0] and sum([1 for i in range(k) if v[i]!=p[i]])<=1:
                            ppath(v)
                path.pop(-1)
            pass
            
        n, k = len(wordList), len(wordList[0])
        
        # build tries
        tries = {}
        for i in range(n):
            for j in range(k):
                w = wordList[i][:j] + ""?"" + wordList[i][j+1:]
                tries[w] = tries.get(w, [])                
                tries[w].append(wordList[i])
            pass
        
        print(beginWord, endWord)
        print(""[build] tries: "", tries)
        
        # bfs (only closing node after 1-level)
        q = [beginWord]
        d = {q[0]: (0, -1)}
        flag = False
        while len(q)>0:
            u = q.pop(0)
            for j in range(k):
                w = u[:j] + ""?"" + u[j+1:]
                for v in tries.get(w, []): # for all v adjacent u
                    if not d.get(v):
                        d[v] = (d[u][0]+1, u)
                        q.append(v)
                    if v==endWord:
                        break
                if d.get(endWord):
                    break
            if d.get(endWord):
                    break
                        
        print(""\n[bfs] d: "", d)
        
        print(""\npath: "")
        
        path = []
        ans = []
        ppath(endWord)
        print(""="" * 20)
        return ans

print = lambda *a,**aa: ()","class Solution {
 public:
  string countAndSay(int n) {
    string ans = ""1"";

    while (--n) {
      string next;
      for (int i = 0; i < ans.length(); ++i) {
        int count = 1;
        while (i + 1 < ans.length() && ans[i] == ans[i + 1]) {
          ++count;
          ++i;
        }
        next += to_string(count) + ans[i];
      }
      ans = move(next);
    }

    return ans;
  }
};"
"class Solution:
    def ladderLength(self, beginWord: 'str', endWord: 'str', wordList: 'List[str]') -> 'int':
        wordSet = set(wordList)
        if endWord not in wordSet:
            return 0
        wordDict = {1:[beginWord]}
        output = 1
        while True:
            words = wordDict[output] 
            wordDict[output + 1] = []
            for word in words:
                for i in range(len(word)):
                    for j in string.ascii_lowercase:
                        wordChange = word[:i] + j + word[i+1:]
                        if wordChange == endWord:
                            return output + 1
                        if wordChange in wordSet:
                            wordDict[output+1].append(wordChange)
                            wordSet.remove(wordChange)
            if wordDict[output+1] == []:
                break
            output += 1
        return 0","class Solution {
 public:
  vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
    vector<vector<int>> ans;
    sort(begin(candidates), end(candidates));
    dfs(candidates, 0, target, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& A, int s, int target, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (target < 0)
      return;
    if (target == 0) {
      ans.push_back(path);
      return;
    }

    for (int i = s; i < A.size(); ++i) {
      path.push_back(A[i]);
      dfs(A, i, target - A[i], move(path), ans);
      path.pop_back();
    }
  }
};"
"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        lengthLong=0
        prevMap = {}
        for i, n in enumerate(nums):
            prevMap[n]=i
        for i, n in enumerate(nums):
            count=1
            while n+1 in prevMap:
                count+=1
                n+=1
            lengthLong=max(lengthLong,count)
        return lengthLong","class Solution {
 public:
  vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
    vector<vector<int>> ans;
    sort(begin(candidates), end(candidates));
    dfs(candidates, 0, target, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& A, int s, int target, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (target < 0)
      return;
    if (target == 0) {
      ans.push_back(path);
      return;
    }

    for (int i = s; i < A.size(); ++i) {
      if (i > s && A[i] == A[i - 1])
        continue;
      path.push_back(A[i]);
      dfs(A, i + 1, target - A[i], move(path), ans);
      path.pop_back();
    }
  }
};"
"class Solution:
def sumNumbers(self, root: Optional[TreeNode]) -> int:
    
    def path(root,local):
        nonlocal res
        if root is None:
            return 
        if root.left is None and root.right is None:
            res.append(local*10+root.val)
            return
        
        path(root.left,local*10+root.val)
        path(root.right,local*10+root.val)
    
    res = []
    path(root,0)
    return sum(res)","class Solution {
 public:
  int firstMissingPositive(vector<int>& nums) {
    const int n = nums.size();

    // Correct slot:
    // nums[i] = i + 1
    // nums[i] - 1 = i
    // nums[nums[i] - 1] = nums[i]
    for (int i = 0; i < n; ++i)
      while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1])
        swap(nums[i], nums[nums[i] - 1]);

    for (int i = 0; i < n; ++i)
      if (nums[i] != i + 1)
        return i + 1;

    return n + 1;
  }
};"
"class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        
        m = len(board)
        n = len(board[0])
        for i in range(m):
            for j in range(n):
                visited = set()
                if board[i][j]=='O':
                    bfs_arr = [(i,j)]
                    visited.add((i,j))
                    surrounded = True
                    while len(bfs_arr)>0:
                        curr = bfs_arr.pop()
                        if curr[0]==0 or curr[0]==m-1 or curr[1]==0 or curr[1]==n-1:
                            surrounded = False
                        
                        for shift in [(+1,0),(-1,0),(0,+1),(0,-1)]:
                            ind_i = curr[0]+shift[0]
                            ind_j = curr[1] + shift[1]                            
                            if ind_i>=0 and ind_i<m and ind_j>=0 and ind_j<n and board[ind_i][ind_j] == 'O' and (ind_i, ind_j) not in visited:
                                bfs_arr.append((ind_i,ind_j ))
                                visited.add((ind_i, ind_j))

                    for val in visited:
                        if surrounded:
                            board[val[0]][val[1]] = 'X'","class Solution {
 public:
  int trap(vector<int>& height) {
    const int n = height.size();
    int ans = 0;
    vector<int> l(n);  // l[i] := max(height[0..i])
    vector<int> r(n);  // r[i] := max(height[i..n))

    for (int i = 0; i < n; ++i)
      l[i] = i == 0 ? height[i] : max(height[i], l[i - 1]);

    for (int i = n - 1; i >= 0; --i)
      r[i] = i == n - 1 ? height[i] : max(height[i], r[i + 1]);

    for (int i = 0; i < n; ++i)
      ans += min(l[i], r[i]) - height[i];

    return ans;
  }
};"
"class Solution:
    def partition(self, s: str) -> List[List[str]]:
        part = [[] for _ in range(len(s))]
        def sub_part(l, r):
            if 0 <= l <= r < len(s) and s[l]==s[r]:
                part[l].append(s[l:r+1])
                sub_part(l-1, r+1)
                
		# find all palindromes
        for i in range(len(s)):
            sub_part(i,i)
            sub_part(i-1,i)
			
        # generate output
		res=[]
		
        def dfs(i, tmp):
            if i >=len(s):
                res.append(tmp)
			else:
				for p in part[i]:
					dfs(i + len(p), tmp + [p])        
        
		dfs(0, [])
        return res","class Solution {
 public:
  string multiply(string num1, string num2) {
    string s(num1.length() + num2.length(), '0');

    for (int i = num1.length() - 1; i >= 0; --i)
      for (int j = num2.length() - 1; j >= 0; --j) {
        const int mult = (num1[i] - '0') * (num2[j] - '0');
        const int sum = mult + (s[i + j + 1] - '0');
        s[i + j] += sum / 10;
        s[i + j + 1] = '0' + sum % 10;
      }

    const int i = s.find_first_not_of('0');
    return i == -1 ? ""0"" : s.substr(i);
  }
};"
"class Solution:
    def minCut(self, s: str) -> int:
        if len(s)<=1: return 0
        dp = []
        for x in range(-1,len(s)):
            dp.append(x)
        for i in range(len(s)):
            for j in range(i,len(s)):
                if s[i:j]==s[j:i:-1]:
                    dp[j+1]=min(dp[j+1],dp[i]+1)
        return dp[len(s)]
    
    def minCut1(self, s: str) -> int:
        if len(s)<=1: return 0
        self.memo=[None]*(len(s)+1)
        self.memo[0]=[[]]
        ps = self.partition(s)
        min_len=float(""inf"")
        for p in ps:
            min_len=min(min_len,len(p))
        return min_len - 1
    
    def partition(self,s):
        l = len(s)
        if self.memo[l]: return self.memo[l]
        result=[]
        for i in range(l-1,-1,-1):
            current=s[i:]
            if current==current[::-1]:
                prevs=self.partition(s[:i])
                for prev in prevs:
                    result+=[prev+[current]]
        self.memo[l]=result
        return result","class Solution {
 public:
  bool isMatch(string s, string p) {
    const int m = s.length();
    const int n = p.length();
    // dp[i][j] := true if s[0..i) matches p[0..j)
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
    dp[0][0] = true;

    auto isMatch = [&](int i, int j) -> bool {
      return j >= 0 && p[j] == '?' || s[i] == p[j];
    };

    for (int j = 0; j < p.length(); ++j)
      if (p[j] == '*')
        dp[0][j + 1] = dp[0][j];

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (p[j] == '*') {
          const bool matchEmpty = dp[i + 1][j];
          const bool matchSome = dp[i][j + 1];
          dp[i + 1][j + 1] = matchEmpty || matchSome;
        } else if (isMatch(i, j)) {
          dp[i + 1][j + 1] = dp[i][j];
        }

    return dp[m][n];
  }
};"
"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        
        return clone(node, {})

def clone(node, dict):
    if node not in dict:
        dict[node] = Node(node.val, [])
        for n in node.neighbors:
            dict[node].neighbors.append(clone(n, dict))
    return dict[node]","class Solution {
 public:
  int jump(vector<int>& nums) {
    int ans = 0;
    int end = 0;
    int farthest = 0;

    // Implicit BFS
    for (int i = 0; i < nums.size() - 1; ++i) {
      farthest = max(farthest, i + nums[i]);
      if (farthest >= nums.size() - 1) {
        ++ans;
        break;
      }
      if (i == end) {    // Visited all the items on the current level
        ++ans;           // Increment the level
        end = farthest;  // Make the queue size for the next level
      }
    }

    return ans;
  }
};"
"class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas)<sum(cost): return -1
        n=len(gas)
        minn=float('inf')  #Variable to track the largest cumulative gas deficit
        debt=0 #Variable indicating the gas deficit at each station
        for i in range(n):
            debt+=gas[i]-cost[i]
            if debt<minn:
                minn=debt
                index=i
        return index+1 if index <n-1 else 0 #return the station right after the one with the largest cumulative deficit","class Solution {
 public:
  vector<vector<int>> permute(vector<int>& nums) {
    vector<vector<int>> ans;

    dfs(nums, vector<bool>(nums.size()), {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, vector<bool>&& used, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (path.size() == nums.size()) {
      ans.push_back(path);
      return;
    }

    for (int i = 0; i < nums.size(); ++i) {
      if (used[i])
        continue;
      used[i] = true;
      path.push_back(nums[i]);
      dfs(nums, move(used), move(path), ans);
      path.pop_back();
      used[i] = false;
    }
  }
};"
"class Solution:
    def candy(self, ratings: List[int]) -> int:
        '''
        1. According to solution 2, use two arrays initialized by n 1's where n is length of ratings array,
                - one to check whether ratings[i]<ratings[i+1] starting from the leftmost position, if so then in the array set the value of index (i+1) = 1 + the value of index i
                - other to check whether ratings[i+1]<ratings[i] starting from the rightmost position, if so then in the array set the value of index i = 1 + the value of index (i+1)
        2. If those two arrays are LeftToRight and RightToLeft respectively, then the result will be sum of all maximum(LeftToRight[i], RightToLeft[i]) for 0<=i<=n-1.
        '''
        
        res_1 = [1]*len(ratings)                                        #array for LeftToRight checking
        res_2 = [1]*len(ratings)                                        #array for RightToLeft checking
        res=0                                                           #initial value of minimum no. of candies
        
        #we can check whether ratings[0]<ratings[1] and ratings[n-1]<ratings[n-2] in the same iteration
        #in the following way we can change the values of index i of both LeftToRight array and RightToLeft array in single iteration
        for i in range(0,len(ratings)-1):
            if ratings[i+1]>ratings[i] and res_1[i+1]<=res_1[i]:               
                res_1[i+1]=res_1[i]+1
            if ratings[len(ratings)-1-i]<ratings[len(ratings)-1-i-1] and res_2[len(ratings)-1-i]>=res_2[len(ratings)-1-i]:
                res_2[len(ratings)-1-i-1]=res_2[len(ratings)-1-i]+1
            
        for i in range(0,len(ratings)):
            res+=max(res_1[i], res_2[i])                                        #getting the maximum of LeftToRight[i] and RightToLeft[i] and adding it to the minimum value
            
        return res","class Solution {
 public:
  vector<vector<int>> permuteUnique(vector<int>& nums) {
    vector<vector<int>> ans;
    sort(begin(nums), end(nums));
    dfs(nums, vector<bool>(nums.size()), {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, vector<bool>&& used, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (path.size() == nums.size()) {
      ans.push_back(path);
      return;
    }

    for (int i = 0; i < nums.size(); ++i) {
      if (used[i])
        continue;
      if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])
        continue;
      used[i] = true;
      path.push_back(nums[i]);
      dfs(nums, move(used), move(path), ans);
      path.pop_back();
      used[i] = false;
    }
  }
};"
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
            return [x for x in nums if nums.count(x)==1][0]","class Solution {
 public:
  void rotate(vector<vector<int>>& matrix) {
    reverse(begin(matrix), end(matrix));
    for (int i = 0; i < matrix.size(); ++i)
      for (int j = i + 1; j < matrix.size(); ++j)
        swap(matrix[i][j], matrix[j][i]);
  }
};"
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return (sum(set(nums))*3-sum(nums))//2","class Solution {
 public:
  vector<vector<string>> groupAnagrams(vector<string>& strs) {
    vector<vector<string>> ans;
    unordered_map<string, vector<string>> keyToAnagrams;

    for (const string& str : strs) {
      string key = str;
      sort(begin(key), end(key));
      keyToAnagrams[key].push_back(str);
    }

    for (const auto& [_, anagrams] : keyToAnagrams)
      ans.push_back(anagrams);

    return ans;
  }
};"
"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        def copyList(node):
            if not node:
                return node
            
            newNode = Node(node.val)
            newNodes[node] = newNode
            newNode.next = copyList(node.next)
            newNode.random = newNodes[node.random]
            
            return newNode
        
        newNodes = {None: None}
        return copyList(head)","class Solution {
 public:
  double myPow(double x, long n) {
    if (n == 0)
      return 1;
    if (n < 0)
      return 1 / myPow(x, -n);
    if (n & 1)
      return x * myPow(x, n - 1);
    return myPow(x * x, n / 2);
  }
};"
"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        t = [0 for _ in range(n)]
        for i in range(n):
            for j in range(i+1):
                word = s[j:i+1]
                if word in wordDict:
                    t[i] += t[j-1] if j > 0 else 1
        return t[n-1]","class Solution {
 public:
  vector<vector<string>> solveNQueens(int n) {
    vector<vector<string>> ans;
    dfs(n, 0, vector<bool>(n), vector<bool>(2 * n - 1), vector<bool>(2 * n - 1),
        vector<string>(n, string(n, '.')), ans);
    return ans;
  }

 private:
  void dfs(int n, int i, vector<bool>&& cols, vector<bool>&& diag1,
           vector<bool>&& diag2, vector<string>&& board,
           vector<vector<string>>& ans) {
    if (i == n) {
      ans.push_back(board);
      return;
    }

    for (int j = 0; j < n; ++j) {
      if (cols[j] || diag1[i + j] || diag2[j - i + n - 1])
        continue;
      board[i][j] = 'Q';
      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = true;
      dfs(n, i + 1, move(cols), move(diag1), move(diag2), move(board), ans);
      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = false;
      board[i][j] = '.';
    }
  }
};"
"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        self.res = []
        
        def helper(s,dic,path):
            if not s:
                self.res.append(' '.join(path))
                return
            if s in dic:
                return
            for i in range(1,len(s)+1):
                if s[:i] in wd:
                    helper(s[i:],dic,path+[s[:i]])
                else:
                    dic.add(s[:i])
        wd = set(wordDict)  
        dic = set()
        helper(s,dic,[])
        return self.res","class Solution {
 public:
  int totalNQueens(int n) {
    int ans = 0;
    dfs(n, 0, vector<bool>(n), vector<bool>(2 * n - 1), vector<bool>(2 * n - 1),
        ans);
    return ans;
  }

 private:
  void dfs(int n, int i, vector<bool>&& cols, vector<bool>&& diag1,
           vector<bool>&& diag2, int& ans) {
    if (i == n) {
      ++ans;
      return;
    }

    for (int j = 0; j < n; ++j) {
      if (cols[j] || diag1[i + j] || diag2[j - i + n - 1])
        continue;
      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = true;
      dfs(n, i + 1, move(cols), move(diag1), move(diag2), ans);
      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = false;
    }
  }
};"
"class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        # if linkedlist empty
        if not head:
            return False
        
        # fast, slow nodes
        fast = slow = head
        
        # counter for fast and slow
        cnt = 0
        
        # while before end of linkedlist
        while fast:
            # advance fast
            fast = fast.next

            # every other loop
            if cnt % 2:
                # advance slow
                slow = slow.next
            
            # if fast and slow point to the same node, we have a loop
            if fast is slow:
                return True
            
            # increment cnt
            cnt += 1
        
        return False","class Solution {
 public:
  int maxSubArray(vector<int>& nums) {
    // dp[i] := max sum subarray ending w/ i
    vector<int> dp(nums.size());

    dp[0] = nums[0];
    for (int i = 1; i < nums.size(); ++i)
      dp[i] = max(nums[i], dp[i - 1] + nums[i]);

    return *max_element(begin(dp), end(dp));
  }
};"
"class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        if not head or not head.next:
            return None
        
        s = set()
        
        while head:
            
            if head in s:
                return head
            
            s.add(head)
            head = head.next
            
        return head","class Solution {
 public:
  vector<int> spiralOrder(vector<vector<int>>& matrix) {
    if (matrix.empty())
      return {};

    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<int> ans;
    int r1 = 0;
    int c1 = 0;
    int r2 = m - 1;
    int c2 = n - 1;

    // Repeatedly add matrix[r1..r2][c1..c2] to ans
    while (ans.size() < m * n) {
      for (int j = c1; j <= c2 && ans.size() < m * n; ++j)
        ans.push_back(matrix[r1][j]);
      for (int i = r1 + 1; i <= r2 - 1 && ans.size() < m * n; ++i)
        ans.push_back(matrix[i][c2]);
      for (int j = c2; j >= c1 && ans.size() < m * n; --j)
        ans.push_back(matrix[r2][j]);
      for (int i = r2 - 1; i >= r1 + 1 && ans.size() < m * n; --i)
        ans.push_back(matrix[i][c1]);
      ++r1, ++c1, --r2, --c2;
    }

    return ans;
  }
};"
"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        curr = head
        lst_ref = []
        while curr:
            lst_ref.append(curr)
            curr = curr.next
        if len(lst_ref) <= 2:
            return
        half_len, rem = divmod(len(lst_ref), 2)
        if rem:
            for a, b in zip(lst_ref[:half_len:1],
                            lst_ref[len(lst_ref) - 1: half_len:-1]):
                a.next = b
            for a, b in zip(lst_ref[len(lst_ref) - 1: half_len + 1:-1],
                            lst_ref[1:half_len:1]):
                a.next = b
            lst_ref[half_len + 1].next = lst_ref[half_len]
        else:
            for a, b in zip(lst_ref[:half_len:1],
                            lst_ref[len(lst_ref) - 1: half_len - 1:-1]):
                a.next = b
            for a, b in zip(lst_ref[len(lst_ref) - 1: half_len:-1],
                            lst_ref[1:half_len:1]):
                a.next = b
        lst_ref[half_len].next = None","class Solution {
 public:
  bool canJump(vector<int>& nums) {
    int i = 0;

    for (int reach = 0; i < nums.size() && i <= reach; ++i)
      reach = max(reach, i + nums[i]);

    return i == nums.size();
  }
};"
"class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
	    ans = []
	    stack = [root]

	    while stack:
		    node = stack.pop()
		    if node:
			    ans.append(node.val)
			    stack.append(node.right)
			    stack.append(node.left)
	    return ans","class Solution {
 public:
  vector<vector<int>> merge(vector<vector<int>>& intervals) {
    vector<vector<int>> ans;

    sort(begin(intervals), end(intervals));

    for (const vector<int>& interval : intervals)
      if (ans.empty() || ans.back()[1] < interval[0])
        ans.push_back(interval);
      else
        ans.back()[1] = max(ans.back()[1], interval[1]);

    return ans;
  }
};"
"class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if not root:
            return res
        def dfs(node):
            if not node:
                return
            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
            pass
        dfs(root)
        return res","class Solution {
 public:
  vector<vector<int>> insert(vector<vector<int>>& intervals,
                             vector<int>& newInterval) {
    const int n = intervals.size();
    vector<vector<int>> ans;
    int i = 0;

    while (i < n && intervals[i][1] < newInterval[0])
      ans.push_back(intervals[i++]);

    // Merge overlapping intervals
    while (i < n && intervals[i][0] <= newInterval[1]) {
      newInterval[0] = min(newInterval[0], intervals[i][0]);
      newInterval[1] = max(newInterval[1], intervals[i][1]);
      ++i;
    }

    ans.push_back(newInterval);

    while (i < n)
      ans.push_back(intervals[i++]);

    return ans;
  }
};"
"class ListNode:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.next = None
        self.prev = None

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
		# a hashmap stores key to ListNode(key, value) pair
        self.map = dict()
        # dummy nodes to mitigate edge cases
        self.head = ListNode(0, 0)
        self.tail = ListNode(0, 0)
        # init the doubly linked list with [head<->tail]
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key: int) -> int:
        if (key in self.map):
            curr = self.map.get(key)
            self.removeX(curr)
            self.addX(curr)
            return curr.val
        return -1

    def put(self, key: int, value: int) -> None:
        if (key in self.map):
            self.removeX(self.map[key])
        
        self.map[key] = ListNode(key, value)
        self.addX(self.map[key])
            
        if (len(self.map) > self.capacity):
            # remove the first(LRU) element in the list
            n = self.head.next
            self.removeX(n)
            self.map.pop(n.key, None)              

        
    def addX(self, head):
        # set the current head pointer's prev to tail's prev pointer
        head.prev = self.tail.prev
        # set the current head pointer's next to tail pointer
        head.next = self.tail
        # set the tail pointer's old prev's next to the current head pointer
        self.tail.prev.next = head
        # set the tail pointer's old prev pointer to the new prev(head) pointer
        self.tail.prev = head
    
    def removeX(self, head):
        # set the old prev's next pointer to current head's next pointer
        head.prev.next = head.next
        # set old next's prev pointer to current head's prev pointer
        head.next.prev = head.prev","class Solution {
 public:
  int lengthOfLastWord(string s) {
    int i = s.length() - 1;

    while (i >= 0 && s[i] == ' ')
      --i;
    const int lastIndex = i;
    while (i >= 0 && s[i] != ' ')
      --i;

    return lastIndex - i;
  }
};"
"class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        
        # No need to sort for empty list or list of size 1
        if not head or not head.next:
            return head
        
        nodes = []
        cur = head
        while head:
            nodes.append(head)
            head = head.next
            
        # Sort nodes by their values ascendingly
        nodes = sorted(nodes, key=lambda node: node.val)

        # Re-organize list
        cur = head = nodes[0]
        for node in nodes[1:]:
            cur.next = node
            cur = cur.next
        cur.next = None
            
        return head","class Solution {
 public:
  vector<vector<int>> generateMatrix(int n) {
    vector<vector<int>> ans(n, vector<int>(n));
    int count = 1;

    for (int min = 0; min < n / 2; ++min) {
      const int max = n - min - 1;
      for (int i = min; i < max; ++i)
        ans[min][i] = count++;
      for (int i = min; i < max; ++i)
        ans[i][max] = count++;
      for (int i = max; i > min; --i)
        ans[max][i] = count++;
      for (int i = max; i > min; --i)
        ans[i][min] = count++;
    }

    if (n & 1)
      ans[n / 2][n / 2] = count;

    return ans;
  }
};"
"class Solution(object):
    def sortList(self, head):
        if not head or not head.next:
            return head
        fast, slow = head.next, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        start = slow.next
        slow.next = None
        l, r = self.sortList(head), self.sortList(start)
        return self.merge(l, r)
        
        
    def merge(self, l, r):
        if not l or not r:
            return l or r
        dummy = p = ListNode(0)
        while l and r:
            if l.val < r.val:
                p.next = l
                l = l.next
            else:
                p.next = r
                r = r.next
            p = p.next
        p.next = l or r
        return dummy.next","class Solution {
 public:
  string getPermutation(int n, int k) {
    string ans;
    vector<int> nums(n);
    vector<int> fact(n + 1, 1);  // fact[i] := i!

    iota(begin(nums), end(nums), 1);

    for (int i = 2; i <= n; ++i)
      fact[i] = fact[i - 1] * i;

    --k;  // 0-indexed

    for (int i = n - 1; i >= 0; --i) {
      const int j = k / fact[i];
      k %= fact[i];
      ans += to_string(nums[j]);
      nums.erase(begin(nums) + j);
    }

    return ans;
  }
};"
"class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        def solve(p1, p2):
            if p2[0] == p1[0]:
                return math.inf, p1[0]
            m = (p2[1] - p1[1]) / (p2[0] - p1[0])
            b = p2[1] - m*p2[0]
            return m, b
        
        n = len(points)
        if n == 1:
            return 1
        lines = defaultdict(set)
        for i in range(n):
            for j in range(i+1, n):
                m, b = solve(points[i], points[j])
                lines[(m,b)].add(i)
                lines[(m,b)].add(j)
                
        return max([len(v) for v in lines.values()])","class Solution {
 public:
  ListNode* rotateRight(ListNode* head, int k) {
    if (!head || !head->next || k == 0)
      return head;

    ListNode* tail;
    int length = 1;
    for (tail = head; tail->next; tail = tail->next)
      ++length;
    tail->next = head;  // Circle the list

    const int t = length - k % length;
    for (int i = 0; i < t; ++i)
      tail = tail->next;
    ListNode* newHead = tail->next;
    tail->next = nullptr;

    return newHead;
  }
};"
"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        def calculate(num1, num2, operator):
            if operator=='+':
                return num1+num2
            if operator=='-':
                return num2-num1
            if operator=='*':
                return num1*num2
            if operator=='/':
                return int(num2/num1)
            return 0
        

        stack=[]
        for i in range(len(tokens)):
            if tokens[i] == '+' or tokens[i] == '-' or tokens[i] == '*' or tokens[i] == '/':
                num1=stack.pop()
                num2=stack.pop()
                stack.append(calculate(num1, num2, tokens[i]))
            else:
                stack.append(int(tokens[i]))
        return stack.pop()","class Solution {
 public:
  int uniquePaths(int m, int n) {
    // dp[i][j] := unique paths from (0, 0) to (i, j)
    vector<vector<int>> dp(m, vector<int>(n, 1));

    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

    return dp[m - 1][n - 1];
  }
};"
"class Solution:
    def reverseWords(self, s: str) -> str:
        s=s.split()
        a=s[::-1]
        return(' '.join(a))","class Solution {
 public:
  int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    const int m = obstacleGrid.size();
    const int n = obstacleGrid[0].size();
    // dp[i][j] := unique paths from (0, 0) to (i - 1, j - 1)
    vector<vector<long>> dp(m + 1, vector<long>(n + 1, 0));
    dp[0][1] = 1;  // Can also set dp[1][0] = 1

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (!obstacleGrid[i - 1][j - 1])
          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

    return dp[m][n];
  }
};"
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        f = lambda x, y:  y if x == 0 else x * y 
        return max(max(accumulate(nums, f)), max(accumulate(nums[::-1], f)))","class Solution {
 public:
  int minPathSum(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i > 0 && j > 0)
          grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);
        else if (i > 0)
          grid[i][0] += grid[i - 1][0];
        else if (j > 0)
          grid[0][j] += grid[0][j - 1];

    return grid[m - 1][n - 1];
  }
};"
"class Solution:
    def findMin(self, nums: List[int]) -> int:
        # Binary search
        lo = 0
        hi = len(nums) - 1
        global_min = inf
        while lo <= hi:
            mid = (lo + hi) // 2
            # Update minimum if needed
            global_min = min(nums[mid], global_min)
            # Case: if the pivot index is within the top half and the top half array is unsorted
            # e.g. [4,5,6,7|mid|8,0,1,2]
            if nums[mid] > nums[hi]:
                lo = mid + 1
            # Case: if the pivot index is within the top half but the top half of array is sorted
            # e.g. [5,6,7,8|mid|0,1,2,3]
            elif mid + 1 < len(nums) and nums[mid + 1] < nums[mid]:
                return nums[mid + 1]
            else:
                hi = mid - 1
        return global_min","class Solution {
 public:
  bool isNumber(string s) {
    trim(s);
    if (s.empty())
      return false;

    bool seenNum = false;
    bool seenDot = false;
    bool seenE = false;

    for (int i = 0; i < s.length(); ++i) {
      switch (s[i]) {
        case '.':
          if (seenDot || seenE)
            return false;
          seenDot = true;
          break;
        case 'e':
        case 'E':
          if (seenE || !seenNum)
            return false;
          seenE = true;
          seenNum = false;
          break;
        case '+':
        case '-':
          if (i > 0 && s[i - 1] != 'e')
            return false;
          seenNum = false;
          break;
        default:
          if (!isdigit(s[i]))
            return false;
          seenNum = true;
      }
    }

    return seenNum;
  }

 private:
  void trim(string& s) {
    s.erase(0, s.find_first_not_of(' '));
    s.erase(s.find_last_not_of(' ') + 1);
  }
};"
"class Solution:
    def findMin(self, nums: List[int]) -> int:
        len_nums = len(nums)
        len_nums1, len_nums2 = len_nums - 1,  len_nums - 2
        for i in range(len_nums // 2):
            if nums[i] > nums[i + 1]:
                return nums[i + 1]
            if nums[len_nums2 - i] > nums[len_nums1 - i]:
                return nums[len_nums1 - i]
        return nums[0]","class Solution {
 public:
  vector<int> plusOne(vector<int>& digits) {
    for (int i = digits.size() - 1; i >= 0; --i) {
      if (digits[i] < 9) {
        ++digits[i];
        return digits;
      }
      digits[i] = 0;
    }

    digits.insert(begin(digits), 1);
    return digits;
  }
};"
"class MinStack:

    def __init__(self):
        self.myStack = list()
        self.min = math.inf

    def push(self, val: int) -> None:
        self.myStack.append(val)
        if val < self.min:
            self.min = val

    def pop(self) -> None:
        if len(self.myStack) == 0:
            return
        self.myStack.pop()
        if len(self.myStack) == 0:
            self.min = math.inf
            return
        self.min = min(self.myStack)

    def top(self) -> int:
        if len(self.myStack) == 0:
            return
        return self.myStack[-1]

    def getMin(self) -> int:
        if len(self.myStack) == 0:
            return
        return self.min","class Solution {
 public:
  string addBinary(string a, string b) {
    string ans;
    int carry = 0;
    int i = a.length() - 1;
    int j = b.length() - 1;

    while (i >= 0 || j >= 0 || carry) {
      if (i >= 0)
        carry += a[i--] - '0';
      if (j >= 0)
        carry += b[j--] - '0';
      ans += carry % 2 + '0';
      carry /= 2;
    }

    reverse(begin(ans), end(ans));
    return ans;
  }
};"
"class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        Set=set()
        curr= headA
        while curr:
            Set.add(curr)
            curr=curr.next
        curr=headB
        while curr:
            if curr in Set:
                return curr
            curr=curr.next
        return None","class Solution {
 public:
  vector<string> fullJustify(vector<string>& words, size_t maxWidth) {
    vector<string> ans;
    vector<string> row;
    size_t rowLetters = 0;

    for (const string& word : words) {
      // If we put the word in this row, it'll exceed the maxWidth,
      // So we cannot put the word to this row and have to pad spaces to
      // Each word in this row
      if (rowLetters + row.size() + word.length() > maxWidth) {
        const int spaces = maxWidth - rowLetters;
        if (row.size() == 1) {
          // Pad all spaces after row[0]
          for (int i = 0; i < spaces; ++i)
            row[0] += "" "";
        } else {
          // Evenly pad spaces to each word (expect the last one) in this row
          for (int i = 0; i < spaces; ++i)
            row[i % (row.size() - 1)] += "" "";
        }
        ans.push_back(join(row, """"));
        row.clear();
        rowLetters = 0;
      }
      row.push_back(word);
      rowLetters += word.length();
    }
    ans.push_back(ljust(join(row, "" ""), maxWidth));

    return ans;
  }

 private:
  string join(const vector<string>& words, const string& s) {
    string joined;
    for (int i = 0; i < words.size(); ++i) {
      joined += words[i];
      if (i != words.size() - 1)
        joined += s;
    }
    return joined;
  }

  string ljust(string s, int width) {
    for (int i = 0; i < s.length() - width; ++i)
      s += "" "";
    return s;
  }
};"
"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        return nums.index(max(nums))","class Solution {
 public:
  int mySqrt(int x) {
    unsigned l = 1;
    unsigned r = x + 1u;

    while (l < r) {
      const unsigned m = (l + r) / 2;
      if (m > x / m)
        r = m;
      else
        l = m + 1;
    }

    // l: smallest number s.t. l * l > x
    return l - 1;
  }
};"
"class Solution:
    def maximumGap(self, num):
        if len(num) < 2:    return 0
        num.sort()
        return max(abs(n2 - n1) for n1, n2 in zip(num[1:], num[:-1]))","class Solution {
 public:
  int climbStairs(int n) {
    // dp[i] := # of distinct ways to climb to i-th stair
    vector<int> dp(n + 1);
    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= n; ++i)
      dp[i] = dp[i - 1] + dp[i - 2];

    return dp[n];
  }
};"
"class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        v1 = list(map(int, version1.split(""."")))
        v2 = list(map(int, version2.split(""."")))
        
        
        for i in range(max(len(v1),len(v2))):
            
            if i<len(v1):
                v1.append(0)
            if i<len(v2):
                v2.append(0)
            if v1[i] > v2[i]:
                return 1
            elif v1[i] < v2[i]:
                return -1
            
        return 0","class Solution {
 public:
  string simplifyPath(string path) {
    string ans;
    istringstream iss(path);
    vector<string> stack;

    for (string dir; getline(iss, dir, '/');) {
      if (dir.empty() || dir == ""."")
        continue;
      if (dir == "".."") {
        if (!stack.empty())
          stack.pop_back();
      } else {
        stack.push_back(dir);
      }
    }

    for (const string& s : stack)
      ans += ""/"" + s;

    return ans.empty() ? ""/"" : ans;
  }
};"
"class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator*denominator<0:
            ans=""-""
        else:
            ans=""""
        q=abs(numerator)//abs(denominator)
        r=abs(numerator)%abs(denominator)
        d=set()
        decimal=[]
        if r==0:
            ans=ans+str(q)
            return ans
        else:
            flag=False
            while r!=0:
                if r not in d:
                    n=r*10
                    q1=n//abs(denominator)
                    d.add(r)
                    decimal.append((q1,r))
                    r=n%abs(denominator)
                else:
                    r1=r
                    flag=True
                    break
        ans+=str(q)+'.'
        if flag==False:
            for Q,R in decimal:
                ans+=str(Q)
        if flag==True:
            for i in range(0,len(decimal)):
                if decimal[i][1]!=r1:
                    ans+=str(decimal[i][0])
                else:
                    break
            ans+='('
            for x in range(i,len(decimal)):
                ans+=str(decimal[x][0])
            ans+=')'         
       return ans","class Solution {
 public:
  int minDistance(string word1, string word2) {
    const int m = word1.length();
    const int n = word2.length();
    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = 1; i <= m; ++i)
      dp[i][0] = i;

    for (int j = 1; j <= n; ++j)
      dp[0][j] = j;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (word1[i - 1] == word2[j - 1])
          dp[i][j] = dp[i - 1][j - 1];
        else
          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;

    return dp[m][n];
  }
};"
"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        # O(n), O(1)
        left = 0
        right = len(numbers) - 1

        while left < right:
            add = numbers[left] + numbers[right]
            if add == target:
                return [left + 1, right + 1]
            elif add > target:
                right -= 1
            else:
                left += 1","class Solution {
 public:
  void setZeroes(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    bool shouldFillFirstRow = false;
    bool shouldFillFirstCol = false;

    for (int j = 0; j < n; ++j)
      if (matrix[0][j] == 0) {
        shouldFillFirstRow = true;
        break;
      }

    for (int i = 0; i < m; ++i)
      if (matrix[i][0] == 0) {
        shouldFillFirstCol = true;
        break;
      }

    // Store the information in the 1st row/col
    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        if (matrix[i][j] == 0) {
          matrix[i][0] = 0;
          matrix[0][j] = 0;
        }

    // Fill 0s for the matrix except the 1st row/col
    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        if (matrix[i][0] == 0 || matrix[0][j] == 0)
          matrix[i][j] = 0;

    // Fill 0s for the 1st row if needed
    if (shouldFillFirstRow)
      for (int j = 0; j < n; ++j)
        matrix[0][j] = 0;

    // Fill 0s for the 1st col if needed
    if (shouldFillFirstCol)
      for (int i = 0; i < m; ++i)
        matrix[i][0] = 0;
  }
};"
"class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
         
        column_title = """"
        while columnNumber > 0:
            columnNumber, remainder = divmod(columnNumber - 1, 26)
            column_title = chr(65 + remainder) + column_title
        return column_title","class Solution {
 public:
  bool searchMatrix(vector<vector<int>>& matrix, int target) {
    if (matrix.empty())
      return false;

    const int m = matrix.size();
    const int n = matrix[0].size();
    int l = 0;
    int r = m * n;

    while (l < r) {
      const int mid = (l + r) / 2;
      const int i = mid / n;
      const int j = mid % n;
      if (matrix[i][j] == target)
        return true;
      if (matrix[i][j] < target)
        l = mid + 1;
      else
        r = mid;
    }

    return false;
  }
};"
"class Solution:
    def majorityElement(self, nums: List[int]) -> int: 
        n = len(nums)
        d = {}
        for i in nums:
            d[i] = d.get(i, 0) + 1
        for x, v in d.items():
            if v>n/2:
             return x","class Solution {
 public:
  void sortColors(vector<int>& nums) {
    int zero = -1;
    int one = -1;
    int two = -1;

    for (const int num : nums)
      if (num == 0) {
        nums[++two] = 2;
        nums[++one] = 1;
        nums[++zero] = 0;
      } else if (num == 1) {
        nums[++two] = 2;
        nums[++one] = 1;
      } else {
        nums[++two] = 2;
      }
  }
};"
"class Solution(object):
    def titleToNumber(self, s):
        return reduce(lambda a,b:a*26+b, map(lambda x:ord(x)-ord('A')+1, s))","class Solution {
 public:
  string minWindow(string s, string t) {
    vector<int> count(128);
    int required = t.length();
    int bestLeft = -1;
    int minLength = s.length() + 1;

    for (const char c : t)
      ++count[c];

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (--count[s[r]] >= 0)
        --required;
      while (required == 0) {
        if (r - l + 1 < minLength) {
          bestLeft = l;
          minLength = r - l + 1;
        }
        if (++count[s[l++]] > 0)
          ++required;
      }
    }

    return bestLeft == -1 ? """" : s.substr(bestLeft, minLength);
  }
};"
"class Solution:
    def trailingZeroes(self, n: int) -> int:
        x = 1
        res = 0
        while 5**x < 10**4+1:
            res += n//5**x
            x += 1
        return res","class Solution {
 public:
  vector<vector<int>> combine(int n, int k) {
    vector<vector<int>> ans;
    dfs(n, k, 1, {}, ans);
    return ans;
  }

 private:
  void dfs(int n, int k, int s, vector<int>&& path, vector<vector<int>>& ans) {
    if (path.size() == k) {
      ans.push_back(path);
      return;
    }

    for (int i = s; i <= n; ++i) {
      path.push_back(i);
      dfs(n, k, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};"
"class BSTIterator:   
    
    def __init__(self, root: Optional[TreeNode]):
        self.nodes = []
        self.inorder(root)
        
    def inorder(self, root):
        if root is None:
            return
        self.inorder(root.left)
        self.nodes.append(root.val)
        self.inorder(root.right)

    def next(self) -> int:
        return self.nodes.pop(0)
        

    def hasNext(self) -> bool:
        return len(self.nodes) > 0
        


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()","class Solution {
 public:
  vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> ans;
    dfs(nums, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, int s, vector<int>&& path,
           vector<vector<int>>& ans) {
    ans.push_back(path);

    for (int i = s; i < nums.size(); ++i) {
      path.push_back(nums[i]);
      dfs(nums, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};"
"class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        dp = [[0 for i in range(len(dungeon[0]))] for i in range(len(dungeon))]
        for i in reversed(range(len(dungeon))):
            for j in reversed(range(len(dungeon[0]))):
                if i==len(dungeon)-1 and j==len(dungeon[0])-1: dp[i][j] = min(dungeon[i][j], 0); continue
                val = max(dp[i][j+1] if j<len(dungeon[0])-1 else float(""-inf""), dp[i+1][j] if i<len(dungeon)-1 else float(""-inf""))
                dp[i][j] = 0 if dungeon[i][j] + val>0 else dungeon[i][j] + val
        return max(-dp[0][0], -dungeon[0][0], 0) + 1","class Solution {
 public:
  bool exist(vector<vector<char>>& board, string word) {
    for (int i = 0; i < board.size(); ++i)
      for (int j = 0; j < board[0].size(); ++j)
        if (dfs(board, word, i, j, 0))
          return true;
    return false;
  }

 private:
  bool dfs(vector<vector<char>>& board, const string& word, int i, int j,
           int s) {
    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())
      return false;
    if (board[i][j] != word[s] || board[i][j] == '*')
      return false;
    if (s == word.length() - 1)
      return true;

    const char cache = board[i][j];
    board[i][j] = '*';
    const bool isExist = dfs(board, word, i + 1, j, s + 1) ||
                         dfs(board, word, i - 1, j, s + 1) ||
                         dfs(board, word, i, j + 1, s + 1) ||
                         dfs(board, word, i, j - 1, s + 1);
    board[i][j] = cache;

    return isExist;
  }
};"
"class Solution:
    
    def compare(self,n1,n2):
        if str(n1)+str(n2)>str(n2)+str(n1):
            return True
        else:
            return False
    
    def largestNumber(self, nums: List[int]) -> str:
        
        if len(list(set(nums)))==1 and nums[0]==0:
            return ""0""
        
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                
                if not self.compare(nums[i],nums[j]):
                    nums[i],nums[j]=nums[j],nums[i]
        
        return ''.join(map(str,nums))","class Solution {
 public:
  int removeDuplicates(vector<int>& nums) {
    int i = 0;

    for (const int num : nums)
      if (i < 2 || num > nums[i - 2])
        nums[i++] = num;

    return i;
  }
};"
"class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        if len(s)<10: return []
        ht=collections.defaultdict(int)
        res=set()
        while len(s)>=10:
            ht[s[:10]]+=1
            if ht[s[:10]]>1: res.add(s[:10])
            s=s[1:]            
        return list(res)","class Solution {
 public:
  bool search(vector<int>& nums, int target) {
    int l = 0;
    int r = nums.size() - 1;

    while (l <= r) {
      const int m = (l + r) / 2;
      if (nums[m] == target)
        return true;
      if (nums[l] == nums[m] && nums[m] == nums[r]) {
        ++l;
        --r;
      } else if (nums[l] <= nums[m]) {  // nums[l..m] are sorted
        if (nums[l] <= target && target < nums[m])
          r = m - 1;
        else
          l = m + 1;
      } else {  // nums[m..n - 1] are sorted
        if (nums[m] < target && target <= nums[r])
          l = m + 1;
        else
          r = m - 1;
      }
    }

    return false;
  }
};"
"class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        
        if k == 0: return 0
        
        t0 = [0] * (k+1)
        t1 = [float('-inf')] * k
        
        for p in prices:
            for tr in range(k):
                t0[tr] = max(t0[tr], t1[tr] + p)
                t1[tr] = max(t1[tr], t0[tr-1] - p)
        return t0[-2]","class Solution {
 public:
  ListNode* deleteDuplicates(ListNode* head) {
    ListNode dummy(0, head);
    ListNode* prev = &dummy;

    while (head) {
      while (head->next && head->val == head->next->val)
        head = head->next;
      if (prev->next == head)
        prev = prev->next;
      else
        prev->next = head->next;
      head = head->next;
    }

    return dummy.next;
  }
};"
"class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        for _ in range(k):
            nums.insert(0, nums.pop())","class Solution {
 public:
  ListNode* deleteDuplicates(ListNode* head) {
    ListNode* curr = head;

    while (curr) {
      while (curr->next && curr->val == curr->next->val)
        curr->next = curr->next->next;
      curr = curr->next;
    }

    return head;
  }
};"
"class Solution:
    def reverseBits(self, n: int) -> int:
        return int(str(bin(n)[2:]).rjust(32,'0')[::-1], 2)","class Solution {
 public:
  int largestRectangleArea(vector<int>& heights) {
    int ans = 0;
    stack<int> stack;

    for (int i = 0; i <= heights.size(); ++i) {
      while (!stack.empty() &&
             (i == heights.size() || heights[stack.top()] > heights[i])) {
        const int h = heights[stack.top()];
        stack.pop();
        const int w = stack.empty() ? i : i - stack.top() - 1;
        ans = max(ans, h * w);
      }
      stack.push(i);
    }

    return ans;
  }
};"
"class Solution:
    def hammingWeight(self, n: int) -> int:
        return len([c for c in f""{n: b}"" if c==""1""])","class Solution {
 public:
  int maximalRectangle(vector<vector<char>>& matrix) {
    if (matrix.empty())
      return 0;

    int ans = 0;
    vector<int> hist(matrix[0].size());

    for (const vector<char>& row : matrix) {
      for (int i = 0; i < row.size(); ++i)
        hist[i] = row[i] == '0' ? 0 : hist[i] + 1;
      ans = max(ans, largestRectangleArea(hist));
    }

    return ans;
  }

 private:
  int largestRectangleArea(const vector<int>& heights) {
    int ans = 0;
    stack<int> stack;

    for (int i = 0; i <= heights.size(); ++i) {
      while (!stack.empty() &&
             (i == heights.size() || heights[stack.top()] > heights[i])) {
        const int h = heights[stack.top()];
        stack.pop();
        const int w = stack.empty() ? i : i - stack.top() - 1;
        ans = max(ans, h * w);
      }
      stack.push(i);
    }

    return ans;
  }
};"
"class Solution:
    def rob(self, nums: List[int]) -> int:
        dp= [0] * len(nums)
        if len(nums) == 1:
            return nums[0]
        for i in range(len(nums)):
            dp[i] = max(dp[i-2]+nums[i],dp[i-1])
        return max(dp)","class Solution {
 public:
  ListNode* partition(ListNode* head, int x) {
    ListNode beforeHead(0);
    ListNode afterHead(0);
    ListNode* before = &beforeHead;
    ListNode* after = &afterHead;

    for (; head; head = head->next)
      if (head->val < x) {
        before->next = head;
        before = head;
      } else {
        after->next = head;
        after = head;
      }

    after->next = nullptr;
    before->next = afterHead.next;

    return beforeHead.next;
  };
};"
"class Solution:
    def rightSideView(self, root: TreeNode):
        rightside = {}
        self.seeTree(root, rightside, 1)
        numbers = [value for value in rightside.values()]
        return numbers
                
    def seeTree(self, root: TreeNode, rightside: dict, nodo: int):
        if root == None:
            return
        if root.val != None:
            rightside[nodo] = root.val
            self.seeTree(root.left, rightside, nodo + 1)
            self.seeTree(root.right, rightside, nodo + 1)
        return","class Solution {
 public:
  bool isScramble(string s1, string s2) {
    if (s1 == s2)
      return true;
    const string hashKey = s1 + '+' + s2;
    if (const auto it = memo.find(hashKey); it != cend(memo))
      return it->second;

    vector<int> count(128);

    for (int i = 0; i < s1.length(); ++i) {
      ++count[s1[i]];
      --count[s2[i]];
    }

    if (any_of(begin(count), end(count), [](int c) { return c != 0; }))
      return memo[hashKey] = false;

    for (int i = 1; i < s1.length(); ++i) {
      if (isScramble(s1.substr(0, i), s2.substr(0, i)) &&
          isScramble(s1.substr(i), s2.substr(i)))
        return memo[hashKey] = true;
      if (isScramble(s1.substr(0, i), s2.substr(s2.length() - i)) &&
          isScramble(s1.substr(i), s2.substr(0, s2.length() - i)))
        return memo[hashKey] = true;
    }

    return memo[hashKey] = false;
  }

 private:
  unordered_map<string, bool> memo;
};"
"class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        rows,cols = len(grid),len(grid[0])
        islands = 0
        visit = set()
        # using dfs in 2 methods
        # firstone
        def dfs(r,c):
            if r <0 or r >= rows or c <0 or c >= len(grid[0]) or grid[r][c]!=""1"" :
                return 
            if (r,c) not in visit:
                visit.add((r,c))
                dfs(r+1,c)
                dfs(r-1,c)
                dfs(r,c+1)
                dfs(r,c-1)

        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == ""1"" and (r,c) not in visit:
                    dfs(r,c)
                    islands+=1
        return islands","class Solution {
 public:
  void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int i = m - 1;      // nums1's index (actual nums)
    int j = n - 1;      // nums2's index
    int k = m + n - 1;  // nums1's index (next filled position)

    while (j >= 0)
      if (i >= 0 && nums1[i] > nums2[j])
        nums1[k--] = nums1[i--];
      else
        nums1[k--] = nums2[j--];
  }
};"
"class Solution:
def rangeBitwiseAnd(self, left: int, right: int) -> int:
    
    k = 0
    while left!=right:
        left>>=1
        right>>=1
        k+=1
    
    return left<<k","class Solution {
 public:
  vector<int> grayCode(int n) {
    vector<int> ans{0};

    for (int i = 0; i < n; ++i)
      for (int j = ans.size() - 1; j >= 0; --j)
        ans.push_back(ans[j] | 1 << i);

    return ans;
  }
};"
"class Solution:
    def isHappy(self, n: int) -> bool:
        while n != 1:
            n = sum([int(i) ** 2 for i in str(n)])
            if n == 4:
                return False
        
        return True","class Solution {
 public:
  vector<vector<int>> subsetsWithDup(vector<int>& nums) {
    vector<vector<int>> ans;
    sort(begin(nums), end(nums));
    dfs(nums, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, int s, vector<int>&& path,
           vector<vector<int>>& ans) {
    ans.push_back(path);

    for (int i = s; i < nums.size(); ++i) {
      if (i > s && nums[i] == nums[i - 1])
        continue;
      path.push_back(nums[i]);
      dfs(nums, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};"
"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        if not head:
            return head
        # print(head.val)
        if head.val == val:
            head = self.removeElements(head.next, val)
        else:
            head.next =  self.removeElements(head.next, val)
        return head","class Solution {
 public:
  int numDecodings(string s) {
    const int n = s.length();
    // dp[i] := # of ways to decode s[i..n)
    vector<int> dp(n + 1);
    dp[n] = 1;  // """"
    dp[n - 1] = isValid(s[n - 1]);

    for (int i = n - 2; i >= 0; --i) {
      if (isValid(s[i]))
        dp[i] += dp[i + 1];
      if (isValid(s[i], s[i + 1]))
        dp[i] += dp[i + 2];
    }

    return dp[0];
  }

 private:
  bool isValid(char c) {
    return c != '0';
  }

  bool isValid(char c1, char c2) {
    return c1 == '1' || c1 == '2' && c2 < '7';
  }
};"
"class Solution:
    def countPrimes(self, n: int) -> int:
        if n < 3:
            return 0
        
        primes = [1]*n
        primes[0] = primes[1] = 0
        for i in range(2,int(n**0.5)+1):
            if primes[i] != 0:
                for j in range(2*i,n,i):
                    primes[j] = 0
        return sum(primes)
        
    def countPrimesOptimized(self, n: int) -> int:
        if n < 3:
            return 0
        
        primes = [1]*n
        primes[0] = primes[1] = 0
        for i in range(2,int(n**0.5)+1):
            if primes[i]:
                primes[i*i:n:i] = [0]*len(primes[i*i:n:i])
                #print(i,primes[i*i:n:i])
        return sum(primes)","class Solution {
 public:
  ListNode* reverseBetween(ListNode* head, int left, int right) {
    if (left == 1)
      return reverseN(head, right);

    head->next = reverseBetween(head->next, left - 1, right - 1);

    return head;
  }

 private:
  ListNode* reverseN(ListNode* head, int n) {
    if (n == 1)
      return head;

    ListNode* newHead = reverseN(head->next, n - 1);
    ListNode* headNext = head->next;
    head->next = headNext->next;
    headNext->next = head;

    return newHead;
  }
};"
"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        MAX_CHARS = 256
        n = len(s)
        m = len(t)
        if n != m:
            return False
        marked = [False] * MAX_CHARS
        map = [-1] * MAX_CHARS

        for i in range(n):
            if map[ord(s[i])] == -1:
                if marked[ord(t[i])] == True:
                    return False
                marked[ord(t[i])] = True
                map[ord(s[i])] = t[i]
            
            elif map[ord(s[i])] != t[i]:
                return False
        return True","class Solution {
 public:
  vector<string> restoreIpAddresses(const string& s) {
    vector<string> ans;
    dfs(s, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int start, vector<string>&& path,
           vector<string>& ans) {
    if (path.size() == 4 && start == s.length()) {
      ans.push_back(path[0] + ""."" + path[1] + ""."" + path[2] + ""."" + path[3]);
      return;
    }
    if (path.size() == 4 || start == s.length())
      return;

    for (int length = 1; length <= 3; ++length) {
      if (start + length > s.length())
        return;  // Out of bound
      if (length > 1 && s[start] == '0')
        return;  // Leading '0'
      const string& num = s.substr(start, length);
      if (stoi(num) > 255)
        return;
      path.push_back(num);
      dfs(s, start + length, move(path), ans);
      path.pop_back();
    }
  }
};"
"class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        prev = None
        while head:
            head.next,head,prev = prev,head.next,head
        return prev","class Solution {
 public:
  vector<int> inorderTraversal(TreeNode* root) {
    vector<int> ans;
    stack<TreeNode*> stack;

    while (root || !stack.empty()) {
      while (root) {
        stack.push(root);
        root = root->left;
      }
      root = stack.top(), stack.pop();
      ans.push_back(root->val);
      root = root->right;
    }

    return ans;
  }
};"
"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        STATUS_VISITING = 0
        STATUS_VISITED = 1
        
        def no_cycle(node):        
            if node in status:
                if status[node] == STATUS_VISITED:
                    return True
                else:
                    return False
            
            status[node] = STATUS_VISITING
            for child in adj[node]:
                if not no_cycle(child):
                    return False
            
            status[node] = STATUS_VISITED
            return True
        
        adj = defaultdict(list)
        nodes = set()
        for a, b in prerequisites:
            adj[b].append(a)
            nodes.add(b)
            
        status = {}
        for node in nodes:
            if not no_cycle(node):
                return False           
            
        return True","class Solution {
 public:
  vector<TreeNode*> generateTrees(int n) {
    if (n == 0)
      return {};
    return generateTrees(1, n);
  }

 private:
  vector<TreeNode*> generateTrees(int min, int max) {
    if (min > max)
      return {nullptr};

    vector<TreeNode*> ans;

    for (int i = min; i <= max; ++i)
      for (TreeNode* left : generateTrees(min, i - 1))
        for (TreeNode* right : generateTrees(i + 1, max)) {
          ans.push_back(new TreeNode(i));
          ans.back()->left = left;
          ans.back()->right = right;
        }

    return ans;
  }
};"
"class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        lb = 0
        ub = 0
        wSum = nums[0]
        numLen = len(nums)
        ans = []
        while lb<numLen:
            # print(lb, ub, wSum)
            if wSum >= target:
                ans.append(ub-lb+1)
            
            if wSum < target and ub+1< numLen:
                ub+=1
                wSum += nums[ub]
            else:
                wSum -= nums[lb]
                lb+=1
                
        # print(ans)
        if ans:
            return min(ans)
        return 0","class Solution {
 public:
  int numTrees(int n) {
    // G[i] := # of unique BST's that store values 1..i
    vector<int> G(n + 1);
    G[0] = 1;
    G[1] = 1;

    for (int i = 2; i <= n; ++i)
      for (int j = 0; j < i; ++j)
        G[i] += G[j] * G[i - j - 1];

    return G[n];
  }
};"
"class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        ans = []
        d = {}
        indegree = {}
        for i in range(numCourses):
            d[i] = []
            indegree[i] = 0
        
        for i in prerequisites:
            d[i[0]].append(i[1])
            indegree[i[1]] += 1
        
        queue = []
        for i in indegree:
            if indegree[i] == 0:
                queue.append(i)
        
        while queue:
            curr = queue.pop(0)
            ans.insert(0,curr)
            for i in d[curr]:
                if indegree[i] > 0:
                    indegree[i]-= 1
                    if indegree[i] == 0:
                        queue.append(i)
        
        for i in indegree:
            if indegree[i] != 0:
                return []
        return(ans)","class Solution {
 public:
  bool isInterleave(string s1, string s2, string s3) {
    const int m = s1.length();
    const int n = s2.length();
    if (m + n != s3.length())
      return false;

    // dp[i][j] := true if s3[0..i + j) is formed by the interleaving of
    //             s1[0..i) and s2[0..j)
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
    dp[0][0] = true;

    for (int i = 1; i <= m; ++i)
      dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];

    for (int j = 1; j <= n; ++j)
      dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        dp[i][j] = dp[i - 1][j] && s1[i - 1] == s3[i + j - 1] ||
                   dp[i][j - 1] && s2[j - 1] == s3[i + j - 1];

    return dp[m][n];
  }
};"
"class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        #  My Effort - Passed all test cases, yet backtracking line doesn't work
        cntBoard = collections.Counter(''.join([e for row in board for e in row ]))
        cntW = [collections.Counter(w) for w in words]
        idxBoard = collections.defaultdict(list)
        m, n = len(board), len(board[0])
        for i in range(m):
            for j in range(n):
                idxBoard[board[i][j]].append((i,j))
        # print(idxBoard)
        dirs = [(0,1), (0,-1), (-1,0), (1,0)]
        # dirs = [(0,1), (0,-1), (1,0), (-1,0)] # fail some test cases

        def dfs(x, y, w, i):
            if i == len(w):
                return True
            for a, b in dirs:
                nx, ny = x + a, y + b
                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and board[nx][ny] == w[i]:
                    visited.add((nx, ny))
                    return dfs(nx, ny, w, i+1) # if I don't add return, the recursive function call returns None or False
                    # visited.remove((nx, ny)) # However, if I add return, this line is never executed, backtracking doesn't work but we actually need backtracking

        ans = []
        
        for w in words:
            if collections.Counter(w) - cntBoard:
                continue
            for x, y in idxBoard[w[0]]:
                visited = set()
                visited.add((x,y))
                result = dfs(x, y, w, 1)
                if result:
                    ans.append(w)
                    break
        return ans","class Solution {
 public:
  bool isValidBST(TreeNode* root) {
    return isValidBST(root, nullptr, nullptr);
  }

 private:
  bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {
    if (root == nullptr)
      return true;
    if (minNode && root->val <= minNode->val)
      return false;
    if (maxNode && root->val >= maxNode->val)
      return false;

    return isValidBST(root->left, minNode, root) &&
           isValidBST(root->right, root, maxNode);
  }
};"
"class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        
        if n == 1:
            return nums[0]
        
        if n == 2:
            return max(nums[0], nums[1])
        
        # result1: don't consider the first house
        # result2: don't consider the last house
        result1 = self.robRange(nums, 1, n-1)
        result2 = self.robRange(nums, 0, n-2)
        return max(result1, result2)
    
    def robRange(self, nums, start, end):
        dp = [0] * len(nums)
        dp[start] = nums[start]
        dp[start + 1] = max(nums[start], nums[start + 1])
        
        for i in range(start + 2, end + 1):
            dp[i] = max(dp[i -2] + nums[i], dp[i - 1])
        
        return dp[end]","class Solution {
 public:
  void recoverTree(TreeNode* root) {
    inorder(root);
    swap(x, y);
  }

 private:
  TreeNode* pred = nullptr;
  TreeNode* x = nullptr;  // 1st wrong node
  TreeNode* y = nullptr;  // 2nd wrond node

  void inorder(TreeNode* root) {
    if (root == nullptr)
      return;

    inorder(root->left);

    if (pred && root->val < pred->val) {
      y = root;
      if (x == nullptr)
        x = pred;
      else
        return;
    }
    pred = root;

    inorder(root->right);
  }

  void swap(TreeNode* x, TreeNode* y) {
    const int temp = x->val;
    x->val = y->val;
    y->val = temp;
  }
};"
"class Solution:
    def shortestPalindrome(self, s: str) -> str:
        i,l = 0,len(s)
        for j in range(l-1,-1,-1):
            if s[i]==s[j]: i+=1
        if i==l: return s
        return s[i:][::-1] + self.shortestPalindrome(s[:i]) + s[i:]","class Solution {
 public:
  bool isSameTree(TreeNode* p, TreeNode* q) {
    if (!p || !q)
      return p == q;
    return p->val == q->val &&              //
           isSameTree(p->left, q->left) &&  //
           isSameTree(p->right, q->right);
  }
};"
"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        n = len(nums)
        k = n - k

        def quickSort(l=0, r=n-1):
            p, pivot = l, nums[r]
            for i in range(l, r):
                if nums[i] <= pivot:
                    nums[i], nums[p] = nums[p], nums[i]
                    p += 1

            nums[p], nums[r] = pivot, nums[p]

            if k > p:
                return quickSort(p + 1, r)
            elif k < p:
                return quickSort(l, p - 1)
            return nums[k]

        return quickSort()","class Solution {
 public:
  bool isSymmetric(TreeNode* root) {
    return isSymmetric(root, root);
  }

 private:
  bool isSymmetric(TreeNode* p, TreeNode* q) {
    if (!p || !q)
      return p == q;

    return p->val == q->val &&                //
           isSymmetric(p->left, q->right) &&  //
           isSymmetric(p->right, q->left);
  }
};"
"class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
    
        res = []
        
        self.backtrack(k, n, [],0,1, res)
        
        return res
    
    def backtrack(self, k, n, cur, comb, ind, res):
        
        if comb > n:
            return 
        elif comb == n and len(cur) == k:
            res.append([]+cur)
        else:
            
            for i in range(ind,10):
                cur.append(i)
                
                self.backtrack(k, n, cur, comb+i, i+1, res)
                cur.pop()","class Solution {
 public:
  vector<vector<int>> levelOrder(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<vector<int>> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      vector<int> currLevel;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        currLevel.push_back(node->val);
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(currLevel);
    }

    return ans;
  }
};"
"class Solution(object):
    def containsDuplicate(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        #1
        # a = list(set(nums))
        # nums.sort()
        # a.sort()
        # return False if a==nums else True
        
        #2
        hash_table = {}
        for num in nums:
            hash_table[num] = hash_table.get(num, 0)+1
            
        return False if max(hash_table.values()) == 1 else True
        
#         #3
#         from collections import Counter
#         return False if set(Counter(nums).values()) == {1} else True","class Solution {
 public:
  vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<vector<int>> ans;
    deque<TreeNode*> q{{root}};
    bool isLeftToRight = true;

    while (!q.empty()) {
      vector<int> currLevel;
      for (int sz = q.size(); sz > 0; --sz)
        if (isLeftToRight) {
          TreeNode* node = q.front();
          q.pop_front();
          currLevel.push_back(node->val);
          if (node->left)
            q.push_back(node->left);
          if (node->right)
            q.push_back(node->right);
        } else {
          TreeNode* node = q.back();
          q.pop_back();
          currLevel.push_back(node->val);
          if (node->right)
            q.push_front(node->right);
          if (node->left)
            q.push_front(node->left);
        }
      ans.push_back(currLevel);
      isLeftToRight = !isLeftToRight;
    }

    return ans;
  }
};"
"class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        if not buildings:
            return []
        if len(buildings) == 1:
            return [[buildings[0][0], buildings[0][2]],[buildings[0][1], 0]]

        mid = (len(buildings)-1) // 2
        left = self.getSkyline(buildings[0:mid+1])
        right = self.getSkyline(buildings[mid+1:])

        return self.merge(left, right)

    def merge(self, left, right):
        i = j = h1 = h2 = 0
        ret = []
        while i < len(left) and j < len(right):
            if left[i][0] < right[j][0]:
                h1 = left[i][1]
                new = [left[i][0], max(h1, h2)]
                if not ret or ret[-1][1] != new[1]:
                    ret.append(new)
                i += 1
            elif left[i][0] > right[j][0]:
                h2 = right[j][1]
                new = [right[j][0], max(h1, h2)]
                if not ret or ret[-1][1]!=new[1]:
                    ret.append(new)
                j+=1
            else:
                h1 = left[i][1]
                h2 = right[j][1]
                new = [right[j][0], max(h1, h2)]
                if not ret or ret[-1][1] != new[1]:
                    ret.append([right[j][0],max(h1, h2)])
                i += 1
                j += 1

        while i < len(left):
            if not ret or ret[-1][1] != left[i][1]:
                ret.append(left[i][:])
            i+=1

        while j < len(right):
            if not ret or ret[-1][1] != right[j][1]:
                ret.append(right[j][:])
            j+=1

        return ret","class Solution {
 public:
  int maxDepth(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + max(maxDepth(root->left), maxDepth(root->right));
  }
};"
"class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:
        if not nums or k<1 or t<0 or (t==0 and len(nums)==len(set(nums))): return False
        for i in range(len(nums)):
            for j in range(1,k+1):
                if (i+j)>=len(nums): break
                if abs(nums[i+j]-nums[i])<=t: return True
        return False","class Solution {
 public:
  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    unordered_map<int, int> inToIndex;

    for (int i = 0; i < inorder.size(); ++i)
      inToIndex[inorder[i]] = i;

    return build(preorder, 0, preorder.size() - 1, inorder, 0,
                 inorder.size() - 1, inToIndex);
  }

 private:
  TreeNode* build(const vector<int>& preorder, int preStart, int preEnd,
                  const vector<int>& inorder, int inStart, int inEnd,
                  const unordered_map<int, int>& inToIndex) {
    if (preStart > preEnd)
      return nullptr;

    const int rootVal = preorder[preStart];
    const int rootInIndex = inToIndex.at(rootVal);
    const int leftSize = rootInIndex - inStart;

    TreeNode* root = new TreeNode(rootVal);
    root->left = build(preorder, preStart + 1, preStart + leftSize, inorder,
                       inStart, rootInIndex - 1, inToIndex);
    root->right = build(preorder, preStart + leftSize + 1, preEnd, inorder,
                        rootInIndex + 1, inEnd, inToIndex);
    return root;
  }
};"
"class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        
        for y, row in enumerate(matrix):
            count_x = 1
            for x, val in enumerate(row):
                if val is '1':
                    matrix[y][x] = count_x
                    count_x += 1
                else:
                    matrix[y][x] = 0
                    count_x = 1

        # transpose
        best = 0
        matrix = list(zip(*matrix))
        popper = list()
        for i in range(10000):
            flag = False
            for j, col in enumerate(matrix):
                count = 0
                for val in col:
                    if val > i: 
                        count += 1
                        if count > i:
                            best = i + 1
                            flag = True
                            break
                    else:
                        count = 0
                if flag:
                    break
                else:
                    popper.append(j)
            if flag:
                matrix = [col for j, col in enumerate(matrix) if j not in popper]
                popper.clear()
            else:
                break
        
        return best ** 2","class Solution {
 public:
  TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    unordered_map<int, int> inToIndex;

    for (int i = 0; i < inorder.size(); ++i)
      inToIndex[inorder[i]] = i;

    return build(inorder, 0, inorder.size() - 1, postorder, 0,
                 postorder.size() - 1, inToIndex);
  }

 private:
  TreeNode* build(const vector<int>& inorder, int inStart, int inEnd,
                  const vector<int>& postorder, int postStart, int postEnd,
                  const unordered_map<int, int>& inToIndex) {
    if (inStart > inEnd)
      return nullptr;

    const int rootVal = postorder[postEnd];
    const int rootInIndex = inToIndex.at(rootVal);
    const int leftSize = rootInIndex - inStart;

    TreeNode* root = new TreeNode(rootVal);
    root->left = build(inorder, inStart, rootInIndex - 1, postorder, postStart,
                       postStart + leftSize - 1, inToIndex);
    root->right = build(inorder, rootInIndex + 1, inEnd, postorder,
                        postStart + leftSize, postEnd - 1, inToIndex);
    return root;
  }
};"
"class Solution:
    
    def count(self,node):

        if node is None: # travelled beyond a leaf
            return 0

        return 1 + self.count(node.left) + self.count(node.right) # all other cases
    
    def countNodes(self, root: Optional[TreeNode]) -> int:
        return self.count(root)","class Solution {
 public:
  vector<vector<int>> levelOrderBottom(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<vector<int>> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      vector<int> currLevel;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        currLevel.push_back(node->val);
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(currLevel);
    }

    reverse(begin(ans), end(ans));
    return ans;
  }
};"
"class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        def get_coordinates(x1,x2,y1,y2):
            return {0:[x1,y1],1:[x2,y1],2:[x2,y2],3:[x1,y2]}
        
        first = get_coordinates(ax1,ax2,ay1,ay2)
        second = get_coordinates(bx1,bx2,by1,by2)
        
        def left_overlap(a,b):
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]>=a[1][0]:
                return abs(b[0][0]-a[1][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]>=b[1][0]:
                return abs(a[0][0]-b[1][0])
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]<a[1][0]:
                return abs(b[1][0]-b[0][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]<b[1][0]:
                return abs(a[1][0]-a[0][0])
        
        def top_overlap(a,b):
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]>=a[2][1]:
                return abs(b[0][1]-a[2][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]>=b[2][1]:
                return abs(a[0][1]-b[2][1])
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]<a[2][1]:
                return abs(b[2][1]-b[0][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]<b[2][1]:
                return abs(a[2][1]-a[0][1])
        
        l=left_overlap(first,second)
        t=top_overlap(first, second)
        
        total_area = (first[1][0]-first[0][0])*(first[2][1]-first[0][1])
        total_area+=(second[1][0]-second[0][0])*(second[2][1]-second[0][1])
        if l is not None and t is not None:
            total_area -=l*t
        return total_area","class Solution {
 public:
  TreeNode* sortedArrayToBST(vector<int>& nums) {
    return build(nums, 0, nums.size() - 1);
  }

 private:
  TreeNode* build(const vector<int>& nums, int l, int r) {
    if (l > r)
      return nullptr;
    const int m = (l + r) / 2;
    return new TreeNode(nums[m], build(nums, l, m - 1), build(nums, m + 1, r));
  }
};"
"class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        
        temp = root.left
        root.left = root.right
        root.right = temp
        
        self.invertTree(root.left)
        self.invertTree(root.right)
        
        return root","class Solution {
 public:
  TreeNode* sortedListToBST(ListNode* head) {
    if (head == nullptr)
      return nullptr;
    if (!head->next)
      return new TreeNode(head->val);

    ListNode* mid = findMid(head);
    TreeNode* root = new TreeNode(mid->val);
    root->left = sortedListToBST(head);
    root->right = sortedListToBST(mid->next);

    return root;
  }

 private:
  ListNode* findMid(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
      prev = slow;
      slow = slow->next;
      fast = fast->next->next;
    }
    prev->next = nullptr;

    return slow;
  }
};"
"class Solution:
    def calculate(self, s: str) -> int:
        #pre-processing to tokenize string 
        s = s.replace("" "", """") #remove white space
        
        tokens = []
        lo = hi = 0
        while hi <= len(s):
            if hi == len(s) or s[hi] in ""+-*/"": 
                tokens.append(s[lo:hi]) #tokenize number
                if hi < len(s): tokens.append(s[hi]) #tokenize operator
                lo = hi + 1
            hi += 1
        
        #dijkstra's two-stack algo
        opd, opr = [], [] #operand &amp; operator stacks 
        sign = 1
        for token in tokens: 
            if token in ""+-*/"": 
                opr.append(token)
                if token == ""-"": sign = -1
            else: 
                token = sign*int(token)
                sign = 1
                if opr and opr[-1] in ""*/"":
                    op = opr.pop()
                    x = opd.pop()
                    if op == ""*"": token = x * token
                    elif op == ""/"": token = int(x / token) #not floor division 
                opd.append(token)
            
        return sum(opd)","class Solution {
 public:
  bool isBalanced(TreeNode* root) {
    if (root == nullptr)
      return true;
    return abs(maxDepth(root->left) - maxDepth(root->right)) <= 1 &&
           isBalanced(root->left) && isBalanced(root->right);
  }

 private:
  int maxDepth(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + max(maxDepth(root->left), maxDepth(root->right));
  }
};"
"class Solution:
    def summaryRanges(self, a: List[int]) -> List[str]:
        if not a:
            return []
        ans=[]
        n=len(a)
        start=a[0]
        flag=0
        for i in range(n-1):
            if a[i]+1==a[i+1]:
                flag=1
            else:
                if flag==1 and start!=a[i]:
                    ans.append(str(start)+'->'+str(a[i]))
                else:
                    ans.append(str(start))
                start=a[i+1]
        if flag==1 and start!=a[i+1]:
            ans.append(str(start)+'->'+str(a[i+1]))
        else:
            ans.append(str(start))
        return ans","class Solution {
 public:
  int minDepth(TreeNode* root) {
    if (root == nullptr)
      return 0;
    if (root->left == nullptr)
      return minDepth(root->right) + 1;
    if (root->right == nullptr)
      return minDepth(root->left) + 1;
    return min(minDepth(root->left), minDepth(root->right)) + 1;
  }
};"
"class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        return [v for v in set(nums) if nums.count(v)>math.floor(len(nums)/3)]","class Solution {
 public:
  bool hasPathSum(TreeNode* root, int sum) {
    if (root == nullptr)
      return false;
    if (root->val == sum && root->left == nullptr && root->right == nullptr)
      return true;
    return hasPathSum(root->left, sum - root->val) ||
           hasPathSum(root->right, sum - root->val);
  }
};"
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        node_vals = []

        def traverse_inorder(node):
            if node is None:
                return
            traverse_inorder(node.left)
            node_vals.append(node.val)
            traverse_inorder(node.right)

        traverse_inorder(root)

        return node_vals[k - 1]","class Solution {
 public:
  vector<vector<int>> pathSum(TreeNode* root, int sum) {
    vector<vector<int>> ans;
    dfs(root, sum, {}, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int sum, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (root == nullptr)
      return;
    if (root->val == sum && root->left == nullptr && root->right == nullptr) {
      path.push_back(root->val);
      ans.push_back(path);
      path.pop_back();
      return;
    }

    path.push_back(root->val);
    dfs(root->left, sum - root->val, move(path), ans);
    dfs(root->right, sum - root->val, move(path), ans);
    path.pop_back();
  }
};"
"class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        return n &amp; (n-1) == 0","class Solution {
 public:
  void flatten(TreeNode* root) {
    if (root == nullptr)
      return;

    flatten(root->left);
    flatten(root->right);

    TreeNode* const left = root->left;    // Flattened left
    TreeNode* const right = root->right;  // Flattened right

    root->left = nullptr;
    root->right = left;

    // Connect the original right subtree
    // To the end of new right subtree
    TreeNode* rightmost = root;
    while (rightmost->right)
      rightmost = rightmost->right;
    rightmost->right = right;
  }
};"
"class Solution:
    def countDigitOne(self, n: int) -> int:
        if n < 1: return 0

        # i = 0
        p = 1 # 10 ** i
        c = 0 # count of 1s less than 10 ** i
        
        result = 0
        for char in str(n)[::-1]:
            d = int(char)
            # if d == 0: pass
            if d == 1:
                result += c + n%(p) + 1
            elif d > 1:
                result += p + d*c
            c += p + (c<<3)+c # c = p + 8*c + c
            p = (p<<3)+p+p # p *= 10
            # i += 1
        return result","class Solution {
 public:
  int numDistinct(string s, string t) {
    const int m = s.length();
    const int n = t.length();
    vector<vector<unsigned long>> dp(m + 1, vector<unsigned long>(n + 1));

    for (int i = 0; i <= m; ++i)
      dp[i][0] = 1;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (s[i - 1] == t[j - 1])
          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
        else
          dp[i][j] = dp[i - 1][j];

    return dp[m][n];
  }
};"
"class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:

        slow_node = head
        fast_node = slow_node
        prev_node = None
        while fast_node is not None:

            if fast_node.next is None:
                # list is odd length (don't add another node to reversed 1st half list - the next node is the odd mid-point)
                fast_node = fast_node.next
                slow_node = slow_node.next
            else:
                # list is even length (add another node to reversed 1st half list)
                fast_node = fast_node.next.next
                temp_node = slow_node
                slow_node = slow_node.next
                temp_node.next = prev_node
                prev_node = temp_node

        # At this point prev_node points to the head of reversed 1st half of list and slow_node points to head of remaining half of list

        while slow_node is not None:
            if slow_node.val != prev_node.val:
                return False
            slow_node = slow_node.next
            prev_node = prev_node.next

        return True","class Solution {
 public:
  Node* connect(Node* root) {
    if (root == nullptr)
      return nullptr;
    connectTwoNodes(root->left, root->right);
    return root;
  }

 private:
  void connectTwoNodes(Node* p, Node* q) {
    if (p == nullptr)
      return;
    p->next = q;
    connectTwoNodes(p->left, p->right);
    connectTwoNodes(q->left, q->right);
    connectTwoNodes(p->right, q->left);
  }
};"
"class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        cur =root
        while cur:
            if p.val > cur.val and q.val>cur.val:
                cur=cur.right
            elif p.val<cur.val and q.val<cur.val:
                cur=cur.left
            else:
                return cur","class Solution {
 public:
  Node* connect(Node* root) {
    Node* node = root;  // The node just above current needling

    while (node) {
      Node dummy(0);  // Dummy node before needling
      // Needle children of node
      for (Node* needle = &dummy; node; node = node->next) {
        if (node->left) {  // Needle left child
          needle->next = node->left;
          needle = needle->next;
        }
        if (node->right) {  // Needle right child
          needle->next = node->right;
          needle = needle->next;
        }
      }
      node = dummy.next;  // Move node to the next level
    }

    return root;
  }
};"
"class Solution:
    def __init__(self):
        self.seen = collections.defaultdict(TreeNode)
        
    def get_list(self, cur, prev, target):
        if not cur:
            return None
        
        self.seen[cur.val] = cur
        
        new_cur = TreeNode(cur.val)
        new_cur.left = prev
        
        if new_cur.val == target.val:
            return new_cur
        
        _next = cur.left
        head_from_left = self.get_list(_next, new_cur, target)
        if head_from_left:
            return head_from_left
        
        _next = cur.right
        head_from_right = self.get_list(_next, new_cur, target)
        if head_from_right:
            return head_from_right
        
        new_cur.left = None
        
        return None

    
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        head1 = self.get_list(root, None, p)
        head2 = self.get_list(root, None, q)
        
        it1, it2 = head1, head2
        
        while it1.val != it2.val:
            if not it1.left:
                it1 = head2
            else:
                it1 = it1.left
            
            if not it2.left:
                it2 = head1
            else:
                it2 = it2.left
        
        return self.seen[it1.val]","class Solution {
 public:
  vector<vector<int>> generate(int numRows) {
    vector<vector<int>> ans;

    for (int i = 0; i < numRows; ++i)
      ans.push_back(vector<int>(i + 1, 1));

    for (int i = 2; i < numRows; ++i)
      for (int j = 1; j < ans[i].size() - 1; ++j)
        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j];

    return ans;
  }
};"
"class Solution:
    def deleteNode(self, node):
        """"""
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """"""            
        node.val = node.next.val
        node.next = node.next.next","class Solution {
 public:
  vector<int> getRow(int rowIndex) {
    vector<int> ans(rowIndex + 1, 1);

    for (int i = 2; i < rowIndex + 1; ++i)
      for (int j = 1; j < i; ++j)
        ans[i - j] += ans[i - j - 1];

    return ans;
  }
};"
"class Solution:
    def productExceptSelf(self, n: List[int]) -> List[int]:
        ans = [1] * len(n)
        
        pre, pos = 1, 1
        
        for i in range(len(n)):
            ans[i] = pre
            pre *= n[i]
            
        for i in range(len(n)-1, -1, -1):
            ans[i] *= pos
            pos *= n[i]
            
        return ans","class Solution {
 public:
  int minimumTotal(vector<vector<int>>& triangle) {
    for (int i = triangle.size() - 2; i >= 0; --i)
      for (int j = 0; j <= i; ++j)
        triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);
    return triangle[0][0];
  }
};"
"class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        l,r = 0,0
        q = []
        
        while True:
            if not q:
                q.append(nums[l])
            else:
                while q and nums[r]>=q[-1]:
                    q.pop()
                q.append(nums[r])         
            if r-l+1==k:
                break
            r+=1
          
        ans = []
        
        while r!=len(nums):
            maxi = q[0]
            ans.append(maxi)	
            if r+1<len(nums):
                while q and (len(q)==0 or nums[r+1]>q[-1]):
                    q.pop()
                q.append(nums[r+1])  
            if nums[l]==q[0]:
                q.pop(0)
            l+=1
            r+=1
        return ans","class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    int sellOne = 0;
    int holdOne = INT_MIN;

    for (const int price : prices) {
      sellOne = max(sellOne, holdOne + price);
      holdOne = max(holdOne, -price);
    }

    return sellOne;
  }
};"
"class Solution:
    def binarysrc(self,arr,k):
        l=0
        r=len(arr)-1
        while l<=r:
            m=(l+r)//2
            if arr[m]==k:
                return m
            elif k>arr[m]:
                l=m+1
            else:
                r=m-1
        else:
            return -1  
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        for i in range(len(matrix)):
            if target>=matrix[i][0] and target<=matrix[i][-1]:
                if self.binarysrc(matrix[i],target)!=-1:
                    return True
        return False","class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    int sell = 0;
    int hold = INT_MIN;

    for (const int price : prices) {
      sell = max(sell, hold + price);
      hold = max(hold, sell - price);
    }

    return sell;
  }
};"
"class Solution:
    def diffWaysToCompute(self, input: str) -> List[int]:
        ops={
            '+':lambda x,y:x+y,
            '-':lambda x,y:x-y,
            '*':lambda x,y:x*y
        }
        def ways(s):
            ans=[]
            for i in range(len(s)):
                if s[i] in '+-*':
                    ans+=[ops[s[i]](l,r) for l,r in itertools.product(ways(s[0:i]),ways(s[i+1:]))]
            if not ans:
                ans.append(int(s))
            return ans
        return ways(input)","class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    int sellTwo = 0;
    int holdTwo = INT_MIN;
    int sellOne = 0;
    int holdOne = INT_MIN;

    for (const int price : prices) {
      sellTwo = max(sellTwo, holdTwo + price);
      holdTwo = max(holdTwo, sellOne - price);
      sellOne = max(sellOne, holdOne + price);
      holdOne = max(holdOne, -price);
    }

    return sellTwo;
  }
};"
"class Solution:
    def isAnagram(self, s, t):
        return Counter(s) == Counter(t)","class Solution {
 public:
  int maxPathSum(TreeNode* root) {
    int ans = INT_MIN;
    maxPathSumDownFrom(root, ans);
    return ans;
  }

 private:
  // root->val + 0/1 of its subtrees
  int maxPathSumDownFrom(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = max(0, maxPathSumDownFrom(root->left, ans));
    const int r = max(0, maxPathSumDownFrom(root->right, ans));
    ans = max(ans, root->val + l + r);
    return root->val + max(l, r);
  }
};"
"class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        self.ans = []
        
        def recurse(node, s):
            if node is None:
                return True
            
            s += str(node.val)
            left = recurse(node.left, s + ""->"")
            right = recurse(node.right, s + ""->"")
            
            if left and right:
                self.ans.append(s)
            
        recurse(root, '')
     
        return self.ans","class Solution {
 public:
  bool isPalindrome(string s) {
    int l = 0;
    int r = s.length() - 1;

    while (l < r) {
      while (l < r && !isalnum(s[l]))
        ++l;
      while (l < r && !isalnum(s[r]))
        --r;
      if (tolower(s[l]) != tolower(s[r]))
        return false;
      ++l;
      --r;
    }

    return true;
  }
};"
"class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        counter = collections.Counter(nums)
        res = sorted(counter, key=lambda x:counter[x])
        return [res[0], res[1]]","class Solution {
 public:
  vector<vector<string>> findLadders(string beginWord, string endWord,
                                     vector<string>& wordList) {
    unordered_set<string> wordSet{begin(wordList), end(wordList)};
    if (!wordSet.count(endWord))
      return {};

    // {""hit"": [""hot""], ""hot"": [""dot"", ""lot""], ...}
    unordered_map<string, vector<string>> graph;

    // Build graph from beginWord -> endWord
    if (!bfs(beginWord, endWord, wordSet, graph))
      return {};

    vector<vector<string>> ans;
    dfs(graph, beginWord, endWord, {beginWord}, ans);
    return ans;
  }

 private:
  bool bfs(const string& beginWord, const string& endWord,
           unordered_set<string>& wordSet,
           unordered_map<string, vector<string>>& graph) {
    unordered_set<string> currentLevelWords{beginWord};

    while (!currentLevelWords.empty()) {
      for (const string& word : currentLevelWords)
        wordSet.erase(word);
      unordered_set<string> nextLevelWords;
      bool reachEndWord = false;
      for (const string& parent : currentLevelWords) {
        vector<string> children;
        getChildren(parent, wordSet, children);
        for (const string& child : children) {
          if (wordSet.count(child)) {
            nextLevelWords.insert(child);
            graph[parent].push_back(child);
          }
          if (child == endWord)
            reachEndWord = true;
        }
      }
      if (reachEndWord)
        return true;
      currentLevelWords = move(nextLevelWords);
    }

    return false;
  }

  void getChildren(const string& parent, const unordered_set<string>& wordSet,
                   vector<string>& children) {
    string s(parent);

    for (int i = 0; i < s.length(); ++i) {
      const char cache = s[i];
      for (char c = 'a'; c <= 'z'; ++c) {
        if (c == cache)
          continue;
        s[i] = c;  // Now is `child`
        if (wordSet.count(s))
          children.push_back(s);
      }
      s[i] = cache;
    }
  }

  void dfs(const unordered_map<string, vector<string>>& graph,
           const string& word, const string& endWord, vector<string>&& path,
           vector<vector<string>>& ans) {
    if (word == endWord) {
      ans.push_back(path);
      return;
    }
    if (!graph.count(word))
      return;

    for (const string& child : graph.at(word)) {
      path.push_back(child);
      dfs(graph, child, endWord, move(path), ans);
      path.pop_back();
    }
  }
};"
"class Solution:
    def isUgly(self, n: int) -> bool:
        if n == 0:      # CRITICAL edge case!
            return False
        a = n
        for d in [2, 3, 5]:  # means -- taking out all ""banned"" factors from the input number
            while a % d == 0:
                a //= d
        return a == 1","class Solution {
 public:
  int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
    unordered_set<string> wordSet(begin(wordList), end(wordList));
    if (!wordSet.count(endWord))
      return 0;

    int ans = 0;
    queue<string> q{{beginWord}};

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        string word = q.front();
        q.pop();
        for (int i = 0; i < word.length(); ++i) {
          const char cache = word[i];
          for (char c = 'a'; c <= 'z'; ++c) {
            word[i] = c;
            if (word == endWord)
              return ans + 1;
            if (wordSet.count(word)) {
              q.push(word);
              wordSet.erase(word);
            }
          }
          word[i] = cache;
        }
      }
    }

    return 0;
  }
};"
"class Solution:
    def find_upper(self, d, n_list, beg):
        re = 1
        for i in range(beg, len(n_list)):
            re = n_list[i]
            if (d < n_list[i]):
                break
        return(re)
            
    def nthUglyNumber(self, n: int) -> int:
        re = 1
        ll = [1]
        for i in range(n-1):
            new_n = ll[len(ll)-1]
            min_n = new_n * 10
            
            d2 = self.find_upper(new_n//2, ll, len(ll)//2) * 2
            if (d2 < min_n):
                min_n = d2
            d3 = self.find_upper(new_n//3, ll, len(ll)//3) * 3
            if (d3 < min_n):
                min_n = d3 
            d5 = self.find_upper(new_n//5, ll, len(ll)//5) * 5
            if (d5 < min_n):
                min_n = d5
                
            ll.append(min_n)
            re = min_n
            
        return(re)","class Solution {
 public:
  int longestConsecutive(vector<int>& nums) {
    int ans = 0;
    unordered_set<int> seen{begin(nums), end(nums)};

    for (int num : nums) {
      // Num is the start of a sequence
      if (seen.count(num - 1))
        continue;
      int length = 1;
      while (seen.count(++num))
        ++length;
      ans = max(ans, length);
    }

    return ans;
  }
};"
"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        #nums.sort()
        list1=[x for x in range(0,len(nums)+1) if x not in nums]
        print(list1[0])
        return list1[0]","class Solution {
 public:
  int sumNumbers(TreeNode* root) {
    int ans = 0;
    dfs(root, 0, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int path, int& ans) {
    if (root == nullptr)
      return;
    if (root->left == nullptr && root->right == nullptr) {
      ans += path * 10 + root->val;
      return;
    }

    dfs(root->left, path * 10 + root->val, ans);
    dfs(root->right, path * 10 + root->val, ans);
  }
};"
"class Solution:
    def numberToWords(self, num: int) -> str:
        ones = {1:'One', 2:'Two', 3:'Three', 4:'Four', 5:'Five', 
                6:'Six', 7:'Seven', 8:'Eight', 9:'Nine'}
        teens = {10:'Ten', 11:'Eleven', 12:'Twelve', 13:'Thirteen', 14:'Fourteen', 15:'Fifteen',
                 16:'Sixteen', 17:'Seventeen', 18:'Eighteen', 19:'Nineteen'}
        tens = {2:'Twenty', 3:'Thirty', 4:'Forty', 5:'Fifty', 
                6:'Sixty', 7:'Seventy', 8:'Eighty', 9:'Ninety'}
        comas = {0:'', 1:'Thousand', 2:'Million', 3:'Billion'}

        def threeDigit(n):
            res = ''
            if n // 100:
                res += (ones[n//100]+' Hundred ')
                if n%100 == 0:
                    return res
                n %= 100
            
            if int(n) == 0:
                return res
            elif n < 10:
                res += (ones[n]+' ')
            elif n < 20:
                res += (teens[n]+' ')
            elif n%10 == 0:
                res += (tens[n//10]+' ')
            else:
                res += (tens[n//10]+' '+ones[n%10]+' ')
            return res
        
        if num == 0:
            return 'Zero'
        if num < 1000:
            return threeDigit(num).strip()

        numdiv, res = [], ''        
        while num > 0:
            numdiv.insert(0, num%1000)
            num //= 1000
        #num: 1234567 => [1,234,567]
        
        for i in range(len(numdiv)):
            part = threeDigit(numdiv[i])
            if part == '':
                continue
            else:
                res += (part+comas[len(numdiv)-1-i]+' ')
        
        return res.rstrip()","class Solution {
 public:
  void solve(vector<vector<char>>& board) {
    if (board.empty())
      return;

    const int m = board.size();
    const int n = board[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<pair<int, int>> q;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i * j == 0 || i == m - 1 || j == n - 1)
          if (board[i][j] == 'O') {
            q.emplace(i, j);
            board[i][j] = '*';
          }

    // Mark grids that stretch from four sides with '*'
    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (board[x][y] != 'O')
          continue;
        q.emplace(x, y);
        board[x][y] = '*';
      }
    }

    for (vector<char>& row : board)
      for (char& c : row)
        if (c == '*')
          c = 'O';
        else if (c == 'O')
          c = 'X';
  }
};"
"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations.sort(reverse = True)
        
        for indx, citation in enumerate(citations):
            if indx >= citation:
                return indx
        return len(citations)","class Solution {
 public:
  vector<vector<string>> partition(string s) {
    vector<vector<string>> ans;
    dfs(s, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int start, vector<string>&& path,
           vector<vector<string>>& ans) {
    if (start == s.length()) {
      ans.push_back(path);
      return;
    }

    for (int i = start; i < s.length(); ++i)
      if (isPalindrome(s, start, i)) {
        path.push_back(s.substr(start, i - start + 1));
        dfs(s, i + 1, move(path), ans);
        path.pop_back();
      }
  }

  bool isPalindrome(const string& s, int l, int r) {
    while (l < r)
      if (s[l++] != s[r--])
        return false;
    return true;
  }
};"
"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        while citations and citations[0]<len(citations):
            citations.pop(0)
        return len(citations)","class Solution {
 public:
  int minCut(string s) {
    const int n = s.length();
    // isPalindrome[i][j] := true if s[i..j] is a palindrome
    vector<vector<bool>> isPalindrome(n, vector<bool>(n, true));
    // dp[i] := min cuts needed for a palindrome partitioning of s[0..i]
    vector<int> dp(n, n);

    for (int l = 2; l <= n; ++l)
      for (int i = 0, j = l - 1; j < n; ++i, ++j)
        isPalindrome[i][j] = s[i] == s[j] && isPalindrome[i + 1][j - 1];

    for (int i = 0; i < n; ++i) {
      if (isPalindrome[0][i]) {
        dp[i] = 0;
        continue;
      }

      // Try all possible partitions
      for (int j = 0; j < i; ++j)
        if (isPalindrome[j + 1][i])
          dp[i] = min(dp[i], dp[j] + 1);
    }

    return dp.back();
  }
};"
"class Solution:
    def firstBadVersion(self, n: int) -> int:
        left  = 1
        while n >= left:
            mid = (n + left) // 2
            if isBadVersion(mid) and not isBadVersion(mid-1):
                return mid
            elif not isBadVersion(mid) :
                left = mid + 1
            else:
                n = mid -1","class Solution {
 public:
  Node* cloneGraph(Node* node) {
    if (node == nullptr)
      return nullptr;

    queue<Node*> q{{node}};
    unordered_map<Node*, Node*> map{{node, new Node(node->val)}};

    while (!q.empty()) {
      Node* u = q.front();
      q.pop();
      for (Node* v : u->neighbors) {
        if (!map.count(v)) {
          map[v] = new Node(v->val);
          q.push(v);
        }
        map[u]->neighbors.push_back(map[v]);
      }
    }

    return map[node];
  }
};"
"class Solution:
    def numSquares(self, n: int) -> int:
        #check whether n is perfect square
        if int(n**0.5)**2==n:
            return 1
        #collect the possible perfect squares used to construct n
        ps=set()
        i=1
        while i**2<=n:
            ps.add(i**2)
            i+=1
        #create two ends of the bfs
        begin=set()
        begin.add(0)
        end=set()
        end.add(n)
        step=0
        while begin and end:
            step+=1
            temp=set()
            high=max(end)
            for i in begin:
                for j in ps:
                    #check if begin reaches end
                    if (i+j) in end:
                        return step
                    #if i+j>high, it's not possible to be a part of the answer
                    elif i+j<high:
                        temp.add(i+j)
            begin=temp
            step+=1
            temp=set()
            low=min(begin)
            for i in end:
                for j in ps:
                    #check if end reaches begin
                    if (i-j) in begin:
                        return step
                    #if i-j<low, it's not possible to be a part of the answer
                    elif i-j>low:
                        temp.add(i-j)
            end=temp
        return -1","class Solution {
 public:
  int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    const int gasses = accumulate(begin(gas), end(gas), 0);
    const int costs = accumulate(begin(cost), end(cost), 0);
    if (gasses - costs < 0)
      return -1;

    int ans = 0;
    int sum = 0;

    // Try to start from each index
    for (int i = 0; i < gas.size(); ++i) {
      sum += gas[i] - cost[i];
      if (sum < 0) {
        sum = 0;
        ans = i + 1;  // Start from next index
      }
    }

    return ans;
  }
};"
"class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        
        def fn(i, expr, total, last):
            """"""Populate ans with expression evaluated to target.""""""
            if i == len(num): 
                if total == target: ans.append(expr)
            else: 
                for ii in range(i, len(num) if num[i] != ""0"" else i+1): 
                    val = int(num[i:ii+1])
                    if i == 0: fn(ii+1, num[i:ii+1], val, val)
                    else: 
                        fn(ii+1, expr + ""*"" + num[i:ii+1], total - last + last * val, last * val)
                        fn(ii+1, expr + ""+"" + num[i:ii+1], total + val, val)
                        fn(ii+1, expr + ""-"" + num[i:ii+1], total - val, -val)
                    
        ans = []
        fn(0, """", 0, 0)
        return ans","class Solution {
 public:
  int candy(vector<int>& ratings) {
    const int n = ratings.size();
    int ans = 0;
    vector<int> l(n, 1);
    vector<int> r(n, 1);

    for (int i = 1; i < n; ++i)
      if (ratings[i] > ratings[i - 1])
        l[i] = l[i - 1] + 1;

    for (int i = n - 2; i >= 0; --i)
      if (ratings[i] > ratings[i + 1])
        r[i] = r[i + 1] + 1;

    for (int i = 0; i < n; ++i)
      ans += max(l[i], r[i]);

    return ans;
  }
};"
"class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        start = 0 
        second = 1

       
        while second < len(nums): 
           
            if(nums[start] == 0 and nums[second] !=0):
               nums[start], nums[second] = nums[second], nums[start]
               start+=1
            if(nums[start] != 0 ):
                start +=1
            second+=1","class Solution {
 public:
  int singleNumber(vector<int>& nums) {
    int ans = 0;

    for (const int num : nums)
      ans ^= num;

    return ans;
  }
};"
"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        
        freq = Counter(nums)
        return freq.most_common(1)[0][0]","class Solution {
 public:
  int singleNumber(vector<int>& nums) {
    int ans = 0;

    for (int i = 0; i < 32; ++i) {
      int sum = 0;
      for (const int num : nums)
        sum += num >> i & 1;
      sum %= 3;
      ans |= sum << i;
    }

    return ans;
  }
};"
"class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        rows, cols = len(board),  len(board[0])     
        def transform(row, col, temp_board):
            nonlocal rows, cols
            neighbors = 0
            for r, c in [(row-1, col-1), (row, col-1), (row+1, col-1), (row-1, col), (row+1, col), (row-1, col+1), (row, col+1), (row+1, col+1)]:
                if 0 <= c < cols and 0 <= r < rows:
                    neighbors += temp_board[r][c]
                    
            if board[row][col] == 1:
                if neighbors < 2 or neighbors > 3:
                    return 0
                else:
                    return 1
            else:
                return 1 if neighbors == 3 else 0
        # Take a snapshot of the current board for calculation
        temp_board = [row[:] for row in board]
        for row in range(rows):
            for col in range(cols):
                board[row][col] = transform(row, col, temp_board)","class Solution {
 public:
  Node* copyRandomList(Node* head) {
    if (head == nullptr)
      return nullptr;
    if (const auto it = map.find(head); it != cend(map))
      return it->second;

    Node* newNode = new Node(head->val);
    map[head] = newNode;
    newNode->next = copyRandomList(head->next);
    newNode->random = copyRandomList(head->random);
    return newNode;
  }

 private:
  unordered_map<Node*, Node*> map;
};"
"class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        s=s.split()
        if(len(s)!=len(pattern)):
            return False
        d=dict()
        for i,j in zip(list(pattern),s):
            if i not in d:
                if j not in d.values():
                    d[i]=j
                else:
                    return False
            else:
                if d[i]!=j:
                    return False
        return True","class Solution {
 public:
  bool wordBreak(string s, vector<string>& wordDict) {
    return wordBreak(s, {begin(wordDict), end(wordDict)}, {});
  }

 private:
  bool wordBreak(const string& s, const unordered_set<string>&& wordSet,
                 unordered_map<string, bool>&& memo) {
    if (wordSet.count(s))
      return true;
    if (const auto it = memo.find(s); it != cend(memo))
      return it->second;

    // 1 <= prefix.length() < s.length()
    for (int i = 1; i < s.length(); ++i) {
      const string& prefix = s.substr(0, i);
      const string& suffix = s.substr(i);
      if (wordSet.count(prefix) && wordBreak(suffix, move(wordSet), move(memo)))
        return memo[s] = true;
    }

    return memo[s] = false;
  }
};"
"class Solution:
    def canWinNim(self, n: int) -> bool:
        
        return n % 4","class Solution {
 public:
  vector<string> wordBreak(string s, vector<string>& wordDict) {
    unordered_set<string> wordSet{begin(wordDict), end(wordDict)};
    unordered_map<string, vector<string>> memo;
    return wordBreak(s, wordSet, memo);
  }

 private:
  vector<string> wordBreak(const string& s,
                           const unordered_set<string>& wordSet,
                           unordered_map<string, vector<string>>& memo) {
    if (const auto it = memo.find(s); it != cend(memo))
      return it->second;

    vector<string> ans;

    // 1 <= prefix.length() < s.length()
    for (int i = 1; i < s.length(); ++i) {
      const string& prefix = s.substr(0, i);
      const string& suffix = s.substr(i);
      if (wordSet.count(prefix))
        for (const string& word : wordBreak(suffix, wordSet, memo))
          ans.push_back(prefix + "" "" + word);
    }

    // Contains whole string, so don't add any space
    if (wordSet.count(s))
      ans.push_back(s);

    return memo[s] = ans;
  }
};"
"class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        bulls = 0
        fqs, fqg = {}, {} #frequency table 
        for s, g in zip(secret, guess): 
            if s == g: bulls += 1
            fqs[s] = 1 + fqs.get(s, 0)
            fqg[g] = 1 + fqg.get(g, 0)
        cows = sum(min(v, fqg.get(k, 0)) for k, v in fqs.items()) - bulls
        return f""{bulls}A{cows}B""","class Solution {
 public:
  bool hasCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
      if (slow == fast)
        return true;
    }

    return false;
  }
};"
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        lis = [nums[0]]
        for num in nums[1:]:
            if lis and num > lis[-1]:
                lis.append(num)
            else:
                index = bisect_left(lis, num)
                lis[index] = num
        return len(lis)","class Solution {
 public:
  ListNode* detectCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
      if (slow == fast) {
        slow = head;
        while (slow != fast) {
          slow = slow->next;
          fast = fast->next;
        }
        return slow;
      }
    }

    return nullptr;
  }
};"
"class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        self.ans = []
        self.minMoves = float('inf')
        
        @lru_cache(None)
        def rec(s, count):
            if not s or count > self.minMoves:
                return
            elif self.isValid(s):
                if count == self.minMoves:
                    self.ans.append(s)
                else:
                    self.minMoves = count
                    self.ans = [s]
            
            for i in range(len(s)):
                if s[i] in '()':
                    rec(s[:i] + s[i+1:], count+1)
                    
        rec(s, 0)
        return self.ans or ['']
            
            
    def isValid(self, s):
        l, r = 0, 0
        for i in range(len(s)):
            if s[i] == '(': l += 1
            elif s[i] == ')': r += 1
                
            if r > l: return False
            
        return r == l","class Solution {
 public:
  void reorderList(ListNode* head) {
    if (!head || !head->next)
      return;

    ListNode* mid = findMid(head);
    ListNode* reversed = reverse(mid);
    merge(head, reversed);
  }

 private:
  ListNode* findMid(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
      prev = slow;
      slow = slow->next;
      fast = fast->next->next;
    }
    prev->next = nullptr;

    return slow;
  }

  ListNode* reverse(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;

    while (curr) {
      ListNode* next = curr->next;
      curr->next = prev;
      prev = curr;
      curr = next;
    }

    return prev;
  }

  void merge(ListNode* l1, ListNode* l2) {
    while (l2) {
      ListNode* next = l1->next;
      l1->next = l2;
      l1 = l2;
      l2 = next;
    }
  }
};"
"class Solution:
    def isAdditiveNumber(self, num: str) -> bool:
        n = len(num)
        for i in range(1, n//2+1):
            x = num[:i]
            if x.startswith(""0"") and len(x) > 1: break #no leading zero 
            for j in range(i+1, min(n-i, (n+i)//2)+1): #i <= n-j and j-i <= n-j
                yy = num[i:j]
                if yy.startswith(""0"") and len(yy) > 1: break #no leading zero
                
                ii, xx = i, x
                while num.startswith(yy, ii):
                    ii += len(yy)
                    xx, yy = yy, str(int(xx) + int(yy))
                if ii == len(num): return True 
                
        return False","class Solution {
 public:
  vector<int> preorderTraversal(TreeNode* root) {
    vector<int> ans;
    preorder(root, ans);
    return ans;
  }

 private:
  void preorder(TreeNode* root, vector<int>& ans) {
    if (root == nullptr)
      return;

    ans.push_back(root->val);
    preorder(root->left, ans);
    preorder(root->right, ans);
  }
};"
"class Solution:
    def solve(self, prices, index, opt):
        if index >= len(prices):
            return 0
        if (index, opt) in self.dp:
            return self.dp[(index, opt)]
        if opt == 0:
            buy = self.solve(prices, index+1, 1) - prices[index]
            cool = self.solve(prices, index+1, 0)
            self.dp[(index, opt)] = max(buy, cool)
        else:
            sell = self.solve(prices, index+2, 0) + prices[index]
            cool = self.solve(prices, index+1, 1)
            self.dp[(index, opt)] = max(sell, cool)
        return self.dp[(index, opt)]
        
    def maxProfit(self, prices: List[int]) -> int:
        self.dp = {}
        return self.solve(prices, 0, 0)","class Solution {
 public:
  vector<int> postorderTraversal(TreeNode* root) {
    vector<int> ans;
    postorder(root, ans);
    return ans;
  }

 private:
  void postorder(TreeNode* root, vector<int>& ans) {
    if (root == nullptr)
      return;

    postorder(root->left, ans);
    postorder(root->right, ans);
    ans.push_back(root->val);
  }
};"
"class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        
        if n<2:
            return range(n)
        
        graph=defaultdict(set)
        indegree=[0]*n
        for u,v in edges:
            graph[u].add(v)
            graph[v].add(u)
            indegree[u]+=1
            indegree[v]+=1
        
        queue=[]
        for i in range(n):
            if indegree[i]==1:
                queue.append(i)
        
        count=n
        
        while count>2:
            new_queue=[]
            
            for current in queue:
                
                for neighbour in graph[current]:
                    indegree[neighbour]-=1
                    graph[neighbour].remove(current)
                    if indegree[neighbour]==1:
                        new_queue.append(neighbour)
                
                count-=1
            queue=new_queue
        
        return queue","class Solution {
 public:
  ListNode* insertionSortList(ListNode* head) {
    ListNode dummy(0);
    ListNode* prev = &dummy;  // The last (largest) of the sorted list

    while (head) {                  // Current inserting node
      ListNode* next = head->next;  // Cache next inserting node
      if (prev->val >= head->val)   // `prev` >= current inserting node
        prev = &dummy;              // Move `prev` to the front
      while (prev->next && prev->next->val < head->val)
        prev = prev->next;
      head->next = prev->next;
      prev->next = head;
      head = next;  // Update current inserting node
    }

    return dummy.next;
  }
};"
"class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        size = len(nums)        
        
        t = [[-1 for p in range(0,size+1)]
            for q in range(0,size+1)]
        
        return self.solve(nums,1,size-1,t)
        
    def solve(self,arr,i,j,t):
        if i >= j:
            return 0
        
        if t[i][j] > 0:
            return t[i][j]
        
        ans = float('-inf')
        
        for k in range(i,j):
            if t[i][k] != -1:
                left = t[i][k]
            else:
                left = self.solve(arr,i,k,t)
                t[i][k] = left
                
            if t[k+1][j] != -1:
                right = t[k+1][j]
            else:
                right = self.solve(arr,k+1,j,t)
                t[k+1][j] = right
                
            temp = left + right + (arr[i-1]*arr[k]*arr[j])
            
            ans = max(ans,temp)
            
        t[i][j] = ans
        return t[i][j]","class Solution {
 public:
  ListNode* sortList(ListNode* head) {
    const int length = getLength(head);
    ListNode dummy(0, head);

    for (int k = 1; k < length; k *= 2) {
      ListNode* curr = dummy.next;
      ListNode* tail = &dummy;
      while (curr) {
        ListNode* l = curr;
        ListNode* r = split(l, k);
        curr = split(r, k);
        auto [mergedHead, mergedTail] = merge(l, r);
        tail->next = mergedHead;
        tail = mergedTail;
      }
    }

    return dummy.next;
  }

 private:
  int getLength(ListNode* head) {
    int length = 0;
    for (ListNode* curr = head; curr; curr = curr->next)
      ++length;
    return length;
  }

  ListNode* split(ListNode* head, int k) {
    while (--k && head)
      head = head->next;
    ListNode* rest = head ? head->next : nullptr;
    if (head != nullptr)
      head->next = nullptr;
    return rest;
  }

  pair<ListNode*, ListNode*> merge(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* tail = &dummy;

    while (l1 && l2) {
      if (l1->val > l2->val)
        swap(l1, l2);
      tail->next = l1;
      l1 = l1->next;
      tail = tail->next;
    }
    tail->next = l1 ? l1 : l2;
    while (tail->next)
      tail = tail->next;

    return {dummy.next, tail};
  }
};"
"class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        ugly = [1]
        seen = set()
        x = []
        heapq.heapify(x)
        while len(ugly) != n:
            for i in primes:
                if ugly[-1]*i not in seen:
                    seen.add(ugly[-1]*i)
                    heapq.heappush(x,ugly[-1]*i)
            ugly.append(heapq.heappop(x))
        return ugly[-1]","class Solution {
 public:
  int maxPoints(vector<vector<int>>& points) {
    int ans = 0;

    for (int i = 0; i < points.size(); ++i) {
      unordered_map<pair<int, int>, int, pairHash> slopeCount;
      const vector<int> p1{points[i]};
      int samePoints = 1;
      int maxPoints = 0;  // Maximum number of points with the same slope
      for (int j = i + 1; j < points.size(); ++j) {
        const vector<int> p2{points[j]};
        if (p1 == p2)
          ++samePoints;
        else
          maxPoints = max(maxPoints, ++slopeCount[getSlope(p1, p2)]);
      }
      ans = max(ans, samePoints + maxPoints);
    }

    return ans;
  }

 private:
  pair<int, int> getSlope(const vector<int>& p, const vector<int>& q) {
    const int dx = p[0] - q[0];
    const int dy = p[1] - q[1];
    if (dx == 0)
      return {0, p[0]};
    if (dy == 0)
      return {p[1], 0};
    const int d = __gcd(dx, dy);
    return {dx / d, dy / d};
  }

  struct pairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};"
"class Solution:
  def countSmaller(self, nums: List[int]) -> List[int]:
    l = len(nums)
    arr, ans = sorted(nums), [0] * l
    if l > 99:
      for i in range(l-1):
          ans[i] = bisect_left(arr, nums[i]) # binary search index
          del arr[ans[i]]
    else:
      for i in range(l):
          ans[i] = arr.index(nums[i]) # linear search index
          del arr[ans[i]]
    return ans","class Solution {
 public:
  int evalRPN(vector<string>& tokens) {
    stack<long> stack;
    const unordered_map<string, function<long(long, long)>> op{
        {""+"", plus<long>()},
        {""-"", minus<long>()},
        {""*"", multiplies<long>()},
        {""/"", divides<long>()}};

    for (const string& token : tokens)
      if (op.count(token)) {
        const long b = stack.top();
        stack.pop();
        const long a = stack.top();
        stack.pop();
        stack.push(op.at(token)(a, b));
      } else {
        stack.push(stoi(token));
      }

    return stack.top();
  }
};"
"class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        mp = {c: i for i, c in enumerate(s)}
        stack = []
        for i, c in enumerate(s): 
            if c not in stack: 
                while stack and c < stack[-1] and i < mp[stack[-1]]: stack.pop()
                stack.append(c)
        return """".join(map(str, stack))","class Solution {
 public:
  string reverseWords(string s) {
    reverse(begin(s), end(s));          // Reverse the whole string
    reverseWords(s, s.length());        // Reverse each word
    return cleanSpaces(s, s.length());  // Clean up spaces
  }

 private:
  void reverseWords(string& s, int n) {
    int i = 0;
    int j = 0;

    while (i < n) {
      while (i < j || i < n && s[i] == ' ')  // Skip spaces
        ++i;
      while (j < i || j < n && s[j] != ' ')  // Skip non spaces
        ++j;
      reverse(begin(s) + i, begin(s) + j);  // Reverse the word
    }
  }

  // Trim leading, trailing, and middle spaces
  string cleanSpaces(string& s, int n) {
    int i = 0;
    int j = 0;

    while (j < n) {
      while (j < n && s[j] == ' ')  // Skip spaces
        ++j;
      while (j < n && s[j] != ' ')  // Keep non spaces
        s[i++] = s[j++];
      while (j < n && s[j] == ' ')  // Skip spaces
        ++j;
      if (j < n)  // Keep only one space
        s[i++] = ' ';
    }

    return s.substr(0, i);
  }
};"
"class Solution:
    def maxProduct(self, words: List[str]) -> int:
        n = len(words)
        hashmap = dict()
        i = 0
        ans = 0
        for word in words:
            hashmap[i] = set(word)
            i += 1
        
        for i in range(0, n - 1):
            a = hashmap[i]
            for j in range(i + 1, n):
                b = hashmap[j]
                if not len(a.intersection(b)):
                    ans = max(ans, len(words[i]) * len(words[j]))
        return ans","class Solution {
 public:
  int maxProduct(vector<int>& nums) {
    int ans = nums[0];
    int dpMin = nums[0];  // Min so far
    int dpMax = nums[0];  // Max so far

    for (int i = 1; i < nums.size(); ++i) {
      const int num = nums[i];
      const int prevMin = dpMin;  // dpMin[i - 1]
      const int prevMax = dpMax;  // dpMax[i - 1]
      if (num < 0) {
        dpMin = min(prevMax * num, num);
        dpMax = max(prevMin * num, num);
      } else {
        dpMin = min(prevMin * num, num);
        dpMax = max(prevMax * num, num);
      }
      ans = max(ans, dpMax);
    }

    return ans;
  }
};"
"class Solution:
    def bulbSwitch(self, n: int) -> int:
        bulb_on = 0
        v = 2
        while n >= 1:
            bulb_on += 1
            n -= v + 1
            v += 2
        return bulb_on","class Solution {
 public:
  int findMin(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (nums[m] < nums[r])
        r = m;
      else
        l = m + 1;
    }

    return nums[l];
  }
};"
"class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        
        def find_k_max_number_in_an_array(nums, k):
            drop_possible = len(nums) - k
            n = len(nums)
            stack = []
            for i, val in enumerate(nums):
                while stack and drop_possible and stack[-1] < val:
                    drop_possible -= 1
                    stack.pop()
                
                stack.append(val)
            
            return stack[:k]
                
        
        def merge_two_array(arr1, arr2):
            #print(arr1, arr2)
            return [max(arr1, arr2).pop(0) for _ in arr1 + arr2]

        def compare_two_array(arr1, arr2):
            """"""
            determine whether arr1 is greater than arr2
            """"""
            if not arr2:
                return True
            i = j = 0
            n = len(arr1)
            while i < n and j < n:
                if arr1[i] > arr2[j]:
                    return True
                elif arr1[i] < arr2[j]:
                    return False
                i += 1
                j += 1
            
            return True
        
        ans = 0
        for i in range(k + 1):
            p = k - i
            
            if i > len(nums1) or p > len(nums2):
                continue
            
            # get this two array by solving function find_k_max_number_in_an_array
            # using similar concept of 402. Remove K Digits
            first_arr = find_k_max_number_in_an_array(nums1, i)
            second_arr = find_k_max_number_in_an_array(nums2, p)
            
            # merge two array with everytime taking lexicographily larger list
            # https://leetcode.com/problems/create-maximum-number/discuss/77286/Short-Python-Ruby-C%2B%2B
            # see explanation
            curr_arr = merge_two_array(first_arr, second_arr)
            #print(curr_arr)
            
            # can be directly use python max function
            if compare_two_array(curr_arr, ans):
                ans = curr_arr
            # ans = max(ans, curr_arr) if ans else curr_arr
            
            #print(ans)
        
        return ans","class Solution {
 public:
  int findMin(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (nums[m] == nums[r])
        --r;
      else if (nums[m] < nums[r])
        r = m;
      else
        l = m + 1;
    }

    return nums[l];
  }
};"
"class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # min number of coins summing up to current amount i
        memo = [-666]*(amount + 1)
        return self.dp(coins, amount, memo)
    
    def dp(self, coins, amount, memo):
        if (amount == 0): return 0
        if (amount < 0): return -1
        
        if (memo[amount] != -666):
            return memo[amount]
        
        res = sys.maxsize
        for coin in coins:
            subProblem = self.dp(coins, amount - coin, memo)
            if (subProblem == -1):
                continue
            res = min(subProblem + 1, res)
        
        memo[amount] = res if res != sys.maxsize else -1
        return memo[amount]","class MinStack {
 public:
  void push(int x) {
    if (stack.empty())
      stack.emplace(x, x);
    else
      stack.emplace(x, min(x, stack.top().second));
  }

  void pop() {
    stack.pop();
  }

  int top() {
    return stack.top().first;
  }

  int getMin() {
    return stack.top().second;
  }

 private:
  stack<pair<int, int>> stack;  // {x, min}
};"
"class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        if len(nums)>1:
            nums.sort()
            temp=nums[:]
            r=len(nums)-1
            ind=1
            while r>=0:
                nums[ind]=temp[r]
                ind+=2
                if ind>=len(nums):
                    ind=0
                r-=1","class Solution {
 public:
  TreeNode* upsideDownBinaryTree(TreeNode* root) {
    if (root == nullptr || root->left == nullptr)
      return root;

    TreeNode* newRoot = upsideDownBinaryTree(root->left);
    root->left->left = root->right;  // 2's left = 3 (root's right)
    root->left->right = root;        // 2's right = 1 (root)
    root->left = nullptr;
    root->right = nullptr;
    return newRoot;
  }
};"
"class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        return n > 0 and math.isclose(round(math.log(n, 3)), math.log(n, 3), rel_tol = 0.000000000000001)","/**
 * The read4 API is defined in the parent class Reader4.
 *     int read4(char *buf4);
 */

class Solution {
 public:
  /**
   * @param buf Destination buffer
   * @param n   Number of characters to read
   * @return    The number of actual characters read
   */
  int read(char* buf, int n) {
    char* buf4 = new char[4];
    int i4 = 0;  // buf4's index
    int n4 = 0;  // buf4's size
    int i = 0;   // buf's index

    while (i < n) {
      if (i4 == n4) {      // All characters in buf4 are consumed
        i4 = 0;            // Reset buf4's index
        n4 = read4(buf4);  // Read 4 (or less) chars from file to buf4
        if (n4 == 0)       // Reach the EOF
          return i;
      }
      buf[i++] = buf4[i4++];
    }

    return i;
  }
};"
"class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        def find(l,r):
            if l > r:
                return 0
            m = (l+r)//2
            left = [0]
            s = 0
            for i in range(m-1,l-1,-1):
                s += nums[i]
                left.append(s)
            right = [0]
            s = 0
            for i in range(m+1,r+1):
                s += nums[i]
                right.append(s)
            right.sort()
            ans = 0
            for i in left:
                ans += (bisect.bisect_right(right,upper-i-nums[m]) - bisect.bisect_left(right,lower-i-nums[m]))
            return ans + find(l,m-1)+find(m+1,r)
        return find(0, len(nums)-1)","/**
 * The read4 API is defined in the parent class Reader4.
 *     int read4(char *buf4);
 */

class Solution {
 public:
  /**
   * @param buf Destination buffer
   * @param n   Number of characters to read
   * @return    The number of actual characters read
   */
  int read(char* buf, int n) {
    int i = 0;  // buf's index

    while (i < n) {
      if (i4 == n4) {      // All characters in buf4 are consumed
        i4 = 0;            // Reset buf4's index
        n4 = read4(buf4);  // Read 4 (or less) chars from file to buf4
        if (n4 == 0)       // Reach the EOF
          return i;
      }
      buf[i++] = buf4[i4++];
    }

    return i;
  }

 private:
  char* buf4 = new char[4];
  int i4 = 0;  // buf4's index
  int n4 = 0;  // buf4's size
};"
"class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head: return head
        p1 = head
        p2 = p1.next
        t = p2
        while p1.next and p2.next:
            p1.next = p2.next
            p1 = p1.next
            p2.next = p1.next
            p2 = p2.next
        p1.next = t
        return head","class Solution {
 public:
  int lengthOfLongestSubstringTwoDistinct(string s) {
    int ans = 0;
    int distinct = 0;
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (++count[s[r]] == 1)
        ++distinct;
      while (distinct == 3)
        if (--count[s[l++]] == 0)
          --distinct;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};"
"class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        m, n = len(matrix), len(matrix[0])
        indegree = defaultdict(int)
        graph = defaultdict(list)
        queue = deque()
        
        for r in range(m):
            for c in range(n):
                for r1, c1 in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:
                    if 0 <= r1 < m and 0 <= c1 < n and matrix[r1][c1] > matrix[r][c]:
                        graph[(r1, c1)].append((r, c))
                        indegree[(r, c)] += 1
                        
                if indegree[(r, c)] == 0: queue.append((r, c, 1))
                    
        while queue:
            r, c, d = queue.popleft()
            
            for r1, c1 in graph[(r, c)]:
                indegree[(r1, c1)] -= 1
                if indegree[(r1, c1)] == 0:
                    queue.append((r1, c1, d+1))
                    
        return d","class Solution {
 public:
  ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
    ListNode* a = headA;
    ListNode* b = headB;

    while (a != b) {
      a = a ? a->next : headB;
      b = b ? b->next : headA;
    }

    return a;
  }
};"
"class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        ans = prefix = k = 0 
        while prefix < n: 
            if k < len(nums) and nums[k] <= prefix + 1: 
                prefix += nums[k]
                k += 1
            else: 
                ans += 1
                prefix += prefix + 1
        return ans","class Solution {
 public:
  bool isOneEditDistance(string s, string t) {
    const int m = s.length();
    const int n = t.length();
    if (m > n)  // Make sure len(s) <= len(t)
      return isOneEditDistance(t, s);

    for (int i = 0; i < m; ++i)
      if (s[i] != t[i]) {
        if (m == n)
          return s.substr(i + 1) == t.substr(i + 1);  // Replace s[i] with t[i]
        return s.substr(i) == t.substr(i + 1);        // Delete t[i]
      }

    return m + 1 == n;  // Delete t[-1]
  }
};"
"class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        preorder = preorder.split(',')
        n = len(preorder)
        idx, enough = 0, True                    # static `idx`, `enough` node to build a binary tree
        def dfs():
            nonlocal n, idx, enough 
            if idx >= n: enough = False; return  # if not enough node to build a binary tree
            if preorder[idx] == '#': return 
            if preorder[idx] != '#':
                idx += 1                         # say this is `idx_1`
                dfs()                            # build left tree
                idx += 1                         # now, `idx` is not `idx_1 + 1` because `idx` is static and it's increasing during recursion. Hope this solve your confusion
                dfs()                            # build right tree
        dfs()
        return enough and idx >= n-1             # all characters are visited and they are enough to build a tree","class Solution {
 public:
  int findPeakElement(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (nums[m] >= nums[m + 1])
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};"
"class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        edges = collections.defaultdict(list)
        n = len(tickets)
        
        for i in range(len(tickets)):
            edges[tickets[i][0]].append(tickets[i][1])
        for k in edges:
            edges[k].sort()
        
        itinerary_list = ['JFK']
        self.traverse(edges, itinerary_list, n)
        return itinerary_list
    
    
    def traverse(self, edges, itinerary_list, n):
        if len(itinerary_list) == n+1:
            return True
        cur_node = itinerary_list[-1]
        
        for i in range(len(edges[cur_node])):
            if edges[cur_node][i] != '#':
                temp = edges[cur_node][i]
                itinerary_list.append(temp)
                edges[cur_node][i] = '#'
                if self.traverse(edges, itinerary_list, n):
                    return True
                edges[cur_node][i] = temp
                itinerary_list.pop()
        return False","class Solution {
 public:
  vector<string> findMissingRanges(vector<int>& nums, int lower, int upper) {
    if (nums.empty())
      return {getRange(lower, upper)};

    vector<string> ans;

    if (nums.front() > lower)
      ans.push_back(getRange(lower, nums.front() - 1));

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] > nums[i - 1] + 1)
        ans.push_back(getRange(nums[i - 1] + 1, nums[i] - 1));

    if (nums.back() < upper)
      ans.push_back(getRange(nums.back() + 1, upper));

    return ans;
  }

 private:
  string getRange(int lo, int hi) {
    if (lo == hi)
      return to_string(lo);
    return to_string(lo) + ""->"" + to_string(hi);
  }
};"
"class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
		m1 = float(""inf"")
		m2 = float(""inf"")
        for i in nums:
            if i<m1:
                m1 = i
            elif i<m2 and i>m1:
                m2 = i
            elif i>m2: return True
        return False","struct Bucket {
  int min;
  int max;
};

class Solution {
 public:
  int maximumGap(vector<int>& nums) {
    if (nums.size() < 2)
      return 0;

    const int mini = *min_element(begin(nums), end(nums));
    const int maxi = *max_element(begin(nums), end(nums));
    if (mini == maxi)
      return 0;

    const int gap = ceil((maxi - mini) / (double)(nums.size() - 1));
    const int bucketSize = (maxi - mini) / gap + 1;
    vector<Bucket> buckets(bucketSize, {INT_MAX, INT_MIN});

    for (const int num : nums) {
      const int i = (num - mini) / gap;
      buckets[i].min = min(buckets[i].min, num);
      buckets[i].max = max(buckets[i].max, num);
    }

    int ans = 0;
    int prevMax = mini;

    for (const Bucket& bucket : buckets) {
      if (bucket.min == INT_MAX)
        continue;  // Empty bucket
      ans = max(ans, bucket.min - prevMax);
      prevMax = bucket.max;
    }

    return ans;
  }
};"
"class Solution:
    def isSelfCrossing(self, x: List[int]) -> bool:
        def intersect(p1, p2, p3, p4):
            v1 = p2 - p1
            if v1.real == 0:
                return p1.imag <= p3.imag <= p2.imag and p3.real <= p1.real <= p4.real
            return p3.imag <= p1.imag <= p4.imag and p1.real <= p3.real <= p2.real
        
        def overlap(p1, p2, p3, p4):
            v1 = p2 - p1
            if v1.real == 0:
                return min(p2.imag, p4.imag) >= max(p1.imag, p3.imag) and p1.real == p3.real
            return min(p2.real, p4.real) >= max(p1.real, p3.real) and p1.imag == p3.imag
                
        uv = complex(0, 1)
        p = complex(0, 0)
        segments = deque()
        for s in x:
            segments.append(sorted([p, (np := p + uv * s)], key=lambda x:(x.real, x.imag)))
            if len(segments) > 5 and intersect(*segments[-1], *segments[-6]):
                    return True
            if len(segments) > 4 and overlap(*segments[-1], *segments[-5]):
                    return True
            if len(segments) > 3 and intersect(*segments[-1], *segments[-4]):
                    return True
            if len(segments) == 6:
                segments.popleft()
            p = np
            uv *= complex(0, 1)
        return False","class Solution {
 public:
  int compareVersion(string version1, string version2) {
    istringstream iss1(version1);
    istringstream iss2(version2);
    int v1;
    int v2;
    char dotChar;

    while (bool(iss1 >> v1) + bool(iss2 >> v2)) {
      if (v1 < v2)
        return -1;
      if (v1 > v2)
        return 1;
      iss1 >> dotChar;
      iss2 >> dotChar;
      v1 = 0;
      v2 = 0;
    }

    return 0;
  };
};"
"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        def isPal(word):
            return word == word[::-1]
        palPairs = []
        wordDict = {}
        for i, word in enumerate(words):
            wordDict[word] = i
        for i, word in enumerate(words):
            for j in range(0, len(word)):
                prefix, suffix = word[:j], word[j:] # find all suffix and prefix
                if prefix[::-1] in wordDict and wordDict[prefix[::-1]] != i and isPal(suffix):
                    palPairs.append([i, wordDict[prefix[::-1]]]) # check if reverse prefix in dict and suffix palindrome
                if suffix[::-1] in wordDict and wordDict[suffix[::-1]] != i and isPal(prefix):
                    palPairs.append([wordDict[suffix[::-1]], i]) # check if reverse suffix in dict and prefix palindrome
                if len(palPairs) > 0 and words[palPairs[-1][1]] == '': # tricky part for prefix or suffix is ''. for example, if '1' + '' is palindrome, then '' + '1' should also be palindrome. and add '' + '1' manually
                    pair = palPairs[-1]
                    palPairs.append([pair[1], pair[0]])
        return palPairs","class Solution {
 public:
  string fractionToDecimal(int numerator, int denominator) {
    if (numerator == 0)
      return ""0"";

    string ans;

    if (numerator < 0 ^ denominator < 0)
      ans += ""-"";

    long n = labs(numerator);
    long d = labs(denominator);
    ans += to_string(n / d);

    if (n % d == 0)
      return ans;

    ans += '.';
    unordered_map<int, int> seen;

    for (long r = n % d; r; r %= d) {
      if (const auto it = seen.find(r); it != cend(seen)) {
        ans.insert(it->second, 1, '(');
        ans += ')';
        break;
      }
      seen[r] = ans.size();
      r *= 10;
      ans += to_string(r / d);
    }

    return ans;
  }
};"
"class Solution:
    def rob(self, root: TreeNode) -> int:
        
        @lru_cache(None)
        def fn(node): 
            """"""Return max money from sub-tree rooted at node.""""""
            if not node: return 0 
            ans = node.val 
            if node.left: ans += fn(node.left.left) + fn(node.left.right)
            if node.right: ans += fn(node.right.left) + fn(node.right.right)
            return max(ans, fn(node.left) + fn(node.right))
        
        return fn(root)","class Solution {
 public:
  vector<int> twoSum(vector<int>& numbers, int target) {
    int l = 0;
    int r = numbers.size() - 1;

    while (numbers[l] + numbers[r] != target)
      if (numbers[l] + numbers[r] < target)
        ++l;
      else
        --r;

    return {l + 1, r + 1};
  }
};"
"class Solution:
    def countBits(self, n: int) -> List[int]:
        lst=[]
        for x in range(0,n+1):
            if x>1:
                lst.append(lst[x//2]+(x%2))
            else:
                lst.append(x)
        return lst","class Solution {
 public:
  string convertToTitle(int n) {
    return n == 0 ? """"
                  : convertToTitle((n - 1) / 26) + (char)('A' + ((n - 1) % 26));
  }
};"
"class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        arr=[]
        for i in range(100):
            arr.append(4**i)
        if n in arr:
            return True
        else:
            return False","class Solution {
 public:
  int majorityElement(vector<int>& nums) {
    int ans;
    int count = 0;

    for (const int num : nums) {
      if (count == 0)
        ans = num;
      count += num == ans ? 1 : -1;
    }

    return ans;
  }
};"
"class Solution:
    def integerBreak(self, n: int) -> int:
    	return 3**(n//3-((n-3*(n//3))<=1))*((n-3*(n//3))+3*((n-3*(n//3))<=1)) if n>3 else n-1","class TwoSum {
 public:
  void add(int number) {
    ++count[number];
  }

  bool find(int value) {
    for (const auto& [key, freq] : count) {
      const int remain = value - key;
      if (key == remain && freq > 1)
        return true;
      if (key != remain && count.count(remain))
        return true;
    }

    return false;
  }

 private:
  unordered_map<int, int> count;
};"
"class Solution:
    def reverseString(self, s: List[str]) -> None:
        """"""
        Do not return anything, modify s in-place instead.
        """"""
        n = len(s)-1
        for i in range(n,-1,-1):
            s.append(s[i])
            s.pop(i)","class Solution {
 public:
  int titleToNumber(string s) {
    return accumulate(begin(s), end(s), 0,
                      [](int a, int b) { return a * 26 + (b - 'A' + 1); });
  }
};"
"class Solution:
    def reverseVowels(self, s: str) -> str:
        s = list(s)
        vowel = list('AEIOU')
        left_counter, right_counter = 0, len(s) - 1
        l_val, r_val = None, None
        while left_counter<right_counter:
            if s[left_counter].upper() in vowel:
                l_val = left_counter
            elif l_val is None:
                left_counter += 1
            if s[right_counter].upper() in vowel:
                r_val = right_counter
            elif r_val is None:
                right_counter -= 1
            if l_val is not None and r_val is not None:
                s[l_val], s[r_val] = s[r_val], s[l_val]
                l_val = r_val = None
                left_counter +=1
                right_counter -=1
            if left_counter > right_counter:
                break
        return """".join(s)","class Solution {
 public:
  int trailingZeroes(int n) {
    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);
  }
};"
"class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        
        nTof = {}
        
        for i in nums:
            if nTof.get(i) is None:
                nTof[i] = 1
            else:
                nTof[i] += 1
        
        unique = list(nTof.keys())
        
        def partition(unique, l, r):
            pivot, p = nTof[unique[r]], r
            
            i = l
            while i < p:
                if nTof[unique[i]] > pivot:
                    unique[i], unique[p-1] = unique[p-1], unique[i]
                    unique[p], unique[p-1] = unique[p-1], unique[p]
                    i -= 1
                    p -= 1
                i += 1
            return p
            
        def quickSelect(unique, l, r, k):
            p = partition(unique, l, r)
            
            if p > k:
                quickSelect(unique, l, p-1, k)
            if p < k:
                quickSelect(unique, p+1, r, k)

            return unique[k:]
            
        return quickSelect(unique, 0, len(unique)-1, len(unique)-k)","class Solution {
 public:
  int calculateMinimumHP(vector<vector<int>>& dungeon) {
    const int m = dungeon.size();
    const int n = dungeon[0].size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));
    dp[m][n - 1] = 1;
    dp[m - 1][n] = 1;

    for (int i = m - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j) {
        dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];
        dp[i][j] = max(dp[i][j], 1);
      }

    return dp[0][0];
  }
};"
"class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list(set(nums1).intersection(set(nums2)))","class Solution {
 public:
  string largestNumber(vector<int>& nums) {
    string ans;

    sort(begin(nums), end(nums), [](int a, int b) {
      return to_string(a) + to_string(b) > to_string(b) + to_string(a);
    });

    for (const int num : nums)
      ans += to_string(num);

    return ans[0] == '0' ? ""0"" : ans;
  }
};"
"class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums = []
        n1 = len(nums1)
        n2 = len(nums2)
        loc1= []
        loc2= []
        for i in range(n1):
            loc1.append(0)
        for j in range(n2):
            loc2.append(0)
        for i in range(n1):
            for j in range(n2):
                if nums1[i] == nums2[j] and loc1[i]==0 and loc2[j]==0:
                    nums.append(nums1[i])
                    loc1[i] = 1
                    loc2[j] = 1
        return nums","class Solution {
 public:
  void reverseWords(vector<char>& s) {
    reverse(begin(s), end(s));  // Reverse the whole string
    reverseWords(s, s.size());  // Reverse each word
  }

 private:
  void reverseWords(vector<char>& s, int n) {
    int i = 0;
    int j = 0;

    while (i < n) {
      while (i < j || i < n && s[i] == ' ')  // Skip spaces
        ++i;
      while (j < i || j < n && s[j] != ' ')  // Skip non spaces
        ++j;
      reverse(begin(s) + i, begin(s) + j);  // Reverse the word
    }
  }
};"
"class Solution:
    def maxEnvelopes(self, en: List[List[int]]) -> int:
        def bs(t,n,v):
            i = 0
            j = n-1
            while i<=j:
                m = (i+j)//2
                if t[m][1] == v:
                    return m
                elif v<t[m][1]:
                    j = m-1
                else:
                    i = m+1
            return i
        en.sort(key = lambda x:(x[0],-x[1]))
        t = [en[0]]
        c = 1
        for i in range(len(en)):
            if t[-1][1] < en[i][1]:
                t.append(en[i])
                c += 1
            else:
                x = bs(t,c,en[i][1])
                t[x] = en[i]
        return len(t)","class Solution {
 public:
  vector<string> findRepeatedDnaSequences(string s) {
    unordered_set<string> ans;
    unordered_set<string_view> seen;
    const string_view sv(s);

    for (int i = 0; i + 10 <= s.length(); ++i) {
      if (seen.count(sv.substr(i, 10)))
        ans.insert(s.substr(i, 10));
      seen.insert(sv.substr(i, 10));
    }

    return {begin(ans), end(ans)};
  }
};"
"class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -> int:
    	if n == 0:
    		return 1
    	g, h = 10, 9
    	for i in range(n-1):
    		g += 9*h
    		h *= (8-i)
    	return(g)
		
- Python 3
- Junaid Mansuri","class Solution {
 public:
  int maxProfit(int k, vector<int>& prices) {
    if (k >= prices.size() / 2) {
      int sell = 0;
      int hold = INT_MIN;

      for (const int price : prices) {
        sell = max(sell, hold + price);
        hold = max(hold, sell - price);
      }

      return sell;
    }

    vector<int> sell(k + 1);
    vector<int> hold(k + 1, INT_MIN);

    for (const int price : prices)
      for (int i = k; i > 0; --i) {
        sell[i] = max(sell[i], hold[i] + price);
        hold[i] = max(hold[i], sell[i - 1] - price);
      }

    return sell[k];
  }
};"
"class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        # initialize rows and columns values and determine transposed flag if needed 
        rows = len(matrix) # m 
        cols = len(matrix[0]) # n 
        transposed_matrix_flag = False
        transposed_matrix = list()

        # consider a power of 10 as siginficant 
        # if cols is significantly larger than rows in our implementation
        # we will do the significantly larger work^2
        # If this were to occur, we should flip our set up 
        if cols > (10*rows) : 
            # set transpose flag to true 
            transposed_matrix_flag = True
            # loop over columns amount 
            for row in range(cols) : 
                # generate rows 
                transposed_row = list()
                # for column in matrix is actually the rows 
                for col in matrix : 
                    # append the row item at the row index to the row 
                    transposed_row.append(col[row])
                # put the transposed row into the transposed matrix 
                transposed_matrix.append(transposed_row)

        # if transposed flag 
        if transposed_matrix_flag :
            # set the transpose and adjust rows and cols as needed  
            matrix = transposed_matrix 
            rows = len(matrix)
            cols = len(matrix[0])

        # minimum value start for maximal sum 
        maximum_sum = -math.inf

        # loop all columns 
        for col_index in range(cols) : 
            # generate a temporary row 
            temp_row = [0] * rows
            # loop columns from col index to cols 
            # col_index_2 is then our bound column index 
            for col_index_2 in range(col_index, cols) : 
                # set that column sums and the column sum 
                column_sums = [0]
                column_sum = 0
                # loop every row index in range rows 
                for row_index in range(rows) :
                    # temp row at the row index is the matrix at the row and the bound col index 
                    temp_row[row_index] += matrix[row_index][col_index_2]
                    # column sum gets this valuation added 
                    column_sum += temp_row[row_index]
                    # difference is determined 
                    difference = column_sum - k
                    # index is determined by bisection 
                    index = bisect.bisect_left(column_sums, difference)
                    # if index is in range of column sums so far 
                    if index < len(column_sums) : 
                        # if column sums at that index is the difference 
                        if column_sums[index] == difference : 
                            # this is the maximal result, return it 
                            return k
                        else : 
                            # otherwise maximum sum is set to maximum of itself and difference of column sum and column sums at index 
                            maximum_sum = max(maximum_sum, column_sum - column_sums[index])
                    # do an insort of column sum into column sums, at most row times 
                    bisect.insort(column_sums, column_sum)
        # if you never returned k, you should return as good as you got 
        return maximum_sum","class Solution {
 public:
  void rotate(vector<int>& nums, int k) {
    k %= nums.size();
    reverse(nums, 0, nums.size() - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.size() - 1);
  }

 private:
  void reverse(vector<int>& nums, int l, int r) {
    while (l < r)
      swap(nums[l++], nums[r--]);
  }
};"
"class Solution:
    def canMeasureWater(self, x: int, y: int, z: int) -> bool:
        def eucid(x,y):
            if x<y: x,y=y,x
            while x!=y!=0:
                remainder=x%y
                x,y=y,remainder
            return x
        e=eucid(x,y)
        if not e: return not z
        return (x+y)>=z and z%e==0","class Solution {
 public:
  uint32_t reverseBits(uint32_t n) {
    uint32_t ans = 0;

    for (int i = 0; i < 32; ++i)
      if (n >> i & 1)
        ans |= 1 << 31 - i;

    return ans;
  }
};"
"class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return num**.5%1 == 0","class Solution {
 public:
  int hammingWeight(uint32_t n) {
    int ans = 0;

    for (int i = 0; i < 32; ++i)
      if ((n >> i) & 1)
        ++ans;

    return ans;
  }
};"
"class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        nums.sort()
        dp = []
        for i, x in enumerate(nums): 
            dp.append([x])
            for ii in range(i): 
                if x % nums[ii] == 0: 
                    dp[-1] = max(dp[-1], dp[ii] + [x], key=len)
        return max(dp, key=len)","class Solution {
 public:
  int rob(vector<int>& nums) {
    if (nums.empty())
      return 0;
    if (nums.size() == 1)
      return nums[0];

    // dp[i] := max money of robbing nums[0..i]
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);

    for (int i = 2; i < nums.size(); ++i)
      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);

    return dp.back();
  }
};"
"class Solution:
    def getSum(self, a: int, b: int) -> int:
        return sum([a,b])","class Solution {
 public:
  vector<int> rightSideView(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      const int size = q.size();
      for (int i = 0; i < size; ++i) {
        TreeNode* node = q.front();
        q.pop();
        if (i == size - 1)
          ans.push_back(node->val);
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
    }

    return ans;
  }
};"
"class Solution:
    def superPow(self, a: int, b: List[int]) -> int:
        b=int(''.join(map(str,b)))
        res = 1    
        a = a % 1337
        if (a == 0) :
            return 0
        while (b>0) :
            if ((b &amp; 1) == 1):
                res=(res*a)%1337
            b=b>>1      
            a=(a*a)%1337
        return res","class Solution {
 public:
  int numIslands(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = 0;

    auto bfs = [&](int r, int c) {
      queue<pair<int, int>> q{{{r, c}}};
      grid[r][c] = '2';  // Mark '2' as visited
      while (!q.empty()) {
        const auto [i, j] = q.front();
        q.pop();
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (grid[x][y] != '1')
            continue;
          q.emplace(x, y);
          grid[x][y] = '2';  // Mark '2' as visited
        }
      }
    };

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == '1') {
          bfs(i, j);
          ++ans;
        }

    return ans;
  }
};"
"class Solution:
    def kSmallestPairs(self, nums1, nums2, k: int):
        temp=[]
        res=[]
        tot=[]
        end=0
        for i in nums1:
            for j in nums2:
                temp.append([i,j])
                tot.append(sum([i,j]))
        for i,v in sorted(zip(temp,tot),key = lambda x: x[1]):
            if end<k:
                res.append(i)
                end+=1
        return res","class Solution {
 public:
  int rangeBitwiseAnd(int m, int n) {
    int shiftBits = 0;

    while (m != n) {
      m >>= 1;
      n >>= 1;
      ++shiftBits;
    }

    return m << shiftBits;
  }
};"
"class Solution:
    def guessNumber(self, n: int) -> int:
        l, r = 1, n
        while l <= r:
            mid = (l + r) // 2
            val = guess(mid)
            if val == -1:
                r = mid - 1
            
            elif val == 1:
                l = mid + 1

            elif val == 0:
                return mid","class Solution {
 public:
  bool isHappy(int n) {
    int slow = squaredSum(n);
    int fast = squaredSum(squaredSum(n));

    while (slow != fast) {
      slow = squaredSum(slow);
      fast = squaredSum(squaredSum(fast));
    }

    return slow == 1;
  }

 private:
  int squaredSum(int n) {
    int sum = 0;
    while (n) {
      sum += pow(n % 10, 2);
      n /= 10;
    }
    return sum;
  };
};"
"class Solution:
    def getMoneyAmount(self, n: int) -> int:
        
        new=[[0 for i in range(0,n+1)] for i in range(0,n+1)]
        for gap in range(1,n+1):
            for j in range(gap,n+1):
                i=j-gap
                if gap==1:
                    new[i][j]=min(i,j)
                    continue
                if i==0 or j==0:
                    continue
                mini=8765432
                for k in range(i,j+1):
                    if k==i:
                        ans=i+new[i+1][j]
                    elif k==j:
                        ans=j+new[i][j-1]
                    else:
                        ans=k+max(new[k+1][j],new[i][k-1])
                    mini=min(ans,mini)
                new[i][j]=mini
        print(new)
        return new[1][-1]","class Solution {
 public:
  ListNode* removeElements(ListNode* head, int val) {
    ListNode dummy(0, head);
    ListNode* prev = &dummy;

    for (; head; head = head->next)
      if (head->val != val) {
        prev->next = head;
        prev = prev->next;
      }
    prev->next = nullptr;  // In case the last val == val

    return dummy.next;
  }
};"
"class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        if not nums:
            return 0
        less = [1]*len(nums)
        more = [1]*len(nums)
        res_l = 1
        res_m = 1
        
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[i] > nums[j] and more[i] < less[j]+1:
                    more[i] = less[j]+1
                    res_m = more[i]
                
                elif nums[i] < nums[j] and less[i] < more[j]+1:
                    less[i] = more[j]+1
                    res_l = less[i]
        return max(res_l,res_m)","class Solution {
 public:
  int countPrimes(int n) {
    if (n <= 2)
      return 0;
    const vector<bool> isPrime = sieveEratosthenes(n);
    return count(begin(isPrime), end(isPrime), true);
  }

 private:
  vector<bool> sieveEratosthenes(int n) {
    vector<bool> isPrime(n, true);
    isPrime[0] = false;
    isPrime[1] = false;
    for (int i = 2; i * i < n; ++i)
      if (isPrime[i])
        for (int j = i * i; j < n; j += i)
          isPrime[j] = false;
    return isPrime;
  }
};"
"class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        nums.sort()
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        for comb_sum in range(target+1):
            for num in nums:
                if comb_sum - num >= 0:
                    dp[comb_sum] = dp[comb_sum] + dp[comb_sum-num]
        return dp[target]","class Solution {
 public:
  bool isIsomorphic(string s, string t) {
    vector<int> charToIndex_s(128);
    vector<int> charToIndex_t(128);

    for (int i = 0; i < s.length(); ++i) {
      if (charToIndex_s[s[i]] != charToIndex_t[t[i]])
        return false;
      charToIndex_s[s[i]] = i + 1;
      charToIndex_t[t[i]] = i + 1;
    }

    return true;
  }
};"
"class Solution:
    
    import heapq
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        
        heap = []
        for arr in matrix:
            heapq.heappush(heap,(arr[0],0,arr))
            
        while k > 0 and heap:
            val,idx,arr = heapq.heappop(heap)
            ans = val
            if idx+1<len(arr):
                heapq.heappush(heap,(arr[idx+1],idx+1,arr))
            k-=1
        return ans","class Solution {
 public:
  ListNode* reverseList(ListNode* head) {
    if (!head || !head->next)
      return head;

    ListNode* newHead = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return newHead;
  }
};"
"class Solution:

    def __init__(self, head: ListNode):
        """"""
        @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node.
        """"""
        self.res = []
        
        while head:
            self.res.append(head.val)
            head = head.next
        

    def getRandom(self) -> int:
        """"""
        Returns a random node's value.
        """"""
        return random.choice(self.res)","enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    vector<vector<int>> graph(numCourses);
    vector<State> state(numCourses);

    for (const vector<int>& prerequisite : prerequisites) {
      const int u = prerequisite[1];
      const int v = prerequisite[0];
      graph[u].push_back(v);
    }

    for (int i = 0; i < numCourses; ++i)
      if (hasCycle(graph, i, state))
        return false;

    return true;
  }

 private:
  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& state) {
    if (state[u] == State::kVisiting)
      return true;
    if (state[u] == State::kVisited)
      return false;

    state[u] = State::kVisiting;
    for (const int v : graph[u])
      if (hasCycle(graph, v, state))
        return true;
    state[u] = State::kVisited;

    return false;
  }
};"
"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        note_freq = collections.Counter(ransomNote)
        mag_freq = collections.Counter(magazine)
        
        for letter in note_freq:
            if note_freq[letter] > mag_freq[letter]:
                return False
        return True","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  bool isWord = false;
  TrieNode() : children(26) {}
};

class Trie {
 public:
  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->isWord = true;
  }

  bool search(const string& word) {
    shared_ptr<TrieNode> node = find(word);
    return node && node->isWord;
  }

  bool startsWith(const string& prefix) {
    return find(prefix) != nullptr;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  shared_ptr<TrieNode> find(const string& prefix) {
    shared_ptr<TrieNode> node = root;
    for (const char c : prefix) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        return nullptr;
      node = node->children[i];
    }
    return node;
  }
};"
"class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        a = nums[0]+nums[1]+nums[len(nums)-1]
        nums.sort()
        for i in range(len(nums)-2):
            l = i+1
            h = len(nums)-1
            while l<h:
                b = nums[i]+nums[l]+nums[h]
                if b > target:
                    h -= 1
                else:
                    l += 1
                if abs(target - b)<abs(target - a):
                    a = b
        return a","class Solution {
 public:
  int minSubArrayLen(int s, vector<int>& nums) {
    int ans = INT_MAX;
    int sum = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      sum += nums[r];
      while (sum >= s) {
        ans = min(ans, r - l + 1);
        sum -= nums[l++];
      }
    }

    return ans < INT_MAX ? ans : 0;
  }
};"
"class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        stack = []
        integerStr = ''
        
        for c in s:
            if c == '[':
                stack.append(NestedInteger())
            elif c == ']':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
                poppedList = stack.pop()
                if len(stack)==0:
                    return poppedList
                stack[-1].add(poppedList)
            elif c == ',':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
            else:
                integerStr += c
                
        return NestedInteger(int(s))","enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
    vector<int> ans;
    vector<vector<int>> graph(numCourses);
    vector<State> state(numCourses);

    for (const vector<int>& prerequisite : prerequisites) {
      const int u = prerequisite[1];
      const int v = prerequisite[0];
      graph[u].push_back(v);
    }

    for (int i = 0; i < numCourses; ++i)
      if (hasCycle(graph, i, state, ans))
        return {};

    reverse(begin(ans), end(ans));
    return ans;
  }

 private:
  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& state,
                vector<int>& ans) {
    if (state[u] == State::kVisiting)
      return true;
    if (state[u] == State::kVisited)
      return false;

    state[u] = State::kVisiting;
    for (const int v : graph[u])
      if (hasCycle(graph, v, state, ans))
        return true;
    state[u] = State::kVisited;
    ans.push_back(u);

    return false;
  }
};"
"class Solution:
    def dfs(self, cur, n, res):
        if cur > n:
            return
        
        res.append(cur)
        for i in range(0, 10):
            self.dfs(cur * 10 + i, n, res)
    
    def lexicalOrder(self, n: int) -> List[int]:
        res = []
        
        for i in range(1, 10):
            self.dfs(i, n, res)
        
        return res","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  bool isWord = false;
  TrieNode() : children(26) {}
};

class WordDictionary {
 public:
  void addWord(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->isWord = true;
  }

  bool search(const string& word) {
    return dfs(word, 0, root);
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  bool dfs(const string& word, int s, shared_ptr<TrieNode> node) {
    if (s == word.length())
      return node->isWord;
    if (word[s] != '.') {
      shared_ptr<TrieNode> next = node->children[word[s] - 'a'];
      return next ? dfs(word, s + 1, next) : false;
    }

    // word[s] == '.' -> search all 26 children
    for (int i = 0; i < 26; ++i)
      if (node->children[i] && dfs(word, s + 1, node->children[i]))
        return true;

    return false;
  }
};"
"class Solution:
    def firstUniqChar(self, s: str) -> int:
        counts = dict()
        
        for letter in s:
            counts[letter] = counts.get(letter, 0) + 1
        
        for i in range(len(s)):
            if counts[s[i]] == 1:
                return i
        return -1
        
        '''
        # SUPER slow solution
        for i in range(len(s)):
            if s.count(s[i]) == 1:
                return i
        return -1
        '''","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  const string* word = nullptr;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
    vector<string> ans;

    for (const string& word : words)
      insert(word);

    for (int i = 0; i < board.size(); ++i)
      for (int j = 0; j < board[0].size(); ++j)
        dfs(board, i, j, root, ans);

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->word = &word;
  }

  void dfs(vector<vector<char>>& board, int i, int j, shared_ptr<TrieNode> node,
           vector<string>& ans) {
    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())
      return;
    if (board[i][j] == '*')
      return;

    const char c = board[i][j];
    shared_ptr<TrieNode> child = node->children[c - 'a'];
    if (child == nullptr)
      return;
    if (child->word != nullptr) {
      ans.push_back(*child->word);
      child->word = nullptr;
    }

    board[i][j] = '*';
    dfs(board, i + 1, j, child, ans);
    dfs(board, i - 1, j, child, ans);
    dfs(board, i, j + 1, child, ans);
    dfs(board, i, j - 1, child, ans);
    board[i][j] = c;
  }
};"
"class Solution:
    def lengthLongestPath(self, input: str) -> int:
        longest = 0
        path = []
        i = 0
        while i < len(input):
            length = 0
            depth = 0
            is_file = False
            in_path_component = False
            whitespaces = 0
            while i < len(input) and input[i] != '\n':
                if input[i] == '\t':
                    depth += 1
                elif input[i] == ' ':
                    if in_path_component:
                        # We may have whitespaces in folder and file names:
                        length += 1
                    else:
                        # Some test cases seem to use 4 whitespaces instead of one tab character:
                        whitespaces += 1
                        if whitespaces == 4:
                            depth += 1
                            whitespaces = 0
                elif input[i] == '.':
                    in_path_component = True
                    is_file = True
                    length += 1
                elif input[i] != '\n' and input[i] != '\t':
                    in_path_component = True
                    length += 1
                i += 1

            # Move back up the file tree to where we currently are:
            while depth < len(path):
                path.pop()

            if is_file:
                # We may have leading whitespaces which could be mistaken with depth. Add these too.
                length += (depth-len(path))*4
                # We may have leading whitespaces in case we saw a number of whitespaces which was not a multiple of 4. Add these too.
                length += whitespaces
                longest = max(longest, sum(path) + length)
            else:
                path.append(length+1)  # +1 as we need to take the separator ""/"" into account.
            i += 1
        return longest","class Solution {
 public:
  int rob(vector<int>& nums) {
    if (nums.empty())
      return 0;
    if (nums.size() == 1)
      return nums[0];

    auto rob = [&](int l, int r) {
      int prev1 = 0;  // dp[i - 1]
      int prev2 = 0;  // dp[i - 2]

      for (int i = l; i <= r; ++i) {
        const int dp = max(prev1, prev2 + nums[i]);
        prev2 = prev1;
        prev1 = dp;
      }

      return prev1;
    };

    return max(rob(0, nums.size() - 2), rob(1, nums.size() - 1));
  }
};"
"class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        for i in t:
            if s.count(i)!=t.count(i):
                return i","class Solution {
 public:
  string shortestPalindrome(string s) {
    string t = s;
    reverse(begin(t), end(t));

    const string_view sv_s(s);
    const string_view sv_t(t);

    for (int i = 0; i < s.length(); ++i)
      if (sv_s.substr(0, s.length() - i) == sv_t.substr(i))
        return t.substr(0, i) + s;

    return t + s;
  }
};"
"class Solution:
    def lastRemaining(self, n: int) -> int:
        return 1 if n==1 else 2*(1+n//2-self.lastRemaining(n//2))
    
    def lastRemaining1(self, n: int) -> int:
        """"""""
        removing from left to right [1 2 3 4 5 6 7 8 9]==[2 4 6 8]==2*[1 2 3 4]
        """"""
        def helper(n,is_left):
            if n == 1: return 1
            if is_left: return 2*helper(n//2,False)
            if n%2==1: return 2*helper(n//2,True)
            return 2*helper(n//2,2)-1
        return helper(n,True)
    
    def lastRemaining2(self, n: int) -> int:
        if n==0: return
        st1,st2,left=list(range(1,n+1)),[],True
        while len(st1)>1:
            if not left:
                st1=st1[::-1]
            for i in range(1,len(st1),2):
                st2.append(st1[i])
            st1=list(st2) if left else list(st2[::-1])
            st2=[]
            left = not left
        return st1[0]","class Solution {
 public:
  int findKthLargest(vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int num : nums) {
      minHeap.push(num);
      if (minHeap.size() > k)
        minHeap.pop();
    }

    return minHeap.top();
  }
};"
"class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        area = 0
        corner = set()
        X0 = Y0 = inf
        X1 = Y1 = -inf
        for x0, y0, x1, y1 in rectangles: 
            area += (x1-x0)*(y1-y0)
            X0 = min(x0, X0)
            Y0 = min(y0, Y0)
            X1 = max(x1, X1)
            Y1 = max(y1, Y1)
            corner ^= {(x0, y0), (x0, y1), (x1, y0), (x1, y1)}
        return area == (X1-X0)*(Y1-Y0) and corner == {(X0, Y0), (X0, Y1), (X1, Y0), (X1, Y1)}","class Solution {
 public:
  vector<vector<int>> combinationSum3(int k, int n) {
    vector<vector<int>> ans;
    dfs(k, n, 1, {}, ans);
    return ans;
  }

 private:
  void dfs(int k, int n, int s, vector<int>&& path, vector<vector<int>>& ans) {
    if (k == 0 && n == 0) {
      ans.push_back(path);
      return;
    }
    if (k == 0 || n <= 0)
      return;

    for (int i = s; i <= 9; ++i) {
      path.push_back(i);
      dfs(k - 1, n - i, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};"
"class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        for i in range(len(s)): 
            if s[i] in t: 
                t =  t[t.index(s[i])+1:]
            else: 
                return False
        return True","class Solution {
 public:
  bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> seen;

    for (const int num : nums)
      if (!seen.insert(num).second)
        return true;

    return false;
  }
};"
"class Solution:
    def validUtf8(self, data: List[int]) -> bool:
        i=0
        while i<len(data):
            x=bin(data[i])[2:]
            if len(x)!=8:
                #Means it's a 1 byte
                i+=1
                continue
            cnt=0
            j=0
            while j<len(x) and x[j]=='1':
                cnt+=1#Count num of 1 or bytes 1(num of 1 must be 2,3 or 4)
                j+=1
            if cnt<=1 or cnt>4 or i+cnt>len(data):#cnt means number if bytes
                return False
            i+=1
            cnt-=1#because 1 one byte is used by current num
            while cnt>0:
                y=bin(data[i])[2:]
                if len(y)!=8 or not y.startswith('10'):
                    return False
                i+=1
                cnt-=1
        return True","class Solution {
 public:
  vector<vector<int>> getSkyline(const vector<vector<int>>& buildings) {
    const int n = buildings.size();
    if (n == 0)
      return {};
    if (n == 1) {
      const int left = buildings[0][0];
      const int right = buildings[0][1];
      const int height = buildings[0][2];
      return {{left, height}, {right, 0}};
    }

    const vector<vector<int>> left =
        getSkyline({begin(buildings), begin(buildings) + n / 2});
    const vector<vector<int>> right =
        getSkyline({begin(buildings) + n / 2, end(buildings)});
    return merge(left, right);
  }

 private:
  vector<vector<int>> merge(const vector<vector<int>>& left,
                            const vector<vector<int>>& right) {
    vector<vector<int>> ans;
    int i = 0;  // left's index
    int j = 0;  // right's index
    int leftY = 0;
    int rightY = 0;

    while (i < left.size() && j < right.size())
      // Choose the point with smaller x
      if (left[i][0] < right[j][0]) {
        leftY = left[i][1];  // Update the ongoing leftY
        addPoint(ans, left[i][0], max(left[i++][1], rightY));
      } else {
        rightY = right[j][1];  // Update the ongoing rightY
        addPoint(ans, right[j][0], max(right[j++][1], leftY));
      }

    while (i < left.size())
      addPoint(ans, left[i][0], left[i++][1]);

    while (j < right.size())
      addPoint(ans, right[j][0], right[j++][1]);

    return ans;
  }

  void addPoint(vector<vector<int>>& ans, int x, int y) {
    if (!ans.empty() && ans.back()[0] == x) {
      ans.back()[1] = y;
      return;
    }
    if (!ans.empty() && ans.back()[1] == y)
      return;
    ans.push_back({x, y});
  }
};"
"class Solution:
    def decodeString(self, s: str) -> str:
        def helper(sub):
            res = ''                               # empty new string initailaized
			i = 0                                 # every time we get a valid new substring, we need to traverse through all of it 
            while i < len(sub):
                if sub[i].isdigit():           # if its a digit, we know the next would be an opening bracket,then our substring
                    d = ''                          # To find the whole number we do another while loop 
                    while sub[i].isdigit():
                        d += sub[i]
                        i += 1
                    st = [""[""]                # preemptively intializing with ""["" because we already know a number will always be followed by a opening bracket 
                    new_sub = ''         # We know that the next x characters will be the substring we need for recursion 
                    i += 1                    # This increment is because we already added '[' to the stack which would have been the open bracket at i
                    while st:                            # Now we get the substring using stack approach, just basic bracket validation
                        if sub[i+1] == ""["":         # i+1 to prevent going out of bounds since we are doing i+=1 after the check 
                            st.append(""["")           # I think not doing i+=1 right before ""while st"" and doing i+=1 will then let you check using sub[i]
                        if sub[i+1] == ""]"":
                            st.pop()
                        new_sub += sub[i]
                        i += 1
                    for j in range(int(d)):              # Now, we have whole substring and hence we need to execute that substring the amount of times the number we obtained
                        res += helper(new_sub)    # recursively call the function on that particular substring
                elif sub[i].isalpha():              # if the character of the current string is an alphabet add it to res
                    res += sub[i]
                i += 1 
            return res                 # Return the res generated after traversing throughout the current string 
        
        return helper(s)             # returns the result of the total string","class Solution {
 public:
  bool containsNearbyDuplicate(vector<int>& nums, int k) {
    unordered_set<int> seen;

    for (int i = 0; i < nums.size(); ++i) {
      if (!seen.insert(nums[i]).second)
        return true;
      if (i >= k)
        seen.erase(nums[i - k]);
    }

    return false;
  }
};"
"class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        c_counts = []
        pc = None
        n = 0
        for c in s:
            if pc is None:
                pc = s
                n = 1
            else:
                if pc == c:
                    n += 1
                else:
                    c_counts.append((pc, n))
                    n = 1
            pc = c
        if pc:
            c_counts.append((pc, n))
        
        max_sub = 0
        for left in range(len(c_counts)):
            chars = {}
            for right in range(left, len(c_counts)):
                if not chars.get(c_counts[right][0]):
                    chars[c_counts[right][0]] = 0
                chars[c_counts[right][0]] += c_counts[right][1]
                if min(chars.values()) > k - 1:
                    max_sub = max(max_sub, sum(chars.values()))
        return max_sub","class Solution {
 public:
  bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff,
                                     int valueDiff) {
    set<long> window;

    for (int i = 0; i < nums.size(); ++i) {
      if (const auto it =
              window.lower_bound(static_cast<long>(nums[i]) - valueDiff);
          it != cend(window) && *it - nums[i] <= valueDiff)
        return true;
      window.insert(nums[i]);
      if (i >= indexDiff)
        window.erase(nums[i - indexDiff]);
    }

    return false;
  }
};"
"class Solution:
    def maxRotateFunction(self, A: List[int]) -> int:
        total = sum(A)
        ans = cur = sum(i * n for i, n in enumerate(A))
        for i in range(len(A)-1, 0, -1):
            cur += total - len(A) * A[i]
            ans = max(ans, cur)
        return ans","class Solution {
 public:
  int maximalSquare(vector<vector<char>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<vector<int>> dp(m, vector<int>(n));
    int maxLength = 0;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        if (i == 0 || j == 0 || matrix[i][j] == '0')
          dp[i][j] = matrix[i][j] == '1' ? 1 : 0;
        else
          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
        maxLength = max(maxLength, dp[i][j]);
      }

    return maxLength * maxLength;
  }
};"
"class Solution:
    def integerReplacement(self, n: int) -> int:
        if n==1: return 0
        if n%2==0: return self.integerReplacement(n//2) + 1
        return min(self.integerReplacement(n-1),self.integerReplacement(n+1))+1","class Solution {
 public:
  int countNodes(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
  }
};"
"class Solution:

    def __init__(self, nums: List[int]):
        self.val_index = collections.defaultdict(list)
        
        for i, num in enumerate(nums):
            self.val_index[num].append(i)

    def pick(self, target: int) -> int:
        return random.choice(self.val_index[target])","class Solution {
 public:
  int computeArea(long A, long B, long C, long D,  //
                  long E, long F, long G, long H) {
    const long x = max(A, E) < min(C, G) ? (min(C, G) - max(A, E)) : 0;
    const long y = max(B, F) < min(D, H) ? (min(D, H) - max(B, F)) : 0;
    return (C - A) * (D - B) + (G - E) * (H - F) - x * y;
  }
};"
"class Solution:
    def calcEquation(self, e: List[List[str]], v: List[float], q: List[List[str]]) -> List[float]:
    	V, e, k = {j: False for i in q for j in i}, sorted(i[0]+[i[1]] for i in zip(e,v)), 0
    	for i,[n,d,v] in enumerate(e):
    		if not (V[n] or V[d]): V[n], k = [1,k], k+1
    		[V[n],V[d]] = [V[n],[V[n][0]/v,k-1]] if V[n] else [[V[d][0]*v,k-1],V[d]]
    	return [-1 if not (V[n] and V[d] and V[n][1] == V[d][1]) else V[n][0]/V[d][0] for [n,d] in q]
		
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int calculate(string s) {
    int ans = 0;
    int num = 0;
    int sign = 1;
    stack<int> stack{{sign}};  // Stack.top(): current env's sign

    for (const char c : s)
      if (isdigit(c))
        num = num * 10 + (c - '0');
      else if (c == '(')
        stack.push(sign);
      else if (c == ')')
        stack.pop();
      else if (c == '+' || c == '-') {
        ans += sign * num;
        sign = (c == '+' ? 1 : -1) * stack.top();
        num = 0;
      }

    return ans + sign * num;
  }
};"
"class Solution:
    def findNthDigit(self, n: int) -> int:
    	s, d = 0, 0
    	while s < n:
    		s += (d+1)*9*10**d
    		d += 1
    	n -= s-d*9*10**(d-1)
    	r, s = n % d, 10**(d-1)+n//d
    	return str(s)[r-1] if r > 0 else str(s-1)[-1]
				
				
- Python 3
- Junaid Mansuri","class MyStack {
 public:
  void push(int x) {
    q.push(x);
    for (int i = 0; i < q.size() - 1; ++i) {
      q.push(q.front());
      q.pop();
    }
  }

  int pop() {
    const int val = q.front();
    q.pop();
    return val;
  }

  int top() {
    return q.front();
  }

  bool empty() {
    return q.empty();
  }

 private:
  queue<int> q;
};"
"class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
    	n, N, j = list(num), [], k
    	for _ in range(len(num)-k):
    		i = n.index(min(n[:j+1]))
    		N.append(n[i])
    		j -= i
    		del n[:i+1]
    	return """".join(N).lstrip(""0"") or ""0""
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  TreeNode* invertTree(TreeNode* root) {
    if (root == nullptr)
      return nullptr;

    TreeNode* const left = root->left;
    TreeNode* const right = root->right;
    root->left = invertTree(right);
    root->right = invertTree(left);
    return root;
  }
};"
"class Solution:
    def canCross(self, s: List[int]):
		# memory variable
        mem = dict()
		
		# k = jump variable; i = current index; s = stones list; mem = memory dictionary
        def frog(s, k, i, mem):
			# unique key
            key = str(s[i]) + "":"" + str(k) + "":"" + str(i)

            if i == len(s)-1:
                return True
            if key in mem:
                return mem[key]
			# possible jumps
            jumps = [k-1, k, k+1]

            result = False

            for jump in jumps:
                if jump and s[i]+jump in s:
                    result = frog(s,jump,s.index(s[i]+jump,i),mem)
                mem[key] = result 

            return mem[key]
        
        frog(s, 0, 0, mem)
        
        return True in mem.values()","class Solution {
 public:
  int calculate(string s) {
    stack<int> nums;
    stack<char> ops;

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (isdigit(c)) {
        int num = c - '0';
        while (i + 1 < s.length() && isdigit(s[i + 1])) {
          num = num * 10 + (s[i + 1] - '0');
          ++i;
        }
        nums.push(num);
      } else if (c == '+' || c == '-' || c == '*' || c == '/') {
        while (!ops.empty() && compare(ops.top(), c))
          nums.push(calculate(pop(ops), pop(nums), pop(nums)));
        ops.push(c);
      }
    }

    while (!ops.empty())
      nums.push(calculate(pop(ops), pop(nums), pop(nums)));

    return nums.top();
  }

 private:
  int calculate(char op, int b, int a) {
    switch (op) {
      case '+':
        return a + b;
      case '-':
        return a - b;
      case '*':
        return a * b;
      case '/':
        return a / b;
    }
    throw;
  }

  // Returns true if priority(op1) >= priority(op2)
  bool compare(char op1, char op2) {
    return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-';
  }

  char pop(stack<char>& ops) {
    const char op = ops.top();
    ops.pop();
    return op;
  }

  int pop(stack<int>& nums) {
    const int num = nums.top();
    nums.pop();
    return num;
  }
};"
"class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        # Store only left children in stack
        self.stack = []
            
        # Add left children of rightmost diagonal to stack
        self.explore_right_add_left(root)
        
        total = 0
        # We have left children
        while self.stack:
            # Explore the right diagonal from next left child
             while self.stack and self.stack[-1] and self.stack[-1].right:
                # Explore right children and add all left children on this diagonal to stack
                self.explore_right_add_left(self.stack.pop())
				
            # If there is a node still at top of stack, it must be a left child with no direct right child
            if self.stack:
                if self.stack[-1].left:
					# has left child, so add left child to explore
                    self.stack.append(self.stack.pop().left)
                else:
                    # is a left leaf
                    total += self.stack.pop().val

        return total
    
    def explore_right_add_left(self, node):
		"""""" Explore right children and add left children to stack.""""""
        while node:
            if node.left:
                self.stack.append(node.left)
            node = node.right","class Solution {
 public:
  vector<string> summaryRanges(vector<int>& nums) {
    vector<string> ans;

    for (int i = 0; i < nums.size(); ++i) {
      const int begin = nums[i];
      while (i + 1 < nums.size() && nums[i] == nums[i + 1] - 1)
        ++i;
      const int end = nums[i];
      if (begin == end)
        ans.push_back(to_string(begin));
      else
        ans.push_back(to_string(begin) + ""->"" + to_string(end));
    }

    return ans;
  }
};"
"class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        res = []
		# Sort the array, with descending order for height and ascending order for the number of taller persons ahead
        people_sorted = sorted(people, key=lambda p: (p[0], -p[1]), reverse=True)
		# Add persons to the result, at respective indices
        for p in people_sorted:
            res.insert(p[1], p)
        return res","class Solution {
 public:
  vector<int> majorityElement(vector<int>& nums) {
    vector<int> ans;
    int candidate1 = 0;
    int candidate2 = 1;   // Any number different from candidate1
    int countSoFar1 = 0;  // # of candidate1 so far
    int countSoFar2 = 0;  // # of candidate2 so far

    for (const int num : nums)
      if (num == candidate1) {
        ++countSoFar1;
      } else if (num == candidate2) {
        ++countSoFar2;
      } else if (countSoFar1 == 0) {  // Assign new candidate
        candidate1 = num;
        ++countSoFar1;
      } else if (countSoFar2 == 0) {  // Assign new candidate
        candidate2 = num;
        ++countSoFar2;
      } else {  // Meet a new number, so pair out previous counts
        --countSoFar1;
        --countSoFar2;
      }

    const int count1 = count(begin(nums), end(nums), candidate1);
    const int count2 = count(begin(nums), end(nums), candidate2);

    if (count1 > nums.size() / 3)
      ans.push_back(candidate1);
    if (count2 > nums.size() / 3)
      ans.push_back(candidate2);
    return ans;
  }
};"
"class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        m, n = len(heightMap), len(heightMap[0])
        
        pq = []
        for i in range(m): 
            heappush(pq, (heightMap[i][0], i, 0))
            heappush(pq, (heightMap[i][n-1], i, n-1))
        for j in range(1, n-1): 
            heappush(pq, (heightMap[0][j], 0, j))
            heappush(pq, (heightMap[m-1][j], m-1, j))
        
        ans = most = 0 
        while pq: 
            ht, i, j = heappop(pq)
            most = max(most, ht)
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if 0 < ii < m-1 and 0 < jj < n-1 and heightMap[ii][jj] != -1: 
                    ans += max(0, most - heightMap[ii][jj])
                    heappush(pq, (heightMap[ii][jj], ii, jj))
                    heightMap[ii][jj] = -1 # mark ""visited""
        return ans","class Solution {
 public:
  int kthSmallest(TreeNode* root, int k) {
    const int leftCount = countNodes(root->left);

    if (leftCount == k - 1)
      return root->val;
    if (leftCount >= k)
      return kthSmallest(root->left, k);
    return kthSmallest(root->right, k - 1 - leftCount);  // LeftCount < k
  }

 private:
  int countNodes(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
  }
};"
"class Solution:
    def longestPalindrome(self, s: str) -> int:
        hashmap = {}
        if len(s) == 0:
            return 0
        for i in s:
            if i not in hashmap:
                hashmap[i] = 1
            else:
                hashmap[i]+= 1
        #Longest odd chars + even chars
        longest_odd_char = 0
        even_chars = 0
        print(hashmap)
        for i in hashmap.keys():
            if hashmap[i]%2 == 1: #odd char string
                if hashmap[i] > longest_odd_char:
                    longest_odd_char = hashmap[i]
            else:
                even_chars += hashmap[i]
        return longest_char + even_chars","class Solution {
 public:
  bool isPowerOfTwo(int n) {
    return n < 0 ? false : __builtin_popcountll(n) == 1;
  }
};"
"class Solution:
    def splitArray(self, nums: List[int], m: int) -> int:        
        #return self.bruteForce(nums,m)
        #self.cache=collections.defaultdict(dict)
        #return self.memo(0,nums,m)
        low,high,res=max(nums),sum(nums),-1
        while low<=high:
            pivot=(low+high)//2
            if self.isValid(nums,m,pivot):
                res,high=pivot,pivot-1
            else:
                low=pivot+1
        return res
    
    def isValid(self,nums,m,pivot):
        chunk,current=0,0
        for v in nums:
            current+=v
            if current>pivot:
                chunk,current=chunk+1,v
        return chunk + 1 <= m
    
    def memo(self,i,nums,m):
        if not nums: return 0
        if m == 1: return sum(nums[i:])
        if i in self.cache and m in self.cache[i]:
            return self.cache[i][m]
        self.cache[i][m]=float(""inf"")
        for j in range(1,len(nums)+1):
            left,right=sum(nums[i:i+j]),self.memo(i+j,nums,m-1)
            self.cache[i][m]=min(self.cache[i][m],max(left,right))
            if left>right: break
        return self.cache[i][m]
    
    def bruteForce(self,nums,m):
        if not nums: return 0
        if m == 1: return sum(nums)
        min_value=float(""inf"")
        for i in range(1,len(nums)+1):
            left,right=sum(nums[:i]),self.bruteForce(nums[i:],m-1)
            min_value=min(min_value,max(left,right))
        return min_value","class Solution {
 public:
  int countDigitOne(int n) {
    int ans = 0;

    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {
      const long divisor = pow10 * 10;
      const int quotient = n / divisor;
      const int remainder = n % divisor;
      if (quotient > 0)
        ans += quotient * pow10;
      if (remainder >= pow10)
        ans += min(remainder - pow10 + 1, pow10);
    }

    return ans;
  }
};"
"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        total = []
        for i in range(1,n+1):
            if i % 3 == 0 and i % 5 == 0:
                total.append(""FizzBuzz"")
                continue
            if i % 3 == 0:
                total.append(""Fizz"")
                continue
            if i % 5 == 0:
                total.append(""Buzz"")
                continue
            total.append(str(i))
            
        return total","class Solution {
 public:
  bool isPalindrome(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
    }

    if (fast != nullptr)
      slow = slow->next;
    slow = reverseList(slow);

    while (slow) {
      if (slow->val != head->val)
        return false;
      slow = slow->next;
      head = head->next;
    }

    return true;
  }

 private:
  ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;

    while (head) {
      ListNode* next = head->next;
      head->next = prev;
      prev = head;
      head = next;
    }

    return prev;
  }
};"
"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        
        def totSlices(nums,slices): # For total number of same difference consecutive integers
            count = 2
            co = nums[1]-nums[0]
            for i in range(2,n):
                pre = nums[i]-nums[i-1]
                if  pre == co:
                    count += 1
                else:
                    if count>2:
                        slices.append(count)
                    co = pre
                    count = 2  
                    
            if count>2:
                slices.append(count)
                
            return slices
        
        
        def totCombination(maxSlice,combination): #For combination of maximum slice integer
            combination = [0]*(maxSlice+1)
            st = 1
                
            for i in range(3,maxSlice+1):
                combination[i] = combination[i-1]+st
                st+=1
                
            return combination
                
        n = len(nums)
        
        if n < 3:
            return 0
        
        total = 0
        
        slices = totSlices(nums,[])
        
        if slices == []:
            return 0
            
        combination = totCombination(max(slices),[])
            
        for i in slices:
            total += combination[i]
                
        return total","class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root->val > max(p->val, q->val))
      return lowestCommonAncestor(root->left, p, q);
    if (root->val < min(p->val, q->val))
      return lowestCommonAncestor(root->right, p, q);
    return root;
  }
};"
"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        
        # Remove redundant element
        nums = set(nums)
        
        # Convert it back to list to use sort
        nums = list(nums)
        
        # Sort the list
        nums.sort()
        
        # Return the third one from the last if not exist then return the last one
        return nums[-3] if len(nums) >= 3 else nums[-1]","class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == nullptr || root == p || root == q)
      return root;

    TreeNode* l = lowestCommonAncestor(root->left, p, q);
    TreeNode* r = lowestCommonAncestor(root->right, p, q);

    if (l && r)
      return root;
    return l ? l : r;
  }
};"
"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        if ""0"" in (num1, num2):
            return num2 if num1 == ""0"" else num1
        
        class MyStr(str):
            dic = {str(v): v for v in range(10)}
            
            def __getitem__(self, index):
                try:
                    return MyStr.dic[super().__getitem__(index)]
                except IndexError:
                    return 0
        
        num1, num2 = MyStr(num1), MyStr(num2)
        carry, s = 0, """"
        for idx in range(-1, -1-max(len(num1), len(num2)), -1):
            o_sum = num1[idx] + num2[idx] + carry
            carry = o_sum // 10
            s = f'{o_sum % 10}{s}'
                
        return f'1{s}' if carry else s","class Solution {
 public:
  void deleteNode(ListNode* node) {
    node->val = node->next->val;
    node->next = node->next->next;
  }
};"
"class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        total = sum(nums)
        if total % 2 != 0: return False 
        target = total // 2
        dp = [False]*(target + 1)
        dp[0] = True
        for num in nums:
            for i in range(target, num-1, -1):
                dp[i] = dp[i] or dp[i-num]
				if dp[target]: return True
        return dp[target]","class Solution {
 public:
  vector<int> productExceptSelf(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n);        // Can also use nums as the ans array
    vector<int> prefix(n, 1);  // Prefix product
    vector<int> suffix(n, 1);  // Suffix product

    for (int i = 1; i < n; ++i)
      prefix[i] = prefix[i - 1] * nums[i - 1];

    for (int i = n - 2; i >= 0; --i)
      suffix[i] = suffix[i + 1] * nums[i + 1];

    for (int i = 0; i < n; ++i)
      ans[i] = prefix[i] * suffix[i];

    return ans;
  }
};"
"class Solution:
    def flow(self, q: List[List[int]], canFlowFrom: List[List[bool]], heights: List[List[int]]):
		# directions that we can water can flow from
        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        while len(q) != 0:
            inds = q.pop(0)
            for direction in directions:
                i = inds[0] + direction[0]
                j = inds[1] + direction[1]
				# check if coordinates are valid and that they haven't been visited
                if i >= 0 and j >= 0 and i < len(heights) and j < len(heights[i]) and heights[inds[0]][inds[1]] <= heights[i][j] and not canFlowFrom[i][j]:
                        q.append([i, j])
                        canFlowFrom[i][j] = True
            
        
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m = len(heights)
        n = len(heights[0])
        flowToAtlantic = [[False] * n for i in range(m)]
        flowToPacific = [[False] * n for i in range(m)]
        atlanticQ = []
        pacificQ = []
        # add edges touching ocean
        for i in range(m):
            pacificQ.append([i, 0])
            flowToPacific[i][0] = True
            atlanticQ.append([i, n - 1])
            flowToAtlantic[i][n - 1] = True
		# add edges touching ocean
        for j in range(n):
            pacificQ.append([0, j])
            flowToPacific[0][j] = True
            atlanticQ.append([m - 1, j])
            flowToAtlantic[m - 1][j] = True
        # flow from edges updwards to validate if can flow to specific ocean for each coordinate
        self.flow(atlanticQ, flowToAtlantic, heights)
        self.flow(pacificQ, flowToPacific, heights)
        res = []
        for i in range(m):
            for j in range(n):
				# if we can reach both oceans, then we can add it to the result list
                if flowToAtlantic[i][j] and flowToPacific[i][j]:
                    res.append([i, j])
        return res","class Solution {
 public:
  vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> ans;
    deque<int> q;  // Max queue

    for (int i = 0; i < nums.size(); ++i) {
      while (!q.empty() && q.back() < nums[i])
        q.pop_back();
      q.push_back(nums[i]);
      if (i >= k && nums[i - k] == q.front())  // Out of bound
        q.pop_front();
      if (i >= k - 1)
        ans.push_back(q.front());
    }

    return ans;
  }
};"
"class Solution:
    def countBattleships(self, board: List[List[str]]) -> int:
        if not board:
            return 0
        counter = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == ""X"":
                    self.dfs(board, i, j)
                    counter += 1
        return counter
    
    def dfs(self, board, i, j):
        if i < 0 or j < 0 or i >= len(board) or j >= len(board[i]) or board[i][j] != ""X"":
            return
        board[i][j] = ""#""
        self.dfs(board, i+1, j)
        self.dfs(board, i-1, j)
        self.dfs(board, i, j+1)
        self.dfs(board, i, j-1)","class Solution {
 public:
  bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int r = 0;
    int c = matrix[0].size() - 1;

    while (r < matrix.size() && c >= 0) {
      if (matrix[r][c] == target)
        return true;
      if (matrix[r][c] > target)
        --c;
      else
        ++r;
    }

    return false;
  }
};"
"class Solution:
    def strongPasswordChecker(self, password: str) -> int:
        lengthOfPassword=len(password)
        
        #IF PASSWORD IS LESS THAN 2 CHARACTER
        if lengthOfPassword<3:
            return 6-lengthOfPassword

        isLower=False
        isUpper=False
        isDigit=False

        repeatedCharacters=[]
        lastCharacter=''
        numberOfRepeatedCharacter=-1

        #LOOP TO CHECK ALL CONTITIONS
        for i in range(lengthOfPassword):

            #CHECKING FOR UPPER<LOER CASE AND DIGIT IN PASSWORD
            if not isUpper and password[i].isupper():
                isUpper=True
            elif not isLower and password[i].islower():
                isLower=True
            elif not isDigit and password[i].isdigit():
                isDigit=True

            #COUNTING TOTAL REPEATATION 
            if lastCharacter==password[i]:
                repeatedCharacters[numberOfRepeatedCharacter]+=1
            else:
                numberOfRepeatedCharacter+=1
                repeatedCharacters.append(1)
                lastCharacter=password[i]
         #<END OF FIRST FOR LOOP>
        cases=int(not isUpper)+int(not isLower)+int(not isDigit)                    
        #LOGIC

        if lengthOfPassword<6:
            #LESS THAN 6 CHARACTERS
            return cases if cases>6-lengthOfPassword else 6-lengthOfPassword
            
        elif lengthOfPassword<=20:        
            #ATLEAST 6 CHARACTER AND ATMOST 20 CHARACTERS
            totalRepeats=0
            for i in repeatedCharacters:
                totalRepeats+=int(i/3)
            return cases if cases>totalRepeats else totalRepeats
            
        elif lengthOfPassword>20:
            extra=lengthOfPassword-20
            totalchanges=0
            while extra!=0:
                #Negitive Value
                pos=-1
                #Modulo should be more than 2
                value=5.99
                countUnique=0
                for i in range(len(repeatedCharacters)):
                    if repeatedCharacters[i]<3:
                        countUnique+=1
                        continue
                    else:
                        if repeatedCharacters[i]%3==0:
                            pos=i
                            value=repeatedCharacters[i]
                            break
                        elif repeatedCharacters[i]%3<value%3:
                            pos=i
                            value=repeatedCharacters[i]

                if value%3==0:
                    if extra-1>=0:
                        repeatedCharacters[pos]-=1
                        extra-=1
                        totalchanges+=1
                    else:
                        break
                elif value%3==1:
                    if extra-2>=0:
                        repeatedCharacters[pos]-=2
                        extra-=2
                        totalchanges+=2
                    else:
                        break
                elif value%3==2:
                    if extra-3>=0:
                        repeatedCharacters[pos]-=3
                        extra-=3
                        totalchanges+=3
                    else:
                        break
                if countUnique>=len(repeatedCharacters):
                    break
            totalRepeats=0
            for number in repeatedCharacters:
                if number>=3:
                    totalRepeats+=int(number/3)
            first=totalchanges+extra
            second=totalRepeats if totalRepeats>cases else cases
            result=int(first+second)

            return result","class Solution {
 public:
  vector<int> diffWaysToCompute(string expression) {
    return ways(expression, {});
  }

 private:
  vector<int> ways(const string& s, unordered_map<string, vector<int>>&& memo) {
    if (const auto it = memo.find(s); it != cend(memo))
      return it->second;

    vector<int> ans;

    for (int i = 0; i < s.length(); ++i)
      if (ispunct(s[i]))
        for (const int a : ways(s.substr(0, i), move(memo)))
          for (const int b : ways(s.substr(i + 1), move(memo)))
            if (s[i] == '+')
              ans.push_back(a + b);
            else if (s[i] == '-')
              ans.push_back(a - b);
            else
              ans.push_back(a * b);

    return memo[s] = (ans.empty() ? vector<int>{stoi(s)} : ans);
  }
};"
"class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32)[::-1]:
            ans <<= 1
            prefix = {num >> i for num in nums}
            ans += any(ans^1^p in prefix for p in prefix)
        return ans","class Solution {
 public:
  bool isAnagram(string s, string t) {
    if (s.length() != t.length())
      return false;

    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (const char c : t)
      if (--count[c] < 0)
        return false;

    return true;
  }
};"
"class Solution:
    def originalDigits(self, s: str) -> str:
        freq = Counter(s)
        nums = [""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine""]
        
        ans = [0]*10
        for c, i in (""g"", 8), (""u"", 4), (""w"", 2), (""x"", 6), (""z"", 0), (""s"", 7), (""v"", 5), (""h"", 3), (""i"", 9), (""o"", 1): 
            ans[i] = freq[c]
            freq -= Counter(nums[i]*freq[c])
        return """".join(sorted(str(i)*x for i, x in enumerate(ans)))","class Solution {
 public:
  int shortestDistance(vector<string>& wordsDict, string word1, string word2) {
    int ans = wordsDict.size();
    int index1 = -1;  // wordsDict[index1] == word1
    int index2 = -1;  // wordsDict[index2] == word2

    for (int i = 0; i < wordsDict.size(); ++i) {
      if (wordsDict[i] == word1) {
        index1 = i;
        if (index2 != -1)
          ans = min(ans, index1 - index2);
      }
      if (wordsDict[i] == word2) {
        index2 = i;
        if (index1 != -1)
          ans = min(ans, index2 - index1);
      }
    }

    return ans;
  }
};"
"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        res = 0
        left = 0
        count = {}
        maxf = 0
        for right in range(len(s)):
            count[s[right]] = 1 + count.get(s[right],0)
            maxf = max(maxf, count[s[right]])
    
            while (right-left+1) - maxf > k:
                count[s[left]] -= 1
                left+=1
            res = max(res, right-left+1)
        return(res)","class Solution {
 public:
  int shortestWordDistance(vector<string>& words, string word1, string word2) {
    const bool isSame = word1 == word2;
    int ans = INT_MAX;
    // If word1 == word2, index1 is the newest index
    int index1 = words.size();
    // If word1 == word2, index2 is the previous index
    int index2 = -words.size();

    for (int i = 0; i < words.size(); ++i) {
      if (words[i] == word1) {
        if (isSame)
          index2 = index1;
        index1 = i;
      } else if (words[i] == word2) {
        index2 = i;
      }
      ans = min(ans, abs(index1 - index2));
    }

    return ans;
  }
};"
"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        if not grid:
            return
        node = Node()
        grid_sum, n = sum(map(sum, grid)), len(grid)
        if grid_sum == (n * n) or grid_sum == 0:
            node.val, node.isLeaf = grid_sum // (n * n), True
            return node
        node.isLeaf, node.val = False, 1
        node.topLeft = self.construct([[j for j in i[:n//2]] for i in grid[:n//2]])
        node.topRight = self.construct([[j for j in i[n//2:]] for i in grid[:n//2]])
        node.bottomLeft = self.construct([[j for j in i[:n//2]] for i in grid[n//2:]])
        node.bottomRight = self.construct([[j for j in i[n//2:]] for i in grid[n//2:]])
        return node","class Solution {
 public:
  bool isStrobogrammatic(string num) {
    const vector<char> rotated{'0', '1', 'x', 'x', 'x',
                               'x', '9', 'x', '8', '6'};
    int l = 0;
    int r = num.length() - 1;

    while (l <= r)
      if (num[l++] != rotated[num[r--] - '0'])
        return false;

    return true;
  }
};"
"class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:
            return None
        
        queue = collections.deque([root])
        res = []
        
        while queue:
            i, l = 0, len(queue)                # l is the number of nodes in current level
            temp_res = []                       # temp_res record node.val at current level
            
            while i < l:                        # i: to iterate through this level
                cur = queue.popleft()
                temp_res.append(cur.val)
                for c in cur.children:          
                    queue.append(c)
                i += 1
            res.append(temp_res)                # After dealing a level, add temp_res which recorded current level to final res
        
        return res","class Solution {
 public:
  vector<string> findStrobogrammatic(int n) {
    return helper(n, n);
  }

 private:
  vector<string> helper(int n, int k) {
    if (n == 0)
      return {""""};
    if (n == 1)
      return {""0"", ""1"", ""8""};

    vector<string> ans;

    for (const string& inner : helper(n - 2, k)) {
      if (n < k)
        ans.push_back(""0"" + inner + ""0"");
      ans.push_back(""1"" + inner + ""1"");
      ans.push_back(""6"" + inner + ""9"");
      ans.push_back(""8"" + inner + ""8"");
      ans.push_back(""9"" + inner + ""6"");
    }

    return ans;
  }
};"
"class Solution:
    def flatten(self, head: 'Node') -> 'Node':
        if head is None:
            return None

        return self.dfs(head)

    def dfs(self, node):
        original_next = node.next
        tail = node

        if node.child:
            node.next = self.dfs(node.child)
            node.next.prev = node
            node.child = None
            tail = node.next
            while tail.next:
                tail = tail.next

        if original_next:
            tail.next = self.dfs(original_next)
            tail.next.prev = tail

        return node","class Solution {
 public:
  int strobogrammaticInRange(string low, string high) {
    int ans = 0;

    for (int n = low.length(); n <= high.length(); ++n) {
      string s(n, ' ');
      dfs(low, high, s, 0, n - 1, ans);
    }

    return ans;
  }

 private:
  const vector<pair<char, char>> pairs{
      {'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};

  void dfs(const string& low, const string& high, string& s, int l, int r,
           int& ans) {
    if (l > r) {
      if (s.length() == low.length() && s < low)
        return;
      if (s.length() == high.length() && s > high)
        return;
      ++ans;
      return;
    }

    for (const auto& [leftDigit, rightDigit] : pairs) {
      if (l == r && leftDigit != rightDigit)
        continue;
      s[l] = leftDigit;
      s[r] = rightDigit;
      if (s.length() > 1 && s[0] == '0')
        continue;
      dfs(low, high, s, l + 1, r - 1, ans);
    }
  }
};"
"class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -> int:
        res = []
        def is_valid_mutate(a, b):
            return sum(1 if a[i] != b[i] else 0 for i in range(len(a))) == 1
        
        def helper(start, bank, count, res):
            if not bank:
                return
            
            for i in range(len(bank)):
                curr = bank[i]
				# curr gene can be mutated from start
                if not is_valid_mutate(curr, start):
                    continue
                
				# we found the mutation from curr to end
                if curr == end:
                    res.append(count + 1)
                    return
                # we put leftover gene bank without curr 
                # and see our curr gene as start can be mutate to leftover gene bank
                helper(curr, bank[:i] + bank[i+1:], count + 1, res)
                    
        helper(start, bank, 0, res)
        return min(res) if res else -1","class Solution {
 public:
  vector<vector<string>> groupStrings(vector<string>& strings) {
    vector<vector<string>> ans;
    unordered_map<string, vector<string>> keyToStrings;

    for (const string& s : strings)
      keyToStrings[getKey(s)].push_back(s);

    for (const auto& [_, strings] : keyToStrings)
      ans.push_back(strings);

    return ans;
  }

 private:
  // ""abc"" -> ""11"" because diff(a, b) = 1 and diff(b, c) = 1
  string getKey(const string& s) {
    string key;

    for (int i = 1; i < s.length(); ++i) {
      const int diff = (s[i] - s[i - 1] + 26) % 26;
      key += to_string(diff) + "","";
    }

    return key;
  }
};"
"class Solution:
    def countSegments(self, s: str) -> int:
        count = 0
        for i in range(len(s)):
            if s[i] != "" "" and (i==0 or s[i-1]== "" ""):
                count+=1

        return count","class Solution {
 public:
  int countUnivalSubtrees(TreeNode* root) {
    int ans = 0;
    isUnival(root, INT_MAX, ans);
    return ans;
  }

 private:
  bool isUnival(TreeNode* root, int val, int& ans) {
    if (root == nullptr)
      return true;

    if (isUnival(root->left, root->val, ans) &
        isUnival(root->right, root->val, ans)) {
      ++ans;
      return root->val == val;
    }

    return false;
  }
};"
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        # removing minimum number of intervals is equivalent to
        # keeping the maximum number of intervals, which can be
        # solved greedily. We can sort by finish time and schedule by
        # earliest non-conflicting finish time to leave for more space
        # for subsequent intervals.
        intervals.sort(key = lambda x: x[1])
        n_keep, prev_end = 1, intervals[0][1]
        for i in range(1, len(intervals)):
            cur_start, cur_end = intervals[i]
            if cur_start >= prev_end:
                n_keep += 1
                prev_end = cur_end
        return len(intervals)-n_keep","class Vector2D {
 public:
  Vector2D(vector<vector<int>>& vec) {
    for (const vector<int>& A : vec)
      for (const int a : A)
        this->vec.push_back(a);
  }

  int next() {
    return vec[i++];
  }

  bool hasNext() {
    return i < vec.size();
  }

 private:
  vector<int> vec;
  int i = 0;
};"
"class Solution:
    def findRightInterval(self, I: List[List[int]]) -> List[int]:
        N, S, A, D, k = len(I), sorted(i[0] for i in I), [-1]*len(I), {j[0]:i for i,j in enumerate(I)}, 0
        for L,R in sorted(I, key = lambda x: x[1]):
            k = bisect.bisect_left(S,R,k)
            if k < N: A[D[L]] = D[S[k]]
        return A
		
		
- Junaid Mansuri","class Solution {
 public:
  bool canAttendMeetings(vector<vector<int>>& intervals) {
    sort(begin(intervals), end(intervals));

    for (int i = 1; i < intervals.size(); ++i)
      if (intervals[i - 1][1] > intervals[i][0])
        return false;

    return true;
  }
};"
"class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        cnt = 0
        if not root:
            return cnt
        
        def counter(n: TreeNode, s=0):
            nonlocal cnt
            if not n:
                return
            s += n.val
            if s == targetSum:
                cnt += 1
            counter(n.left, s)
            counter(n.right, s)
                        
        def dfs(n: TreeNode):
            if not n:
                return
            counter(n)
            dfs(n.left)
            dfs(n.right)
        
        dfs(root)
        return cnt","class Solution {
 public:
  int minMeetingRooms(vector<vector<int>>& intervals) {
    sort(begin(intervals), end(intervals));

    // Store end times of each room.
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const vector<int>& interval : intervals) {
      // No overlap, we can reuse the same room.
      if (!minHeap.empty() && interval[0] >= minHeap.top())
        minHeap.pop();
      minHeap.push(interval[1]);
    }

    return minHeap.size();
  }
};"
"class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        
        def fn(x): 
            """"""Return node counts in denary trie.""""""
            ans, diff = 0, 1
            while x <= n: 
                ans += min(n - x + 1, diff)
                x *= 10 
                diff *= 10 
            return ans 
        
        x = 1
        while k > 1: 
            cnt = fn(x)
            if k > cnt: k -= cnt; x += 1
            else: k -= 1; x *= 10 
        return x","class Solution {
 public:
  vector<vector<int>> getFactors(int n) {
    vector<vector<int>> ans;
    dfs(n, 2, {}, ans);  // The smallest factor is 2
    return ans;
  }

 private:
  void dfs(int n, int s, vector<int>&& path, vector<vector<int>>& ans) {
    if (n <= 1) {
      if (path.size() > 1)
        ans.push_back(path);
      return;
    }

    for (int i = s; i <= n; ++i)
      if (n % i == 0) {
        path.push_back(i);
        dfs(n / i, i, move(path), ans);
        path.pop_back();
      }
  }
};"
"class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        res = []
        nums.sort()
        for i in range(len(nums)-1):
            if nums[i] == nums[i+1]:
                res.append(nums[i])
        return res","class Solution {
 public:
  bool verifyPreorder(vector<int>& preorder) {
    int i = 0;
    dfs(preorder, i, INT_MIN, INT_MAX);
    return i == preorder.size();
  }

 private:
  void dfs(const vector<int>& preorder, int& i, int min, int max) {
    if (i == preorder.size())
      return;
    if (preorder[i] < min || preorder[i] > max)
      return;

    const int val = preorder[i++];
    dfs(preorder, i, min, val);
    dfs(preorder, i, val, max);
  }
};"
"class Solution:
    def compress(self, C: List[str]) -> int:
    	if len(C) <= 1: return
    	c, i, _ = 1, 0, C.append("" "")
    	while C[i] != "" "":
    		if C[i] == C[i+1]: c += 1
    		elif c > 1: C[i+2-c:i+1], i, c = list(str(c)), i + 1 - c + len(list(str(c))), 1
    		i += 1
    	del C[-1]
			

- Junaid Mansuri","class Solution {
 public:
  int minCost(vector<vector<int>>& costs) {
    for (int i = 1; i < costs.size(); ++i) {
      costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);
      costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);
      costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);
    }

    return *min_element(begin(costs.back()), end(costs.back()));
  }
};"
"class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        result = self.getNumberByIterList(l1) + self.getNumberByIterList(l2)
        divisor = 10
        if result == 0:
            return ListNode(0)
        head, prev = None, None
        while result > 0:
            result, remainder = divmod(result, divisor)
            head = ListNode(remainder, prev)
            prev = head
        return head

    
    def getNumberByIterList(self, li):
        number = 0 
        while li is not None:
            number = number * 10 + li.val
            li = li.next
        return number","class Solution {
 public:
  vector<string> binaryTreePaths(TreeNode* root) {
    vector<string> ans;
    dfs(root, {}, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, vector<string>&& path, vector<string>& ans) {
    if (root == nullptr)
      return;
    if (root->left == nullptr && root->right == nullptr) {
      ans.push_back(join(path) + to_string(root->val));
      return;
    }

    path.push_back(to_string(root->val) + ""->"");
    dfs(root->left, move(path), ans);
    dfs(root->right, move(path), ans);
    path.pop_back();
  }

  string join(const vector<string>& path) {
    string joined;
    for (const string& s : path)
      joined += s;
    return joined;
  }
};"
"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        dp = [defaultdict(int) for _ in range(len(nums))]
        res = 0
        for i in range(len(nums)):
            for j in range(i):
                dp[i][nums[i] - nums[j]] += dp[j][nums[i] - nums[j]] + 1
                res += dp[j][nums[i] - nums[j]]
        return res","class Solution {
 public:
  int addDigits(int num) {
    return 1 + (num - 1) % 9;
  }
};"
"class Solution:
    def dist(self, p1, p2):
        return sqrt(pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2))
    
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        res = 0
        
        for i in range(len(points)):
            ""cache for every point""
            dist_cache = collections.defaultdict(int)
            
            for j in range(len(points)):
                if i == j:
                    continue
                    
                dist_cache[self.dist(points[i], points[j])] += 1
            
            
            for key in dist_cache:
                """"""
                The formula for generating permutations given n object where we are allowed to choose r of them, is: P(n, r) = n! / (n-r)! 
                In our case we have: n = dist_cache[key] (where key is some distance). Also we can choose 2 elements at a time: r = 2. So formula now: P(n, 2) = n! / (n-2)!
                Using some mathematical transformations: n! / (n-2)! = n * (n-1) * (n-2)! / (n-2)! = n * (n-1)
                This logic applies to each point.
                """"""
                res += dist_cache[key] * (dist_cache[key] - 1)
        
        return res","class Solution {
 public:
  int threeSumSmaller(vector<int>& nums, int target) {
    if (nums.size() < 3)
      return 0;

    int ans = 0;

    sort(begin(nums), end(nums));

    for (int i = 0; i + 2 < nums.size(); ++i) {
      int l = i + 1;
      int r = nums.size() - 1;
      while (l < r)
        if (nums[i] + nums[l] + nums[r] < target) {
          // (nums[i], nums[l], nums[r])
          // (nums[i], nums[l], nums[r - 1])
          // ...,
          // (nums[i], nums[l], nums[l + 1])
          ans += r - l;
          ++l;
        } else {
          --r;
        }
    }

    return ans;
  }
};"
"class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        return {x for x in range(1,len(nums)+1)} - set(nums)","class Solution {
 public:
  vector<int> singleNumber(vector<int>& nums) {
    const int xors = accumulate(begin(nums), end(nums), 0, bit_xor<>());
    const int lowbit = xors & -xors;
    vector<int> ans(2);

    // Seperate nums into two groups by the lowbit
    for (const int num : nums)
      if (num & lowbit)
        ans[0] ^= num;
      else
        ans[1] ^= num;

    return ans;
  }
};"
"class Solution:    
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root:
            return None
        
        if root.val == key:
            # first case - no childrens
            if not root.left and not root.right:
                return None
            
            # second case - there is one of chlidren (left or right)
            if not root.left:
                return root.right
            
            if not root.right:
                return root.left
            
            # third case - there are both childrens (left and right)
            tmp = root.left
            while tmp.right:
                tmp = tmp.right
            
            root.val = tmp.val
            root.left = self.deleteNode(root.left, root.val)
            
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        else:
            root.right = self.deleteNode(root.right, key)
        
        return root","class Solution {
 public:
  bool validTree(int n, vector<vector<int>>& edges) {
    if (n == 0 || edges.size() != n - 1)
      return false;

    vector<vector<int>> graph(n);
    queue<int> q{{0}};
    unordered_set<int> seen{{0}};

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      for (const int v : graph[u])
        if (!seen.count(v)) {
          q.push(v);
          seen.insert(v);
        }
    }

    return seen.size() == n;
  }
};"
"class Solution:
    def frequencySort(self, s: str) -> str:
        a = Counter(s)
        b = """"
        abc = sorted(a, reverse = True,  key = a.get)
        for i in abc:
            for j in range(a[i]):
                b+=i
        return b","class Solution {
 public:
  bool isUgly(int n) {
    if (n == 0)
      return false;

    for (const int prime : {2, 3, 5})
      while (n % prime == 0)
        n /= prime;

    return n == 1;
  }
};"
"class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        ans, prev = 0, -inf
        for x, y in sorted(points, key=lambda x: x[1]): 
            if prev < x: 
                ans += 1
                prev = y
        return ans","class Solution {
 public:
  int nthUglyNumber(int n) {
    vector<int> uglyNums{1};
    int i2 = 0;
    int i3 = 0;
    int i5 = 0;

    while (uglyNums.size() < n) {
      const int next2 = uglyNums[i2] * 2;
      const int next3 = uglyNums[i3] * 3;
      const int next5 = uglyNums[i5] * 5;
      const int next = min({next2, next3, next5});
      if (next == next2)
        ++i2;
      if (next == next3)
        ++i3;
      if (next == next5)
        ++i5;
      uglyNums.push_back(next);
    }

    return uglyNums.back();
  }
};"
"class Solution:
    def minMoves(self, nums: List[int]) -> int:
        return sum(nums) - min(nums)*len(nums)","class Solution {
 public:
  int minCostII(vector<vector<int>>& costs) {
    int prevIndex = -1;  // The previous minimum index
    int prevMin1 = 0;    // Minimum cost so far
    int prevMin2 = 0;    // 2nd minimum cost so far

    for (const vector<int>& cost : costs) {  // O(n)
      int index = -1;  // The painted index s.t. achieve the minimum cost after
                       // Painting current house
      int min1 = INT_MAX;  // The minimum cost after painting current house
      int min2 = INT_MAX;  // The 2nd minimum cost after painting current house
      for (int i = 0; i < cost.size(); ++i) {  // O(k)
        const int theCost = cost[i] + (i == prevIndex ? prevMin2 : prevMin1);
        if (theCost < min1) {
          index = i;
          min2 = min1;
          min1 = theCost;
        } else if (theCost < min2) {  // Min1 <= theCost < min2
          min2 = theCost;
        }
      }
      prevIndex = index;
      prevMin1 = min1;
      prevMin2 = min2;
    }

    return prevMin1;
  }
};"
"class Solution:
    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:
        AB = [a+b for a in A for b in B]
        CD = [c+d for c in C for d in D]
                
        # Two sum from AB and CD
        counts = 0
        CD_count = collections.Counter(CD)
        for num in AB:
            counts += CD_count.get(-num, 0)
                
        return counts","class Solution {
 public:
  bool canPermutePalindrome(string s) {
    unordered_set<char> seen;

    for (const char c : s)
      if (!seen.insert(c).second)
        seen.erase(c);

    return seen.size() <= 1;
  }
};"
"class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        i = j = 0
        out = 0
        while i < len(g) and j < len(s):
            if g[i] <= s[j]:
                i += 1
                out += 1
            j += 1
        return out","class Solution {
 public:
  vector<string> generatePalindromes(string s) {
    int odd = 0;
    unordered_map<char, int> count;

    // Get character occurrence
    for (const char c : s)
      ++count[c];

    // Count odd one
    for (const auto& [_, value] : count)
      if (value & 1)
        ++odd;

    // can't form any palindrome
    if (odd > 1)
      return {};

    vector<string> ans;
    vector<char> candidates;
    string mid;

    // Get mid and candidates characters
    for (const auto& [key, value] : count) {
      if (value & 1)
        mid += key;
      for (int i = 0; i < value / 2; ++i)
        candidates.push_back(key);
    }

    // Backtracking to generate our ans (strings)
    dfs(candidates, mid, vector<bool>(candidates.size()), """", ans);
    return ans;
  }

 private:
  // Generate all unique palindromes from candidates
  void dfs(const vector<char>& candidates, const string& mid,
           vector<bool>&& used, string&& path, vector<string>& ans) {
    if (path.length() == candidates.size()) {
      string secondHalf = path;
      reverse(begin(secondHalf), end(secondHalf));
      ans.push_back(path + mid + secondHalf);
      return;
    }

    for (int i = 0; i < candidates.size(); ++i) {
      if (used[i])
        continue;
      if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1])
        continue;
      used[i] = true;
      path.push_back(candidates[i]);
      dfs(candidates, mid, move(used), move(path), ans);
      path.pop_back();
      used[i] = false;
    }
  }
};"
"class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        prev_greater = [-1] * len(nums)
        stack = []
        for i, n in enumerate(nums):
            # Use >= so that PGE is strictly greater as opposed to greater or equal
            while stack and n >= nums[stack[-1]]:
                stack.pop()
            if stack:
                prev_greater[i] = stack[-1]
            stack.append(i)
            
        mins = [0]
        for i in range(1, len(nums)):
            mins.append(mins[-1])
            if nums[i] < nums[mins[-1]]:
                mins[-1] = i
            
        for i in range(1, len(nums)):
            if ((pg := prev_greater[i]) != -1 and
                nums[mins[pg]] < nums[i] and # nums[i] < nums[pg] by the definition of PGE
                mins[pg] != pg): # mins[pg] <= pg, so only need to check if mins[pg] != pg
                return True
        return False","class Solution {
 public:
  int missingNumber(vector<int>& nums) {
    int ans = nums.size();

    for (int i = 0; i < nums.size(); ++i)
      ans ^= i ^ nums[i];

    return ans;
  }
};"
"class Solution:
    def circularArrayLoop(self, nums: List[int]) -> bool:
        seen = set() # visited &amp; no cycle 
        for i, x in enumerate(nums): 
            if i in seen: continue 
            temp = set() # visited in this round 
            while True: 
                ii = (i + nums[i])% len(nums)
                if ii in seen or nums[ii] * x < 0 or ii == i: # no cycle 
                    seen |= temp 
                    break 
                if ii in temp and ii != i: return True 
                temp.add(i := ii)
        return False","class Solution {
 public:
  string alienOrder(vector<string>& words) {
    unordered_map<char, unordered_set<char>> graph;
    vector<int> inDegree(26);
    buildGraph(graph, words, inDegree);
    return topology(graph, inDegree);
  }

 private:
  void buildGraph(unordered_map<char, unordered_set<char>>& graph,
                  const vector<string>& words, vector<int>& inDegree) {
    // Create node for each character in each word
    for (const string& word : words)
      for (const char c : word)
        if (!graph.count(c))
          graph[c] = unordered_set<char>();

    for (int i = 1; i < words.size(); ++i) {
      const string& first = words[i - 1];
      const string& second = words[i];
      const int length = min(first.length(), second.length());
      for (int j = 0; j < length; ++j) {
        const char u = first[j];
        const char v = second[j];
        if (u != v) {
          if (!graph[u].count(v)) {
            graph[u].insert(v);
            ++inDegree[v - 'a'];
          }
          break;  // Later characters' order are meaningless
        }
        // First = ""ab"", second = ""a"" -> invalid
        if (j == length - 1 && first.length() > second.length()) {
          graph.clear();
          return;
        }
      }
    }
  }

  string topology(unordered_map<char, unordered_set<char>>& graph,
                  vector<int>& inDegree) {
    string s;
    queue<char> q;

    for (const auto& [c, _] : graph)
      if (inDegree[c - 'a'] == 0)
        q.push(c);

    while (!q.empty()) {
      const char u = q.front();
      q.pop();
      s += u;
      for (const char v : graph[u])
        if (--inDegree[v - 'a'] == 0)
          q.push(v);
    }

    // Words = [""z"", ""x"", ""y"", ""x""]
    return s.length() == graph.size() ? s : """";
  }
};"
"class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        # Calculate the max time for a pig to test buckets...
        # Note that, max time will not be (minutesToTest / minutesToDie)...
        # Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...
        max_time = minutesToTest / minutesToDie + 1
        # Initialize the required minimum number of pigs...
        req_pigs = 0
        # To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...
        while (max_time) ** req_pigs < buckets:
            # Increment until it will be greater or equals to bucket...
            req_pigs += 1
        # Return the required minimum number of pigs...
        return req_pigs","class Solution {
 public:
  int closestValue(TreeNode* root, double target) {
    // If target < root->val, search left subtree
    if (target < root->val && root->left) {
      const int left = closestValue(root->left, target);
      if (abs(left - target) < abs(root->val - target))
        return left;
    }

    // If target > root->val, search right subtree
    if (target > root->val && root->right) {
      const int right = closestValue(root->right, target);
      if (abs(right - target) < abs(root->val - target))
        return right;
    }

    return root->val;
  }
};"
"class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        a = s[0]
        x = len(s)
        for i in range(1,len(s)):
            if a == s[i:i+len(a)]:
                c = int(len(s)/len(a))
                if a * c == s:
                    return True
            else:
                pass
            a += s[i]
        return False","class Codec {
 public:
  // Encodes a list of strings to a single string.
  string encode(vector<string>& strs) {
    string encoded;

    for (const string& s : strs)
      encoded += to_string(s.length()) + '/' + s;

    return encoded;
  }

  // Decodes a single string to a list of strings.
  vector<string> decode(string s) {
    vector<string> decoded;

    for (int i = 0; i < s.length();) {
      const int slash = s.find('/', i);
      const int length = stoi(s.substr(i, slash - i));
      i = slash + length + 1;
      decoded.push_back(s.substr(slash + 1, i - slash - 1));
    }

    return decoded;
  }
};"
"class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
    	xb, yb = bin(min(x,y))[2:], bin(max(x,y))[2:]
    	return list(yb[:(len(yb)-len(xb))]).count('1') + sum([1 for i in range(len(xb)) if xb[-1-i] != yb[-1-i]])
		
		
- Junaid Mansuri","class Solution {
 public:
  vector<int> closestKValues(TreeNode* root, double target, int k) {
    deque<int> q;

    inorder(root, q);

    while (q.size() > k)
      if (abs(q.front() - target) > abs(q.back() - target))
        q.pop_front();
      else
        q.pop_back();

    return {begin(q), end(q)};
  }

 private:
  void inorder(TreeNode* root, deque<int>& q) {
    if (root == nullptr)
      return;

    inorder(root->left, q);
    q.push_back(root->val);
    inorder(root->right, q);
  }
};"
"class Solution:
    def minMoves2(self, n: List[int]) -> int:
    	return (lambda x,y: sum(abs(i-x[y]) for i in x))(sorted(n), len(n)//2)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  string numberToWords(int num) {
    if (num == 0)
      return ""Zero"";
    return helper(num);
  }

 private:
  const vector<string> belowTwenty{
      """",        ""One"",     ""Two"",       ""Three"",    ""Four"",
      ""Five"",    ""Six"",     ""Seven"",     ""Eight"",    ""Nine"",
      ""Ten"",     ""Eleven"",  ""Twelve"",    ""Thirteen"", ""Fourteen"",
      ""Fifteen"", ""Sixteen"", ""Seventeen"", ""Eighteen"", ""Nineteen""};
  const vector<string> tens{"""",      """",      ""Twenty"",  ""Thirty"", ""Forty"",
                            ""Fifty"", ""Sixty"", ""Seventy"", ""Eighty"", ""Ninety""};

  string helper(int num) {
    string s;

    if (num < 20)
      s = belowTwenty.at(num);
    else if (num < 100)
      s = tens.at(num / 10) + "" "" + belowTwenty.at(num % 10);
    else if (num < 1000)
      s = helper(num / 100) + "" Hundred "" + helper(num % 100);
    else if (num < 1000000)
      s = helper(num / 1000) + "" Thousand "" + helper(num % 1000);
    else if (num < 1000000000)
      s = helper(num / 1000000) + "" Million "" + helper(num % 1000000);
    else
      s = helper(num / 1000000000) + "" Billion "" + helper(num % 1000000000);

    trim(s);
    return s;
  }

  void trim(string& s) {
    s.erase(0, s.find_first_not_of(' '));
    s.erase(s.find_last_not_of(' ') + 1);
  }
};"
"class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        
            p = 0
            for i in range(len(grid)):
                for j in range(len(grid[i])):
                    if grid[i][j]:
                        p += 4 - (i and grid[i-1][j])*2 - (j and grid[i][j - 1])*2
            return p","class Solution {
 public:
  int hIndex(vector<int>& citations) {
    const int n = citations.size();
    int accumulate = 0;
    vector<int> count(n + 1);

    for (const int citation : citations)
      ++count[min(citation, n)];

    // To find the largeset h-index, loop from back to front
    // I is the candidate h-index
    for (int i = n; i >= 0; --i) {
      accumulate += count[i];
      if (accumulate >= i)
        return i;
    }

    throw;
  }
};"
"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:

        @lru_cache(maxsize=None)
        def can_win(choices, remainder):
            if choices[-1] >= remainder: return True

            for index in range(len(choices)):
                if not can_win(choices[:index] + choices[index + 1:], remainder - choices[index]): return True

            return False

        summed_choices =  maxChoosableInteger * (maxChoosableInteger + 1) / 2
        if summed_choices < desiredTotal: return False
        if summed_choices == desiredTotal: return maxChoosableInteger % 2

        return can_win(tuple(range(1, maxChoosableInteger + 1)), desiredTotal)","class Solution {
 public:
  int hIndex(vector<int>& citations) {
    const int n = citations.size();
    int l = 0;
    int r = n;

    while (l < r) {
      const int m = (l + r) / 2;
      if (citations[m] >= n - m)
        r = m;
      else
        l = m + 1;
    }

    return n - l;
  }
};"
"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:
        cnt = idx = 0 
        count = []
        index = []
        for i in range(n1): 
            for ch in s1: 
                if ch == s2[idx]: 
                    idx += 1
                    if idx == len(s2): 
                        cnt += 1
                        idx = 0 
            count.append(cnt)
            index.append(idx)
            for ii in range(i): 
                if index[ii] == idx: 
                    prev = count[ii]
                    repeat = (cnt - prev) * ((n1-1-ii) // (i - ii))
                    post = count[ii + (n1-1-ii) % (i-ii)] - count[ii]
                    return (prev + repeat + post) // n2
        return count[-1]//n2","class Solution {
 public:
  int numWays(int n, int k) {
    if (n == 0)
      return 0;
    if (n == 1)
      return k;
    if (n == 2)
      return k * k;

    // dp[i] := # of ways to paint n posts with k colors
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = k;
    dp[2] = k * k;

    for (int i = 3; i <= n; ++i)
      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1);

    return dp[n];
  }
};"
"class Solution:
    def findSubstringInWraproundString(self, p: str) -> int:
        dp=[0 for i in range(26)]
        if p=="""":
            return 0
        count=1
        pre=ord(p[0])-ord('a')
        dp[pre]=1
        for i in p[1:]:
            cur=ord(i)-ord('a')
            if (pre+1)%26==cur:
                count+=1
                dp[cur]=max(dp[cur],count)
            else:
                count=1
                dp[cur]=max(dp[cur],count)
            pre=cur
        return sum(dp)","class Solution {
 public:
  int findCelebrity(int n) {
    int candidate = 0;

    // Everyone knows the celebrity
    for (int i = 1; i < n; ++i)
      if (knows(candidate, i))
        candidate = i;

    // Candidate knows nobody and everyone knows the celebrity
    for (int i = 0; i < n; ++i) {
      if (i < candidate && knows(candidate, i) || !knows(i, candidate))
        return -1;
      if (i > candidate && !knows(i, candidate))
        return -1;
    }

    return candidate;
  }
};"
"class Solution:
    def validate_ipv4(self,IP:str)->str:
        for x in IP.split("".""):
            if len(x)==0 or len(x)>3: return ""Neither""
            if not x.isdigit() or not 0<=int(x)<=255 or (x[0]==""0"" and len(x)!=1): return ""Neither""
        return ""IPv4""
    
    def validate_ipv6(self,IP:str)->str:
        hex_digits=""0123456789abcdefABCDEF""
        for x in IP.split("":""):
            if len(x)==0 or len(x)>4 or not all(c in hex_digits for c in x): return ""Neither""
        return ""IPv6"" 
        
    def validIPAddress(self, IP: str) -> str:
        """"""
        O(n) time complexity
        O(1) space complexity
        """"""
        if ""."" in IP and IP.count(""."")==3:
            return self.validate_ipv4(IP)
        elif "":"" in IP and IP.count("":"")==7:
            return self.validate_ipv6(IP)
        else:
            return ""Neither""","bool isBadVersion(int version);

class Solution {
 public:
  int firstBadVersion(int n) {
    int l = 1;
    int r = n;

    while (l < r) {
      const int m = l + (r - l) / 2;
      if (isBadVersion(m))
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};"
"class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        
        wordset = set(words)
        
        @cache
        def f(word,i):
            if i >= len(word):
                return True
            j = i+1
            while j <= len(word):
                if word[i:j] in wordset and j-i != len(word) and f(word,j):
                    return True
                j += 1
            return False
        
        return [word for word in words if any(word) and f(word,0)]","class Solution {
 public:
  int numSquares(int n) {
    vector<int> dp(n + 1, n);  // 1^2 x n

    dp[0] = 0;  // No way
    dp[1] = 1;  // 1^2

    for (int i = 2; i <= n; ++i)
      for (int j = 1; j * j <= i; ++j)
        dp[i] = min(dp[i], dp[i - j * j] + 1);

    return dp[n];
  }
};"
"class Solution:
    def makesquare(self, matchsticks) -> bool:
        total_circumference = sum(matchsticks)
        side = total_circumference/4

        if int(side) != side:
            return False
			
        matchsticks.sort()
        
        paths = [0]*4
        h = {}
		
        if matchsticks[-1] > side:
            return False
        
        def r():
            if not matchsticks:
                return True

            num = matchsticks.pop()

            ret = False
            for x in range(4):
                if paths[x] + num <= side:
                    paths[x] += num
                    ret |= r()
                    if ret:
                        return True
                    paths[x] -= num
                    if not paths[x]:
                        break

            matchsticks.append(num)
            return ret
        return r()","class Solution {
 public:
  void wiggleSort(vector<int>& nums) {
    // 1. if i is even, then nums[i] <= nums[i - 1]
    // 2. if i is odd, then nums[i] >= nums[i - 1]
    for (int i = 1; i < nums.size(); ++i)
      if ((!(i & 1) && nums[i] > nums[i - 1]) ||
          ((i & 1) && nums[i] < nums[i - 1]))
        swap(nums[i], nums[i - 1]);
  }
};"
"class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        arr = sorted([(len(i), sum([1 for j in i if j == '0'])) for i in strs])
        arr = [(i[1], i[0]-i[1], i[0]) for i in arr] # N0, N1, len
        
        ptr = 0
        larr = len(arr)
        print(larr)
        memo = {}

        def dfs(n0: int, n1: int, ptr: int):
            # print((n0, n1, ptr))
            if (n0, n1, ptr) in memo:
                return memo[(n0, n1, ptr)]

            if ptr == larr:
                return 0

            if n0 + n1 < arr[ptr][2]:
                return 0
            
            nextp = ptr + 1

            if not (n0 >= arr[ptr][0] and n1 >= arr[ptr][1]):
                return dfs(n0, n1, nextp)

            take = 1 + dfs(n0 - arr[ptr][0], n1 - arr[ptr][1], nextp)

            if arr[ptr][2] == 1:
                ntake = 0
            else:
                ntake = dfs(n0, n1, nextp)

            ans = take if take > ntake else ntake
            memo[(n0,n1,ptr)] = ans
            return ans
        
        return dfs(m, n, 0)","class Solution {
 public:
  vector<string> addOperators(string num, int target) {
    vector<string> ans;
    dfs(num, target, 0, 0, 0, {}, ans);
    return ans;
  }

 private:
  string join(const vector<string>& path) {
    string joined;
    for (const string& s : path)
      joined += s;
    return joined;
  }

  // Start index, prev value, current evaluated value
  void dfs(const string& num, int target, int start, long prev, long eval,
           vector<string>&& path, vector<string>& ans) {
    if (start == num.length()) {
      if (eval == target)
        ans.push_back(join(path));
      return;
    }

    for (int i = start; i < num.length(); ++i) {
      if (i > start && num[start] == '0')
        return;
      const string& s = num.substr(start, i - start + 1);
      const long curr = stol(s);
      if (start == 0) {
        path.push_back(s);
        dfs(num, target, i + 1, curr, curr, move(path), ans);
        path.pop_back();
      } else {
        for (const string& op : {""+"", ""-"", ""*""}) {
          path.push_back(op + s);
          if (op == ""+"")
            dfs(num, target, i + 1, curr, eval + curr, move(path), ans);
          else if (op == ""-"")
            dfs(num, target, i + 1, -curr, eval - curr, move(path), ans);
          else
            dfs(num, target, i + 1, prev * curr, eval - prev + prev * curr,
                move(path), ans);
          path.pop_back();
        }
      }
    }
  }
};"
"class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        houses.sort()
        heaters.sort()
        total, size = len(houses), len(heaters)
		#dummy solution to check if heater with radius r, to cover all houses
        def valid_radius(r):
            house_offset = 0
            heater_offset = 0
            while house_offset < total:
                #case 1: current house is covered by current house, simply pass
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
				#case 2 house cannot be covered, and locates on left side of heater, we can never find a heater to cover this house
                if houses[house_offset] < heaters[heater_offset]:
                    return False
                    break
				#case 3 go ahead to further heater, find the closest heater to cover the house or find no such heater valid
                while heater_offset < size and abs(houses[house_offset] - heaters[heater_offset]) > r:
                    heater_offset += 1
                if heater_offset >= size:return False
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
                else:
                    return False
                    break
            return True
		#binary search to get radius
        low, high = 0, max(abs(heaters[0] - houses[0]), abs(heaters[0] - houses[-1]))
        mid = (low + high)//2
        while high - low > 1:
            if valid_radius(mid):
                high = mid
            else:low = mid
            mid = (low + high)//2

        return low if valid_radius(low) else high","class Solution {
 public:
  void moveZeroes(vector<int>& nums) {
    int i = 0;
    for (const int num : nums)
      if (num != 0)
        nums[i++] = num;

    while (i < nums.size())
      nums[i++] = 0;
  }
};"
"class Solution:
    def findComplement(self, num: int) -> int:
        return int("""".join([""1"" if i == ""0"" else ""0"" for i in list(bin(num))[2:]]),2)","class PeekingIterator : public Iterator {
 public:
  PeekingIterator(const vector<int>& nums) : Iterator(nums) {}

  // Returns the next element in the iteration without advancing the iterator.
  int peek() {
    // Iterator(*this) makes a copy of current iterator, then call next on the
    // Copied iterator to get the next value without affecting current iterator
    return Iterator(*this).next();
  }

  // hasNext() and next() should behave the same as in the Iterator interface.
  // Override them if needed.
  int next() {
    return Iterator::next();
  }

  bool hasNext() const {
    return Iterator::hasNext();
  }
};"
"class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        nums_len = len(nums)
        
        
        if (nums_len == 0):
            return 0
        
        current_bit = 1
        ret = 0
        max_ = max(nums) 

                
        while (current_bit <= max_):
            counter = 0
            
            
            for number in nums:
                if (number &amp; current_bit):
                    counter += 1
                    
            ret += counter * (nums_len - counter)
            current_bit <<= 1
            
        return ret","class Solution {
 public:
  TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
    if (root == nullptr)
      return nullptr;
    if (root->val <= p->val)
      return inorderSuccessor(root->right, p);

    TreeNode* left = inorderSuccessor(root->left, p);
    return left ? left : root;
  }
};"
"class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.radius = radius 
        self.x_center = x_center
        self.y_center = y_center

    def randPoint(self) -> List[float]:
        radius = self.radius*sqrt(random.random()) # sample radius as r*sqrt(x) 
        theta = 2*pi*random.random() # sample angle as unif [0, 2*pi) 
        return self.x_center + radius*cos(theta), self.y_center + radius*sin(theta)","class Solution {
 public:
  void wallsAndGates(vector<vector<int>>& rooms) {
    const int m = rooms.size();
    const int n = rooms[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<pair<int, int>> q;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (rooms[i][j] == 0)
          q.emplace(i, j);

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (rooms[x][y] != INT_MAX)
          continue;
        rooms[x][y] = rooms[i][j] + 1;
        q.emplace(x, y);
      }
    }
  }
};"
"class Solution:
    def largestPalindrome(self, n: int) -> int:
        return [0, 9, 987, 123, 597, 677, 1218, 877, 475][n]

        
    def isPalindrome(x):
        return str(x) == str(x)[::-1]

    def solve(n):
        best = 0
        for i in range(10**n-1, 0, -1):
            for j in range(max(i, (best-1)//i+1), 10**n):
                if isPalindrome(i*j):
                    #print(i, j, i*j)
                    best = i*j
        return best","class Solution {
 public:
  int findDuplicate(vector<int>& nums) {
    int slow = nums[nums[0]];
    int fast = nums[nums[nums[0]]];

    while (slow != fast) {
      slow = nums[slow];
      fast = nums[nums[fast]];
    }

    slow = nums[0];

    while (slow != fast) {
      slow = nums[slow];
      fast = nums[fast];
    }

    return slow;
  }
};"
"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        
        # Init
        medians = []
        n = len(nums)
        
        # Make median indexes
        m1,m2 = (k//2,k//2) if k%2 else ((k//2)-1,k//2)
       
        # Sort the array and find the first median
        arr = sorted(nums[:k])
        medians.append(float((arr[m1] + arr[m2])/2))
        
        # Find rest medians
        for i in range(0,n-k): 
            arr.remove(nums[i])
            bisect.insort(arr, nums[i+k])
            medians.append(float((arr[m1] + arr[m2])/2))
        
        # return
        return medians","class Solution {
 public:
  void gameOfLife(vector<vector<int>>& board) {
    const int m = board.size();
    const int n = board[0].size();

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        int ones = 0;
        for (int x = max(0, i - 1); x < min(m, i + 2); ++x)
          for (int y = max(0, j - 1); y < min(n, j + 2); ++y)
            ones += board[x][y] & 1;
        // Any live cell with 2 or 3 live neighbors
        // lives on to the next generation
        if (board[i][j] == 1 && (ones == 3 || ones == 4))
          board[i][j] |= 0b10;
        // Any dead cell with exactly 3 live neighbors
        // becomes a live cell, as if by reproduction
        if (board[i][j] == 0 && ones == 3)
          board[i][j] |= 0b10;
      }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        board[i][j] >>= 1;
  }
};"
"class Solution:
    def magicalString(self, n: int) -> int:
        if n==0: return 0
        if n<=3: return 1
        s,index = [1,2,2],2
        while len(s)<n:
            s+=[3-s[-1]]*s[index]
            index+=1
        return s[:n].count(1)","class Solution {
 public:
  bool wordPattern(string pattern, string str) {
    const int n = pattern.length();
    istringstream iss(str);
    vector<int> charToIndex(128);
    unordered_map<string, int> stringToIndex;

    int i = 0;
    for (string word; iss >> word; ++i) {
      if (i == n)  // Out of bound
        return false;
      if (charToIndex[pattern[i]] != stringToIndex[word])
        return false;
      charToIndex[pattern[i]] = i + 1;
      stringToIndex[word] = i + 1;
    }

    return i == n;
  }
};"
"class Solution:
    def licenseKeyFormatting(self, S: str, K: int) -> str:
    	S = """".join([i for i in S if i != '-']).upper()
    	L = len(S)
    	t = L%K
    	if t == 0:
    		t = K
    	T = S[0:t] + '-'
    	for i in range(t,L,K):
    		T = T + S[i:i+K] + '-'
    	return(T[0:-1])
		
- Python 3
- Junaid Mansuri","class Solution {
 public:
  bool wordPatternMatch(string pattern, string s) {
    return isMatch(pattern, 0, s, 0, unordered_map<char, string>(),
                   unordered_set<string>());
  }

 private:
  bool isMatch(const string& pattern, int i, const string& s, int j,
               unordered_map<char, string>&& charToString,
               unordered_set<string>&& seen) {
    if (i == pattern.length() && j == s.length())
      return true;
    if (i == pattern.length() || j == s.length())
      return false;

    const char c = pattern[i];

    if (const auto it = charToString.find(c); it != cend(charToString)) {
      const string& t = it->second;
      // Check if we can match t w/ s[j:]
      if (s.substr(j).find(t) == string::npos)
        return false;

      // If can match, so continue match the rest
      return isMatch(pattern, i + 1, s, j + t.length(), move(charToString),
                     move(seen));
    }

    for (int k = j; k < s.length(); ++k) {
      const string& t = s.substr(j, k - j + 1);

      // This string is already mapped by other character
      if (seen.count(t))
        continue;

      charToString[c] = t;
      seen.insert(t);

      if (isMatch(pattern, i + 1, s, k + 1, move(charToString), move(seen)))
        return true;

      // Backtracking
      charToString.erase(c);
      seen.erase(t);
    }

    return false;
  }
};"
"class Solution:
    def smallestGoodBase(self, n: str) -> str:
        n = int(n)
        for p in range(int(log2(n)), 1, -1): 
            k = int(n**(1/p))
            if (k**(p+1)-1)//(k-1) == n: return str(k)
        return str(n-1)","class Solution {
 public:
  bool canWinNim(int n) {
    return n % 4 != 0;
  }
};"
"class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        l, output = 0,0
        
        for r, number in enumerate(nums):
            
            if number == 0:
                l = r+1
            
            output = max(output, r-l+1)
        
        return output","class Solution {
 public:
  vector<string> generatePossibleNextMoves(string currentState) {
    vector<string> ans;

    for (int i = 0; i + 1 < currentState.length(); ++i)
      if (currentState[i] == '+' && currentState[i + 1] == '+')
        ans.push_back(currentState.substr(0, i) + ""--"" +
                      currentState.substr(i + 2));

    return ans;
  }
};"
"class Solution:
    def PredictTheWinner(self, nums: List[int]) -> bool:
        
        N = len(nums)
        if N % 2 == 0: return True # can always win by picking larger one of odd or even subarray
        
		# DP
        dp = nums[:]
        for i in range(1, N):
            for j in range(N - i):
                dp[j] = max(nums[j] - dp[j + 1], nums[j + i] - dp[j])
        
        return dp[0] >= 0","class Solution {
 public:
  bool canWin(string currentState) {
    const auto it = memo.find(currentState);
    if (it == cend(memo))
      return it->second;

    // If any of currentState[i:i + 2] == ""++"" and your friend can't win after
    // Changing currentState[i:i + 2] to ""--"" (or ""-""), then you can win
    for (int i = 0; i + 1 < currentState.length(); ++i)
      if (currentState[i] == '+' && currentState[i + 1] == '+' &&
          !canWin(currentState.substr(0, i) + '-' + currentState.substr(i + 2)))
        return memo[currentState] = true;

    return memo[currentState] = false;
  }

 private:
  unordered_map<string, bool> memo;
};"
"class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        hand = ''.join(sorted(hand))
        
        @cache
        def fn(board, hand):
            """"""Return min number of balls to insert.""""""
            if not board: return 0
            if not hand: return inf 
            ans = inf 
            for i, ch in enumerate(hand): 
                if i == 0 or hand[i-1] != ch: # pruning 1
                    hh = hand[:i] + hand[i+1:]
                    for j in range(0, len(board)): 
                        if ch == board[j] or j and board[j-1] == board[j]: # pruning 2
                            bb, nn = """", board[:j] + ch + board[j:]
                            while bb != nn:
                                bb, nn = nn, """"
                                for k, grp in groupby(bb): 
                                    x = len(list(grp))
                                    if x < 3: nn += k*x
                            ans = min(ans, 1 + fn(bb, hh))
            return ans 
        
        return (lambda x: x if x < inf else -1)(fn(board, hand))","class MedianFinder {
 public:
  void addNum(int num) {
    if (maxHeap.empty() || num <= maxHeap.top())
      maxHeap.push(num);
    else
      minHeap.push(num);

    // Balance two heaps s.t.
    // |maxHeap| >= |minHeap| and |maxHeap| - |minHeap| <= 1
    if (maxHeap.size() < minHeap.size())
      maxHeap.push(minHeap.top()), minHeap.pop();
    else if (maxHeap.size() - minHeap.size() > 1)
      minHeap.push(maxHeap.top()), maxHeap.pop();
  }

  double findMedian() {
    if (maxHeap.size() == minHeap.size())
      return (maxHeap.top() + minHeap.top()) / 2.0;
    return maxHeap.top();
  }

 private:
  priority_queue<int> maxHeap;
  priority_queue<int, vector<int>, greater<>> minHeap;
};"
"class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        for i in range(2, len(nums)+1):
            for x in set(itertools.combinations(nums, i)):
                if all(a <= b for a, b in zip(x, x[1:])):
                    res.append(x)
        return res","class Solution {
 public:
  int minTotalDistance(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<int> I;  // I indices s.t. grid[i][j] == 1
    vector<int> J;  // J indices s.t. grid[i][j] == 1

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j])
          I.push_back(i);

    for (int j = 0; j < n; ++j)
      for (int i = 0; i < m; ++i)
        if (grid[i][j])
          J.push_back(j);

    // Sum(i - median(I)) + sum(j - median(J))
    return minTotalDistance(I) + minTotalDistance(J);
  }

 private:
  int minTotalDistance(const vector<int>& grid) {
    int sum = 0;
    int i = 0;
    int j = grid.size() - 1;

    while (i < j)
      sum += grid[j--] - grid[i++];

    return sum;
  }
};"
"class Solution:
    def constructRectangle(self, area: int) -> List[int]:
        sqrt_val = int(math.sqrt(area))
        l = w = sqrt_val
        while (l * w) != area and l > 0 and w > 0:
            l += 1
            w = area // l
            
        return [l, w] if w > 1 else (area, 1)","class Codec {
 public:
  // Encodes a tree to a single string.
  string serialize(TreeNode* root) {
    if (root == nullptr)
      return """";

    string s;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      TreeNode* node = q.front();
      q.pop();
      if (node != nullptr) {
        s += to_string(node->val) + "" "";
        q.push(node->left);
        q.push(node->right);
      } else {
        s += ""n "";
      }
    }

    return s;
  }

  // Decodes your encoded data to tree.
  TreeNode* deserialize(string data) {
    if (data.empty())
      return nullptr;

    istringstream iss(data);
    string word;
    iss >> word;
    TreeNode* root = new TreeNode(stoi(word));
    queue<TreeNode*> q{{root}};

    while (iss >> word) {
      TreeNode* node = q.front();
      q.pop();
      if (word != ""n"") {
        node->left = new TreeNode(stoi(word));
        q.push(node->left);
      }
      iss >> word;
      if (word != ""n"") {
        node->right = new TreeNode(stoi(word));
        q.push(node->right);
      }
    }

    return root;
  }
};"
"class Solution(object):
    def reversePairs(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        def merge(array,start,mid,end):
            leftArray=array[start:mid+1]
            rightArray=array[mid+1:end+1]
            i,j=0,0
            m,n=len(leftArray),len(rightArray)
            for k in range(start,end+1):
                if j>=n or (i<m and leftArray[i]<rightArray[j]):
                    array[k]=leftArray[i]
                    i+=1
                else:
                    array[k]=rightArray[j]
                    j+=1
        def merge_sort(array,start,end):
            pairs=0
            if start<end:
                mid=start+(end-start)//2
                pairs+=merge_sort(array,start,mid)
                pairs+=merge_sort(array,mid+1,end)
                j=mid+1
                for i in range(start,mid+1):
                    while j<=end and array[i]>array[j]*2:
                        j+=1
                    pairs+=j-mid-1
                merge(array,start,mid,end)
            return pairs
        pairs=merge_sort(nums,0,len(nums)-1)
        return pairs","class Solution {
 public:
  int longestConsecutive(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return dfs(root, root->val, 0, 0);
  }

 private:
  int dfs(TreeNode* root, int target, int length, int maxLength) {
    if (root == nullptr)
      return maxLength;
    if (root->val == target)
      maxLength = max(maxLength, ++length);
    else
      length = 1;
    return max(dfs(root->left, root->val + 1, length, maxLength),
               dfs(root->right, root->val + 1, length, maxLength));
  }
};"
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        def findtarget(nums,currsum, length,target,memo):
            if((length,currsum) in memo):
                return memo[(length,currsum)]
            if(length == len(nums)):
                if(currsum == target):
                    memo[(length,currsum)] = 1
                    return 1
                else:
                    memo[(length,currsum)] = 0
                    return 0
            memo[(length,currsum)] = findtarget(nums,currsum+nums[length],length+1,target,memo)+findtarget(nums,currsum-nums[length],length+1,target,memo)
            return memo[(length,currsum)]
        return findtarget(nums,0,0,target,{})","class Solution {
 public:
  string getHint(string secret, string guess) {
    int A = 0;
    int B = 0;
    vector<int> count1(10);
    vector<int> count2(10);

    for (int i = 0; i < secret.length(); ++i)
      if (secret[i] == guess[i])
        ++A;
      else {
        ++count1[secret[i] - '0'];
        ++count2[guess[i] - '0'];
      }

    for (int i = 0; i < 10; ++i)
      B += min(count1[i], count2[i]);

    return to_string(A) + ""A"" + to_string(B) + ""B"";
  }
};"
"class Solution:
    def findPoisonedDuration(self, t: List[int], duration: int) -> int:
        if not t:
            return 0
        n = len(t)
        return sum(min(t[t2] - t[t1], duration) for t1, t2 in zip(range(0, n - 1), range(1, n))) + duration","class Solution {
 public:
  int lengthOfLIS(vector<int>& nums) {
    if (nums.empty())
      return 0;

    // dp[i] := Length of LIS ending at nums[i]
    vector<int> dp(nums.size(), 1);

    for (int i = 1; i < nums.size(); ++i)
      for (int j = 0; j < i; ++j)
        if (nums[j] < nums[i])
          dp[i] = max(dp[i], dp[j] + 1);

    return *max_element(begin(dp), end(dp));
  }
};"
"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        dict_greater = {}

        stack = [nums2[0]]
        for num in nums2[1:]:

            if num < stack[-1]:
                stack.append(num)

            while len(stack) > 0 and num > stack[-1]:
                dict_greater[stack.pop()] = num
            stack.append(num)

        while len(stack) > 0:
            dict_greater[stack.pop()] = -1

        return [dict_greater[j] for j in nums1 if j in dict_greater]","class Solution {
 public:
  vector<string> removeInvalidParentheses(string s) {
    vector<string> ans;
    const auto [l, r] = getLeftAndRightCounts(s);
    dfs(s, 0, l, r, ans);
    return ans;
  }

 private:
  // Similar to 921. Minimum Add to Make Parentheses Valid
  // Returns how many '(' and ')' need to be deleted
  pair<int, int> getLeftAndRightCounts(const string& s) {
    int l = 0;
    int r = 0;

    for (const char c : s)
      if (c == '(')
        ++l;
      else if (c == ')') {
        if (l == 0)
          ++r;
        else
          --l;
      }

    return {l, r};
  }

  void dfs(const string& s, int start, int l, int r, vector<string>& ans) {
    if (l == 0 && r == 0 && isValid(s)) {
      ans.push_back(s);
      return;
    }

    for (int i = start; i < s.length(); ++i) {
      if (i > start && s[i] == s[i - 1])
        continue;
      if (l > 0 && s[i] == '(')  // Delete s[i]
        dfs(s.substr(0, i) + s.substr(i + 1), i, l - 1, r, ans);
      if (r > 0 && s[i] == ')')  // Delete s[i]
        dfs(s.substr(0, i) + s.substr(i + 1), i, l, r - 1, ans);
    }
  }

  bool isValid(const string& s) {
    int count = 0;  // # of '(' - # of ')'

    for (const char c : s) {
      if (c == '(')
        ++count;
      else if (c == ')')
        --count;
      if (count < 0)
        return false;
    }

    return true;  // Count == 0
  }
};"
"class Solution:

    def __init__(self, rects: List[List[int]]):
        self.rects = rects # store rectangles
        self.wt = [0] # weighted sampling 
        for x1, y1, x2, y2 in rects: 
            wt = (x2 - x1 + 1) * (y2 - y1 + 1) # wt ~ number of points 
            self.wt.append(self.wt[-1] + wt) 

    def pick(self) -> List[int]:
        n = randint(1, self.wt[-1]) # nth point
        k = bisect_left(self.wt, n)-1 # kth rectangle
        offset = n - self.wt[k] - 1 # offset from x1, y1
        x1, y1, x2, _ = self.rects[k]
        return [x1 + offset % (x2 - x1 + 1), y1 + offset // (x2 - x1 + 1)]","class Solution {
 public:
  int minArea(vector<vector<char>>& image, int x, int y) {
    const int m = image.size();
    const int n = image[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    vector<int> topLeft{x, y};
    vector<int> bottomRight{x, y};
    queue<pair<int, int>> q{{{x, y}}};
    image[x][y] = '2';  // Visited

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        const int r = i + dirs[k];
        const int c = j + dirs[k + 1];
        if (r < 0 || r == m || c < 0 || c == n)
          continue;
        if (image[r][c] != '1')
          continue;
        topLeft[0] = min(topLeft[0], r);
        topLeft[1] = min(topLeft[1], c);
        bottomRight[0] = max(bottomRight[0], r);
        bottomRight[1] = max(bottomRight[1], c);
        q.emplace(r, c);
        image[r][c] = '2';
      }
    }

    const int width = bottomRight[1] - topLeft[1] + 1;
    const int height = bottomRight[0] - topLeft[0] + 1;
    return width * height;
  }
};"
"class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix: return []
        temp = []
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if len(temp)-1<i+j: temp.append([matrix[i][j]])
                else: temp[i+j].append(matrix[i][j])
        res,i = [],0
        for item in temp:
            if i%2==0: res += item[::-1]
            else: res += item
            i += 1
        return res","class NumArray {
 public:
  NumArray(vector<int>& nums) : prefix(nums.size() + 1) {
    partial_sum(begin(nums), end(nums), begin(prefix) + 1);
  }

  int sumRange(int left, int right) {
    return prefix[right + 1] - prefix[left];
  }

 private:
  vector<int> prefix;
};"
"class Solution:
    def findWords(self, w: List[str]) -> List[str]:
    	L = [set('qwertyuiop'),set('asdfghjkl'),set('zxcvbnm')]
    	D, A = {j:i for i in range(3) for j in L[i]}, []
    	for i,j in enumerate([i.lower() for i in w]):
    		if set(j).issubset(L[D[j[0]]]): A.append(w[i])
    	return A
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class NumMatrix {
 public:
  NumMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty())
      return;

    const int m = matrix.size();
    const int n = matrix[0].size();
    // prefix[i][j] := sum of matrix[0..i)[0..j)
    prefix.resize(m + 1, vector<int>(n + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        prefix[i + 1][j + 1] =
            matrix[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];
  }

  int sumRegion(int row1, int col1, int row2, int col2) {
    return prefix[row2 + 1][col2 + 1] - prefix[row1][col2 + 1] -
           prefix[row2 + 1][col1] + prefix[row1][col1];
  }

 private:
  vector<vector<int>> prefix;
};"
"class Solution:
    def findMode(self, root: TreeNode) -> List[int]:
        dic = dict()
        if root is None:
            return []
        def inorder(root,dic):
            if root is None:
                return
            else:
                left = inorder(root.left,dic)
                if root.val in dic:
                    dic[root.val] += 1
                else:
                    dic[root.val] = 1
                
                right = inorder(root.right,dic)
                
            return dic
        dic = inorder(root,dic)
        max_val = float('-inf')
        val = 0
        lis = []
        for key,value in dic.items():
            if value == max_val:
                val = key
                lis.append(val)
            elif value > max_val:
                lis = []
                max_val = value
                val = key
                lis.append(val)
	```","class UnionFind {
 public:
  vector<int> id;

  UnionFind(int n) : id(n, -1), rank(n) {}

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> rank;
};

class Solution {
 public:
  vector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {
    const vector<int> dirs{0, 1, 0, -1, 0};
    vector<int> ans;
    vector<vector<bool>> seen(m, vector<bool>(n));
    UnionFind uf(m * n);
    int count = 0;

    for (const vector<int>& p : positions) {
      const int i = p[0];
      const int j = p[1];
      if (seen[i][j]) {
        ans.push_back(count);
        continue;
      }
      seen[i][j] = true;
      const int id = getId(i, j, n);
      uf.id[id] = id;
      ++count;
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        const int neighborId = getId(x, y, n);
        if (uf.id[neighborId] == -1)  // Water
          continue;
        const int currentRoot = uf.find(id);
        const int neighborRoot = uf.find(neighborId);
        if (currentRoot != neighborRoot) {
          uf.unionByRank(currentRoot, neighborRoot);
          --count;
        }
      }
      ans.push_back(count);
    }

    return ans;
  }

 private:
  int getId(int i, int j, int n) {
    return i * n + j;
  }
};"
"class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        projects = sorted([(c, p) for p, c in zip(profits, capital)])
        i, N = 0, len(projects)
        profits_maxheap = []
        cur_capital = w
        while k > 0:
            while i < N and cur_capital >= projects[i][0]:
                heapq.heappush(profits_maxheap, -projects[i][1])
                i += 1
            if not profits_maxheap:
                break
            cur_capital -= heapq.heappop(profits_maxheap)
            k -= 1
        return cur_capital","class Solution {
 public:
  bool isAdditiveNumber(string num) {
    const int n = num.length();

    // num[0..i] = firstNum
    for (int i = 0; i < n / 2; ++i) {
      if (i > 0 && num[0] == '0')
        return false;
      const long firstNum = stol(num.substr(0, i + 1));
      // num[i + 1..j] = secondNum
      // Len(thirdNum) >= max(len(firstNum), len(secondNum))
      for (int j = i + 1; max(i, j - i) < n - j; ++j) {
        if (j > i + 1 && num[i + 1] == '0')
          break;
        const long secondNum = stol(num.substr(i + 1, j - i));
        if (dfs(num, firstNum, secondNum, j + 1))
          return true;
      }
    }

    return false;
  }

 private:
  bool dfs(const string& num, long firstNum, long secondNum, long s) {
    if (s == num.length())
      return true;

    const long thirdNum = firstNum + secondNum;
    const string& thirdNumStr = to_string(thirdNum);
    return num.find(thirdNumStr, s) == s &&
           dfs(num, secondNum, thirdNum, s + thirdNumStr.length());
  }
};"
"class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        stack = []
        old_len = len(nums)
        
        nums += nums
        
        res = [-1] * len(nums)
        for idx in range(len(nums) -1, -1, -1):
            while stack and nums[idx] >= stack[-1]:
                stack.pop()
            
            if stack:
                res[idx] = stack[-1]
            
            stack.append(nums[idx])
        
        return res[:old_len]","class FenwickTree {
 public:
  FenwickTree(int m, int n) : sums(m + 1, vector<int>(n + 1)) {}

  void update(int row, int col, int delta) {
    for (int i = row; i < sums.size(); i += i & -i)
      for (int j = col; j < sums[0].size(); j += j & -j)
        sums[i][j] += delta;
  }

  int get(int row, int col) {
    int sum = 0;
    for (int i = row; i > 0; i -= i & -i)
      for (int j = col; j > 0; j -= j & -j)
        sum += sums[i][j];
    return sum;
  }

 private:
  vector<vector<int>> sums;
};

class NumMatrix {
 public:
  NumMatrix(vector<vector<int>>& matrix)
      : matrix(matrix), tree(matrix.size(), matrix[0].size()) {
    for (int i = 0; i < matrix.size(); ++i)
      for (int j = 0; j < matrix[0].size(); ++j)
        tree.update(i + 1, j + 1, matrix[i][j]);
  }

  void update(int row, int col, int val) {
    tree.update(row + 1, col + 1, val - matrix[row][col]);
    matrix[row][col] = val;
  }

  int sumRegion(int row1, int col1, int row2, int col2) {
    return tree.get(row2 + 1, col2 + 1) - tree.get(row1, col2 + 1) -
           tree.get(row2 + 1, col1) + tree.get(row1, col1);
  }

 private:
  vector<vector<int>> matrix;
  FenwickTree tree;
};"
"class Solution:
    def convertToBase7(self, num: int) -> str:
        if num == 0:
            return str(num)
        res = ''
        x = abs(num)
        while x > 0:
            res = str(x%7) + res
            x //= 7
        return '-' + res if num < 0 else res","class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    int sell = 0;
    int hold = INT_MIN;
    int prev = 0;

    for (const int price : prices) {
      const int cache = sell;
      sell = max(sell, hold + price);
      hold = max(hold, prev - price);
      prev = cache;
    }

    return sell;
  }
};"
"class Solution:
    def findRelativeRanks(self, nums: List[int]) -> List[str]:
        awarded_medals = [""Gold Medal"", ""Silver Medal"", ""Bronze Medal""]
        nums_with_indx = sorted([(i, s) for i, s in enumerate(nums)], key=lambda t: t[1], reverse=True)
        for rank, t in enumerate(nums_with_indx):
            pos, score = t
            nums[pos] = awarded_medals[rank] if rank < 3 else str(rank + 1)
        
        return nums","class Solution {
 public:
  vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
    if (n == 1 || edges.empty())
      return {0};

    vector<int> ans;
    unordered_map<int, unordered_set<int>> graph;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].insert(v);
      graph[v].insert(u);
    }

    for (const auto& [label, children] : graph)
      if (children.size() == 1)
        ans.push_back(label);

    while (n > 2) {
      n -= ans.size();
      vector<int> nextLeaves;
      for (const int leaf : ans) {
        const int u = *begin(graph[leaf]);
        graph[u].erase(leaf);
        if (graph[u].size() == 1)
          nextLeaves.push_back(u);
      }
      ans = nextLeaves;
    }

    return ans;
  }
};"
"class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
    	if num <= 1: return False
    	s, q = 0, num**.5
    	for i in range(2,1+int(q)):
    		if num%i == 0: s += i + num//i
    	if int(q) == q: s -= int(q)
    	return s == num - 1
		
		
- Python 3
- Junaid Mansuri","class Solution {
 public:
  vector<vector<int>> multiply(vector<vector<int>>& mat1,
                               vector<vector<int>>& mat2) {
    const int m = mat1.size();
    const int n = mat2.size();
    const int l = mat2[0].size();
    vector<vector<int>> ans(m, vector<int>(l));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < l; ++j)
        for (int k = 0; k < n; ++k)
          ans[i][j] += mat1[i][k] * mat2[k][j];

    return ans;
  }
};"
"class Solution:
    def traversal(self, node, d, max_freq):
        if node == None:
            return 0
        
        _sum = self.traversal(node.left, d, max_freq) + self.traversal(node.right, d, max_freq) + node.val

        d[_sum] = d.get(_sum, 0) + 1
        
        max_freq[0] = max(max_freq[0], d[_sum])
        
        return _sum
        
        
    def findFrequentTreeSum(self, root: Optional[TreeNode]) -> List[int]:
        d = {}
        max_freq = [0]
        
        self.traversal(root, d, max_freq)

        ans = []
        for key in d:
            if d[key] == max_freq[0]:
                ans.append(key)
        
        return ans","class Solution {
 public:
  int maxCoins(vector<int>& nums) {
    const int n = nums.size();

    nums.insert(begin(nums), 1);
    nums.insert(end(nums), 1);

    // dp[i][j] := maxCoins(nums[i..j])
    dp.resize(n + 2, vector<int>(n + 2));
    return maxCoins(nums, 1, n);
  }

 private:
  vector<vector<int>> dp;

  int maxCoins(vector<int>& nums, int i, int j) {
    if (i > j)
      return 0;
    if (dp[i][j] > 0)
      return dp[i][j];

    for (int k = i; k <= j; ++k)
      dp[i][j] = max(dp[i][j],                                              //
                     maxCoins(nums, i, k - 1) + maxCoins(nums, k + 1, j) +  //
                         nums[i - 1] * nums[k] * nums[j + 1]);

    return dp[i][j];
  }
};"
"class Solution:
    def fib(self, n: int) -> int:
        if n == 0:
            return 0
        fibs = [0,1]
        for i in range(2, n+1):
            fibs.append(fibs[-1] + fibs[-2])


        return fibs[-1]","class Solution {
 public:
  int nthSuperUglyNumber(int n, vector<int>& primes) {
    const int k = primes.size();
    vector<int> indices(k);
    vector<int> uglyNums{1};

    while (uglyNums.size() < n) {
      vector<int> nexts(k);
      for (int i = 0; i < k; ++i)
        nexts[i] = uglyNums[indices[i]] * primes[i];
      const int next = *min_element(begin(nexts), end(nexts));
      for (int i = 0; i < k; ++i)
        if (next == nexts[i])
          ++indices[i];
      uglyNums.push_back(next);
    }

    return uglyNums.back();
  }
};"
"class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        char_pos = defaultdict(set)
        for i, c in enumerate(ring):
            char_pos[c].add(i)
        
        def minStep(fromm, to):
            if fromm == to:
                return 0
            minSteps = abs(fromm - to)
            minSteps = min(minSteps, abs(len(ring) - minSteps))
            return minSteps
        
        n = len(key)
        dp = [0] * len(ring)
        for p in char_pos[key[0]]:
            dp[p] = minStep(0, p)
        prev_char = key[0]
        for c in key[1:]:
            if prev_char == c:
                continue
            for next_pos in char_pos[c]:
                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])
            prev_char = c
        return min(dp[p] for p in char_pos[prev_char]) + len(key)","class Solution {
 public:
  vector<vector<int>> verticalOrder(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<int> range(2);
    getRange(root, range, 0);  // Get the leftmost and rightmost x index

    vector<vector<int>> ans(range[1] - range[0] + 1);
    queue<pair<TreeNode*, int>> q{{{root, -range[0]}}};  // (TreeNode, x)

    while (!q.empty()) {
      const auto [node, x] = q.front();
      q.pop();
      ans[x].push_back(node->val);
      if (node->left)
        q.emplace(node->left, x - 1);
      if (node->right)
        q.emplace(node->right, x + 1);
    }

    return ans;
  }

 private:
  void getRange(TreeNode* root, vector<int>& range, int x) {
    if (root == nullptr)
      return;

    range[0] = min(range[0], x);
    range[1] = max(range[1], x);

    getRange(root->left, range, x - 1);
    getRange(root->right, range, x + 1);
  }
};"
"class Solution:
    def largestValues(self, root: TreeNode) -> List[int]:
        levels = {}
        def dfs(node, level):
            if not node:return
            if level not in levels.keys():levels[level] = [node.val]
            else:levels[level].append(node.val)
            if node.right:dfs(node.right, level+1)
            if node.left:dfs(node.left, level+1)
        dfs(root, 1)
        return ([max(value) for value in levels.values()])","class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  vector<int> countSmaller(vector<int>& nums) {
    vector<int> ans(nums.size());
    unordered_map<int, int> ranks;
    getRanks(nums, ranks);
    FenwickTree tree(ranks.size());

    for (int i = nums.size() - 1; i >= 0; --i) {
      const int num = nums[i];
      ans[i] = tree.get(ranks[num] - 1);
      tree.update(ranks[num], 1);
    }

    return ans;
  }

 private:
  void getRanks(const vector<int>& nums, unordered_map<int, int>& ranks) {
    set<int> sorted(begin(nums), end(nums));
    int rank = 0;
    for (const int num : sorted)
      ranks[num] = ++rank;
  }
};"
"class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        memo = {}
        
        def helper(s: str, i: int, j:int, memo: dict):
            if (i,j) in memo:
                return memo[(i,j)]
            
            if i==j:
                memo[(i,j)] = 1
                return 1
            
            if i>j:
                memo[(i,j)] = 0
                return 0
            
            if s[i] == s[j]:
                sub = helper(s, i+1, j-1, memo)
                memo[(i+1,j-1)] = sub
                return sub + 2
            
            left = helper(s, i, j-1, memo)
            memo[(i,j-1)] = left
            right = helper(s, i+1, j, memo)
            memo[(i+1,j)] = right
            return max(left, right)
        
        return helper(s, 0, len(s)-1, memo)","class Solution {
 public:
  string removeDuplicateLetters(string s) {
    string ans;
    vector<int> count(128);
    vector<bool> used(128);

    for (const char c : s)
      ++count[c];

    for (const char c : s) {
      --count[c];
      if (used[c])
        continue;
      while (!ans.empty() && ans.back() > c && count[ans.back()] > 0) {
        used[ans.back()] = false;
        ans.pop_back();
      }
      used[c] = true;
      ans.push_back(c);
    }

    return ans;
  }
};"
"class Solution:
    def findMinMoves(self, machines: List[int]) -> int:
        total = sum(machines)
        if total % len(machines): return -1 # impossible 
        avg = total // len(machines)
        
        ans = prefix = 0
        for i, x in enumerate(machines): 
            ans = max(ans, abs(prefix), x - avg)
            prefix += x - avg
        return ans","class Solution {
 public:
  int shortestDistance(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    const int nBuildings = getBuildingCount(grid);
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = INT_MAX;
    // dist[i][j] := total distance of grid[i][j] (0) to reach all buildings (1)
    vector<vector<int>> dist(m, vector<int>(n));
    // reachCount[i][j] := # of buildings (1) grid[i][j] (0) can reach
    vector<vector<int>> reachCount(m, vector<int>(n));

    auto bfs = [&](int row, int col) -> bool {
      queue<pair<int, int>> q{{{row, col}}};
      vector<vector<bool>> seen(m, vector<bool>(n));
      seen[row][col] = true;
      int depth = 0;
      int seenBuildings = 1;

      while (!q.empty()) {
        ++depth;
        for (int sz = q.size(); sz > 0; --sz) {
          const auto [i, j] = q.front();
          q.pop();
          for (int k = 0; k < 4; ++k) {
            const int x = i + dirs[k];
            const int y = j + dirs[k + 1];
            if (x < 0 || x == m || y < 0 || y == n)
              continue;
            if (seen[x][y])
              continue;
            seen[x][y] = true;
            if (!grid[x][y]) {
              dist[x][y] += depth;
              ++reachCount[x][y];
              q.emplace(x, y);
            } else if (grid[x][y] == 1) {
              ++seenBuildings;
            }
          }
        }
      }

      return seenBuildings == nBuildings;
    };

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1)  // Bfs from this building
          if (!bfs(i, j))
            return -1;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (reachCount[i][j] == nBuildings)
          ans = min(ans, dist[i][j]);

    return ans == INT_MAX ? -1 : ans;
  }

 private:
  int getBuildingCount(vector<vector<int>>& grid) {
    return accumulate(begin(grid), end(grid), 0, [](int s, vector<int>& row) {
      return s + count(begin(row), end(row), 1);
    });
  }
};"
"class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [[0] * (amount + 1) for i in range(len(coins) + 1)]
        for i in range(len(coins) + 1):
            for j in range(amount + 1):
                if j == 0:
                    dp[i][j] = 1
                elif i == 0:
                    dp[i][j] = 0
        for i in range(1 , len(coins) + 1):
            for j in range(1 , amount + 1):
                if coins[i - 1] <= j:
                    dp[i][j] = dp[i - 1][j] + dp[i][j-coins[i - 1]]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[-1][-1]","class Solution {
 public:
  int maxProduct(vector<string>& words) {
    size_t ans = 0;
    vector<int> masks;

    for (const string& word : words)
      masks.push_back(getMask(word));

    for (int i = 0; i < words.size(); ++i)
      for (int j = 0; j < i; ++j)
        if ((masks[i] & masks[j]) == 0)
          ans = max(ans, words[i].length() * words[j].length());

    return ans;
  }

 private:
  int getMask(const string& word) {
    int mask = 0;
    for (const char c : word)
      mask |= 1 << c - 'a';
    return mask;
  }
};"
"class Solution:

    def __init__(self, m: int, n: int):
        self.cols = n
        self.nums = m * n
        
        self.tail = self.nums - 1
        self.indexes = {}
        

    def flip(self) -> List[int]:
        ind = random.randint(0, self.tail)
        rc = self.indexes.get(ind, ind)
        self.indexes[ind] = self.indexes.get(self.tail, self.tail)
        self.tail -= 1
        
        return [rc // self.cols, rc % self.cols]
        

    def reset(self) -> None:
        self.tail = self.nums - 1
        self.indexes = {}","class Solution {
 public:
  int bulbSwitch(int n) {
    // K-th bulb only be switched when k % i == 0.
    // So we can reiterate the problem:
    // To find # of number <= n that have odd factors.
    // Obviously, only square numbers have odd factor(s).
    // E.g. n = 10, only 1, 4, and 9 are square numbers that <= 10
    return sqrt(n);
  }
};"
"class Solution:
    def findLUSlength(self, a: str, b: str) -> int:
        if len(a) != len(b):
            return max(len(a), len(b))
        return -1 if a == b else len(a)","class Solution {
 public:
  vector<string> generateAbbreviations(string word) {
    vector<string> ans;
    dfs(word, 0, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& word, int i, int count, vector<string>&& path,
           vector<string>& ans) {
    if (i == word.length()) {
      ans.push_back(join(path) + getCountString(count));
      return;
    }

    // Abbreviate word[i]
    dfs(word, i + 1, count + 1, move(path), ans);
    // Keep word[i], so consume the count as a string
    path.push_back(getCountString(count) + word[i]);
    dfs(word, i + 1, 0, move(path), ans);  // Reset count to 0
    path.pop_back();
  }

  string getCountString(int count) {
    return count > 0 ? to_string(count) : """";
  }

  string join(const vector<string>& path) {
    string joined;
    for (const string& s : path)
      joined += s;
    return joined;
  };
};"
"class Solution:
    def findLUSlength(self, strs: List[str]) -> int:
        
        def fn(p, s):
            """"""Return True if p is a subsequence of s.""""""
            ss = iter(s)
            return all(ch in ss for ch in p)
        
        ans = -1 
        for i, s in enumerate(strs): 
            for ii in range(len(strs)): 
                if i != ii and len(s) <= len(strs[ii]) and fn(s, strs[ii]): break 
            else: ans = max(ans, len(s))
        return ans","class Solution {
 public:
  vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
    vector<int> ans;

    for (int k1 = 0; k1 <= k; ++k1) {
      const int k2 = k - k1;
      if (k1 > nums1.size() || k2 > nums2.size())
        continue;
      ans = max(ans, maxNumber(maxNumber(nums1, k1), maxNumber(nums2, k2)));
    }

    return ans;
  }

 private:
  vector<int> maxNumber(const vector<int>& nums, int k) {
    if (k == 0)
      return {};

    vector<int> ans;
    int toPop = nums.size() - k;

    for (const int num : nums) {
      while (!ans.empty() && ans.back() < num && toPop-- > 0)
        ans.pop_back();
      ans.push_back(num);
    }

    return {begin(ans), begin(ans) + k};
  }

 private:
  vector<int> maxNumber(const vector<int>& nums1, const vector<int>& nums2) {
    vector<int> ans;

    auto s1 = cbegin(nums1);
    auto s2 = cbegin(nums2);

    while (s1 != cend(nums1) || s2 != cend(nums2))
      if (lexicographical_compare(s1, cend(nums1), s2, cend(nums2)))
        ans.push_back(*s2++);
      else
        ans.push_back(*s1++);

    return ans;
  }
};"
"class Solution:
    def checkSubarraySum(self, N: List[int], K: int) -> bool:
    	L, S, s = len(N), set([0]), 0
    	for i in range(L-1):
    		if (N[i]+N[i+1]) == 0 or (K and not (N[i]+N[i+1]) % K): return True
    	if K == 0: return False
    	for n in N:
    		a, s = s, (s + n) % K
    		if s in S and a != s: return True
    		else: S.add(s)
    	return False
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int coinChange(vector<int>& coins, int amount) {
    // dp[i] := fewest # of coins to make up i
    vector<int> dp(amount + 1, amount + 1);
    dp[0] = 0;

    for (const int coin : coins)
      for (int i = coin; i <= amount; ++i)
        dp[i] = min(dp[i], dp[i - coin] + 1);

    return dp[amount] == amount + 1 ? -1 : dp[amount];
  }
};"
"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        def isSubsequence(a: str, b: str) -> bool:
            i = 0
            for c in a:
                if (i := b.find(c, i)) == -1:
                    return False
                i += 1
            return True
        
        heap = [(-len(word), word) for word in d]
        heapq.heapify(heap)
        while heap:
            word = heapq.heappop(heap)[1]
            if isSubsequence(word, s):
                return word
        return ''","class Solution {
 public:
  int countComponents(int n, vector<vector<int>>& edges) {
    int ans = 0;
    vector<vector<int>> graph(n);
    unordered_set<int> seen;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    for (int i = 0; i < n; ++i)
      if (!seen.count(i)) {
        bfs(graph, i, seen);
        ++ans;
      }

    return ans;
  }

 private:
  void bfs(const vector<vector<int>>& graph, int node,
           unordered_set<int>& seen) {
    queue<int> q{{node}};
    seen.insert(node);

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      for (const int v : graph[u])
        if (!seen.count(v)) {
          q.push(v);
          seen.insert(v);
        }
    }
  }
};"
"class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        acc = 0  # Stores the value for the current position in the nums

        # Why we have diff_dict?
        # we need to know how many elements before we had the difference value matching the current value at question

        # Example:
        # If at any point we have {0: 15, -1: 14, -2: 13}
        # and we have the acc as -1 on the 16th index, then the sequence must have been
        # 13 14 15 16
        # 1  1  1  0
        # Thus there is a combination that is valid between indexes 15-16
        # Next, if the acc is -2 on 16th index, then the sequence must have been
        # 13 14 15 16 17
        # 1  1  1  0  0
        # Thus there is a larger combination between indexes 14-17
        diff_dict = {0: -1}  # we have -1 here to make start index count
        # if we wouldn't the first starting value wouldn't be included in the calculation

        max_length = 0  # This stores the maximum value result
        for index, num in enumerate(nums):

            # FYI: To make negation of summation work we are saying that 0 is actually -1
            # (we could have easily said 1 is 2 and 0 is -2)
            # The important thing here is that we have something that we can use to count the discrepency.
            if num == 1:
                acc += 1
            else:
                acc -= 1

            if acc in diff_dict:  # There is a specific index that provides the longest subarray with the current acc
                length = index - diff_dict[acc]
                # Thus current index - first index to provide the same difference
                # is the maximum length for an array including the current index
                max_length = max(max_length, length)
            else:
                # We have never encountered an index with such a difference between values,
                # let's just store it for now.
                # If in the future we encounter another one, we will use this as the first one and calculate maximum
                # If the question were to ask for the minimum,
                # then we would update the dict with the newest index independent of whether it exists or not
                diff_dict[acc] = index
        return max_length","class Solution {
 public:
  void wiggleSort(vector<int>& nums) {
    const int n = nums.size();
    const auto it = begin(nums) + n / 2;
    nth_element(begin(nums), it, end(nums));
    const int median = *it;

// Index-rewiring
#define A(i) nums[(1 + 2 * i) % (n | 1)]

    for (int i = 0, j = 0, k = n - 1; i <= k;)
      if (A(i) > median)
        swap(A(i++), A(j++));
      else if (A(i) < median)
        swap(A(i), A(k--));
      else
        ++i;
  }
};"
"class Solution:
    def countArrangement(self, N: int) -> int:        
        n_list = [i+1 for i in range(N)]

        a = 0
        def search_ba(rest_ns, curr_ns):
            if not rest_ns:
                # Found beautiful arrangement
                nonlocal a
                a +=1
                return

            i = len(curr_ns) + 1
            for j in range(len(rest_ns)):
                n = rest_ns[j]
                if (n % i)==0 or (i % n)==0:
                    # Found number from `rest_ns` fit for next position of `curr_ns`
                    search_ba(rest_ns[:j]+rest_ns[j+1:], curr_ns + [n])


        search_ba(n_list, [])
        return a","class Solution {
 public:
  int maxSubArrayLen(vector<int>& nums, int k) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i];
      const int target = prefix - k;
      if (const auto it = prefixToIndex.find(target); it != cend(prefixToIndex))
        ans = max(ans, i - it->second);
      if (!prefixToIndex.count(prefix))
        prefixToIndex[prefix] = i;
    }

    return ans;
  }
};"
"class Solution:

    def __init__(self, w: List[int]):
        self.prefix = [0]
        for x in w: self.prefix.append(self.prefix[-1] + x)

    def pickIndex(self) -> int:
        r = randint(1, self.prefix[-1])
        return bisect_left(self.prefix, r)-1","class Solution {
 public:
  bool isPowerOfThree(int n) {
    return n > 0 && static_cast<int>(pow(3, 19)) % n == 0;
  }
};"
"class Solution:
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        i, j = click[0], click[1]
        
        # If a mine ('M') is revealed, then the game is over - change it to 'X'.
        if board[i][j] == ""M"":
            board[i][j] = ""X""
        # Else, proceed to *reveal* it.
        else:
            self.reveal(board, i, j)
        
        # Return the updated board.
        return board
    # End of updateBoard(...)
        
        
    def reveal(self, board, i, j):
        
        # We only need to check if the point on the board is an ""E'""
        if board[i][j] == ""E"":
            
            # Count number of adjacent mines
            n_adj_mines = self.countAdjMine(board, i, j)
            
            # If an empty square ('E') *with no adjacent mines is revealed*...
            if n_adj_mines == 0:
                
                # Then change it to revealed blank ('B')...
                board[i][j] = ""B""
                
                # ... and all of its adjacent unrevealed squares should be revealed recursively.
                for di, dj in [(1,0), (1,1), (0,1), (-1,1), (-1,0), (-1,-1), (0,-1), (1,-1)]:
                    newi, newj = i+di, j+dj
                    if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                        self.reveal(board, newi, newj)
            
            # Else, if an empty square ('E') with at least one adjacent mine is revealed...
            else:
                # If the point contains a digit, we update the digit.
                if board[i][j].isdigit():
                     board[i][j] = str(int(board[i][j]) + n_adj_mines)
                
                # Else if the point is not a digit, we fill it with the digit that
                # represents the number of adjacent mines
                else:
                    board[i][j] = str(n_adj_mines)
    # End of reveal(...)
    
            
    # Helper function to count adjacent mines
    def countAdjMine(self, board, i, j):
        count = 0
        for di, dj in [(1,0), (1,1), (0,1), (-1,1), (-1,0), (-1,-1), (0,-1), (1,-1)]:
            newi, newj = i+di, j+dj
            if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                if board[newi][newj] == ""M"":
                    count += 1
        return count
    # End of helpr function to count adj mines.","class Solution {
 public:
  int countRangeSum(vector<int>& nums, int lower, int upper) {
    const int n = nums.size();
    int ans = 0;
    vector<long> prefix{0};

    for (int i = 0; i < n; ++i)
      prefix.push_back(prefix.back() + nums[i]);

    mergeSort(prefix, 0, n, lower, upper, ans);
    return ans;
  }

 private:
  void mergeSort(vector<long>& prefix, int l, int r, int lower, int upper,
                 int& ans) {
    if (l >= r)
      return;

    const int m = (l + r) / 2;
    mergeSort(prefix, l, m, lower, upper, ans);
    mergeSort(prefix, m + 1, r, lower, upper, ans);
    merge(prefix, l, m, r, lower, upper, ans);
  }

  void merge(vector<long>& prefix, int l, int m, int r, int lower, int upper,
             int& ans) {
    int lo = m + 1;  // 1st index s.t. prefix[lo] - prefix[i] >= lower
    int hi = m + 1;  // 1st index s.t. prefix[hi] - prefix[i] > upper

    // For each index i in range [l, m], add hi - lo to ans
    for (int i = l; i <= m; ++i) {
      while (lo <= r && prefix[lo] - prefix[i] < lower)
        ++lo;
      while (hi <= r && prefix[hi] - prefix[i] <= upper)
        ++hi;
      ans += hi - lo;
    }

    vector<long> sorted(r - l + 1);
    int k = 0;      // sorted's index
    int i = l;      // left's index
    int j = m + 1;  // right's index

    while (i <= m && j <= r)
      if (prefix[i] < prefix[j])
        sorted[k++] = prefix[i++];
      else
        sorted[k++] = prefix[j++];

    // Put possible remaining left part to the sorted array
    while (i <= m)
      sorted[k++] = prefix[i++];

    // Put possible remaining right part to the sorted array
    while (j <= r)
      sorted[k++] = prefix[j++];

    copy(begin(sorted), end(sorted), begin(prefix) + l);
  }
};"
"class Solution(object):
    def getMinimumDifference(self, root):
        """"""
        :type root: TreeNode
        :rtype: int
        """"""

        def get_values(values, root):
            if root is not None:
                values.append(root.val)
                values = get_values(values, root.left)
                values = get_values(values, root.right)
            return values

        values_list = get_values([], root)

        if len(values_list) != len(set(values_list)):
            return 0

        values_list.sort()
        minimum_diff = values_list[1] - values_list[0]

        for i in range(1, len(values_list)):
            diff = values_list[i] - values_list[i - 1]
            if diff < minimum_diff:
                minimum_diff = diff

        return minimum_diff","class Solution {
 public:
  ListNode* oddEvenList(ListNode* head) {
    ListNode oddHead(0);
    ListNode evenHead(0);
    ListNode* odd = &oddHead;
    ListNode* even = &evenHead;

    for (int isOdd = 0; head; head = head->next)
      if (isOdd ^= 1) {
        odd->next = head;
        odd = odd->next;
      } else {
        even->next = head;
        even = even->next;
      }

    odd->next = evenHead.next;
    even->next = nullptr;
    return oddHead.next;
  }
};"
"class Solution:
    def findPairs(self, nums: List[int], k: int) -> int:
        ans, seen = set(), set()
        for x in nums: 
            if x - k in seen: ans.add(x)
            if x + k in seen: ans.add(x+k)
            seen.add(x)
        return len(ans)","class Solution {
 public:
  int longestIncreasingPath(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    int ans = 0;
    vector<vector<int>> memo(m, vector<int>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        ans = max(ans, dfs(matrix, i, j, INT_MIN, memo));

    return ans;
  }

 private:
  // memo[i][j] := the LIP starting from matrix[i][j]
  int dfs(const vector<vector<int>>& matrix, int i, int j, int prev,
          vector<vector<int>>& memo) {
    if (i < 0 || i == matrix.size() || j < 0 || j == matrix[0].size())
      return 0;
    if (matrix[i][j] <= prev)
      return 0;
    int& ans = memo[i][j];
    if (ans > 0)
      return ans;

    const int curr = matrix[i][j];
    return ans = 1 + max({dfs(matrix, i + 1, j, curr, memo),
                          dfs(matrix, i - 1, j, curr, memo),
                          dfs(matrix, i, j + 1, curr, memo),
                          dfs(matrix, i, j - 1, curr, memo)});
  }
};"
"class Solution:
    def complexNumberMultiply(self, a: str, b: str) -> str:
        k1=a.split('+')
        k2=b.split('+')
        (xa,ya)=(k1[0],k1[1][:-1])
        (xb,yb)=(k2[0],k2[1][:-1])
        return(str(int(xa)*int(xb)+int(ya)*int(yb)*-1)+'+'+str(int(xa)*int(yb)+int(ya)*int(xb))+'i')","class Solution {
 public:
  int minPatches(vector<int>& nums, int n) {
    int ans = 0;
    int i = 0;      // Point to nums
    long miss = 1;  // Min sum in [1, n] we might miss

    while (miss <= n)
      if (i < nums.size() && nums[i] <= miss) {
        miss += nums[i++];
      } else {
        // Greedily add miss itself to increase the range
        // From [1, miss) to [1, 2 * miss)
        miss += miss;
        ++ans;
      }

    return ans;
  }
};"
"class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        val = 0
        node, stack = root, []
        while stack or node: 
            if node: 
                stack.append(node)
                node = node.right
            else: 
                node = stack.pop()
                node.val = val = node.val + val 
                node = node.left 
        return root","class Solution {
 public:
  bool isValidSerialization(string preorder) {
    int degree = 1;  // OutDegree (children) - inDegree (parent)
    istringstream iss(preorder);

    for (string node; getline(iss, node, ',');) {
      if (--degree < 0)
        return false;
      if (node != ""#"")
        degree += 2;
    }

    return degree == 0;
  }
};"
"class Solution:
    def time2min(self, t):
        return int(t[:2]) * 60 + int(t[3:])
    
    def findMinDifference(self, timePoints: List[str]) -> int:
        
        new = [self.time2min(t) for t in timePoints]
        new.sort()
        offset = 60*24
        new.extend([n+offset for n in new])
        
        diff = []
        for i in range(len(new)-1):
            diff.append(new[i+1] - new[i])
        
        return min(diff)","class Solution {
 public:
  vector<string> findItinerary(vector<vector<string>>& tickets) {
    vector<string> ans;
    unordered_map<string, multiset<string>> graph;

    for (const vector<string>& ticket : tickets)
      graph[ticket[0]].insert(ticket[1]);

    dfs(graph, ""JFK"", ans);
    reverse(begin(ans), end(ans));
    return ans;
  }

 private:
  void dfs(unordered_map<string, multiset<string>>& graph, const string& u,
           vector<string>& ans) {
    while (graph.count(u) && !graph[u].empty()) {
      const string v = *begin(graph[u]);
      graph[u].erase(begin(graph[u]));
      dfs(graph, v, ans);
    }
    ans.push_back(u);
  }
};"
"class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        return self.helper(nums)
    
    def helper(self, nums):
        if len(nums)==1:
            return nums[0]
        mid = len(nums)//2
        if nums[mid]!=nums[mid-1] and nums[mid]!=nums[mid+1]:
            return nums[mid]
        else:
            if mid%2==0:
                if nums[mid]==nums[mid-1]:
                    return self.helper(nums[:mid-1])
                else:
                    return self.helper(nums[mid:])
            else:
                if nums[mid]==nums[mid-1]:
                    return self.helper(nums[mid+1:])
                else:
                    return self.helper(nums[:mid])","struct T {
  int min;   // Min value in the subtree
  int max;   // Max value in the subtree
  int size;  // Total size of the subtree
};

class Solution {
 public:
  int largestBSTSubtree(TreeNode* root) {
    return dfs(root).size;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {INT_MAX, INT_MIN, 0};

    T l = dfs(root->left);
    T r = dfs(root->right);

    if (l.max < root->val && root->val < r.min)
      return {min(l.min, root->val), max(r.max, root->val),
              1 + l.size + r.size};

    // Mark as invalid one, but still record the size of children
    // Returns (-INF, INF) because any node won't > INT and < -INF
    return {INT_MIN, INT_MAX, max(l.size, r.size)};
  }
};"
"class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        res = ''
        for i in range(len(s)//(2*k)):
            res += s[2*k*i:2*k*i+k][::-1] + s[2*k*i+k:2*k*(i+1)]
        
        remainder = len(s) % (2*k)
        
        if remainder <= k and remainder > 0:
            res += s[-remainder:][::-1]
        elif remainder > k:
            res += s[-remainder:-remainder+k][::-1] + s[-remainder+k:]
        
        return res","class Solution {
 public:
  bool increasingTriplet(vector<int>& nums) {
    int first = INT_MAX;
    int second = INT_MAX;

    for (const int num : nums)
      if (num <= first)
        first = num;
      else if (num <= second)  // First < num <= second
        second = num;
      else
        return true;  // First < second < num (third)

    return false;
  }
};"
"class Solution:
    def updateMatrix(self, A: List[List[int]]) -> List[List[int]]:
    	M, N, Q = len(A), len(A[0]), []
    	B = [[0]*N for _ in range(M)]
    	for i,j in itertools.product(range(M),range(N)):
    		if not A[i][j]: continue
    		b = 1
    		for k,l in [[i-1,j],[i,j+1],[i+1,j],[i,j-1]]:
    			if not (k in [-1,M] or l in [-1,N] or A[k][l]): B[i][j], b = 1, 0
    		if b: Q.append((i,j))
    	for a in range(2):
	    	for i,j in Q:
	    		m = math.inf
	    		for k,l in [[i-1,j],[i,j+1],[i+1,j],[i,j-1]]:
	    			if not (k in [-1,M] or l in [-1,N]) and B[k][l] > 0: m = min(m,B[k][l])
	    		if m != math.inf: B[i][j] = m + 1
    		if a == 1: return B
    		Q.reverse()
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  bool isSelfCrossing(vector<int>& x) {
    if (x.size() <= 3)
      return false;

    for (int i = 3; i < x.size(); ++i) {
      if (x[i - 2] <= x[i] && x[i - 1] <= x[i - 3])
        return true;
      if (i >= 4 && x[i - 1] == x[i - 3] && x[i - 2] <= x[i] + x[i - 4])
        return true;
      if (i >= 5 && x[i - 4] <= x[i - 2] && x[i - 2] <= x[i] + x[i - 4] &&
          x[i - 1] <= x[i - 3] && x[i - 3] <= x[i - 1] + x[i - 5])
        return true;
    }

    return false;
  }
};"
"class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        if not root:
            return 0
        return self.dfs(root)[1]
    
    def dfs(self, root):
        if not root:
            return 0, -sys.maxsize
        l_depth, l_diameter = self.dfs(root.left)
        r_depth, r_diameter = self.dfs(root.right)
        
        return max(l_depth, r_depth) + 1, max(l_diameter, r_diameter, l_depth + r_depth)","class Solution {
 public:
  vector<vector<int>> palindromePairs(vector<string>& words) {
    vector<vector<int>> ans;
    unordered_map<string, int> map;  // {reversed word: its index}

    for (int i = 0; i < words.size(); ++i) {
      string word = words[i];
      reverse(begin(word), end(word));
      map[word] = i;
    }

    for (int i = 0; i < words.size(); ++i) {
      const string& word = words[i];
      // Special case to prevent duplicate calculation
      if (const auto it = map.find("""");
          it != cend(map) && it->second != i && isPalindrome(word))
        ans.push_back({i, it->second});
      for (int j = 1; j <= word.length(); ++j) {
        const string& l = word.substr(0, j);
        const string& r = word.substr(j);
        if (const auto it = map.find(l);
            it != cend(map) && it->second != i && isPalindrome(r))
          ans.push_back({i, it->second});
        if (const auto it = map.find(r);
            it != cend(map) && it->second != i && isPalindrome(l))
          ans.push_back({it->second, i});
      }
    }

    return ans;
  }

 private:
  bool isPalindrome(const string& word) {
    int l = 0;
    int r = word.length() - 1;
    while (l < r)
      if (word[l++] != word[r--])
        return false;
    return true;
  }
};"
"class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:

        @cache
        def dp(l, r, count = 0):
            if l > r: return 0
            // Initial count for the letter at boxes[l]
            count += 1
            ptr = l + 1
            while ptr <= r and boxes[l] == boxes[ptr]:
                ptr += 1
                count += 1
            points = (count ** 2) + dp(ptr, r)
            for i in range(ptr + 1, r + 1):
                if boxes[l] == boxes[i]:
                    points = max(points, dp(i, r, count) + dp(ptr, i - 1))
            return points

        return dp(0, len(boxes) - 1)","struct T {
  int robRoot;
  int notRobRoot;
};

class Solution {
 public:
  int rob(TreeNode* root) {
    const auto& [robRoot, notRobRoot] = robOrNotRob(root);
    return max(robRoot, notRobRoot);
  }

 private:
  T robOrNotRob(TreeNode* root) {
    if (root == nullptr)
      return {0, 0};
    const T l = robOrNotRob(root->left);
    const T r = robOrNotRob(root->right);
    return {root->val + l.notRobRoot + r.notRobRoot,
            max(l.robRoot, l.notRobRoot) + max(r.robRoot, r.notRobRoot)};
  }
};"
"class Solution:
    
    def find(self, x: int) -> int:
        """"""
        C = cities
        
        Time: O(1) amortized time
        """"""
        if self.parents[x] != x:
            self.parents[x] = self.find(self.parents[x])
        return self.parents[x]

    def union(self, x: int, y: int) -> bool:
        """"""
        C = cities
        
        Time: O(1) amortized time
        """"""
        x_rep = self.find(x)
        y_rep = self.find(y)
        
        if x_rep == y_rep:
            return False
        
        if self.ranks[x_rep] > self.ranks[y_rep]:
            self.parents[y_rep] = x_rep
        elif self.ranks[x_rep] < self.ranks[y_rep]:
            self.parents[x_rep] = y_rep
        else:
            self.parents[y_rep] = x_rep
            self.ranks[x_rep] += 1
            
        return True
        
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        """"""
        C = number of cities
        
        Time: O(C^2)
        - We go over each C^2 pair. The union for each operation is O(1) amortized.
        
        Space: O(2C + logC) = O(C)
        - We keep track of C parents and ranks
        - The find operation will take at most logC recursion space.
        """"""
        total_cities = len(isConnected)
        total_provinces = total_cities

        self.parents = list(range(total_cities))
        self.ranks = [0] * total_cities

        for i in range(total_cities):
            for j in range(total_cities):
                if isConnected[i][j] == 1 and self.union(i, j):
                    total_provinces -= 1

        return total_provinces","class Solution {
 public:
  vector<int> countBits(int n) {
    // Let f(i) := i's # of 1's in bitmask
    // f(i) = f(i / 2) + i % 2
    vector<int> ans(n + 1);

    for (int i = 1; i <= n; ++i)
      ans[i] = ans[i / 2] + (i & 1);

    return ans;
  }
};"
"class Solution:
    def checkRecord(self, s: str) -> bool:
        a, l = 0, 0
        for i in range(len(s)):
            if s[i] == 'A':
                a += 1
                if l < 3:
                    l = 0
            elif s[i] == 'L':
                if l == 0:
                    l += 1
                elif l > 0 and s[i-1] == 'L':
                    l += 1
                else:
                    l = 0
            else:
                if l < 3:
                    l = 0
            if (a > 1 or l > 2):
                return False
            else:
                pass
        return True","class Solution {
 public:
  int depthSum(vector<NestedInteger>& nestedList) {
    int ans = 0;
    int depth = 0;
    queue<NestedInteger> q;

    addIntegers(q, nestedList);

    while (!q.empty()) {
      ++depth;
      for (int sz = q.size(); sz > 0; --sz) {
        const NestedInteger ni = q.front();
        q.pop();
        if (ni.isInteger())
          ans += ni.getInteger() * depth;
        else
          addIntegers(q, ni.getList());
      }
    }

    return ans;
  }

 private:
  void addIntegers(queue<NestedInteger>& q,
                   const vector<NestedInteger>& nestedList) {
    for (const NestedInteger& ni : nestedList)
      q.push(ni);
  }
};"
"class Solution:
    def checkRecord(self, n: int) -> int:
        self.dp = defaultdict(int)

        self.dp[0] = 1
        self.dp[1] = 2
        self.dp[2] = 4
        self.dp[3] = 7

        self.helper(n)
        total = self.dp[n]

        for i in range(1, n + 1):
            total += self.dp[i - 1] * self.dp[n - i] 

        return total % ((10 ** 9) + 7)

    def helper(self, i):
        if i < 0:
            return 0
        if i in self.dp:
            return self.dp[i]

        self.dp[i] = (2 * self.helper(i - 1) - self.helper(i - 4)) % ((10 ** 9) + 7)
        
        return self.dp[i]","class Solution {
 public:
  int lengthOfLongestSubstringKDistinct(string s, int k) {
    int ans = 0;
    int distinct = 0;
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (++count[s[r]] == 1)
        ++distinct;
      while (distinct == k + 1)
        if (--count[s[l++]] == 0)
          --distinct;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};"
"class Solution:
    def optimalDivision(self, nums: List[int]) -> str:
        n=len(nums)
        new=[[(0,"""") for i in range(0,n)] for i in range(0,n)]
        for i in range(0,n):
            new[i][i]=(nums[i],str(nums[i]))
        for i in range(0,n-1):
            for j in range(i+1,n):
                new[i][j]=(new[i][j-1][0]/nums[j],new[i][j-1][1]+""/""+str(nums[j]))
        ans=[(0,"""")]*n
        ans[0]=(nums[0],str(nums[0])
        for i in range(1,n):
            for j in range(0,i):
                if (ans[i][0]<ans[j][0]/new[j+1][i][0]):
                    if i-j>=2:
                        ans[i]=(ans[j][0]/new[j+1][i][0],ans[j][1]+""/""+""(""+new[j+1][i][1]+"")"")
                    else:
                        ans[i]=(ans[j][0]/new[j+1][i][0],ans[j][1]+""/""+new[j+1][i][1])
        return ans[-1][1]","class NestedIterator {
 public:
  NestedIterator(vector<NestedInteger>& nestedList) {
    addInteger(nestedList);
  }

  int next() {
    const int num = q.front();
    q.pop();
    return num;
  }

  bool hasNext() {
    return !q.empty();
  }

 private:
  queue<int> q;

  void addInteger(const vector<NestedInteger>& nestedList) {
    for (const NestedInteger& ni : nestedList)
      if (ni.isInteger())
        q.push(ni.getInteger());
      else
        addInteger(ni.getList());
  }
};"
"class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        edge = []
        for w in wall: 
            prefix = 0
            for k in range(len(w)-1): 
                prefix += w[k]
                edge.append(prefix)
        
        ans = cnt = 0
        prev = None
        for x in sorted(edge): 
            cnt = 1 if x != prev else cnt+1 # reset counter 
            ans = max(ans, cnt)
            prev = x
        return len(wall) - ans","class Solution {
 public:
  bool isPowerOfFour(int n) {
    // Why (4^n - 1) % 3 == 0?
    // (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are
    // Three consecutive numbers; among one of them, there must be a multiple
    // Of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.
    // Therefore, 4^n - 1 is a multiple of 3.
    return n > 0 && __builtin_popcountll(n) == 1 && (n - 1) % 3 == 0;
  }
};"
"class Solution:
    def nextGreaterElement(self, n: int) -> int:
    	n = [int(i) for i in str(n)]
    	for i in range(2,len(n)+1):
    		b, f = 1, n[-i]
    		for j in range(1,10-f):
    			if f + j in n[-i+1:]:
    				b = 0
    				break
    		if b == 1: continue
    		n[n.index(f+j,-i)], n[-i] = f, f + j
    		n[-i+1:] = sorted(n[-i+1:])
    		n = int("""".join([str(i) for i in n]))
    		return n if n < 2**31 else -1
    	return -1
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int integerBreak(int n) {
    // If an optimal product contains a factor f >= 4, then we can replace it
    // With 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f,
    // We never need a factor >= 4, meaning we only need factors 1, 2, and 3
    // (and 1 is wasteful).
    // Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice.
    if (n == 2)  // 1 * 1
      return 1;
    if (n == 3)  // 1 * 2
      return 2;

    int ans = 1;

    while (n > 4) {
      n -= 3;
      ans *= 3;
    }
    ans *= n;

    return ans;
  }
};"
"class Solution:
    def reverseWords(self, s: str) -> str:
        l1=s.split()
        l=[]
        for i in l1:
            c=i[::-1]
            l.append(c)
        for i in l:
            c=' '.join(l)
        return c
            
        ``","class Solution {
 public:
  void reverseString(vector<char>& s) {
    int l = 0;
    int r = s.size() - 1;

    while (l < r)
      swap(s[l++], s[r--]);
  }
};"
"class Solution:
    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':
        if quadTree1.isLeaf and quadTree2.isLeaf:                                    # case 1: both are leaf nodes
            node = Node(quadTree1.val | quadTree2.val, 1, None, None, None, None)
            return node
        elif quadTree1.isLeaf and not quadTree2.isLeaf:                              # case 2: node 1 is leaf node, node 2 is not
            node = Node(0, 0, 
                        self.intersect(quadTree1, quadTree2.topLeft), 
                        self.intersect(quadTree1, quadTree2.topRight), 
                        self.intersect(quadTree1, quadTree2.bottomLeft), 
                        self.intersect(quadTree1, quadTree2.bottomRight))
        elif not quadTree1.isLeaf and quadTree2.isLeaf:                              # case 3: node 2 is leaf node, node 1 is not
            node = Node(0, 0, 
                        self.intersect(quadTree1.topLeft, quadTree2), 
                        self.intersect(quadTree1.topRight, quadTree2), 
                        self.intersect(quadTree1.bottomLeft, quadTree2), 
                        self.intersect(quadTree1.bottomRight, quadTree2))
        else:                                                                        # case 4: neither nodes are leaf 
            node = Node(0, 0, 
                        self.intersect(quadTree1.topLeft, quadTree2.topLeft), 
                        self.intersect(quadTree1.topRight, quadTree2.topRight), 
                        self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft), 
                        self.intersect(quadTree1.bottomRight, quadTree2.bottomRight))
            
        if node.topLeft.isLeaf and node.topRight.isLeaf and node.bottomLeft.isLeaf \
            and node.bottomRight.isLeaf and node.topLeft.val == node.topRight.val \
            == node.bottomLeft.val == node.bottomRight.val:                          # shrink quad nodes to one leaf node is values in 4 areas are the same
            return Node(node.topLeft.val, 1, None, None, None, None)
        return node","class Solution {
 public:
  string reverseVowels(string s) {
    const unordered_set<char> vowels{'a', 'e', 'i', 'o', 'u',
                                     'A', 'E', 'I', 'O', 'U'};
    int l = 0;
    int r = s.length() - 1;

    while (l < r) {
      while (l < r && !vowels.count(s[l]))
        ++l;
      while (l < r && !vowels.count(s[r]))
        --r;
      swap(s[l++], s[r--]);
    }

    return s;
  }
};"
"class Solution:
    def maxDepth(self, root: 'Node') -> int:
        
        def dfs(root: 'Node', length: int):
            if root is None:
                return
                
            length += 1
            
            if not root.children:
                result.append(length)
            else:
                for child in root.children:
                    dfs(child, length)
                
        result = []
        dfs(root, length=0)
        
        if not result:
            return 0
        
        return max(result)","class MovingAverage {
 public:
  MovingAverage(int size) : size(size) {}

  double next(int val) {
    if (q.size() == size)
      sum -= q.front(), q.pop();
    sum += val;
    q.push(val);
    return sum / q.size();
  }

 private:
  int size;
  double sum = 0;
  queue<int> q;
};"
"class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        
        if len(nums)==0:
            return 0
        rSum=0
        count=0
        res_map={}
        res_map[0]=1
        for i in range(len(nums)):
            rSum+=nums[i]
            
            compliment=rSum-k
            if compliment in res_map:
                count = count + res_map[compliment]
            if rSum in res_map:
                res_map[rSum]=res_map[rSum]+1
            else:
                res_map[rSum]=1
        return count","struct T {
  int num;
  int freq;
  T(int num, int freq) : num(num), freq(freq) {}
};

class Solution {
 public:
  vector<int> topKFrequent(vector<int>& nums, int k) {
    const int n = nums.size();
    vector<int> ans;
    unordered_map<int, int> count;
    auto compare = [](const T& a, const T& b) { return a.freq > b.freq; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (const int num : nums)
      ++count[num];

    for (const auto& [num, freq] : count) {
      minHeap.emplace(num, freq);
      if (minHeap.size() > k)
        minHeap.pop();
    }

    while (!minHeap.empty())
      ans.push_back(minHeap.top().num), minHeap.pop();

    return ans;
  }
};"
"class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()
        return sum(nums[::2])","class TicTacToe {
 public:
  TicTacToe(int n) : n(n), rows(n), cols(n) {}

  /**
   * Player {player} makes a move at ({row}, {col}).
   *
   * @param row    The row of the board.
   * @param col    The column of the board.
   * @param player The player, can be either 1 or 2.
   * @return The current winning condition, can be either:
   *         0: No one wins.
   *         1: Player 1 wins.
   *         2: Player 2 wins.
   */
  int move(int row, int col, int player) {
    const int toAdd = player == 1 ? 1 : -1;
    const int target = player == 1 ? n : -n;

    if (row == col) {
      diag += toAdd;
      if (diag == target)
        return player;
    }

    if (row + col == n - 1) {
      antiDiag += toAdd;
      if (antiDiag == target)
        return player;
    }

    rows[row] += toAdd;
    if (rows[row] == target)
      return player;

    cols[col] += toAdd;
    if (cols[col] == target)
      return player;

    return 0;
  }

 private:
  const int n;
  // Record count('X') - count('O')
  vector<int> rows;
  vector<int> cols;
  int diag = 0;
  int antiDiag = 0;
};"
"class Solution:
    def findTilt(self, root: TreeNode) -> int:
        cur_sum = [0]
        def helper(node: TreeNode):
            if not node: return 0
            lt = helper(node.left)
            rt = helper(node.right)
            cur_sum[0] += abs(lt-rt)
            return node.val + lt + rt
        helper(root)
        return cur_sum[0]","class Solution {
 public:
  vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    vector<int> ans;
    unordered_set<int> set{begin(nums1), end(nums1)};

    for (const int num : nums2)
      if (set.erase(num))
        ans.push_back(num);

    return ans;
  }
};"
"class Solution:
    def nearestPalindromic(self, n: str) -> str:
        sz = len(n)
        cand = n[:sz//2] + (n[sz//2] if sz&amp;1 else """") + n[0:sz//2][::-1]
        
        def fn(carry): 
            digits = list(map(int, n))[:(sz+1)//2]
            i = (sz-1)//2
            while i >= 0 and carry: 
                digits[i] += carry 
                carry = digits[i] // 10 
                digits[i] = (digits[i] + 10) % 10 
                i -= 1
            half = (str(carry)+''.join(map(str, digits))).lstrip('0')
            if len(half) < len(digits): return '9'*(sz-1) or '0'
            if len(half) > len(digits): return '1' + '0'*(sz-1) + '1'
            half = half or '0'
            if sz&amp;1: return half + half[:-1:][::-1]
            else: return half + half[::-1]
            
        large = fn(1)
        small = fn(-1)
        # print(cand, ""|"", large, ""|"", small)
        if cand == n: return min(small, large, key=lambda x: (abs(int(x)-int(n)), int(x)))
        return min(cand, large, small, key=lambda x: (abs(int(x)-int(n)), int(x)))","class Solution {
 public:
  vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.size() > nums2.size())
      return intersect(nums2, nums1);

    vector<int> ans;
    unordered_map<int, int> count;

    for (const int num : nums1)
      ++count[num];

    for (const int num : nums2)
      if (const auto it = count.find(num);
          it != cend(count) && it->second-- > 0)
        ans.push_back(num);

    return ans;
  }
};"
"class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        ans = 0 
        for i in range(len(nums)): 
            cnt = 0
            while nums[i] != -1: 
                cnt += 1
                nums[i], i = -1, nums[i]
            ans = max(ans, cnt)
        return ans","class Solution {
 public:
  int numberOfPatterns(int m, int n) {
    int ans = 0;
    vector<vector<int>> across(10, vector<int>(10));
    vector<bool> seen(10);

    across[1][3] = across[3][1] = 2;
    across[1][7] = across[7][1] = 4;
    across[3][9] = across[9][3] = 6;
    across[7][9] = across[9][7] = 8;
    across[1][9] = across[9][1] = across[2][8] = across[8][2] = across[3][7] =
        across[7][3] = across[4][6] = across[6][4] = 5;

    ans += dfs(m, n, 1, 1, seen, across) * 4;  // 1, 3, 7, 9 are symmetric
    ans += dfs(m, n, 2, 1, seen, across) * 4;  // 2, 4, 6, 8 are symmetric
    ans += dfs(m, n, 5, 1, seen, across);      // 5
    return ans;
  }

 private:
  int dfs(int m, int n, int u, int depth, vector<bool>& seen,
          const vector<vector<int>>& across) {
    if (depth > n)
      return 0;

    seen[u] = true;
    int ans = depth >= m ? 1 : 0;

    for (int v = 1; v <= 9; ++v) {
      if (v == u || seen[v])
        continue;
      const int acrossed = across[u][v];
      if (acrossed == 0 || seen[acrossed])
        ans += dfs(m, n, v, depth + 1, seen, across);
    }

    seen[u] = false;
    return ans;
  }
};"
"class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        newList = []
        
        #convert to 1-D list
        for i in mat:
            for j in i:
                newList.append(j)

        elements = len(newList)        #total no. of elements

        resMat = []
        
        #if the no. of elements of the new required matrix size (r x c) are not equal to total number of elements, we need to return the original matrix
        if r*c != elements:
            return mat
        else:
            for i in range(0,len(newList),c):
                resMat.append(newList[i:i+c])
            return resMat","class SummaryRanges {
 public:
  void addNum(int val) {
    if (map.count(val))
      return;

    const int lo = lowerKey(val);
    const int hi = higherKey(val);

    // {lo, map[lo][1]} + val + {hi, map[hi][1]} = {lo, map[hi][1]}
    if (lo >= 0 && hi >= 0 && map[lo][1] + 1 == val && val + 1 == hi) {
      map[lo][1] = map[hi][1];
      map.erase(hi);
      // {lo, map[lo][1]} + val = {lo, val}
      // (prevent adding duplicate entry by using '>=' instead of '==')
    } else if (lo >= 0 && map[lo][1] + 1 >= val) {
      map[lo][1] = max(map[lo][1], val);
    } else if (hi >= 0 && val + 1 == hi) {
      // Val + {hi, map[hi][1]} = {val, map[hi][1]}
      map[val] = {val, map[hi][1]};
      map.erase(hi);
    } else {
      map[val] = {val, val};
    }
  }

  vector<vector<int>> getIntervals() {
    vector<vector<int>> intervals;
    for (const auto& [_, interval] : map)
      intervals.push_back(interval);
    return intervals;
  }

 private:
  map<int, vector<int>> map;  // {start: {start, end}}

  // Maximum in map < key
  int lowerKey(int key) {
    auto it = map.lower_bound(key);  // Minimum in map >= key
    if (it == begin(map))
      return -1;
    return (--it)->first;
  }

  // Minimum in map > key
  int higherKey(int key) {
    const auto it = map.upper_bound(key);  // Minimum in map > key
    if (it == cend(map))
      return -1;
    return it->first;
  }
};"
"class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        d1={}
        d2={}
        if(len(s1)>len(s2)):
            return False
        sl = len(s1)
        left = 0
        right = sl-1
        
        for i in s1:
            if(i not in d1):
                d1[i] = 1
            else:
                d1[i] +=1
        
        for i in range(left,right+1):
            if(s2[i] not in d2):
                d2[s2[i]] = 1
            else:
                d2[s2[i]] +=1
        
        if(d1 == d2):
            return True
            
        while(right < len(s2)-1):
            right+=1
            if(s2[right] not in d2):
                d2[s2[right]] = 1
            else:
                d2[s2[right]] +=1
            
            if(d2[s2[left]] == 1):
                del d2[s2[left]]
            else:
                d2[s2[left]]-=1
            left+=1
            if(d1 == d2):
                return True
            
            
        return False","class SnakeGame {
 public:
  /** Initialize your data structure here.
     @param width - screen width
     @param height - screen height
     @param food - A list of food positions
     E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the
     second is at [1,0]. */
  SnakeGame(int width, int height, vector<vector<int>>& food)
      : width(width), height(height), food(food) {
    lookup.insert(getId(0, 0));
    body.push_back(getId(0, 0));
  }

  /** Moves the snake.
      @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down
      @return The game's score after the move. Return -1 if game over.
      Game over when snake crosses the screen boundary or bites its body. */
  int move(string direction) {
    // Old head's position
    int i = body.front() / width;
    int j = body.front() % width;

    // Update head's position and check if out of bound
    if (direction == ""U"" && --i < 0)
      return -1;
    if (direction == ""L"" && --j < 0)
      return -1;
    if (direction == ""R"" && ++j == width)
      return -1;
    if (direction == ""D"" && ++i == height)
      return -1;

    const int newHead = getId(i, j);

    // Case 1: eat food and increase size by 1
    if (k < food.size() && i == food[k][0] && j == food[k][1]) {
      lookup.insert(newHead);
      body.push_front(newHead);
      ++k;
      return ++score;
    }

    // Case 2: new head != old tail and eat body!
    if (newHead != body.back() && lookup.count(newHead))
      return -1;

    // Case 3: normal case
    // Remove old tail first (important), then add new head
    // Because new head may be in old tail's position
    lookup.erase(body.back());
    lookup.insert(newHead);
    body.pop_back();
    body.push_front(newHead);

    return score;
  }

 private:
  int width;
  int height;
  int score = 0;
  int k = 0;  // food's index
  vector<vector<int>> food;
  unordered_set<int> lookup;
  deque<int> body;  // snake's body

  int getId(int i, int j) {
    return i * width + j;
  }
};"
"class Solution:
    
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        if root is None:
            return False
        
        def add_hash(node):
            if not node:
                return hash('#')
            node.hash = hash(add_hash(node.left) + hash(node.val) + add_hash(node.right))
            return node.hash
        
        add_hash(root)
        add_hash(subRoot)
        return self.rec(root, subRoot)

    def rec(self, root, subRoot):
        if root is None:
            return False
        
        if root.hash == subRoot.hash and self.isEqual(root, subRoot):
                return True
        
        return self.rec(root.left, subRoot) or self.rec(root.right, subRoot)
    
    def isEqual(self, subroot1, subroot2):
        if subroot1 is None or subroot2 is None:
            return subroot1 is None and subroot2 is None
        else:
            return subroot1.val == subroot2.val and self.isEqual(subroot1.left, subroot2.left) and self.isEqual(subroot1.right, subroot2.right)","class Solution {
 public:
  int maxEnvelopes(vector<vector<int>>& envelopes) {
    sort(begin(envelopes), end(envelopes), [](const auto& a, const auto& b) {
      return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];
    });

    // Same as 300. Longest Increasing Subsequence
    int ans = 0;
    vector<int> dp(envelopes.size());

    for (const vector<int>& e : envelopes) {
      int l = 0;
      int r = ans;
      while (l < r) {
        const int m = (l + r) / 2;
        if (dp[m] >= e[1])
          r = m;
        else
          l = m + 1;
      }
      dp[l] = e[1];
      if (l == ans)
        ++ans;
    }

    return ans;
  }
};"
"class Solution:
    def distributeCandies(self, candies: List[int]) -> int:
        average = len(candies) // 2
        kind = len(set(candies))
        if average >= kind :
            return kind
        else:
            return average","struct Tweet {
  int id;
  int time;
  Tweet* next = nullptr;
  Tweet(int id, int time) : id(id), time(time) {}
};

struct User {
  int id;
  unordered_set<int> followeeIds;
  Tweet* tweetHead = nullptr;

  User() {}

  User(int id) : id(id) {
    follow(id);  // Follow himself
  }

  void follow(int followeeId) {
    followeeIds.insert(followeeId);
  }

  void unfollow(int followeeId) {
    followeeIds.erase(followeeId);
  }

  void post(int tweetId, int time) {
    Tweet* oldTweetHead = tweetHead;
    tweetHead = new Tweet(tweetId, time);
    tweetHead->next = oldTweetHead;
  }
};

class Twitter {
 public:
  /** Compose a new tweet. */
  void postTweet(int userId, int tweetId) {
    if (!users.count(userId))
      users[userId] = User(userId);
    users[userId].post(tweetId, time++);
  }

  /**
   * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in
   * the news feed must be posted by users who the user followed or by the user
   * herself. Tweets must be ordered from most recent to least recent.
   */
  vector<int> getNewsFeed(int userId) {
    if (!users.count(userId))
      return {};

    vector<int> newsFeed;

    auto compare = [](const Tweet* a, const Tweet* b) {
      return a->time < b->time;
    };
    priority_queue<Tweet*, vector<Tweet*>, decltype(compare)> maxHeap(compare);

    for (const int followeeId : users[userId].followeeIds) {
      Tweet* tweetHead = users[followeeId].tweetHead;
      if (tweetHead != nullptr)
        maxHeap.push(tweetHead);
    }

    int count = 0;
    while (!maxHeap.empty() && count++ < 10) {
      Tweet* tweet = maxHeap.top();
      maxHeap.pop();
      newsFeed.push_back(tweet->id);
      if (tweet->next)
        maxHeap.push(tweet->next);
    }

    return newsFeed;
  }

  /**
   * Follower follows a followee.
   * If the operation is invalid, it should be a no-op.
   */
  void follow(int followerId, int followeeId) {
    if (followerId == followeeId)
      return;
    if (!users.count(followerId))
      users[followerId] = User(followerId);
    if (!users.count(followeeId))
      users[followeeId] = User(followeeId);
    users[followerId].follow(followeeId);
  }

  /**
   * Follower unfollows a followee.
   * If the operation is invalid, it should be a no-op.
   */
  void unfollow(int followerId, int followeeId) {
    if (followerId == followeeId)
      return;
    if (const auto it = users.find(followerId);
        it != cend(users) && users.count(followeeId))
      it->second.unfollow(followeeId);
  }

 private:
  int time = 0;
  unordered_map<int, User> users;  // {userId: User}
};"
"class Solution:
    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
        
        @cache
        def fn(i, j, mv): 
            """"""Return out of boundary paths.""""""
            if not (0 <= i < m and 0 <= j < n): return 1 
            if mv == 0: return 0
            return (fn(i-1, j, mv-1) + fn(i, j-1, mv-1) + fn(i, j+1, mv-1) + fn(i+1, j, mv-1)) % 1_000_000_007
        
        return fn(startRow, startColumn, maxMove)","class Solution {
 public:
  bool isReflected(vector<vector<int>>& points) {
    int minX = INT_MAX;
    int maxX = INT_MIN;
    unordered_set<pair<int, int>, pairHash> seen;

    for (const vector<int>& p : points) {
      const int x = p[0];
      const int y = p[1];
      minX = min(minX, x);
      maxX = max(maxX, x);
      seen.insert({x, y});
    }

    const int sum = minX + maxX;
    // (leftX + rightX) / 2 = (minX + maxX) / 2
    //  leftX = minX + maxX - rightX
    // RightX = minX + maxX - leftX

    for (const vector<int>& p : points)
      if (!seen.count({sum - p[0], p[1]}))
        return false;

    return true;
  }

 private:
  struct pairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};"
"class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        sortednums = sorted(nums)
        if sortednums == nums:
            return 0
        start = 0
        end = len(nums)-1
        for i in range(len(nums)):
            if nums[i]!=sortednums[i]:
                start = i
                break
        for i in range(len(nums)-1,0,-1):
            if nums[i]!=sortednums[i]:
                end = i
                break
        return len(nums[start:end+1])","class Solution {
 public:
  int countNumbersWithUniqueDigits(int n) {
    if (n == 0)
      return 1;

    int ans = 10;
    int uniqueDigits = 9;

    for (int availableNum = 9; n > 1 && availableNum > 0; --n, --availableNum) {
      uniqueDigits *= availableNum;
      ans += uniqueDigits;
    }

    return ans;
  }
};"
"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        dp=[[0 for _ in range(len(word2)+1)]for _ in range(len(word1)+1)]
        for i in range(1,len(dp)):
            for j in range(1,len(dp[0])):
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]+1
                else:
                    dp[i][j]=max(dp[i][j-1],dp[i-1][j])
        return len(word1)+len(word2)-2*dp[-1][-1]","class Solution {
 public:
  string rearrangeString(string s, int k) {
    const int n = s.length();
    string ans;
    vector<int> count(128);
    vector<int> valid(128);  // valid[i] := the leftmost index char i can appear

    for (const char c : s)
      ++count[c];

    for (int i = 0; i < n; ++i) {
      const char c = getBestLetter(count, valid, i);
      if (c == '*')
        return """";
      ans += c;
      --count[c];
      valid[c] = i + k;
    }

    return ans;
  }

  // Returns the letter that has most count and also valid
 private:
  char getBestLetter(const vector<int>& count, const vector<int>& valid,
                     int index) {
    int maxCount = -1;
    char bestLetter = '*';

    for (char c = 'a'; c <= 'z'; ++c)
      if (count[c] > 0 && count[c] > maxCount && index >= valid[c]) {
        bestLetter = c;
        maxCount = count[c];
      }

    return bestLetter;
  }
};"
"class Solution:
    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:
        def clockwise(p1,p2,p3):
            x1,y1=p1
            x2,y2=p2
            x3,y3=p3
            
            return ((y3-y2)*(x2-x1)-(y2-y1)*(x3-x2))
        trees.sort()
        upper=[]
        lower=[]
        for t in trees:
            while len(upper)>1 and clockwise(upper[-2],upper[-1],t)>0:
                upper.pop()
            while len(lower)>1 and clockwise(lower[-2],lower[-1],t)<0:
                lower.pop()
            upper.append(tuple(t))
            lower.append(tuple(t))
            
        return list(set(upper+lower))","class Solution {
 public:
  vector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) {
    const int n = nums.size();
    const bool upward = a > 0;
    vector<int> ans(n);
    vector<int> quad;

    for (const int num : nums)
      quad.push_back(f(num, a, b, c));

    int i = upward ? n - 1 : 0;
    for (int l = 0, r = n - 1; l <= r;)
      if (upward)  // Maximum in both ends
        ans[i--] = quad[l] > quad[r] ? quad[l++] : quad[r--];
      else  // Minimum in both ends
        ans[i++] = quad[l] < quad[r] ? quad[l++] : quad[r--];

    return ans;
  }

 private:
  // The concavity of f only depends on a's sign
  int f(int x, int a, int b, int c) {
    return (a * x + b) * x + c;
  }
};"
"class Solution:
    def __init__(self):     # initializing the answer list
        self.ans=[]
		
    def preorder(self, root: 'Node') -> List[int]:
        if not root:             # if leaf Node
            return
        self.ans.append(root.val)   # append the root value
        for i in root.children:    # iterate over every children 
            self.preorder(i)
        return self.ans        # return ans","class Solution {
 public:
  int maxKilledEnemies(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int enemyCount = 0;
    // dp[i][j] := max enemies grid[i][j] can kill
    vector<vector<int>> dp(m, vector<int>(n));

    auto update = [&](int i, int j) {
      if (grid[i][j] == '0')
        dp[i][j] += enemyCount;
      else if (grid[i][j] == 'E')
        ++enemyCount;
      else  // grid[i][j] == 'W'
        enemyCount = 0;
    };

    // Extend four directions, if meet 'W', need to start over from 0
    for (int i = 0; i < m; ++i) {
      enemyCount = 0;
      for (int j = 0; j < n; ++j)
        update(i, j);
      enemyCount = 0;
      for (int j = n - 1; j >= 0; --j)
        update(i, j);
    }

    for (int j = 0; j < n; ++j) {
      enemyCount = 0;
      for (int i = 0; i < m; ++i)
        update(i, j);
      enemyCount = 0;
      for (int i = m - 1; i >= 0; --i)
        update(i, j);
    }

    return accumulate(begin(dp), end(dp), 0,
                      [](int subtotal, const vector<int>& row) {
      return max(subtotal, *max_element(begin(row), end(row)));
    });
  }
};"
"class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        st = [root]
        l = []
        while st:
            node = st.pop()
            if node:
                l.insert(0,node.val)
                if node.children:
                    for i in node.children:
                        st.append(i)
        return l","class Solution {
 public:
  int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    int ans = INT_MIN;

    for (int baseCol = 0; baseCol < n; ++baseCol) {
      // sums[i] := sum(matrix[i][baseCol..j])
      vector<int> sums(m, 0);
      for (int j = baseCol; j < n; ++j) {
        for (int i = 0; i < m; ++i)
          sums[i] += matrix[i][j];
        // Find the max subarray no more than k
        set<int> accumulate{0};
        int prefix = 0;
        for (const int sum : sums) {
          prefix += sum;
          if (const auto it = accumulate.lower_bound(prefix - k);
              it != cend(accumulate))
            ans = max(ans, prefix - *it);
          accumulate.insert(prefix);
        }
      }
    }

    return ans;
  }
};"
"class Solution:
    def isValid(self, code: str) -> bool:
        prefix = suffix = False 
        stack = []
        i = 0 
        while i < len(code): 
            if code[i:i+2] == '</': 
                ii = i = i+2
                for i in range(i, len(code)): 
                    if code[i] == '>': break 
                else: return False 
                if i == len(code)-1: suffix = True 
                tag = code[ii:i]
                if not stack or stack[-1] != tag: return False 
                stack.pop()
                if not stack and not suffix: return False 
            elif code[i:i+3] == '<![': 
                ii = i = i+3
                buffer = 1
                for i in range(i, len(code)): 
                    if code[i] == '[': 
                        if buffer: 
                            buffer = 0 
                            if code[ii:i] != ""CDATA"": return False 
                    elif code[i:i+3] == ']]>': 
                        if buffer: return False 
                        break 
                else: return False 
            elif code[i] == '<': 
                ii = i = i+1
                for i in range(i, len(code)): 
                    if code[i] == '>': break 
                else: return False 
                if ii == 1: prefix = True 
                tag = code[ii:i]
                if not (all(map(str.isupper, tag)) and 1 <= len(tag) <= 9): return False 
                stack.append(tag)
            i += 1
        return prefix and suffix and not stack","class Solution {
 public:
  int depthSumInverse(vector<NestedInteger>& nestedList) {
    int ans = 0;
    int prevSum = 0;
    queue<NestedInteger> q{{begin(nestedList), end(nestedList)}};

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const NestedInteger ni = q.front();
        q.pop();
        if (ni.isInteger())
          prevSum += ni.getInteger();
        else {
          for (const NestedInteger nextNi : ni.getList())
            q.push(nextNi);
        }
      }
      ans += prevSum;
    }

    return ans;
  }
};"
"class Solution:
    def fractionAddition(self, expression: str) -> str:
        n, d = 0, 1
        nums = (int(x) for x in re.findall(""[+-]?\d+"", expression))
        for nn, dd in zip(*[iter(nums)]*2):
            n = n*dd + nn*d
            d *= dd
        g = gcd(n, d)
        return f""{n//g}/{d//g}""","class Solution {
 public:
  bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    return targetCapacity == 0 ||
           jug1Capacity + jug2Capacity >= targetCapacity &&
               targetCapacity % __gcd(jug1Capacity, jug2Capacity) == 0;
  }
};"
"class Solution:
    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
    	D = [(i[0]-j[0])**2+(i[1]-j[1])**2 for i,j in itertools.combinations([p1,p2,p3,p4],2)]
    	return False if not D else [D.count(min(D)),D.count(max(D))] == [4,2]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  vector<vector<int>> findLeaves(TreeNode* root) {
    vector<vector<int>> ans;

    depth(root, ans);
    return ans;
  }

 private:
  // Depth of root (0-indexed)
  int depth(TreeNode* root, vector<vector<int>>& ans) {
    if (root == nullptr)
      return -1;

    const int l = depth(root->left, ans);
    const int r = depth(root->right, ans);
    const int h = 1 + max(l, r);
    if (ans.size() == h)  // Meet leaf
      ans.push_back({});

    ans[h].push_back(root->val);
    return h;
  }
};"
"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        
        c = Counter(nums)
        res = 0
        for x in set(nums):
            
            less, big = x - 1, x + 1
            if less in c or big in c:
                res = max(res, c[less] + c[x], c[big] + c[x])
        return res","class Solution {
 public:
  bool isPerfectSquare(int num) {
    long l = 1;
    long r = num;

    while (l < r) {
      const long m = (l + r) / 2;
      if (m >= num / m)
        r = m;
      else
        l = m + 1;
    }

    return l * l == num;
  }
};"
"class Solution:
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
        if not ops:
            return m*n
        return min(op[0] for op in ops)*min(op[1] for op in ops)","class Solution {
 public:
  vector<int> largestDivisibleSubset(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans;
    // sizeEndsAt[i] := largest size ends at nums[i]
    vector<int> sizeEndsAt(n, 1);
    // prevIndex[i] := the best index s.t.
    // 1. nums[i] % nums[prevIndex[i]] == 0 and
    // 2. can increase the size of the subset
    vector<int> prevIndex(n, -1);
    int maxSize = 0;  // Max size of the subset
    int index = -1;   // Track the best ending index

    sort(begin(nums), end(nums));

    // Fix max ending num in the subset first
    for (int i = 0; i < n; ++i) {
      for (int j = i - 1; j >= 0; --j)
        if (nums[i] % nums[j] == 0 && sizeEndsAt[i] < sizeEndsAt[j] + 1) {
          sizeEndsAt[i] = sizeEndsAt[j] + 1;
          prevIndex[i] = j;
        }
      // Find a new subset that has a bigger size
      if (maxSize < sizeEndsAt[i]) {
        maxSize = sizeEndsAt[i];
        index = i;  // Update the best ending index
      }
    }

    // Loop from back to front
    while (index != -1) {
      ans.push_back(nums[index]);
      index = prevIndex[index];
    }

    return ans;
  }
};"
"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
    	D = {j:i for i,j in enumerate(list2)}
    	L = sorted([[i+D[j],j] for i,j in enumerate(list1) if j in D])
    	return [r[1] for r in L if r[0] == L[0][0]]
		
		
- Python 3
- Junaid Mansuri","class Solution {
 public:
  ListNode* plusOne(ListNode* head) {
    if (head == nullptr)
      return new ListNode(1);
    if (addOne(head) == 1)
      return new ListNode(1, head);
    return head;
  }

 private:
  int addOne(ListNode* node) {
    const int carry = node->next ? addOne(node->next) : 1;
    const int sum = node->val + carry;
    node->val = sum % 10;
    return sum / 10;
  }
};"
"class Solution:
    def findIntegers(self, n: int) -> int:
        # fn - count of numbers with size of n in bin representation which satisfy the rule
        # for example: fn[3] = 5 => *** = {'000', '001', '010', '100', '101'}
        # fn[2] = 3 => ** = {'00', '01', '10'}
        # fn[6] = {'10****', '0*****'} = fn[4] + fn[5]
        # fn[0] is trick for loop to append 1 to result if max_n has '1' in last bit
        fn = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269]
        # another words fn is count of numbers which satisfy the rule and less then 2^n for n >= 1
        
        nstr = bin(n)[2:]
        p = nstr.find('11')
        tmp = list(nstr)
        if p >= 0:
            for i in range(p + 1, len(tmp)):
                tmp[i] = '10'[(i - p) % 2]
        
        max_n = ''.join(tmp)
        # max_n - bin representation of max number that satisfy the rule
        # bin(n) = '10011010' -> max_n = '10010101'
        # bin(n) = '1100' -> max_n = '1010'
        
        # main idea:
        #  n = 154 = 10011010 -> max_n = 10010101 = 10000000 + 10000 + 100 + 1
        # 10000000 => {10000000} + {0*******} -> 1 + fn[7] = 35
        # 10000 => {10000} + {0****} - {00000} (just used in prev step) -> 1 + fn[4] - 1 = fn[4] = 8
        # 100 => {100} + {0**} - {000} -> fn[2] = 3
        # 1 or fn[0]
        # ans = 35 + 8 + 3 + 1 = 47
        
        ans = fn[len(max_n) - 1] + 1
        for i in range(2, len(max_n)):
            if max_n[i] == '1':
                ans += fn[len(max_n) - i - 1]
        
        return ans
	```","class Solution {
 public:
  vector<int> getModifiedArray(int length, vector<vector<int>>& updates) {
    vector<int> ans(length);
    int prefix = 0;

    for (const vector<int>& update : updates) {
      const int startIndex = update[0];
      const int endIndex = update[1];
      const int inc = update[2];
      ans[startIndex] += inc;
      if (endIndex + 1 < length)
        ans[endIndex + 1] -= inc;
    }

    for (int i = 0; i < length; ++i) {
      prefix += ans[i];
      ans[i] = prefix;
    }

    return ans;
  }
};"
"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        l = None
        for i in range(len(flowerbed)):
            if n>len(flowerbed) or n==0:
                return n==0
            if not flowerbed[i] and not l and (i==len(flowerbed)-1  or (i<len(flowerbed)-1 and not flowerbed[i+1])):
                n-=1
                flowerbed[i] = 1
            l = flowerbed[i]
        return n==0","class Solution {
 public:
  int getSum(unsigned a, unsigned b) {
    while (b) {                      // Still have carry bits
      const unsigned carry = a & b;  // Record carry bits
      a ^= b;                        // ^ works like + w/o handling carry bits
      b = carry << 1;
    }
    return a;
  }
};"
"class Solution:
    def tree2str(self, root: TreeNode) -> str:
        def rec(node: TreeNode) -> str:
            out = str(node.val)
            
            if node.left:
                out += f""({rec(node.left)})""
            elif node.right:
                out += ""()""
                
            if node.right:
                out += f""({rec(node.right)})""
                
            return out
    
        return rec(root)","class Solution {
 public:
  int superPow(int a, vector<int>& b) {
    constexpr int k = 1337;
    int ans = 1;

    auto powMod = [&](int x, int y) {  // X^y % k
      int pow = 1;
      while (y--)
        pow = (pow * x) % k;
      return pow;
    };

    a %= k;
    for (const int i : b)
      ans = powMod(ans, 10) * powMod(a, i) % k;

    return ans;
  }
};"
"class Solution:
    def findDuplicate(self, paths: List[str]) -> List[List[str]]:
        mp = {} # mapping from content to file 
        for path in paths: 
            files = path.split()
            for i in range(1, len(files)): 
                f, c = files[i].split(""("")
                mp.setdefault(c[:-1], []).append(files[0] + ""/"" + f) 
        return [x for x in mp.values() if len(x) > 1]","struct T {
  int i;
  int j;
  int sum;  // nums1[i] + nums2[j]
  T(int i, int j, int sum) : i(i), j(j), sum(sum) {}
};

class Solution {
 public:
  vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2,
                                     int k) {
    vector<vector<int>> ans;
    auto compare = [&](const T& a, const T& b) { return a.sum > b.sum; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < k && i < nums1.size(); ++i)
      minHeap.emplace(i, 0, nums1[i] + nums2[0]);

    while (!minHeap.empty() && ans.size() < k) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      ans.push_back({nums1[i], nums2[j]});
      if (j + 1 < nums2.size())
        minHeap.emplace(i, j + 1, nums1[i] + nums2[j + 1]);
    }

    return ans;
  }
};"
"class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        count=0
        for i in range(len(nums)-2):
            k=i+2
            for j in range(i+1,len(nums)-1):
                if nums[i]==0: continue
                while k<len(nums) and nums[i] + nums[j] > nums[k]:
                    k+=1
                count+=k-j-1
        return count","/**
 * Forward declaration of guess API.
 * (The problem description is not clear, so I translate it into follows.)
 *
 * @param traget num
 *        guess num
 *
 * @return -1 if guess num >  target num
 *          0 if guess num == target num
 *          1 if guess num <  target num
 */

class Solution {
 public:
  int guessNumber(int n) {
    int l = 1;
    int r = n;

    // Find the first guess num that >= target num
    while (l < r) {
      const int m = l + (r - l) / 2;
      if (guess(m) <= 0)  // -1, 0
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};"
"class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if root1 == root2 == None:
            return None
        
        if root1 and root2 == None:
            return root1
        
        if root2 and root1 == None:
            return root2

        if root1 and root2:
            root = TreeNode(root1.val + root2.val)
            root.left = self.mergeTrees(root1.left, root2.left)
            root.right = self.mergeTrees(root1.right, root2.right)
            return root","class Solution {
 public:
  int getMoneyAmount(int n) {
    // dp[i][j] := min money you need to guarantee a win of picking i..j
    dp.resize(n + 1, vector<int>(n + 1, INT_MAX));
    return getMoneyAmount(1, n);
  }

 private:
  vector<vector<int>> dp;

  int getMoneyAmount(int i, int j) {
    if (i >= j)
      return 0;
    if (dp[i][j] != INT_MAX)
      return dp[i][j];

    for (int k = i; k <= j; ++k)
      dp[i][j] =
          min(dp[i][j],
              max(getMoneyAmount(i, k - 1), getMoneyAmount(k + 1, j)) + k);

    return dp[i][j];
  }
};"
"class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = {} # frequency table 
        for x in tasks: freq[x] = 1 + freq.get(x, 0)
        mx = max(freq.values()) # highest frequency
        cnt = sum(v == mx for v in freq.values()) # occurrences of most frequent tasks
        return max(len(tasks), (mx-1)*(n+1) + cnt)","class Solution {
 public:
  int wiggleMaxLength(vector<int>& nums) {
    int increasing = 1;
    int decreasing = 1;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] > nums[i - 1])
        increasing = decreasing + 1;
      else if (nums[i] < nums[i - 1])
        decreasing = increasing + 1;

    return max(increasing, decreasing);
  }
};"
"class Solution:
    def addOneRow(self, root: Optional[TreeNode], v: int, d: int) -> Optional[TreeNode]:
        temp=root
        def hii(temp,d):
            
            if d==2 and temp:
                x=TreeNode(v)
                y=TreeNode(v)
                x.left=temp.left
                y.right=temp.right
                temp.left=x
                temp.right=y
                return root
            else:
                if temp:
                    hii(temp.left,d-1)
                    hii(temp.right,d-1)
            return root
        
        if d==1:
            x=TreeNode(v)
            x.left=root
            return x
        
        return hii(temp,d)","class Solution {
 public:
  int combinationSum4(vector<int>& nums, int target) {
    vector<unsigned long long> dp(target + 1);
    dp[0] = 1;

    for (int i = 1; i <= target; ++i)
      for (const int num : nums)
        if (i >= num)
          dp[i] += dp[i - num];

    return dp[target];
  }
};"
"class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        
        nums.sort()
        return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])","struct T {
  int i;
  int j;
  int num;  // matrix[i][j]
  T(int i, int j, int num) : i(i), j(j), num(num) {}
};

class Solution {
 public:
  int kthSmallest(vector<vector<int>>& matrix, int k) {
    auto compare = [&](const T& a, const T& b) { return a.num > b.num; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < k && i < matrix.size(); ++i)
      minHeap.emplace(i, 0, matrix[i][0]);

    while (k-- > 1) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      if (j + 1 < matrix[0].size())
        minHeap.emplace(i, j + 1, matrix[i][j + 1]);
    }

    return minHeap.top().num;
  }
};"
"class Solution:
    def kInversePairs(self, n: int, k: int) -> int:
        curr = [0 for _ in range(k+1)]
        prev = [0 for _ in range(k+1)]
        for i in range(1,n+1):
            value = 0
            for j in range(k+1):
                if j == 0:
                    curr[j] = 1
                    value += prev[j]
                else:
                    if j >= i:
                        value-=prev[j-i]
                    value+=prev[j]
                    curr[j] = value
            curr,prev = prev,curr
        return prev[-1] % (10**9+7)","class PhoneDirectory {
 public:
  /** Initialize your data structure here
      @param maxNumbers - The maximum numbers that can be stored in the phone
     directory. */
  PhoneDirectory(int maxNumbers) : next(maxNumbers) {
    for (int i = 0; i < maxNumbers - 1; ++i)
      next[i] = i + 1;
    next.back() = 0;
  }

  /** Provide a number which is not assigned to anyone.
      @return - Return an available number. Return -1 if none is available. */
  int get() {
    if (next[number] == -1)
      return -1;

    const int ans = number;
    number = next[number];
    next[ans] = -1;  // Mark as used
    return ans;
  }

  /** Check if a number is available or not. */
  bool check(int number) {
    return next[number] != -1;
  }

  /** Recycle or release a number. */
  void release(int number) {
    if (next[number] != -1)
      return;

    next[number] = this->number;
    this->number = number;
  }

 private:
  int number = 0;    // Current possible available number
  vector<int> next;  // Next available number
};"
"class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        prefix = 0 
        pq = [] # max-heap 
        for x, y in sorted(courses, key=lambda x: x[1]): 
            prefix += x
            heappush(pq, -x)
            while prefix > y: prefix += heappop(pq)
        return len(pq)","class RandomizedSet {
 public:
  /** Inserts a value to the set. Returns true if the set did not already
   * contain the specified element. */
  bool insert(int val) {
    if (valToIndex.count(val))
      return false;

    valToIndex[val] = vals.size();
    vals.push_back(val);
    return true;
  }

  /** Removes a value from the set. Returns true if the set contained the
   * specified element. */
  bool remove(int val) {
    if (!valToIndex.count(val))
      return false;

    const int index = valToIndex[val];
    // Following two lines order are important when vals.size() == 1
    valToIndex[vals.back()] = index;
    valToIndex.erase(val);
    vals[index] = vals.back();
    vals.pop_back();
    return true;
  }

  /** Get a random element from the set. */
  int getRandom() {
    const int index = rand() % vals.size();
    return vals[index];
  }

 private:
  unordered_map<int, int> valToIndex;  // {val: index in vals}
  vector<int> vals;
};"
"class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        hi = -inf
        pq = []
        for i, num in enumerate(nums): 
            heappush(pq, (num[0], i, 0))
            hi = max(hi, num[0])
        
        ans = [-inf, inf]
        while pq: 
            ans = min(ans, [pq[0][0], hi], key=lambda x: (x[1]-x[0], x[0]))
            _, i, j = heappop(pq)
            if j+1 == len(nums[i]): break 
            hi = max(hi, nums[i][j+1])
            heappush(pq, (nums[i][j+1], i, j+1))
        return ans","struct Item {
  int val;
  int indexInMap;
  Item(int val, int indexInMap) : val(val), indexInMap(indexInMap) {}
};

class RandomizedCollection {
 public:
  /** Inserts a value to the collection. Returns true if the collection did not
   * already contain the specified element. */
  bool insert(int val) {
    valToIndices[val].push_back(items.size());
    items.emplace_back(val, valToIndices[val].size() - 1);
    return valToIndices[val].size() == 1;
  }

  /** Removes a value from the collection. Returns true if the collection
   * contained the specified element. */
  bool remove(int val) {
    if (!valToIndices.count(val))
      return false;

    const int index = valToIndices[val].back();
    valToIndices[items.back().val][items.back().indexInMap] = index;
    valToIndices[val].pop_back();
    if (valToIndices[val].empty())
      valToIndices.erase(val);
    items[index] = items.back();
    items.pop_back();
    return true;
  }

  /** Get a random element from the collection. */
  int getRandom() {
    const int index = rand() % items.size();
    return items[index].val;
  }

 private:
  unordered_map<int, vector<int>> valToIndices;
  vector<Item> items;
};"
"class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        # Fermat theorem on sum of two squares
        x = 2
        while x*x <= c: 
            if c % x == 0: 
                mult = 0
                while c % x == 0: 
                    mult += 1
                    c //= x
                if x % 4 == 3 and mult &amp; 1: return False 
            x += 1
        return c % 4 != 3","class Solution {
 public:
  /** @param head The linked list's head.
      Note that the head is guaranteed to be not null, so it contains at least
     one node. */
  Solution(ListNode* head) : head(head) {}

  /** Returns a random node's value. */
  int getRandom() {
    int ans = -1;
    int i = 1;

    for (ListNode* curr = head; curr; curr = curr->next, ++i)
      if (rand() % i == 0)
        ans = curr->val;

    return ans;
  }

 private:
  ListNode* head;
};"
"class Solution:
    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:
        ans = [0] * n
        stk, start = [], None
        for log in logs:
            jid, kw, ts = log.split(':')
            jid, ts = int(jid), int(ts)
            if kw == 'start':
                if stk:
                    ans[stk[-1]] += (ts - start)
                stk.append(jid)
                start = ts
            else:
                ans[stk.pop()] += (ts - start + 1)
                start = ts + 1
        return ans","class Solution {
 public:
  bool canConstruct(string ransomNote, string magazine) {
    vector<int> count(128);

    for (const char c : magazine)
      ++count[c];

    for (const char c : ransomNote)
      if (--count[c] < 0)
        return false;

    return true;
  }
};"
"class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        lst=[root]
        flst=[]
        avg=[]
        sm,ct=0,0
        while lst:
            x=lst.pop(0)
            sm+=x.val
            ct+=1
            if x.left:
                flst.append(x.left)
            if x.right:
                flst.append(x.right)
            if lst==[]:
                lst=flst[:]
                flst=[]
                av=sm/ct
                avg.append(round(av,5))
                sm=0
                ct=0
        return avg","class Solution {
 public:
  Solution(vector<int>& nums) : nums(move(nums)) {}

  /** Resets the array to its original configuration and return it. */
  vector<int> reset() {
    return nums;
  }

  /** Returns a random shuffling of the array. */
  vector<int> shuffle() {
    vector<int> A(nums);
    for (int i = A.size() - 1; i > 0; --i) {
      const int j = rand() % (i + 1);
      swap(A[i], A[j]);
    }
    return A;
  }

 private:
  vector<int> nums;
};"
"class Solution:
    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
        #Approach: At every decision making node, we have an option to choose one of 
        #many available sale special offers! Once we run out of offers to choose from,
        #we will simply have to buy the remaining items needed at regular price described
        #from price array!
        
        #To keep track of the special offer I used so far, I will utilize a boolean array
        #s.t. b_arr[i] = 1 if already used 0 else!
        num_specials = len(special)
        b_arr = [0 for _ in range(num_specials)]
        
        #i will also use nonlocal variable to keep track of amount spent so far!
        #i will periodically update this as I recurse and also when I backtrack!
        amount_spent = 0
        #n will store the original number of items I need to buy!
        n = sum(needs)
        ans = float(inf)
        #paramter:
        #1. rem. total elements to buy!
        #2. array describing number of rem. items by item type!
        def helper(remaining, a):
            nonlocal b_arr, num_specials, amount_spent, ans, special, price
            #base case: rem. items == 0! We reach this base case if we are able to buy
            #every item type according to our needs just from using special offers and not 
            #paying at regular price!
            if(remaining == 0):
                #update answer!
                ans = min(amount_spent, ans)
                return
            
            #if not base case, that means we still have items to buy!
            #consider iterating through each and every special offer! 
            #check that it's available!
            #if available, check that speical offer does not require buying items more than need!
            #If so, deduct amount of items by each item type and update remaining amount
            #and recurse on it!
            #When recursing, restore state of b_arr, amount_spent, as well as array a!
            special_valid = False
            for i in range(num_specials):
                #ith offer already used!
                if(b_arr[i] == 1):
                    continue
                #run a loop to check if ith offer amount to buy never exceeds the
                #current needs!
                is_valid = True
                for j in range(len(a)):
                    #check if ith special offer causes overbuying! If so, set is_valid flag off!
                    if(a[j] < special[i][j]):
                        is_valid = False
                        break
                #check if flag is not set!
                if(not is_valid):
                    continue
                special_valid = True
                #otherwise, if current ith special offer is valid for all item types,
                #go ahead and update remaining items, state of array a, as well as amount spent!
                amount_spent += special[i][-1]
                
                #set the boolean array on to indicate we used up ith offer!
                b_arr[i] = 1
                overall_remaining = remaining
                for b in range(len(a)):
                    a[b] -= special[i][b]
                    overall_remaining -= special[i][b]
                
                #go ahead and recurse!
                helper(overall_remaining, a)
                
                #once we return from rec. call, set the flag back off,
                #update amount spent, as well as state of array a when
                #backtracking to parent caller in recursion!
                b_arr[i] = 0
                #update amount spent!
                amount_spent -= special[i][-1]
                
                for c in range(len(a)):
                    a[c] += special[i][c]
            #check if even a single special offer can be used by using special_valid boolean flag!
            #If not, then we have to buy remaining items and update amount_paid so far! 
            if(not special_valid):
                new_amount_paid = amount_spent
                for d in range(len(a)):
                    if(a[d] > 0):
                        new_amount_paid += (a[d] * price[d])
                ans = min(ans, new_amount_paid)
                        
        
        helper(n, needs)
        #edge case: without using any special offer, buying at regular price might be the best
        #option!
        without = 0
        for z in range(len(price)):
            without += (price[z] * needs[z])
        return min(ans, without)","class Solution {
 public:
  NestedInteger deserialize(string s) {
    if (s[0] != '[')
      return NestedInteger(stoi(s));

    stack<NestedInteger> stack;
    int start;  // the start index of num

    for (int i = 0; i < s.length(); ++i) {
      switch (s[i]) {
        case '[':
          stack.push(NestedInteger());
          start = i + 1;
          break;
        case ',':
          if (i > start) {
            const int num = stoi(s.substr(start, i));
            stack.top().add(NestedInteger(num));
          }
          start = i + 1;
          break;
        case ']':
          NestedInteger popped = stack.top();
          stack.pop();
          if (i > start) {
            const int num = stoi(s.substr(start, i));
            popped.add(NestedInteger(num));
          }
          if (stack.empty())
            return popped;
          else
            stack.top().add(popped);
          start = i + 1;
          break;
      }
    }

    throw;
  }
};"
"class Solution:
    def numDecodings(self, s: str) -> int:
        
        @cache 
        def fn(i): 
            """"""Return decode ways.""""""
            if i == len(s): return 1 
            if s[i] == ""0"": return 0 
            if i == len(s)-1: return 9 if s[i] == '*' else 1
            if s[i] == ""*"": 
                ans = 9*fn(i+1)
                if s[i+1] == ""*"": ans += 15*fn(i+2)
                else: 
                    ans += fn(i+2)
                    if s[i+1] <= ""6"": ans += fn(i+2)
            else: 
                ans = fn(i+1)
                if s[i+1] == ""*"": 
                    if s[i] == ""1"": ans += 9*fn(i+2)
                    elif s[i] == ""2"": ans += 6*fn(i+2)
                elif int(s[i:i+2]) <= 26: ans += fn(i+2)
            return ans % 1_000_000_007
        
        return fn(0)","class Solution {
 public:
  vector<int> lexicalOrder(int n) {
    vector<int> ans;
    int curr = 1;

    while (ans.size() < n) {
      ans.push_back(curr);
      if (curr * 10 <= n) {
        curr *= 10;
      } else {
        while (curr % 10 == 9 || curr == n)
          curr /= 10;
        ++curr;
      }
    }

    return ans;
  }
};"
"class Solution:
    def solveEquation(self, equation: str) -> str:
        s = ''
        x, i = 0, 0
        rev = False
		
        for c in equation:
            if c in '+-':
				if s:
					i += int(s or 0) * (rev or -1)
                s = c
            elif c == 'x':
                x -= int(s+'1' if s in '+-' else s) * (rev or -1)
                s = ''
            elif c == '=':
			    if s:
					i -= int(s or 0)
					s = ''
                rev = True
            else:
                s += c
        else:
		    if s:
				i += int(s or 0) * (rev or -1)
            return f'x={i//x}' if x else 'No solution' if i else 'Infinite solutions'","class Solution {
 public:
  int firstUniqChar(string s) {
    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (int i = 0; i < s.length(); ++i)
      if (count[s[i]] == 1)
        return i;

    return -1;
  }
};"
"class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        sums, ans = 0, float(""-inf"")
        i = 0
        for j in range(len(nums)):
            sums += nums[j]
            if j-i+1 == k:
                ans = max(ans, sums)
                sums -= nums[i]
                i = i+1
        return ans / k","struct T {
  int depth;
  size_t length;
  T(int depth, size_t length) : depth(depth), length(length) {}
};

class Solution {
 public:
  int lengthLongestPath(string input) {
    size_t ans = 0;
    stack<T> stack{{{-1, 0}}};  // Placeholder
    istringstream iss(input);

    for (string token; getline(iss, token, '\n');) {
      const int depth =
          count_if(begin(token), end(token), [](char c) { return c == '\t'; });
      token.erase(remove(begin(token), end(token), '\t'), end(token));
      while (depth <= stack.top().depth)
        stack.pop();
      if (isFile(token))
        ans = max(ans, stack.top().length + token.length());
      else  // Directory + '/'
        stack.emplace(depth, stack.top().length + token.length() + 1);
    }

    return ans;
  }

 private:
  bool isFile(const string& token) {
    return token.find('.') != string::npos;
  }
};"
"class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        a = Counter(nums)
        Fsm = sum(nums)
        Csm = (len(nums) * (len(nums)+1))//2
        tp = a.most_common(1)
        return [tp[0][0], Csm - (Fsm - tp[0][0])]","class Solution {
 public:
  char findTheDifference(string s, string t) {
    char ans = 0;

    for (const char c : s)
      ans ^= c;

    for (const char c : t)
      ans ^= c;

    return ans;
  }
};"
"class Solution:
def findLongestChain(self, pairs: List[List[int]]) -> int:
    n=len(pairs)
    dp=[1]*n
    pairs=sorted(pairs,key=lambda k:k[0])
    for i in range(1,n):
        for j in range(0,i):
            if pairs[i][0]>pairs[j][1] and dp[i]<dp[j]+1:
                dp[i]=dp[j]+1
    return max(dp)","class Solution {
 public:
  int lastRemaining(int n) {
    return n == 1 ? 1 : 2 * (1 + n / 2 - lastRemaining(n / 2));
  }
};"
"class Solution:
    def countSubstrings(self, s: str) -> int:
        count = 0
   
        for l in range(len(s)):
            count += Solution.check(l,l,s)
            count += Solution.check(l,l+1,s)
            
        return count
    
    @staticmethod
    def check(l, r, s):
        count = 0
        while(l>=0 and r<len(s)):
            if s[l] == s[r]:
                count +=1
            else:
                break
            l-=1
            r+=1
        return count","class Solution {
 public:
  bool isRectangleCover(vector<vector<int>>& rectangles) {
    int area = 0;
    int x1 = INT_MAX;
    int y1 = INT_MAX;
    int x2 = INT_MIN;
    int y2 = INT_MIN;
    unordered_set<string> corners;

    for (const vector<int>& r : rectangles) {
      area += (r[2] - r[0]) * (r[3] - r[1]);
      x1 = min(x1, r[0]);
      y1 = min(y1, r[1]);
      x2 = max(x2, r[2]);
      y2 = max(y2, r[3]);

      // Four points of current rectangle
      const vector<string> points{to_string(r[0]) + "" "" + to_string(r[1]),
                                  to_string(r[0]) + "" "" + to_string(r[3]),
                                  to_string(r[2]) + "" "" + to_string(r[1]),
                                  to_string(r[2]) + "" "" + to_string(r[3])};
      for (const string& point : points)
        if (!corners.insert(point).second)
          corners.erase(point);
    }

    if (corners.size() != 4)
      return false;
    if (!corners.count(to_string(x1) + "" "" + to_string(y1)) ||
        !corners.count(to_string(x1) + "" "" + to_string(y2)) ||
        !corners.count(to_string(x2) + "" "" + to_string(y1)) ||
        !corners.count(to_string(x2) + "" "" + to_string(y2)))
      return false;

    return area == (x2 - x1) * (y2 - y1);
  }
};"
"class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        s = sentence.split()
        dictionary.sort(key=lambda x:len(x))
        for i,j in enumerate(s):
            for v in dictionary:
                if j.startswith(v):
                    s[i] = v
                    break
        return ' '.join(s)","class Solution {
 public:
  bool isSubsequence(string s, string t) {
    if (s.empty())
      return true;

    int i = 0;
    for (const char c : t)
      if (s[i] == c && ++i == s.length())
        return true;

    return false;
  }
};"
"class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        d, r = senate.count(""D""), senate.count(""R"")
        killedR, killedD = 0, 0
        deleted = set()
        while d and r:
            for idx,letter in enumerate(senate):
                if idx in deleted: continue
                if letter == ""R"" and killedR == 0:
                    killedD += 1
                    d -= 1
                elif letter == ""D"" and killedD == 0:
                    killedR += 1
                    r -= 1
                elif letter == ""R"" and killedR > 0:
                    deleted.add(idx)
                    killedR -= 1
                else:
                    deleted.add(idx)
                    killedD -= 1
        return ""Dire"" if d else ""Radiant""","class Solution {
 public:
  bool validUtf8(vector<int>& data) {
    int leftToCheck = 0;

    for (const int d : data)
      if (leftToCheck == 0) {
        if ((d >> 3) == 0b11110)
          leftToCheck = 3;
        else if ((d >> 4) == 0b1110)
          leftToCheck = 2;
        else if ((d >> 5) == 0b110)
          leftToCheck = 1;
        else if ((d >> 7) == 0b0)
          leftToCheck = 0;
        else
          return false;
      } else {
        if ((d >> 6) != 0b10)
          return false;
        --leftToCheck;
      }

    return leftToCheck == 0;
  }
};"
"class Solution:
    def minSteps(self, n: int) -> int:
        ans=0
        for d in range(2,n+1):
            while n%d==0:
                ans+=d
                n/=d
            if n<d:
                break
        return ans","class Solution {
 public:
  string decodeString(string s) {
    stack<pair<string, int>> stack;  // (prevStr, repeatCount)
    string currStr;
    int currNum = 0;

    for (const char c : s)
      if (isdigit(c)) {
        currNum = currNum * 10 + (c - '0');
      } else {
        if (c == '[') {
          stack.emplace(currStr, currNum);
          currStr = """";
          currNum = 0;
        } else if (c == ']') {
          const auto [prevStr, n] = stack.top();
          stack.pop();
          currStr = prevStr + getRepeatedStr(currStr, n);
        } else {
          currStr += c;
        }
      }

    return currStr;
  }

 private:
  // S * n times
  string getRepeatedStr(const string& s, int n) {
    string repeat;
    while (n--)
      repeat += s;
    return repeat;
  }
};"
"class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
        
        def fn(node): 
            """"""Return serialized sub-tree rooted at node.""""""
            if not node: return "" ""
            left, right = fn(node.left), fn(node.right)
            srl = "","".join((str(node.val), left, right))
            if seen.get(srl, 0) == 1: ans.append(node)
            seen[srl] = 1 + seen.get(srl, 0)
            return srl
        
        ans, seen = [], {}
        fn(root)
        return ans","class Solution {
 public:
  int longestSubstring(string s, int k) {
    int ans = 0;

    for (int n = 1; n <= 26; ++n)
      ans = max(ans, longestSubstringWithNUniqueCharacters(s, k, n));

    return ans;
  }

 private:
  int longestSubstringWithNUniqueCharacters(const string& s, int k, int n) {
    int ans = 0;
    int uniqueChars = 0;  // # of unique chars in window
    int noLessThanK = 0;  // # of chars >= k in window
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (count[s[r]] == 0)
        ++uniqueChars;
      if (++count[s[r]] == k)
        ++noLessThanK;
      while (uniqueChars > n) {
        if (count[s[l]] == k)
          --noLessThanK;
        if (--count[s[l]] == 0)
          --uniqueChars;
        ++l;
      }
      if (noLessThanK == n)  // Unique chars also == n
        ans = max(ans, r - l + 1);
    }

    return ans;
  }
};"
"class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
		#Generates node values depth-first from right-to-left
        def dftRtoL(root):
            if root.right: yield from dftRtoL(root.right)
            yield root.val
            if root.left: yield from dftRtoL(root.left)
        
		#Generates node values depth-first from left-to-right
        def dftLtoR(root):
            if root.left: yield from dftLtoR(root.left)
            yield root.val
            if root.right: yield from dftLtoR(root.right)
        
        pl, pr = dftLtoR(root), dftRtoL(root)
        l, r = next(pl), next(pr)
        
		#If the node values are equal then all nodes have been checked and there is no solution
        while l != r:
			#l+r is too small, decrease l
            if l + r < k:
                l = next(pl)
			#l+r is too big, increase r
            elif l + r > k:
                r = next(pr)
			#l+r == k, the solution is found
            else: return True
        return False","class Solution {
 public:
  int maxRotateFunction(vector<int>& nums) {
    const int sum = accumulate(begin(nums), end(nums), 0);
    int f = 0;

    // Calculate F(0) first
    for (int i = 0; i < nums.size(); ++i)
      f += i * nums[i];

    int ans = f;

    for (int i = nums.size() - 1; i > 0; --i) {
      f += sum - nums.size() * nums[i];
      ans = max(ans, f);
    }

    return ans;
  }
};"
"class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        if nums == []:
            return None
        else:
            node = TreeNode(max(nums))
        node.left = self.constructMaximumBinaryTree(nums[:nums.index(max(nums))])
        node.right = self.constructMaximumBinaryTree(nums[nums.index(max(nums))+1:])
        return node","class Solution {
 public:
  int integerReplacement(long n) {
    int ans = 0;

    for (; n > 1; ++ans)
      if ((n & 1) == 0)  // Ends w/ 0
        n >>= 1;
      else if (n == 3 || ((n >> 1) & 1) == 0)  // N = 3 or ends w/ 01
        --n;
      else  // Ends w/ 11
        ++n;

    return ans;
  }
};"
"class Solution:
    def printTree(self, root: TreeNode) -> List[List[str]]:
        ht = lambda node: 1 + max(ht(node.left), ht(node.right)) if node else 0 # height of binary tree 
        m = ht(root) # rows 
        n = 2**m - 1 # columns 
        
        def dfs(node, i, lo=0, hi=n): 
            """"""Populate ans via dfs.""""""
            if not node: return 
            mid = lo + hi >> 1
            ans[i][mid] = str(node.val)
            dfs(node.left, i+1, lo, mid) or dfs(node.right, i+1, mid+1, hi)

        ans = [[""""]*n for _ in range(m)]
        dfs(root, 0)
        return ans","class Solution {
 public:
  Solution(vector<int>& nums) : nums(move(nums)) {}

  int pick(int target) {
    int ans = -1;
    int range = 0;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == target && rand() % ++range == 0)
        ans = i;

    return ans;
  }

 private:
  vector<int> nums;
};"
"class Solution:
    def judgeCircle(self, moves: str) -> bool:
        x,y=0,0
        for i in range(len(moves)):
            if (moves[i] == 'L'):
                x += 1;
            if (moves[i] == 'R'):
                x -= 1;
            if (moves[i] == 'U'):
                y += 1;
            if (moves[i] == 'D'):
                y -= 1;
        return x==0 and y==0","class Solution {
 public:
  vector<double> calcEquation(vector<vector<string>>& equations,
                              vector<double>& values,
                              vector<vector<string>>& queries) {
    vector<double> ans;
    // graph[A][B] := A / B
    unordered_map<string, unordered_map<string, double>> graph;

    for (int i = 0; i < equations.size(); ++i) {
      const string& A = equations[i][0];
      const string& B = equations[i][1];
      graph[A][B] = values[i];
      graph[B][A] = 1 / values[i];
    }

    for (const vector<string>& query : queries) {
      const string& A = query[0];
      const string& C = query[1];
      if (!graph.count(A) || !graph.count(C))
        ans.push_back(-1);
      else
        ans.push_back(divide(graph, A, C, unordered_set<string>()));
    }

    return ans;
  }

 private:
  // Returns A / C
  double divide(
      const unordered_map<string, unordered_map<string, double>>& graph,
      const string& A, const string& C, unordered_set<string>&& seen) {
    if (A == C)
      return 1.0;

    seen.insert(A);

    // Value := A / B
    for (const auto& [B, value] : graph.at(A)) {
      if (seen.count(B))
        continue;
      const double res = divide(graph, B, C, move(seen));  // B / C
      if (res > 0)                                         // Valid result
        return value * res;  // A / C = (A / B) * (B / C)
    }

    return -1;  // Invalid result
  }
};"
"class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        li=[]
        ans=[]
        for i in range(len(arr)):
            diff=abs(arr[i]-x)
            heapq.heappush(li,[diff,arr[i]])
        for i in range(k):
            diff,val=heapq.heappop(li)
            ans.append(val)
        ans.sort()
        return ans","class Solution {
 public:
  int findNthDigit(int n) {
    int digitSize = 1;
    int startNum = 1;
    long count = 9;

    while (digitSize * count < n) {
      n -= digitSize * count;
      ++digitSize;
      startNum *= 10;
      count *= 10;
    }

    const int targetNum = startNum + (n - 1) / digitSize;
    const int index = (n - 1) % digitSize;
    return to_string(targetNum)[index] - '0';
  }
};"
"class Solution:
    def isPossible(self, nums: List[int]) -> bool:
        freq = {}
        for x in nums: freq[x] = 1 + freq.get(x, 0) # frequency table of nums
        
        seen = deque()
        for i, x in enumerate(nums):
            if i == 0 or nums[i-1] != x: 
                if (n := freq[x] - freq.get(x-1, 0)) > 0: seen.extend([x]*n)
                elif any(x - seen.popleft() < 3 for _ in range(-n)): return False 
                if not freq.get(x+1, 0) and any(x - seen.popleft() < 2 for _ in range(freq[x])): return False 
        return True","class Solution {
 public:
  vector<string> readBinaryWatch(int num) {
    vector<string> ans;
    dfs(num, 0, 0, 0, ans);
    return ans;
  }

 private:
  const vector<int> hours{1, 2, 4, 8};
  const vector<int> minutes{1, 2, 4, 8, 16, 32};

  void dfs(int n, int s, int h, int m, vector<string>& ans) {
    if (n == 0) {
      string time = to_string(h) + "":"" + (m < 10 ? ""0"" : """") + to_string(m);
      ans.push_back(time);
      return;
    }

    for (int i = s; i < hours.size() + minutes.size(); ++i)
      if (i < 4 && h + hours[i] < 12)
        dfs(n - 1, i + 1, h + hours[i], m, ans);
      else if (i >= 4 && m + minutes[i - 4] < 60)
        dfs(n - 1, i + 1, h, m + minutes[i - 4], ans);
  }
};"
"class Solution:
    def imageSmoother(self, M: List[List[int]]) -> List[List[int]]:
        m, n = len(M), len(M[0])
        # Calculate sums in the same row.
        for i in range(m):
            tmp = M[i][0]
            for j in range(1, n):
                value = M[i][j]
                M[i][j - 1] += value
                M[i][j] += tmp
                tmp = value

        # Calculate the sums by columns.
        for j in range(n):
            tmp = M[0][j]
            for i in range(1, m):
                value = M[i][j]
                M[i - 1][j] += value
                M[i][j] += tmp
                tmp = value
        
        # Calulate the number of cells.
        for i in range(m):
            x = 3 - (1 if i == 0 else 0) - (1 if i == m - 1 else 0)
            for j in range(n):
                y = 3 - (1 if j == 0 else 0) - (1 if j == n - 1 else 0)
                M[i][j] //= x * y
        return M","class Solution {
 public:
  string removeKdigits(string num, int k) {
    if (num.length() == k)
      return ""0"";

    string ans;
    vector<char> stack;

    for (int i = 0; i < num.length(); ++i) {
      while (k > 0 && !stack.empty() && stack.back() > num[i]) {
        stack.pop_back();
        --k;
      }
      stack.push_back(num[i]);
    }

    while (k-- > 0)
      stack.pop_back();

    for (const char c : stack) {
      if (c == '0' && ans.empty())
        continue;
      ans += c;
    }

    return ans.empty() ? ""0"" : ans;
  }
};"
"class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        if not root:
            return 0
        L=[[root]]
        V=[[0]]
        while L[-1]:
            R=[]
            S=[]
            for i in range(len(L[-1])):
                if L[-1][i].left:
                    S.append(2*V[-1][i])
                    R.append(L[-1][i].left)
                if L[-1][i].right:
                    S.append(2*V[-1][i]+1)
                    R.append(L[-1][i].right)
            V.append(S)
            L.append(R)
        v=[S[-1]-S[0]+1 for S in V if S]
        return max(v)","class Solution {
 public:
  bool canCross(vector<int>& stones) {
    const int n = stones.size();
    // dp[i][j] := true if a frog can make a size j jump to stones[i]
    vector<vector<bool>> dp(n, vector<bool>(n + 1));
    dp[0][0] = true;

    for (int i = 1; i < n; ++i)
      for (int j = 0; j < i; ++j) {
        const int k = stones[i] - stones[j];
        if (k > n)
          continue;
        for (const int x : {k - 1, k, k + 1})
          if (0 <= x && x <= n)
            dp[i][k] = dp[i][k] || dp[j][x];
      }

    return any_of(begin(dp.back()), end(dp.back()),
                  [](bool val) { return val; });
  }
};"
"class Solution:
    def strangePrinter(self, s: str) -> int:
        s = """".join(ch for i, ch in enumerate(s) if i == 0 or s[i-1] != ch)
        
        @cache
        def fn(lo, hi): 
            """"""Return min ops to print s[lo:hi].""""""
            if lo == hi: return 0
            ans = 1 + fn(lo+1, hi)
            for mid in range(lo+1, hi): 
                if s[lo] == s[mid]: 
                    ans = min(ans, fn(lo, mid) + fn(mid+1, hi))
            return ans 
        
        return fn(0, len(s))","class Solution {
 public:
  int sumOfLeftLeaves(TreeNode* root) {
    if (root == nullptr)
      return 0;

    int ans = 0;

    if (root->left) {
      if (root->left->left == nullptr && root->left->right == nullptr)
        ans += root->left->val;
      else
        ans += sumOfLeftLeaves(root->left);
    }
    ans += sumOfLeftLeaves(root->right);

    return ans;
  }
};"
"class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        changes = 0
        for i, j in zip(range(0, len(nums) - 1), range(1, len(nums))):
            if nums[j] < nums[i]:
                lchanges, rchanges = 0, 0
                for x in reversed(range(0, j)):
                    if nums[x] > nums[j]:
                        lchanges += 1
                        if lchanges == 2:
                            break;
                    else:
                        break
                for y in range(j, len(nums)):
                    if nums[y] < nums[i]:
                        rchanges += 1
                        if rchanges == 2:
                            break
                    else:
                        break
                changes += min(lchanges, rchanges)
                if changes >= 2:
                    return False
        return True","class Solution {
 public:
  string toHex(unsigned num) {
    const vector<char> hex{'0', '1', '2', '3', '4', '5', '6', '7',
                           '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    string ans;

    while (num) {
      ans += hex[num & 0xf];
      num >>= 4;
    }

    reverse(begin(ans), end(ans));
    return ans.empty() ? ""0"" : ans;
  }
};"
"class Solution:
    def constructArray(self, n: int, k: int) -> List[int]:
        t=[i for i in range(1,n+1)]
        for j in range(1,k):
            t[j:]=t[j:][::-1]
        return t","class Solution {
 public:
  vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
    vector<vector<int>> ans;

    sort(begin(people), end(people), [](const auto& a, const auto& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] > b[0];
    });

    for (const vector<int>& p : people)
      ans.insert(begin(ans) + p[1], p);

    return ans;
  }
};"
"class Solution:
    def findKthNumber(self, m: int, n: int, k: int) -> int:
        pq = [(1, 1, 1)]    # Priority queue (table[i][j], i, j)
        seen = set((1,1))   # Visited nodes
        
        # Traverse the first k-1 nodes
        for i in range(1, k):
            # Pop ith smallest node
            cur, a, b = heappop(pq)
            
            # Add right node if it hasn't been seen to pq
            if a < m and (a+1, b) not in seen: 
                heappush(pq, (cur+b, a+1, b))
                seen.add((a+1, b))
            
            # Add left node if it hasn't been seen to pq
            if b < n and (a, b+1) not in seen: 
                heappush(pq, (cur+a, a, b+1))
                seen.add((a, b+1))
        
        # Next node in priority queue is the kth smallest node
        return heappop(pq)[0]","struct T {
  int i;
  int j;
  int h;  // heightMap[i][j] or the height after filling water
  T(int i, int j, int h) : i(i), j(j), h(h) {}
};

class Solution {
 public:
  int trapRainWater(vector<vector<int>>& heightMap) {
    const int m = heightMap.size();
    const int n = heightMap[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = 0;
    auto compare = [](const T& a, const T& b) { return a.h > b.h; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i) {
      minHeap.emplace(i, 0, heightMap[i][0]);
      minHeap.emplace(i, n - 1, heightMap[i][n - 1]);
      seen[i][0] = true;
      seen[i][n - 1] = true;
    }

    for (int j = 1; j < n - 1; ++j) {
      minHeap.emplace(0, j, heightMap[0][j]);
      minHeap.emplace(m - 1, j, heightMap[m - 1][j]);
      seen[0][j] = true;
      seen[m - 1][j] = true;
    }

    while (!minHeap.empty()) {
      const auto [i, j, h] = minHeap.top();
      minHeap.pop();
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        if (heightMap[x][y] < h) {
          ans += h - heightMap[x][y];
          minHeap.emplace(x, y, h);  // Fill the water on grid[x][y]
        } else {
          minHeap.emplace(x, y, heightMap[x][y]);
        }
        seen[x][y] = true;
      }
    }

    return ans;
  }
};"
"class Solution:
    def trimBST(self, root: TreeNode, L: int, R: int) -> TreeNode:
        # iterative
        if root is None: return None
        
        while root and (root.val < L or root.val > R):
            if root.val < L: root = root.right
            else: root = root.left
        
        lnode = rnode = root
        while lnode.left:
            if lnode.left.val < L:
                lnode.left = lnode.left.right
            else: lnode = lnode.left
        while rnode.right:
            if rnode.right.val > R:
                rnode.right = rnode.right.left
            else: rnode = rnode.right
        return root","class Solution {
 public:
  bool validWordAbbreviation(const string& word, const string& abbr) {
    int i = 0;  // word's index
    int j = 0;  // abbr's index

    while (i < word.length() && j < abbr.length()) {
      if (word[i] == abbr[j]) {
        ++i;
        ++j;
        continue;
      }
      if (abbr[j] <= '0' || abbr[j] > '9')
        return false;
      int num = 0;
      while (j < abbr.length() && isdigit(abbr[j])) {
        num = num * 10 + abbr[j] - '0';
        ++j;
      }
      i += num;
    }

    return i == word.length() && j == abbr.length();
  }
};"
"class Solution:
    def maximumSwap(self, num: int) -> int:
        num = str(num)
        
        for i in range(len(num)):
            max_number = max([k for k in num[i:]])
            index = max([k for k in range(i, len(num)) if num[k]==max_number])
            
            if int(num[i])<int(max_number):
			    # String does not support item assignment, so using slicing for swapping the elements.
                num = num[:i] + num[index] + num[i+1:index] + num[i] + num[index+1:]
                break
                
        return int(num)","class Solution {
 public:
  int longestPalindrome(string s) {
    int ans = 0;
    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (const int c : count)
      ans += c % 2 == 0 ? c : c - 1;

    const bool hasOddCount =
        any_of(begin(count), end(count), [](int c) { return c & 1; });

    return ans + hasOddCount;
  }
};"
"class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        if not root.left:
            return -1

        if not root:
            return -1
        left=self.findSecondMinimumValue(root.left)
        right = self.findSecondMinimumValue(root.right)
        if root.right.val>root.val:
            if left==-1:
                return root.right.val
            else:
                return min(left,root.right.val)
        elif root.left.val>root.val:
            if right==-1:
                return root.left.val
            else:
                return min(right,root.left.val)
        else:
            if left==-1:
                return right
            if right==-1:
                return left
            return min(left, right)","class Solution {
 public:
  int splitArray(vector<int>& nums, int m) {
    const int n = nums.size();
    // dp[i][k] := min of largest sum to split first i nums into k groups
    dp.resize(n + 1, vector<int>(m + 1, INT_MAX));
    prefix.resize(n + 1);

    partial_sum(begin(nums), end(nums), begin(prefix) + 1);
    return splitArray(nums, n, m);
  }

 private:
  vector<vector<int>> dp;
  vector<int> prefix;

  int splitArray(const vector<int>& nums, int i, int k) {
    if (k == 1)
      return prefix[i];
    if (dp[i][k] < INT_MAX)
      return dp[i][k];

    // Try all possible partitions
    for (int j = k - 1; j < i; ++j)
      dp[i][k] =
          min(dp[i][k], max(splitArray(nums, j, k - 1), prefix[i] - prefix[j]));

    return dp[i][k];
  }
};"
"class Solution:
    # Operations: O(flip odds), E(flip evens), A(flip all), T(flip 3k + 1), N(flip nothing)
    states = {
        'N': 0b000,
        'A': 0b111,
        'O': 0b101,
        'E': 0b010,
        'T': 0b001,
        'AT': 0b111 ^ 0b001,
        'OT': 0b101 ^ 0b001,
        'ET': 0b010 ^ 0b001,
    }
    steps = {
        0: ['N'],
        1: ['A', 'O', 'E', 'T'],
        2: ['N', 'A', 'O', 'E', 'AT', 'OT', 'ET'],
        3: states.keys(),
    }
    def flipLights(self, n: int, m: int) -> int:
        n, m = min(n, 3), min(m, 3)
        mask = (1 << n) - 1
        ans = set()
        for s in self.steps[m]:
            ans.add((0b111 ^ self.states[s]) &amp; mask)
        return len(ans)","class Solution {
 public:
  string minAbbreviation(string target, vector<string>& dictionary) {
    const int m = target.length();
    vector<int> masks;

    for (const string& word : dictionary) {
      if (word.length() != m)
        continue;
      masks.push_back(getMask(target, word));
    }

    if (masks.empty())
      return to_string(m);

    vector<string> abbrs;

    const int maxCand = pow(2, m);
    // For all candidate representation of target
    for (int cand = 0; cand < maxCand; ++cand)
      // All masks have at lease one bit different from candidate
      if (all_of(begin(masks), end(masks),
                 [cand](int mask) { return cand & mask; }))
        abbrs.push_back(getAbbr(target, cand));

    string ans = target;

    for (const string& abbr : abbrs)
      if (getAbbrLen(abbr) < getAbbrLen(ans))
        ans = abbr;

    return ans;
  }

 private:
  int getMask(const string& target, const string& word) {
    const int m = target.length();
    // mask[i] = 0 := target[i] == word[i]
    // mask[i] = 1 := target[i] != word[i]
    // E.g. target = ""apple""
    //        word = ""blade""
    //        mask =  11110
    int mask = 0;
    for (int i = 0; i < m; ++i)
      if (word[i] != target[i])
        mask |= 1 << m - 1 - i;
    return mask;
  }

  string getAbbr(const string& target, int cand) {
    const int m = target.length();
    string abbr;
    int replacedCount = 0;
    for (int i = 0; i < m; ++i)
      if (cand >> m - 1 - i & 1) {
        // cand[i] = 1, abbr should show the original character
        if (replacedCount > 0)
          abbr += to_string(replacedCount);
        abbr += target[i];
        replacedCount = 0;
      } else {
        // cand[i] = 0, abbr can be replaced
        ++replacedCount;
      }
    if (replacedCount > 0)
      abbr += to_string(replacedCount);
    return abbr;
  }

  int getAbbrLen(const string& abbr) {
    int abbrLen = 0;
    int i = 0;
    int j = 0;
    while (i < abbr.length()) {
      if (isalpha(abbr[j]))
        ++j;
      else
        while (j < abbr.length() && isdigit(abbr[j]))
          ++j;
      ++abbrLen;
      i = j;
    }
    return abbrLen;
  }
};"
"class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        lis = [[1, 1] for _ in nums] # longest increasing subsequence (length &amp; count)
        for i, x in enumerate(nums): 
            for ii in range(i): 
                if nums[ii] < x: 
                    if lis[ii][0] + 1 > lis[i][0]: lis[i] = [1 + lis[ii][0], lis[ii][1]]
                    elif lis[ii][0] + 1 == lis[i][0]: lis[i][1] += lis[ii][1]
        mx, _ = max(lis, default=(0, 0))
        return sum(y for x, y in lis if x == mx)","class Solution {
 public:
  vector<string> fizzBuzz(int n) {
    vector<string> ans;

    for (int i = 1; i <= n; ++i) {
      string s;
      if (i % 3 == 0)
        s += ""Fizz"";
      if (i % 5 == 0)
        s += ""Buzz"";
      ans.push_back(s.empty() ? to_string(i) : s);
    }

    return ans;
  }
};"
"class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        curlen = 0
        maxlen = 0
        if not nums:
            return 0
        for i in nums:
            if nums[i] < nums[i+1]:
                curlen +=1
                maxlen = curlen
        return maxlen","class Solution {
 public:
  int numberOfArithmeticSlices(vector<int>& nums) {
    const int n = nums.size();
    if (n < 3)
      return 0;

    vector<int> dp(n);  // # arithmetic slices ends at i

    for (int i = 2; i < nums.size(); ++i)
      if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2])
        dp[i] = dp[i - 1] + 1;

    return accumulate(begin(dp), end(dp), 0);
  }
};"
"class Solution:
    def cutOffTree(self, forest: List[List[int]]) -> int:
        a = []
        n = len(forest)
        m = len(forest[0])
        for i in range(n):
            for j in range(m):
                if forest[i][j] > 1:
                    a.append(forest[i][j])
        a.sort()
        
        s = 0
        ux = 0
        uy = 0
        for h in a:
            if forest[ux][uy] == h:
                continue        
            dist = [[None] * m for i in range(n)]
            q = deque()
            q.append((ux, uy))
            dist[ux][uy] = 0
            found = False
            while q and not found:
                ux, uy = q.popleft()
                d = [(-1, 0), (0, 1), (1, 0), (0, -1)]
                for dx, dy in d:
                    vx = ux + dx
                    vy = uy + dy
                    if vx < 0 or vx >= n or vy < 0 or vy >= m:
                        continue
                    if forest[vx][vy] == 0:
                        continue
                    if dist[vx][vy] is None:
                        dist[vx][vy] = dist[ux][uy] + 1
						# It's important to stop here! Otherwise there will be TLE
                        if forest[vx][vy] == h:
                            s += dist[vx][vy]
                            ux = vx
                            uy = vy
                            found = True
                            break
                        q.append((vx, vy))
            if not found:
                return -1
        return s","class Solution {
 public:
  int thirdMax(vector<int>& nums) {
    long max1 = LONG_MIN;  // The maximum
    long max2 = LONG_MIN;  // 2nd maximum
    long max3 = LONG_MIN;  // 3rd maximum

    for (const int num : nums)
      if (num > max1) {
        max3 = max2;
        max2 = max1;
        max1 = num;
      } else if (max1 > num && num > max2) {
        max3 = max2;
        max2 = num;
      } else if (max2 > num && num > max3) {
        max3 = num;
      }

    return max3 == LONG_MIN ? max1 : max3;
  }
};"
"class Solution:
    def valid(self, s, stack=[]):
        i, l = 0, len(s)
        if not l:
            return True
        
        while i<l:
            c = s[i]
            if c == '(':
                stack.append(c)
                
            elif c == ')':
                if stack and stack[-1] == '(':
                    stack.pop()
                else:
                    return False
                
            else:
                sub = s[i+1:]
                return (self.valid('('+sub, stack[:])
                       or self.valid(')'+sub, stack[:])
                       or self.valid(sub, stack[:]))
            
            i += 1
            
        return True if len(stack)==0 else False
    
    
    def checkValidString(self, s: str) -> bool:
        return self.valid(s)","class Solution {
 public:
  string addStrings(string num1, string num2) {
    string ans;
    int carry = 0;
    int i = num1.length() - 1;
    int j = num2.length() - 1;

    while (i >= 0 || j >= 0 || carry) {
      if (i >= 0)
        carry += num1[i--] - '0';
      if (j >= 0)
        carry += num2[j--] - '0';
      ans += carry % 10 + '0';
      carry /= 10;
    }

    reverse(begin(ans), end(ans));
    return ans;
  }
};"
"class Solution:
    def validPalindrome(self, s: str) -> bool:
        n=len(s)
        left,right=0,n-1
        cnt=0
        while left<=right:
            if s[left]==s[right]:
                left+=1
                right-=1
            else:
                if cnt==1:
                    return False
                else:
                    if self.check(s,left+1,right):
                        left+=1
                    elif self.check(s,left,right-1):
                        right-=1
                    else:
                        return False
                    cnt+=1
        return True
    def check(self,s,left,right):
        if s[left:right+1]==s[left:right+1][::-1]:
            return True
        return False","class Solution {
 public:
  bool canPartition(vector<int>& nums) {
    const int sum = accumulate(begin(nums), end(nums), 0);
    if (sum & 1)
      return false;
    return knapsack(nums, sum / 2);
  }

 private:
  bool knapsack(const vector<int>& nums, int subsetSum) {
    const int n = nums.size();
    // dp[i][j] := true if j can be formed by nums[0..i)
    vector<vector<bool>> dp(n + 1, vector<bool>(subsetSum + 1));
    dp[0][0] = true;

    for (int i = 1; i <= n; ++i) {
      const int num = nums[i - 1];
      for (int j = 0; j <= subsetSum; ++j)
        if (j < num)
          dp[i][j] = dp[i - 1][j];
        else
          dp[i][j] = dp[i - 1][j] || dp[i - 1][j - num];
    }

    return dp[n][subsetSum];
  }
};"
"class Solution:
    def calPoints(self, ops: List[str]) -> int:
        res = []
        for i in ops:
            if i == 'C':
                res.pop()
            elif i == 'D':
                x = res[len(res)-1]
                res.append(2*x)
            elif i == '+':
                x = res[len(res) - 1]
                y = res[len(res) - 2]
                res.append(x+y)
            else:
                res.append(int(i))
            
            
        return sum(res)","class Solution {
 public:
  vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
    const int m = heights.size();
    const int n = heights[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    vector<vector<int>> ans;
    queue<pair<int, int>> qP;
    queue<pair<int, int>> qA;
    vector<vector<bool>> seenP(m, vector<bool>(n));
    vector<vector<bool>> seenA(m, vector<bool>(n));

    auto bfs = [&](queue<pair<int, int>>& q, vector<vector<bool>>& seen) {
      while (!q.empty()) {
        const auto [i, j] = q.front();
        q.pop();
        const int h = heights[i][j];
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (seen[x][y] || heights[x][y] < h)
            continue;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
    };

    for (int i = 0; i < m; ++i) {
      qP.emplace(i, 0);
      qA.emplace(i, n - 1);
      seenP[i][0] = true;
      seenA[i][n - 1] = true;
    }

    for (int j = 0; j < n; ++j) {
      qP.emplace(0, j);
      qA.emplace(m - 1, j);
      seenP[0][j] = true;
      seenA[m - 1][j] = true;
    }

    bfs(qP, seenP);
    bfs(qA, seenA);

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (seenP[i][j] && seenA[i][j])
          ans.push_back({i, j});

    return ans;
  }
};"
"class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        dict={}
        n=len(edges)
        for i in range(1,n+1):
            dict[i]=i
            
        def find_parent(u):
            if dict[u]==u:
                
                return u
            else:
                a=find_parent(dict[u])
                
                dict[u]=a
                return a
            
        for i,j in edges:
            u=find_parent(i)
            v=find_parent(j)
            
            if u==v:
                return [i,j]
            else:
                dict[v]=u","class Solution {
 public:
  int wordsTyping(vector<string>& sentence, int rows, int cols) {
    const string& combined = getCombined(sentence);
    const int n = combined.length();
    int i = 0;  // (i % n) points to the index of combined in each row

    while (rows--) {
      i += cols;
      if (combined[i % n] == ' ') {
        ++i;
      } else {
        while (i > 0 && combined[(i - 1) % n] != ' ')
          --i;
      }
    }

    return i / n;
  }

 private:
  string getCombined(const vector<string>& sentence) {
    string combined;
    for (const string& word : sentence)
      combined += (word + ' ');
    return combined;
  }
};"
"class Solution:
    def longestUnivaluePathUtil(self, root: TreeNode, maxCounter) -> int:
        counter = 0
        counterChoose = [0]
        if root!=None:
            if root.left!=None:
                temp = self.longestUnivaluePathUtil(root.left, maxCounter) + 1
                if root.val==root.left.val:
                    counterChoose.append(temp)
                    counter+= temp
            if root.right!=None:
                temp = self.longestUnivaluePathUtil(root.right, maxCounter) + 1
                if root.val==root.right.val:
                    counter+= temp
                    counterChoose.append(temp)
        maxCounter[0] = max(maxCounter[0], counter)
        return max(counterChoose)
    def longestUnivaluePath(self, root: TreeNode) -> int:
        maxCounter = [0]
        self.longestUnivaluePathUtil(root, maxCounter)
        return maxCounter[0]","class Solution {
 public:
  int countBattleships(vector<vector<char>>& board) {
    int ans = 0;

    for (int i = 0; i < board.size(); ++i)
      for (int j = 0; j < board[0].size(); ++j) {
        if (board[i][j] == '.')
          continue;
        if (i > 0 && board[i - 1][j] == 'X')
          continue;
        if (j > 0 && board[i][j - 1] == 'X')
          continue;
        ++ans;
      }

    return ans;
  }
};"
"class Solution:
    def __init__(self):
        self.possibleMoves = [(-2,1),(-1,2),(1,2),(2,1),(2,-1),(1,-2),(-1,-2),(-2,-1)]
        self.mem = dict()
        
    def isInside(self, r, c, N):
        if r < 0 or c < 0 or r >= N or c >= N:
            return False
        return True
    
    def Util(self, N, K, r, c):
        if K == 0:
            return 1
        if (K, r, c) in self.mem:
            return self.mem[(K, r, c)]
        total = 0
        for i, j in self.possibleMoves:
            if self.isInside(r + i, c + j, N):
                corMoves = self.Util(N, K - 1, r + i, c + j)
                total += corMoves
        self.mem[(K, r, c)] = total
        return total
    
    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:
        totalPossible = self.Util(N, K, r, c)
        return totalPossible / 8 ** K","class Solution {
 public:
  int strongPasswordChecker(string s) {
    const int n = s.length();
    const int missing = getMissing(s);
    // # of replacements to deal with 3 repeating characters
    int replaces = 0;
    // # of seqs that can be substituted with 1 deletions, (3k)-seqs
    int oneSeq = 0;
    // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs
    int twoSeq = 0;

    for (int i = 2; i < n;)
      if (s[i] == s[i - 1] && s[i - 1] == s[i - 2]) {
        int length = 2;  // Length of repeating s
        while (i < n && s[i] == s[i - 1]) {
          ++length;
          ++i;
        }
        replaces += length / 3;  // 'aaaaaaa' -> 'aaxaaxa'
        if (length % 3 == 0)
          ++oneSeq;
        if (length % 3 == 1)
          ++twoSeq;
      } else {
        ++i;
      }

    if (n < 6)
      return max(6 - n, missing);
    if (n <= 20)
      return max(replaces, missing);

    const int deletes = n - 20;
    // Each replacement in (3k)-seqs can be substituted with 1 deletions
    replaces -= min(oneSeq, deletes);
    // Each replacement in (3k + 1)-seqs can be substituted with 2 deletions
    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) / 2;
    // Each replacement in other seqs can be substituted with 3 deletions
    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) / 3;
    return deletes + max(replaces, missing);
  }

 private:
  int getMissing(const string& s) {
    int missing = 3;
    if (any_of(begin(s), end(s), [](char c) { return isupper(c); }))
      --missing;
    if (any_of(begin(s), end(s), [](char c) { return islower(c); }))
      --missing;
    if (any_of(begin(s), end(s), [](char c) { return isdigit(c); }))
      --missing;
    return missing;
  }
};"
"class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        curr = sum(nums[:k])
        # groups of sum-k 
        g = [0]*n
        for i in range(n-k+1):
            g[i] = curr
            if i+k < n:
                curr += nums[i+k] - nums[i]
        # pre[i]: the previous group index with maximum sum when i is the center group
        pre = [0]*n
        for i in range(k+1, n-2*k+1):
            pre[i] = pre[i-1] if g[pre[i-1]] >= g[i-k] else i-k
        # after[i]: the next group index with maximum sum when i is the center group
        after = [n-k]*n
        for i in range(n-2*k, k-1, -1):
            after[i] = after[i+1] if g[after[i+1]] > g[i+k] else i+k
        
        # Final iteration: find the maximum total sum with their group index 
        ans = []
        S = 0
        for i in range(k, n-2*k+1):
            curr = g[pre[i]] + g[i] + g[after[i]]
            if curr > S:
                S = curr
                ans = [pre[i], i, after[i]]
        return ans","class Solution {
 public:
  int findMaximumXOR(vector<int>& nums) {
    const int maxNum = *max_element(begin(nums), end(nums));
    if (maxNum == 0)
      return 0;
    const int maxBit = static_cast<int>(log2(maxNum));
    int ans = 0;
    int mask = 0;

    // If ans is 11100 when i = 2, it means that before we reach the last two
    // bits, 11100 is the maximum XOR we have, and we're going to explore if we
    // can get another two '1's and put them into ans.
    for (int i = maxBit; i >= 0; --i) {
      // Mask grows like: 100...000, 110...000, 111...000, ..., 111...111.
      mask |= 1 << i;
      unordered_set<int> prefixes;
      // We only care about the left parts,
      // If i = 2, nums = {1110, 1011, 0111}
      //    -> prefixes = {1100, 1000, 0100}
      for (const int num : nums)
        prefixes.insert(num & mask);
      // If i = 1 and before this iteration, the ans is 10100, it means that we
      // want to grow the ans to 10100 | 1 << 1 = 10110 and we're looking for
      // XOR of two prefixes = candidate.
      const int candidate = ans | 1 << i;
      for (const int prefix : prefixes)
        if (prefixes.count(prefix ^ candidate)) {
          ans = candidate;
          break;
        }
    }

    return ans;
  }
};"
"class Solution(object):
    def getImportance(self, employees, id):
        """"""
        :type employees: Employee
        :type id: int
        :rtype: int
        """"""
        d = dict()
        for node in employees:
            d[node.id] = node
            
        def Importance(node):
            if len(node.subordinates)==0:
                return node.importance
            else:
                S = node.importance
                for _id in node.subordinates:
                    S += Importance(d[_id])
                return S
                
        return Importance(d[id])","class Solution {
 public:
  bool validWordSquare(vector<string>& words) {
    for (int i = 0; i < words.size(); ++i)
      for (int j = 0; j < words[i].size(); ++j) {
        if (words.size() <= j || words[j].size() <= i)  // Out of bound
          return false;
        if (words[i][j] != words[j][i])
          return false;
      }

    return true;
  }
};"
"class Solution:
    def minStickers(self, stickers: List[str], target: str) -> int:

        stickers = [Counter(s) for s in stickers if set(s)&amp;set(target)]
        dp = {}
        def generate(target):
            if not target: return 0
            if target in dp: return dp[target]
            
            target_counter = Counter(target)
            res = float(""inf"")
            for sticker in stickers:
                if sticker[target[0]] == 0: continue
                tmp = 1 + generate("""".join([letter*count for letter,count in (target_counter-sticker).items()]))

                res = min(res,tmp)
            dp[target] = res
            return res

        res = generate(target)
        return -1 if res == float(""inf"") else res","class Solution {
 public:
  string originalDigits(string s) {
    string ans;
    vector<int> count(10);

    for (const char c : s) {
      if (c == 'z')
        ++count[0];
      if (c == 'o')
        ++count[1];
      if (c == 'w')
        ++count[2];
      if (c == 'h')
        ++count[3];
      if (c == 'u')
        ++count[4];
      if (c == 'f')
        ++count[5];
      if (c == 'x')
        ++count[6];
      if (c == 's')
        ++count[7];
      if (c == 'g')
        ++count[8];
      if (c == 'i')
        ++count[9];
    }

    count[1] -= count[0] + count[2] + count[4];
    count[3] -= count[8];
    count[5] -= count[4];
    count[7] -= count[6];
    count[9] -= count[5] + count[6] + count[8];

    for (int i = 0; i < 10; ++i)
      for (int j = 0; j < count[i]; ++j)
        ans += i + '0';

    return ans;
  }
};"
"class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        """"""
        Firstly, we use a Counter to count the frequency of each word within
        words, assigning the outcome as count. Then, for each key, value pair
        in count, a tuple of (value, key) is created, which is subsequently 
        sorted using a lambda of -x[0] (the frequency, sorted high to low), and 
        the lexographical order within the frequency. Finally, the k largest
        values of words are returned.
        
        :param words: the words to be considered. (List[str])
        :param k: the number of words to be considered. (int)
        :return outcome_list: the list containing the outcome. (List[str])
        """"""
        words = ((value, key) for key, value in Counter(words).items())
        words = sorted(words, key=lambda x: (-x[0], x[1]))
        return [value for key, value in words[:k]]","class Solution {
 public:
  int characterReplacement(string s, int k) {
    int ans = 0;
    int maxCount = 0;
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      maxCount = max(maxCount, ++count[s[r]]);
      while (maxCount + k < r - l + 1)
        --count[s[l++]];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};"
"class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        while True:
            previous_bit = n &amp; 1
            n >>= 1
            if not n:
                return True
            
            current_bit = n &amp; 1
            if previous_bit == current_bit:
                return False
            previous_bit = current_bit","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  vector<const string*> startsWith;
  TrieNode() : children(26) {}
};

class Trie {
 public:
  Trie(const vector<string>& words) {
    for (const string& word : words)
      insert(word);
  }

  vector<const string*> findBy(const string& prefix) {
    shared_ptr<TrieNode> node = root;
    for (const char c : prefix) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        return {};
      node = node->children[i];
    }
    return node->startsWith;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
      node->startsWith.push_back(&word);
    }
  }
};

class Solution {
 public:
  vector<vector<string>> wordSquares(vector<string>& words) {
    if (words.empty())
      return {};

    const int n = words[0].length();
    vector<vector<string>> ans;
    vector<string> path;
    Trie trie(words);

    for (const string& word : words) {
      path.push_back(word);
      dfs(trie, n, path, ans);
      path.pop_back();
    }

    return ans;
  }

 private:
  void dfs(Trie& trie, const int n, vector<string>& path,
           vector<vector<string>>& ans) {
    if (path.size() == n) {
      ans.push_back(path);
      return;
    }

    const string prefix = getPrefix(path);

    for (const string* s : trie.findBy(prefix)) {
      path.push_back(*s);
      dfs(trie, n, path, ans);
      path.pop_back();
    }
  }

  // E.g. path = [""wall"",
  //              ""area""]
  //    prefix =  ""le..""
  string getPrefix(const vector<string>& path) {
    string prefix;
    const int index = path.size();
    for (const string& s : path)
      prefix += s[index];
    return prefix;
  }
};"
"class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        def dfs(i,j):
            if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]==0:
                return 0
            grid[i][j]=0
            down = dfs(i+1,j)
            up = dfs(i-1,j)
            right = dfs(i,j+1)
            left = dfs(i,j-1)
            a = 1+(up+down+right+left)
            return a
        ans = 0
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                ans = max(ans,dfs(row,col))
        return ans","class Solution {
 public:
  Node* treeToDoublyList(Node* root) {
    if (root == nullptr)
      return nullptr;

    Node* leftHead = treeToDoublyList(root->left);
    Node* rightHead = treeToDoublyList(root->right);
    root->left = root;
    root->right = root;
    return connect(connect(leftHead, root), rightHead);
  }

 private:
  Node* connect(Node* node1, Node* node2) {
    if (node1 == nullptr)
      return node2;
    if (node2 == nullptr)
      return node1;

    Node* tail1 = node1->left;
    Node* tail2 = node2->left;

    // Connect node1's tail with node2
    tail1->right = node2;
    node2->left = tail1;

    // Connect node2's tail with node1
    tail2->right = node1;
    node1->left = tail2;
    return node1;
  }
};"
"class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        group_lens = [len(list(g)) for _, g in groupby(s)]
        return sum(min(a, b) for a, b in zip(group_lens, group_lens[1:]))","class Solution {
 public:
  Node* construct(vector<vector<int>>& grid) {
    return helper(grid, 0, 0, grid.size());
  }

 private:
  Node* helper(const vector<vector<int>>& grid, int i, int j, int w) {
    if (allSame(grid, i, j, w))
      return new Node(grid[i][j], true);

    Node* node = new Node(true, false);
    node->topLeft = helper(grid, i, j, w / 2);
    node->topRight = helper(grid, i, j + w / 2, w / 2);
    node->bottomLeft = helper(grid, i + w / 2, j, w / 2);
    node->bottomRight = helper(grid, i + w / 2, j + w / 2, w / 2);
    return node;
  }

  bool allSame(const vector<vector<int>>& grid, int i, int j, int w) {
    return all_of(begin(grid) + i, begin(grid) + i + w,
                  [&](const vector<int>& row) {
      return all_of(begin(row) + j, begin(row) + j + w,
                    [&](int num) { return num == grid[i][j]; });
    });
  }
};"
"class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        d = {}
        m, j, count = 1, [nums[0]], []
        for i in nums:
            if i not in d:
                d[i] = 1
            else:
                d[i] += 1
                if d[i] > m:
                    m = d[i]
                    j = [i]
                elif d[i] == m:
                    j.append(i)
        for i in j:
            count.append(len(nums) - nums[::-1].index(i) - nums.index(i))
        return min(count)","class Codec {
 public:
  // Encodes a tree to a single string.
  string serialize(Node* root) {
    if (root == nullptr)
      return """";

    string s;
    queue<Node*> q{{root}};
    s += to_string(root->val) + "" "";

    while (!q.empty())
      for (int sz = q.size(); sz > 0; --sz) {
        Node* node = q.front();
        q.pop();
        if (node->children.empty()) {
          s += ""n"";
        } else {
          for (Node* child : node->children) {
            q.push(child);
            s += to_string(child->val) + ""#"";
          }
        }
        s += "" "";
      }

    return s;
  }

  // Decodes your encoded data to tree.
  Node* deserialize(string data) {
    if (data.empty())
      return nullptr;

    istringstream iss(data);
    string word;
    iss >> word;
    Node* root = new Node(stoi(word));
    queue<Node*> q{{root}};

    while (iss >> word) {
      Node* parent = q.front();
      q.pop();
      vector<string> kids = getKids(word);
      vector<Node*> children;
      for (const string& kid : kids) {
        if (kid == ""n"")
          continue;
        Node* child = new Node(stoi(kid));
        children.push_back(child);
        q.push(child);
      }
      parent->children = children;
    }

    return root;
  }

 private:
  vector<string> getKids(const string& word) {
    vector<string> kids;
    for (int i = 0, j = 0; j < word.length(); ++j)
      if (word[j] == '#') {
        kids.push_back(word.substr(i, j - i));
        i = j + 1;
      }
    return kids;
  }
};"
"class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        total = sum(nums)
        if total % k: return False 
        
        avg = total // k
        
        @cache
        def fn(x, mask):
            """"""Return True if available elements can be parititioned.""""""
            if x > avg: return False 
            if x == avg: return fn(0, mask)
            if not mask: return True 
            for i in range(len(nums)): 
                if mask &amp; 1<<i and fn(x + nums[i], mask ^ 1<<i): return True 
            return False 
        
        nums.sort(reverse=True)
        return fn(0, (1 << len(nums))-1)","class Solution {
 public:
  vector<vector<int>> levelOrder(Node* root) {
    if (root == nullptr)
      return {};

    vector<vector<int>> ans;
    queue<Node*> q{{root}};

    while (!q.empty()) {
      vector<int> currLevel;
      for (int sz = q.size(); sz > 0; --sz) {
        Node* node = q.front();
        q.pop();
        currLevel.push_back(node->val);
        for (Node* child : node->children)
          q.push(child);
      }
      ans.push_back(currLevel);
    }

    return ans;
  }
};"
"class Solution:
    def fallingSquares(self, positions: List[List[int]]) -> List[int]:
        ans = []
        for i, (x, l) in enumerate(positions): 
            val = 0
            for ii in range(i): 
                xx, ll = positions[ii]
                if xx < x+l and x < xx+ll: val = max(val, ans[ii])
            ans.append(val + l)
        for i in range(1, len(ans)): ans[i] = max(ans[i-1], ans[i])
        return ans","class Solution {
 public:
  Node* flatten(Node* head, Node* rest = nullptr) {
    if (head == nullptr)
      return rest;

    head->next = flatten(head->child, flatten(head->next, rest));
    if (head->next)
      head->next->prev = head;
    head->child = nullptr;
    return head;
  }
};"
"class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return None
        
        if root.val == val:
            return root
        
        return self.searchBST(root.left, val) or self.searchBST(root.right, val)","class Codec {
 public:
  // Encodes an n-ary tree to a binary tree.
  TreeNode* encode(Node* root) {
    if (root == nullptr)
      return nullptr;

    TreeNode* rootTreeNode = new TreeNode(root->val);
    queue<pair<Node*, TreeNode*>> q{{{root, rootTreeNode}}};

    while (!q.empty()) {
      const auto [parentNode, parentTreeNode] = q.front();
      q.pop();
      TreeNode* prevTreeNode = nullptr;
      TreeNode* headTreeNode = nullptr;
      for (Node* child : parentNode->children) {
        TreeNode* currTreeNode = new TreeNode(child->val);
        if (prevTreeNode != nullptr)
          prevTreeNode->right = currTreeNode;
        else
          headTreeNode = currTreeNode;
        prevTreeNode = currTreeNode;
        q.emplace(child, currTreeNode);
      }
      parentTreeNode->left = headTreeNode;
    }

    return rootTreeNode;
  }

  // Decodes your binary tree to an n-ary tree.
  Node* decode(TreeNode* root) {
    if (root == nullptr)
      return nullptr;

    Node* rootNode = new Node(root->val);
    queue<pair<Node*, TreeNode*>> q{{{rootNode, root}}};

    while (!q.empty()) {
      const auto [parentNode, parentTreeNode] = q.front();
      q.pop();
      TreeNode* sibling = parentTreeNode->left;
      while (sibling) {
        Node* currNode = new Node(sibling->val);
        parentNode->children.push_back(currNode);
        q.emplace(currNode, sibling);
        sibling = sibling->right;
      }
    }

    return rootNode;
  }
};"
"class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        s = 'right' if val > root.val else 'left'
        if getattr(root, s) is None:
            setattr(root, s, TreeNode(val))
        else:
            self.insertIntoBST(getattr(root, s), val)
        return root","class AllOne {
 public:
  void inc(string key) {
    const auto it = keyToIterator.find(key);

    // doesn't find the key
    if (it == cend(keyToIterator)) {
      if (l.empty() || l.front().value > 1)
        l.push_front({1, {key}});
      else
        l.front().keys.insert(key);
      keyToIterator[key] = begin(l);
      return;
    }

    const auto lit = it->second;  // List iterator
    auto nit = next(lit);         // Next iterator

    if (nit == end(l) || nit->value > lit->value + 1)
      nit = l.insert(nit, {lit->value + 1, {key}});
    else  // Nit->value == lit->value + 1
      nit->keys.insert(key);
    keyToIterator[key] = nit;  // Reset the mapping

    // Remove the key in keys set
    lit->keys.erase(key);
    if (lit->keys.empty())
      l.erase(lit);
  }

  void dec(string key) {
    const auto it = keyToIterator.find(key);

    // doens't find the key
    if (it == cend(keyToIterator))
      return;

    const auto lit = it->second;  // List iterator

    if (lit->value == 1) {  // No need to find prev iterator in this case
      keyToIterator.erase(key);
    } else {
      auto pit = prev(lit);  // Prev iterator

      if (lit == begin(l) || pit->value < lit->value - 1)
        pit = l.insert(lit, {lit->value - 1, {key}});
      else  // Pit->value == lit-value - 1
        pit->keys.insert(key);
      keyToIterator[key] = pit;  // Reset the mapping
    }

    // Remove the key in keys set
    lit->keys.erase(key);
    if (lit->keys.empty())
      l.erase(lit);
  }

  string getMaxKey() {
    return l.empty() ? """" : *cbegin(l.back().keys);
  }

  string getMinKey() {
    return l.empty() ? """" : *cbegin(l.front().keys);
  }

 private:
  struct Node {
    int value;
    unordered_set<string> keys;
  };

  list<Node> l;
  unordered_map<string, list<Node>::iterator> keyToIterator;
};"
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        low = 0
        high = len(nums)-1
        loc = -1
        while (low <= high):
            mid = (high+low)//2
            if nums[mid] == target:
                return mid
            if nums[mid] > target:
                high = mid-1
            elif nums[mid] < target:
                low = mid+1
        return loc","class Solution {
 public:
  int minMutation(string start, string end, vector<string>& bank) {
    unordered_set<string> bankSet{bank.begin(), bank.end()};
    if (!bankSet.count(end))
      return -1;

    int ans = 0;
    queue<string> q{{start}};

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        string word = q.front();
        q.pop();
        for (int j = 0; j < word.length(); ++j) {
          const char cache = word[j];
          for (const char c : {'A', 'C', 'G', 'T'}) {
            word[j] = c;
            if (word == end)
              return ans;
            if (bankSet.count(word)) {
              bankSet.erase(word);
              q.push(word);
            }
          }
          word[j] = cache;
        }
      }
    }

    return -1;
  }
};"
"# Array List Solution

class MyHashSet:

    def __init__(self):
        self.buckets = []

    def add(self, key: int) -> None:
        count = 0
        for x in self.buckets:
            if key in x:
                x += [key]
                count += 1
        if count == 0:
            self.buckets += [[key]]

    def remove(self, key: int) -> None:
        for x in self.buckets:
            while key in x:
                x.remove(key)

    def contains(self, key: int) -> bool:
        for x in self.buckets:
            if key in x:
                return True
        return False","class Solution {
 public:
  int countSegments(string s) {
    int ans = 0;

    for (int i = 0; i < s.length(); ++i)
      if (s[i] != ' ' && (i == 0 || s[i - 1] == ' '))
        ++ans;

    return ans;
  }
};"
"class Solution:
    def toLowerCase(self, s: str) -> str:
        output = ''
        for char in s:
            ascii_index = ord(char)
            if 65 <= ascii_index <= 90:
                output += chr(ascii_index+32)
            else:
                output += char
        return output","class Solution {
 public:
  int eraseOverlapIntervals(vector<vector<int>>& intervals) {
    if (intervals.empty())
      return 0;

    sort(begin(intervals), end(intervals),
         [](const auto& a, const auto& b) { return a[1] < b[1]; });

    int ans = 0;
    int currentEnd = intervals[0][1];

    for (int i = 1; i < intervals.size(); ++i)
      if (intervals[i][0] >= currentEnd)
        currentEnd = intervals[i][1];
      else
        ++ans;

    return ans;
  }
};"
"class Solution:

    def __init__(self, n: int, blacklist: List[int]):
        # The size of whitelist
        self.white_len = n - len(blacklist)
        # Last index of the array
        self.last_idx = n - 1
        # Mapping dictionary
        self.mapping = {}
        # Set the index of blacklist element all to -1
        for i in blacklist:
            self.mapping[i] = -1
        
        for i in blacklist:
            # skip blacklist
            if i >= self.white_len:
                continue
            while self.last_idx in blacklist:
                self.last_idx -= 1
            self.mapping[i] = self.last_idx
            self.last_idx -= 1

    def pick(self) -> int:
        idx = randint(0,self.white_len-1)
        if idx in self.mapping:
            return self.mapping[idx]
        return idx","class Solution {
 public:
  vector<int> findRightInterval(vector<vector<int>>& intervals) {
    vector<int> ans;
    map<int, int> startToIndex;

    for (int i = 0; i < intervals.size(); ++i)
      startToIndex[intervals[i][0]] = i;

    for (const vector<int>& interval : intervals) {
      const auto it = startToIndex.lower_bound(interval[1]);
      if (it == cend(startToIndex))
        ans.push_back(-1);
      else
        ans.push_back(it->second);
    }

    return ans;
  }
};"
"class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        @lru_cache(None)
        def getASCII(char):
            return ord(char)
        
        if len(s1) < len(s2):
            s1, s2 = s2, s1
            
        m, n = len(s1), len(s2)
        
        dp = [0]*(n+1)
        
        for i in range(1, n+1):
            dp[i] += dp[i-1] + getASCII(s2[i-1])
            
        for i in range(1, m+1):
            new_dp = [0]*(n+1) 
            new_dp[0] = dp[0] + getASCII(s1[i-1])
            
            for j in range(1, n+1):
                if s1[i-1] == s2[j-1]:
                    new_dp[j] = dp[j-1]
                else:
                    new_dp[j] = min(getASCII(s1[i-1])+dp[j], getASCII(s2[j-1])+new_dp[j-1])
            
            dp = new_dp
        
        return dp[-1]","class Solution {
 public:
  int pathSum(TreeNode* root, int sum) {
    if (root == nullptr)
      return 0;
    return dfs(root, sum) +            //
           pathSum(root->left, sum) +  //
           pathSum(root->right, sum);
  }

 private:
  int dfs(TreeNode* root, int sum) {
    if (root == nullptr)
      return 0;
    return (sum == root->val) +                //
           dfs(root->left, sum - root->val) +  //
           dfs(root->right, sum - root->val);
  }
};"
"class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
       
        # Init
        n = len(nums)
        m = 0 # no. of subarrays
       
        # Base Case
        if k == 0:
            return 0
        
        # Base Case
        if sum(nums) == n:
            return (n)*(n+1)//2 if k > 1 else 0 
        
        # For each element
        for i,num_i in enumerate(nums):
            
            # Calc curr product
            curr_prod = num_i
            
            # Check if is less then k, else continue
            if curr_prod < k:
                m += 1
            else:
                continue
            
            # For each j from i+1 to n-1
            for num_j in nums[i+1:]:
                
                # calc current product
                curr_prod = curr_prod * num_j
                
                # Check if is less then k, else break
                if curr_prod < k:
                    m += 1
                else:
                    break
                    
        return m","class Solution {
 public:
  vector<int> findAnagrams(string s, string p) {
    vector<int> ans;
    vector<int> count(128);
    int required = p.length();

    for (const char c : p)
      ++count[c];

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (--count[s[r]] >= 0)
        --required;
      while (required == 0) {
        if (r - l + 1 == p.length())
          ans.push_back(l);
        if (++count[s[l++]] > 0)
          ++required;
      }
    }

    return ans;
  }
};"
"class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        self.dp=[[-1 for i in range(2)] for i in range(50001)]
        return self.dfs(0,0,prices,fee)
    def dfs(self,day,own,prices,fee):
        if day==len(prices):
            return 0
        if self.dp[day][own]!=-1:
            return self.dp[day][own]
        if own:
            p1=prices[day]-fee+self.dfs(day+1,not own,prices,fee)
            p2=self.dfs(day+1,own,prices,fee)
            self.dp[day][own]=max(p1,p2)
        else:
            p1=-(prices[day])+self.dfs(day+1,not own,prices,fee) #here we are sending(not own) bcoz own is 0
            p2=self.dfs(day+1,own,prices,fee)# here we are sending(own) bcoz own is 0
            self.dp[day][own]=max(p1,p2)
        return self.dp[day][own]","class Solution {
 public:
  string parseTernary(string expression) {
    const char c = expression[i];

    if (i + 1 == expression.length() || expression[i + 1] == ':') {
      i += 2;  // Skip ':'
      return string(1, c);
    }

    i += 2;  // Skip '?'
    const string& first = parseTernary(expression);
    const string& second = parseTernary(expression);
    return c == 'T' ? first : second;
  }

 private:
  int i = 0;
};"
"class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        i = 0
        while i in range(len(bits)):
            if i == len(bits)-1:
                return True
            if bits[i] == 0:
                i += 1
            else:
                i += 2
        return False","class Solution {
 public:
  int findKthNumber(long n, int k) {
    auto getGap = [&n](long a, long b) {
      long gap = 0;
      while (a <= n) {
        gap += min(n + 1, b) - a;
        a *= 10;
        b *= 10;
      }
      return gap;
    };

    long currNum = 1;

    for (int i = 1; i < k;) {
      long gap = getGap(currNum, currNum + 1);
      if (i + gap <= k) {
        i += gap;
        ++currNum;
      } else {
        ++i;
        currNum *= 10;
      }
    }

    return currNum;
  }
};"
"class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        def helper(l):
            base = 1 << 7
            M = 10 **9 + 7
            a = pow(base, l, M)
            t1, t2 = 0, 0
            hashes = set()
            for i in range(len(nums1)):
                t1 = (base * t1 + nums1[i]) % M
                if i >= l:
                    t1 -= a * nums1[i - l]
                    t1 %= M
                if i >= l - 1:
                    hashes.add(t1)
                    
            for j in range(len(nums2)):
                t2 = (base * t2 + nums2[j]) % M
                if j >= l:
                    t2 -= a * nums2[j - l]
                    t2 %= M
                if j >= l - 1:
                    if t2 in hashes: return True
            return False
        
        a, b = 0, min(len(nums1), len(nums2))
        while a < b:
            m = (a + b + 1) // 2
            if helper(m):
                a = m
            else:
                b = m - 1
        return a","class Solution {
 public:
  int arrangeCoins(long n) {
    return (-1 + sqrt(8 * n + 1)) / 2;
  }
};"
"class Solution:
    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        nums.sort()
        N = len(nums)

        def less(v):
            """"""number of distances < v""""""
            cnt, left = 0, 0
            for right in range(1, N):
                while left < right and nums[right] - nums[left] >= v:
                    left += 1
                cnt += right - left
            return cnt

        lo, hi = 0, max(nums) - min(nums)
        while lo <= hi:
            v = (lo+hi) // 2
            cnt = less(v)
            if cnt < k:
                lo = v + 1
            else:
                hi = v - 1
        return hi","class Solution {
 public:
  vector<int> findDuplicates(vector<int>& nums) {
    vector<int> ans;

    for (const int num : nums) {
      nums[abs(num) - 1] *= -1;
      if (nums[abs(num) - 1] > 0)
        ans.push_back(abs(num));
    }

    return ans;
  }
};"
"class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort(reverse=True)
        words.sort(key=lambda x : len(x))
        i = len(words)-1
        while i > -1:
            flag = True
            for j in range(1,len(words[i])):
                if words[i][:j] not in words:
                    flag = False
            if flag:
                return words[i]
            i -= 1
        return ''","class Solution {
 public:
  int compress(vector<char>& chars) {
    int ans = 0;

    for (int i = 0; i < chars.size();) {
      const char letter = chars[i];
      int count = 0;
      while (i < chars.size() && chars[i] == letter) {
        ++count;
        ++i;
      }
      chars[ans++] = letter;
      if (count > 1)
        for (const char c : to_string(count))
          chars[ans++] = c;
    }

    return ans;
  }
};"
"class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        email_to_ids = collections.defaultdict(list)
        visited_accounts = [False]*len(accounts)
        for i, acct in enumerate(accounts):
            for email in acct[1:]:            
                email_to_ids[email].append(i)
        
        res = []
        for id, acct in enumerate(accounts):
            if visited_accounts[id]: 
                continue
            visited_accounts[id] = True
            merged_emails = set()
            stack = acct[1:]
            while stack:
                email = stack.pop()
                merged_emails.add(email)
                for id in email_to_ids[email]:
                    if not visited_accounts[id]: 
                        stack.extend([new_email for new_email in accounts[id][1:] if new_email != email])            
                        visited_accounts[id] = True
            res.append([acct[0]] + sorted(merged_emails))
        return res","class Solution {
 public:
  bool sequenceReconstruction(vector<int>& org, vector<vector<int>>& seqs) {
    if (seqs.empty())
      return false;

    const int n = org.size();
    vector<vector<int>> graph(n);
    vector<int> inDegree(n);

    // Build graph
    for (const vector<int>& seq : seqs) {
      if (seq.size() == 1 && seq[0] < 1 || seq[0] > n)
        return false;
      for (int i = 0; i + 1 < seq.size(); ++i) {
        const int u = seq[i];
        const int v = seq[i + 1];
        if (u < 1 || u > n || v < 1 || v > n)
          return false;
        graph[u - 1].push_back(v - 1);
        ++inDegree[v - 1];
      }
    }

    // Topology
    queue<int> q;

    for (int i = 0; i < n; ++i)
      if (inDegree[i] == 0)
        q.push(i);

    int i = 0;  // org's index

    while (!q.empty()) {
      if (q.size() > 1)
        return false;
      const int u = q.front();
      q.pop();
      if (u != org[i] - 1)
        return false;
      ++i;
      for (const int v : graph[u])
        if (--inDegree[v] == 0)
          q.push(v);
    }

    return i == n;
  }
};"
"class Solution:

    pat1 = re.compile(r""//[^~]*~"")
    pat2 = re.compile(r""/\*.*?\*/"")

    def removeComments(self, source: List[str]) -> List[str]:
        one_line = ""~"".join(source) + ""~""
        idx_pat1 = one_line.find(""//"")
        idx_pat2 = one_line.find(""/*"")

        while -1 < idx_pat1 or -1 < idx_pat2:
            if -1 < idx_pat1 and -1 < idx_pat2:
                if idx_pat1 < idx_pat2:
                    one_line = Solution.pat1.sub(""~"", one_line, 1)
                else:
                    one_line = Solution.pat2.sub("""", one_line, 1)
            elif -1 < idx_pat1:
                one_line = Solution.pat1.sub(""~"", one_line, 1)
            else:
                one_line = Solution.pat2.sub("""", one_line, 1)
            idx_pat1 = one_line.find(""//"")
            idx_pat2 = one_line.find(""/*"")

        return [line for line in one_line.split(""~"") if line]","class Solution {
 public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    stack<ListNode*> stack1;
    stack<ListNode*> stack2;

    while (l1) {
      stack1.push(l1);
      l1 = l1->next;
    }

    while (l2) {
      stack2.push(l2);
      l2 = l2->next;
    }

    ListNode* head = nullptr;
    int carry = 0;

    while (carry || !stack1.empty() || !stack2.empty()) {
      if (!stack1.empty())
        carry += stack1.top()->val, stack1.pop();
      if (!stack2.empty())
        carry += stack2.top()->val, stack2.pop();
      ListNode* node = new ListNode(carry % 10);
      node->next = head;
      head = node;
      carry /= 10;
    }

    return head;
  }
};"
"class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        if(len(nums) <= 1):
            return 0
        s = sum(nums)
        c = 0
        for i in range(len(nums)):
            if (s - nums[i]) / 2 == c:
                return i
            c += nums[i]
        return -1","class Solution {
 public:
  int numberOfArithmeticSlices(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    // dp[i][j] := # of subseqs end w/ nums[j] nums[i]
    vector<vector<int>> dp(n, vector<int>(n));
    unordered_map<long, vector<int>> numToIndices;

    for (int i = 0; i < n; ++i)
      numToIndices[nums[i]].push_back(i);

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < i; ++j) {
        const long target = nums[j] * 2L - nums[i];
        if (const auto it = numToIndices.find(target); it != cend(numToIndices))
          for (const int k : it->second)
            if (k < j)
              dp[i][j] += (dp[j][k] + 1);
        ans += dp[i][j];
      }

    return ans;
  }
};"
"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        n = 0
        current = head
        while (current):
            n += 1
            current = current.next
        
        parts = []
        for k in range(k, 0, -1):
            partSize = ceil(n / k)
            nextNode = head
            for _ in range(partSize - 1):
                if (not nextNode): break
                nextNode = nextNode.next
            parts.append(head)
            if (nextNode):
                head = nextNode.next
                nextNode.next = None
            n -= partSize
                
        return parts","class Solution {
 public:
  int numberOfBoomerangs(vector<vector<int>>& points) {
    int ans = 0;

    for (const vector<int>& p : points) {
      unordered_map<int, int> distCount;
      for (const vector<int>& q : points) {
        const int dist = getDist(p, q);
        ++distCount[dist];
      }
      for (const auto& [_, freq] : distCount)
        ans += freq * (freq - 1);  // C(freq, 2)
    }

    return ans;
  }

 private:
  int getDist(const vector<int>& p, const vector<int>& q) {
    return pow(p[0] - q[0], 2) + pow(p[1] - q[1], 2);
  }
};"
"class Solution:
    def countOfAtoms(self, formula: str) -> str:
        mp = {}
        stack = []
        for i, x in enumerate(formula): 
            if x == ""("": stack.append(i)
            elif x == "")"": mp[stack.pop()] = i
        
        def fn(lo, hi): 
            """"""Return count of atom in a freq table.""""""
            k = lo 
            ans = defaultdict(int)
            while k < hi: 
                cnt = 0 
                if formula[k] == ""("": 
                    freq = fn(k+1, mp[k])
                    k = mp[k] + 1
                    while k < hi and formula[k].isdigit(): 
                        cnt = 10*cnt + int(formula[k])
                        k += 1
                    for key, val in freq.items(): ans[key] += val * max(1, cnt)
                else: 
                    atom = formula[k]
                    k += 1
                    while k < hi and formula[k] != ""("" and not formula[k].isupper(): 
                        if formula[k].isalpha(): atom += formula[k]
                        else: cnt = 10*cnt + int(formula[k])
                        k += 1
                    ans[atom] += max(1, cnt)
            return ans 
        
        
        ans = []
        for k, v in sorted(fn(0, len(formula)).items()): 
            ans.append(k)
            if v > 1: ans.append(str(v))
        return """".join(ans)","class Solution {
 public:
  vector<int> findDisappearedNumbers(vector<int>& nums) {
    vector<int> ans;

    for (const int num : nums) {
      const int index = abs(num) - 1;
      nums[index] = -abs(nums[index]);
    }

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] > 0)
        ans.push_back(i + 1);

    return ans;
  }
};"
"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
    	L = []
    	for i in range(left,right+1):
    		d = list(str(i))
    		m = len(d)
    		if '0' in d:
    			continue
    		j = 0
    		while j < m and i%int(d[j]) == 0:
    			j += 1
    		if j == m:
    			L.append(i)
    	return(L)
		
	- Python 3
	- Junaid Mansuri","class Codec {
 public:
  string serialize(TreeNode* root) {
    if (root == nullptr)
      return """";

    string s;

    serialize(root, s);
    return s;
  }

  TreeNode* deserialize(string data) {
    if (data.empty())
      return nullptr;

    istringstream iss(data);
    queue<int> q;

    for (string s; iss >> s;)
      q.push(stoi(s));

    return deserialize(INT_MIN, INT_MAX, q);
  }

 private:
  void serialize(TreeNode* root, string& s) {
    if (root == nullptr)
      return;

    s += to_string(root->val) + "" "";
    serialize(root->left, s);
    serialize(root->right, s);
  }

  TreeNode* deserialize(int min, int max, queue<int>& q) {
    if (q.empty())
      return nullptr;

    const int val = q.front();
    if (val < min || val > max)
      return nullptr;

    q.pop();
    TreeNode* root = new TreeNode(val);
    root->left = deserialize(min, val, q);
    root->right = deserialize(val, max, q);
    return root;
  }
};"
"# Binary Search Tree Solution -> If exact matching of intervals found then return False
#                                Else you can add this interval to that particular node's left or right
class Node:
    def __init__(self, s, e):
        self.s = s
        self.e = e
        self.left = None
        self.right = None
class MyCalendar:
    def __init__(self):
        self.head = None
        
    def insert(self, s, e, node):
        if s >= node.e:
            if node.right: return self.insert(s, e, node.right)
            else: 
                nn = Node(s, e)
                node.right = nn
                return True
        elif e <= node.s:
            if node.left: return self.insert(s, e, node.left)
            else:
                nn = Node(s, e)
                node.left = nn
                return True
        else: return False
        
    def book(self, s: int, e: int) -> bool:
        if self.head == None:
            nn = Node(s, e)
            self.head = nn
            return True
        return self.insert(s, e, self.head)","class Solution {
 public:
  TreeNode* deleteNode(TreeNode* root, int key) {
    if (root == nullptr)
      return nullptr;
    if (root->val == key) {
      if (root->left == nullptr)
        return root->right;
      if (root->right == nullptr)
        return root->left;
      TreeNode* minNode = getMin(root->right);
      root->right = deleteNode(root->right, minNode->val);
      minNode->left = root->left;
      minNode->right = root->right;
      root = minNode;
    } else if (root->val < key) {
      root->right = deleteNode(root->right, key);
    } else {  // root->val > key
      root->left = deleteNode(root->left, key);
    }
    return root;
  }

 private:
  TreeNode* getMin(TreeNode* node) {
    while (node->left)
      node = node->left;
    return node;
  }
};"
"class Solution:
    def countPalindromicSubsequences(self, s: str) -> int:
        n = len(s)
        t = [[0 for _ in range(n)] for _ in range(n)]
        
        for g in range(n):
            i = 0
            for j in range(g, n):
                if g == 0:
                    t[i][j] = 1
                elif g == 1:
                    t[i][j] = 2
                else:
                    if s[i] != s[j]:
                        t[i][j] = t[i][j-1] + t[i+1][j] - t[i+1][j-1]
                    else:
                        if s[i:j+1].count(s[i]) == 2:
                            t[i][j] = 2*t[i+1][j-1] + 2
                        elif s[i:j+1].count(s[i]) == 3:
                            t[i][j] = 2*t[i+1][j-1] + 1
                        else:
                            temp = s[i+1:j]
                            x = i + temp.index(s[i]) + 2
                            y = j - temp[::-1].index(s[i]) - 2
                            t[i][j] = 2*t[i+1][j-1] - t[x][y]
                i = i+1
        
        return t[0][n-1]% (10**9 + 7)","class Solution {
 public:
  string frequencySort(string s) {
    const int n = s.length();
    string ans;
    vector<int> count(128);
    // bucket[i] := stores chars that appear i times in s
    vector<vector<char>> bucket(n + 1);

    for (const char c : s)
      ++count[c];

    for (int i = 0; i < 128; ++i) {
      const int freq = count[i];
      if (freq > 0)
        bucket[freq].push_back((char)i);
    }

    for (int freq = n; freq > 0; --freq)
      for (const char c : bucket[freq])
        ans += string(freq, c);

    return ans;
  }
};"
"class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        
        rows = len(image)
        cols = len(image[0])
        color_to_change = image[sr][sc]
        
        def dfs(r,c):
            if(r<0 or c<0 or r>rows-1 or c>cols-1 or image[r][c] == newColor or image[r][c]!=color_to_change):
                return
            image[r][c] = newColor
            
            #iterate through all four directions
            dfs(r+1,c)
            dfs(r-1,c)
            dfs(r,c+1)
            dfs(r,c-1)
        
        dfs(sr,sc)
        return image","class Solution {
 public:
  int findMinArrowShots(vector<vector<int>>& points) {
    sort(begin(points), end(points),
         [](const auto& a, const auto& b) { return a[1] < b[1]; });

    int ans = 1;
    int arrowX = points[0][1];

    for (int i = 1; i < points.size(); ++i)
      if (points[i][0] > arrowX) {
        arrowX = points[i][1];
        ++ans;
      }

    return ans;
  }
};"
"class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        ans = []
        for a in asteroids:
            if a > 0:
                ans.append(a)
            else:
                appendFlag = True
                while ans:
                    if ans[-1] < 0:
                        break
                    else:
                        if ans[-1] + a < 0:
                            ans.pop(-1)
                        elif ans[-1] + a == 0:
                            ans.pop(-1)
                            appendFlag = False
                            break
                        else:
                            appendFlag = False
                            break
                if appendFlag:
                    ans.append(a)                    
        return ans","class Solution {
 public:
  int minMoves(vector<int>& nums) {
    const int min = *min_element(begin(nums), end(nums));
    return accumulate(begin(nums), end(nums), 0,
                      [&](int a, int b) { return a + (b - min); });
  }
};"
"class Solution:
    def evaluate(self, expression: str) -> int:
        loc = {}
        stack = []
        for i, x in enumerate(expression): 
            if x == ""("": stack.append(i)
            elif x == "")"": loc[stack.pop()] = i
        
        def fn(lo, hi, mp): 
            """"""Return value of given expression.""""""
            if expression[lo] == ""("": return fn(lo+1, hi-1, mp)
            i = lo
            vals = []
            while i < hi: 
                if expression[i:i+3] in (""let"", ""add""): 
                    op = expression[i:i+3]
                    i += 3
                elif expression[i:i+4] == ""mult"": 
                    op = ""mult""
                    i += 4
                elif expression[i].isalpha(): 
                    x = """"
                    while i < hi and expression[i].isalnum(): 
                        x += expression[i]
                        i += 1
                    if op in (""add"", ""mult""): vals.append(mp[x])
                elif expression[i].isdigit() or expression[i] == ""-"": 
                    v = """"
                    while i < hi and (expression[i].isdigit() or expression[i] == ""-""): 
                        v += expression[i]
                        i += 1
                    if op == ""let"": mp[x] = int(v)
                    else: vals.append(int(v))
                elif expression[i] == ""("": 
                    v = fn(i+1, loc[i], mp.copy())
                    i = loc[i] + 1
                    if op == ""let"": mp[x] = v
                    else: vals.append(v)
                else: i += 1
            if op == ""let"": return int(v)
            elif op == ""add"": return sum(vals)
            else: return reduce(mul, vals)
            
        return fn(0, len(expression), {})","class Solution {
 public:
  int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3,
                   vector<int>& nums4) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int a : nums1)
      for (const int b : nums2)
        ++count[a + b];

    for (const int c : nums3)
      for (const int d : nums4)
        if (const auto it = count.find(-c - d); it != cend(count))
          ans += it->second;

    return ans;
  }
};"
"class Solution:
def monotoneIncreasingDigits(self, n: int) -> int:
    s = str(n)
    for i in range(len(s)-1,0,-1):
        if s[i]<s[i-1]:
            n = n-(int(s[i:])+1)
            s = str(n)
    return n","class Solution {
 public:
  int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(begin(g), end(g));
    sort(begin(s), end(s));

    int i = 0;
    for (int j = 0; j < s.size() && i < g.size(); ++j)
      if (g[i] <= s[j])
        ++i;

    return i;
  }
};"
"class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        
        N = len(temperatures)
        stack, answer = [], [0 for _ in range(N)]
        for index, value in enumerate(temperatures):
            while stack and stack[-1][1] < value:
                i = stack.pop()[0]
                answer[i] = index-i
            stack.append((index, value))
        return answer","class Solution {
 public:
  bool find132pattern(vector<int>& nums) {
    stack<int> stack;  // decreasing stack
    int ak = INT_MIN;  // We want to find a seq ai < ak < aj.

    for (int i = nums.size() - 1; i >= 0; --i) {
      // ai < ak, we're done because ai must also smaller than aj.
      if (nums[i] < ak)
        return true;
      while (!stack.empty() && stack.top() < nums[i])
        ak = stack.top(), stack.pop();
      stack.push(nums[i]);  // nums[i] is a candidate of aj.
    }

    return false;
  }
};"
"class Solution:
    def deleteAndEarn(self, n: List[int]) -> int:
    	if not n: return 0
    	a, b, C = 0, n.count(1), collections.Counter(n)
    	for i in range(2,max(n)+1): b, a = max(C[i]*i + a, b), b
    	return b
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  bool circularArrayLoop(vector<int>& nums) {
    const int n = nums.size();
    if (n < 2)
      return false;

    auto advance = [&](int i) {
      const int val = (i + nums[i]) % n;
      return i + nums[i] >= 0 ? val : n + val;
    };

    for (int i = 0; i < n; ++i) {
      if (nums[i] == 0)
        continue;
      int slow = i;
      int fast = advance(slow);
      while (nums[i] * nums[fast] > 0 && nums[i] * nums[advance(fast)] > 0) {
        if (slow == fast) {
          if (slow == advance(slow))
            break;
          return true;
        }
        slow = advance(slow);
        fast = advance(advance(fast));
      }

      slow = i;
      const int sign = nums[i];
      while (sign * nums[slow] > 0) {
        const int next = advance(slow);
        nums[slow] = 0;
        slow = next;
      }
    }

    return false;
  }
};"
"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        
        rows = len(grid)
        cols = len(grid[0])
        
        #Go down or go right
        directions = [(1, 0), (0, 1)]
        
        #Enables cache for our dp
        @lru_cache(None)
        def dp(row_1, row_2, col_1, col_2):
            
            #if we hit a wall or we go out of the grid
            if col_1 >= cols or col_2 >= cols or row_1 >= rows or row_2 >= rows or grid[row_1][col_1] == -1 or grid[row_2][col_2] == -1:
                return -inf
            #Pick current cherries
            result = grid[row_1][col_1]
            
            #Do not double cherries if both paths are the same
            if col_1 != col_2 or row_1 != row_2:
                result += grid[row_2][col_2]
            
            # If we are at the end of the grid stop
            if not (row_1 == rows - 1 and col_1 == cols - 1):
                result += max(dp(new_row_1 + row_1, new_row_2 + row_2, new_col_1 + col_1, new_col_2 + col_2) 
                              for new_row_1, new_col_1 in directions
                              for new_row_2, new_col_2 in directions)
            
            return result
        
        ans = dp(0, 0, 0, 0)
        return 0 if ans == -inf else ans","class Solution {
 public:
  int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
    return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));
  }
};"
"class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        d = {}
        graph = [[] for _ in range(n)]
        for i in times:
            d[(i[0]-1,i[1]-1)] = i[2]
            graph[i[0]-1].append(i[1]-1)        
        parent = [-1]*n
        cost = [10**9]*n
        visited = [False]*n
        cost[k-1] = 0
        x = 0
        while x <= n-1:
            m = (-1,10**9)
            for i in range(n):
                if not visited[i] and m[1] > cost[i]:
                    m = (i,cost[i])
            for i,j in enumerate(graph[m[0]]):
                if (m[0],j) in d and cost[j] > cost[m[0]] + d[(m[0],j)]:
                    cost[j] = cost[m[0]] + d[(m[0],j)]
                    parent[j] = m[0]
            visited[m[0]] = True
            x += 1
        return -1 if (max(cost)) == 10**9 else max(cost)","class Solution {
 public:
  bool repeatedSubstringPattern(string s) {
    const string ss = s + s;
    return ss.substr(1, ss.length() - 2).find(s) != string::npos;
  }
};"
"class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
    	t, n = ord(target), list(map(ord,letters))
    	if t >= max(n): return chr(min(n))
    	d = {c : i for i,c in enumerate(n) if c > t}
    	return letters[d[min(d)]]
		
		
- Python 3
- Junaid Mansuri","struct Node {
  int key;
  int value;
  int freq;
  list<int>::const_iterator it;
};

class LFUCache {
 public:
  LFUCache(int capacity) : capacity(capacity), minFreq(0) {}

  int get(int key) {
    const auto it = keyToNode.find(key);
    if (it == cend(keyToNode))
      return -1;

    Node& node = it->second;
    touch(node);
    return node.value;
  }

  void put(int key, int value) {
    if (capacity == 0)
      return;
    if (const auto it = keyToNode.find(key); it != cend(keyToNode)) {
      Node& node = it->second;
      node.value = value;
      touch(node);
      return;
    }

    if (keyToNode.size() == capacity) {
      // Evict LRU key from the minFreq list
      const int keyToEvict = freqToList[minFreq].back();
      freqToList[minFreq].pop_back();
      keyToNode.erase(keyToEvict);
    }

    minFreq = 1;
    freqToList[1].push_front(key);
    keyToNode[key] = {key, value, 1, cbegin(freqToList[1])};
  }

 private:
  int capacity;
  int minFreq;
  unordered_map<int, Node> keyToNode;
  unordered_map<int, list<int>> freqToList;

  void touch(Node& node) {
    // Update the node's frequency
    const int prevFreq = node.freq;
    const int newFreq = ++node.freq;

    // Remove the iterator from prevFreq's list
    freqToList[prevFreq].erase(node.it);
    if (freqToList[prevFreq].empty()) {
      freqToList.erase(prevFreq);
      // Update minFreq if needed
      if (prevFreq == minFreq)
        ++minFreq;
    }

    // Insert the key to the front of newFreq's list
    freqToList[newFreq].push_front(node.key);
    node.it = cbegin(freqToList[newFreq]);
  }
};"
"class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int: 
        # Handle empty cost case
        if not cost: return 0
        
        # min_cost is the minimum cost to get to some step i
        min_cost = [0] * len(cost)
        min_cost[0] = cost[0]
        
        # Loop through. At each i, the cost is:
        #   - The cost of that step plus the minimum cost of the two steps before it
        for i in range(1, len(cost)):
            min_cost[i] = cost[i] + min(min_cost[i-1], min_cost[i-2])

        # Return the smaller of the two last steps (since two steps could be taken from the second last step out)
        return min(min_cost[-1], min_cost[-2])","class Solution {
 public:
  int hammingDistance(int x, int y) {
    int ans = 0;

    while (x || y) {
      ans += (x & 1) ^ (y & 1);
      x >>= 1;
      y >>= 1;
    }

    return ans;
  }
};"
"class Solution:
    def dominantIndex(self, nums: List[int]) -> int:
    	M = max(nums)
    	return nums.index(M) if len([0 for i in nums if 2*i <= M]) == len(nums)-1 else -1
		
		
- Python 3
- Junaid Mansuri","class Solution {
 public:
  int minMoves2(vector<int>& nums) {
    const int n = nums.size();
    nth_element(begin(nums), begin(nums) + n / 2, end(nums));
    const int median = nums[n / 2];
    return accumulate(begin(nums), end(nums), 0,
                      [&](int a, int b) { return a + abs(b - median); });
  }
};"
"class Solution:
    def shortestCompletingWord(self, l: str, w: List[str]) -> str:
        res={}
        lp=l.lower()
        d={}
        for i in lp:
            if i.isalpha():
                d[i]=lp.count(i)
        for i in w:
            j=i.lower()
            c=0
            for k in d.keys():
                if j.count(k)<d[k]:
                    c=1
                    break
            if c==0:
                m=res.get(len(j),[])
                res[len(j)]=m+[j]
        return res[(min(list(res.keys())))][0]","class Solution {
 public:
  int islandPerimeter(vector<vector<int>>& grid) {
    int islands = 0;
    int neighbors = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j]) {
          ++islands;
          if (i - 1 >= 0 && grid[i - 1][j])
            ++neighbors;
          if (j - 1 >= 0 && grid[i][j - 1])
            ++neighbors;
        }

    return islands * 4 - neighbors * 2;
  }
};"
"class Solution:
    def containVirus(self, isInfected: List[List[int]]) -> int:

        # return number of walls needed
        def dfs(r, c):

            # return
            if (r, c) in visited or r < 0 or c < 0 or r >= m or c >= n:
                return 0

            # contained cells
            if isInfected[r][c] == -1:
                return 0
            
            # uninfected cells
            if isInfected[r][c] == 0:
                risky.add((r, c))
                return 1
            
            # infected cells
            visited.add((r ,c))
            walls = 0
            if isInfected[r][c] == 1:
                walls += dfs(r+1, c)
                walls += dfs(r-1, c)
                walls += dfs(r, c+1)
                walls += dfs(r, c-1)

            return walls
        
        m, n = len(isInfected), len(isInfected[0])
        total_wall = 0

        while True:
            # store (len(risky), risky, wall, starting points)
            gettingInfected = []
            visited = set()
            for i in range(m):
                for j in range(n):
                    if isInfected[i][j] == 1 and isInfected[i][j] not in visited:
                        risky = set()
                        w = dfs(i, j)
                        gettingInfected.append((-len(risky), risky, w, i, j))

            
            # heapy the gettingInfectious array to get the max len of risky
            heapq.heapify(gettingInfected)

            if not gettingInfected or gettingInfected[0][2] == 0:
                return total_wall

            # mark the infected cells as contained starting from (i, j)
            lr, risky, w, i, j = heapq.heappop(gettingInfected)
            # maybe a dfs for marking the cells?
            queue = collections.deque([(i, j)])
            while queue:
                r, c = queue.pop()
                if r < 0 or c < 0 or r >= m or c >= n or isInfected[r][c] != 1:
                    continue

                isInfected[r][c] = -1

                queue.append((r+1, c))
                queue.append((r-1, c))
                queue.append((r, c+1))
                queue.append((r, c-1))

            # increment the total walls
            total_wall += w
            for area in gettingInfected:
                riskyCells = area[1]
                for cell in riskyCells:
                    r, c = cell
                    isInfected[r][c] = 1","class Solution {
 public:
  bool canIWin(int maxChoosableInteger, int desiredTotal) {
    if (desiredTotal <= 0)
      return true;

    const int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;
    if (sum < desiredTotal)
      return false;

    return dp(desiredTotal, 0, maxChoosableInteger);
  }

 private:
  unordered_map<int, bool> memo;  // true: can win, false: can't win

  // state: record integers that have been chosen
  bool dp(int total, int state, int n) {
    if (total <= 0)
      return false;
    if (const auto it = memo.find(state); it != cend(memo))
      return it->second;

    for (int i = 1; i <= n; ++i) {
      if (state & 1 << i)  // Integer i is used
        continue;
      if (!dp(total - i, state | 1 << i, n))
        return true;
    }

    return memo[state] = false;
  }
};"
"class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        mp, queue, vis, ans = Counter(deadends), deque(), Counter(), 0
        
        if mp['0000'] > 0:
            return -1
        queue.append(['0','0','0','0'])
        vis['0000'], len_q = 1, 1
        while len_q:
            ans += 1
            while len_q:
                var = queue.popleft()
                digit = ''.join(var)
                if digit == target:
                    return ans - 1
                for i in range(4):
                    ch = var[i]
                    forw, rev = int(ch) + 1 if int(ch) + 1 < 10 else 9 - int(ch), int(ch) - 1 if int(ch) - 1 >= 0 else 9 + int(ch)
                    for direction in [forw, rev]:
                        var[i] = str(direction)
                        digit = ''.join(var)
                        if mp[digit] == 0 and vis[digit] == 0:
                            queue.append([d for d in digit])
                            vis[digit] = 1
                    var[i] = ch
                len_q -= 1
            len_q = len(queue)
        return -1","class Solution {
 public:
  int minTransfers(vector<vector<int>>& transactions) {
    vector<int> balance(21);
    vector<int> debt;

    for (const vector<int>& t : transactions) {
      const int from = t[0];
      const int to = t[1];
      const int amount = t[2];
      balance[from] -= amount;
      balance[to] += amount;
    }

    for (const int b : balance)
      if (b > 0)
        debt.push_back(b);

    return dfs(debt, 0);
  }

 private:
  int dfs(vector<int>& debt, int s) {
    while (s < debt.size() && !debt[s])
      ++s;
    if (s == debt.size())
      return 0;

    int ans = INT_MAX;

    for (int i = s + 1; i < debt.size(); ++i)
      if (debt[i] * debt[s] < 0) {
        debt[i] += debt[s];  // debt[s] is settled
        ans = min(ans, 1 + dfs(debt, s + 1));
        debt[i] -= debt[s];  // Backtrack
      }

    return ans;
  }
};"
"class Solution:
    def crackSafe(self, n: int, k: int) -> str:

        total = k**n-1
        start = '0' * n
        visited = set()
        visited.add('0' * n)
        self.ans = '0' * n

        def dfs(total,start):
            if total == 0: 
                return True
            for i in range(k):
                last = start[1:n]
                #print(last+str(i))
                end = last+str(i)
                if end not in visited:
                    visited.add(end)
                    total = total-1
                    self.ans = self.ans+str(i)
                    if dfs(total, end):
                        return True
                    else:
                        visited.remove(end)
                        total = total+1
                        self.ans = self.ans[:-1]
                        #print(""l"")
            return False

        dfs(total,start)
        return self.ans","struct Record {
  int count;
  int nextIndex;
  Record(int count, int nextIndex) : count(count), nextIndex(nextIndex) {}
};

class Solution {
 public:
  int getMaxRepetitions(string s1, int n1, string s2, int n2) {
    vector<Record> records;  // [count(s1 matches s2[i:]), next index of s2[i:]]

    for (int i = 0; i < s2.length(); ++i) {
      int count = 0;
      int nextIndex = i;
      for (int j = 0; j < s1.length(); ++j)
        if (s2[nextIndex] == s1[j])
          if (++nextIndex == s2.length()) {  // Have a match
            ++count;
            nextIndex = 0;
          }
      records.emplace_back(count, nextIndex);
    }

    int matches = 0;  // S1 matches s2
    int index = 0;

    while (n1--) {
      matches += records[index].count;
      index = records[index].nextIndex;
    }

    return matches / n2;  // S1 matches S2
  }
};"
"class Solution:
    def reachNumber(self, target: int) -> int:
        t = abs(target)
        n = int(((1+8*t)**.5-1)/2)
        LT = n*(n+1)//2
        if LT == t: return n
        if (LT + n + 1 - t) % 2 == 0: return n + 1
        return n + 3 - n % 2
			
			
	- Python 3
	- Junaid Mansuri","class Solution {
 public:
  int findSubstringInWraproundString(string p) {
    int maxLength = 1;
    vector<int> count(26);  // Substrings end at i

    for (int i = 0; i < p.length(); ++i) {
      if (i > 0 && (p[i] - p[i - 1] == 1 || p[i - 1] - p[i] == 25))
        ++maxLength;
      else
        maxLength = 1;
      const int index = p[i] - 'a';
      count[index] = max(count[index], maxLength);
    }

    return accumulate(begin(count), end(count), 0);
  }
};"
"class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        mem = dict()
        mem2 = set()
        for a in allowed:
            if a[:2] not in mem:
                mem[a[:2]] = list()
            
            mem2.add(a[0])

            mem[a[:2]].append(a[-1])
        
        n = len(bottom)

        def helper(cur_sol, i, j):
            if i == n:
                return True
            
            l, r = cur_sol[i - 1][j], cur_sol[i - 1][j + 1]
            if l + r in mem:
                for candidate in mem[l + r]:
                    if j == 0 or (j > 0 and cur_sol[i][j - 1] + candidate in mem):
                        if j == n - i - 1 or (j < n - i - 1 and candidate in mem2):
                            cur_sol[i].append(candidate)
                            if j < n - i - 1:
                                next_i, next_j = i, j + 1
                            else:
                                next_i, next_j = i + 1, 0
                            if helper(cur_sol, next_i, next_j):
                                return True

                            cur_sol[i].pop()

            return False

        cur_sol = [list(bottom)] + [list() for _ in range(n - 1)]
        return helper(cur_sol, 1, 0)","class Solution {
 public:
  string validIPAddress(string IP) {
    string digit;
    istringstream iss(IP);

    if (count(begin(IP), end(IP), '.') == 3) {
      for (int i = 0; i < 4; ++i)  // Make sure we have 4 parts
        if (!getline(iss, digit, '.') || !isIPv4(digit))
          return ""Neither"";
      return ""IPv4"";
    }

    if (count(begin(IP), end(IP), ':') == 7) {
      for (int i = 0; i < 8; ++i)  // Make sure we have 8 parts
        if (!getline(iss, digit, ':') || !isIPv6(digit))
          return ""Neither"";
      return ""IPv6"";
    }

    return ""Neither"";
  }

 private:
  static inline string validIPv6Chars = ""0123456789abcdefABCDEF"";

  bool isIPv4(const string& digit) {
    if (digit.empty() || digit.length() > 3)
      return false;
    if (digit.length() > 1 && digit[0] == '0')
      return false;

    for (const char c : digit)
      if (c < '0' || c > '9')
        return false;

    const int num = stoi(digit);
    return 0 <= num && num <= 255;
  }

  bool isIPv6(const string& digit) {
    if (digit.empty() || digit.length() > 4)
      return false;

    for (const char c : digit)
      if (validIPv6Chars.find(c) == string::npos)
        return false;

    return true;
  }
};"
"class Solution:
    def intersectionSizeTwo(self, A: List[List[int]]) -> int:
        A.sort(key=lambda x:(x[1],-x[0]))
        ans = []
        ans.append(A[0][1]-1)
        ans.append(A[0][1])
        n = len(A)
        # print(A)
        for i in range(1,n):
            if A[i][0]>ans[-1]:
                ans.append(A[i][1]-1)
                ans.append(A[i][1])
            elif A[i][0]>ans[-2]:
                ans.append(A[i][1])
        # print(ans)
        return len(ans)","class Solution {
 public:
  bool isConvex(vector<vector<int>>& points) {
    auto getCross = [](const vector<int>& p, const vector<int>& q,
                       const vector<int>& r) -> int {
      return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0]);
    };

    const int n = points.size();
    long sign = 0;

    for (int i = 0; i < points.size(); ++i) {
      const int cross =
          getCross(points[i], points[(i + 1) % n], points[(i + 2) % n]);
      if (cross == 0)  // P, q, r are collinear
        continue;
      if (sign == 0)  // Find first cross that's not 0
        sign = cross;
      else if (cross * sign < 0)
        return false;
    }

    return true;
  }
};"
"class Solution:
    def makeLargestSpecial(self, s: str) -> str:
        
        def fn(lo, hi): 
            if lo == hi: return """"
            vals = []
            ii, prefix = lo, 0
            for i in range(lo, hi):
                prefix += 1 if s[i] == ""1"" else -1 
                if prefix == 0: 
                    vals.append(""1"" + fn(ii+1, i) + ""0"")
                    ii = i+1
            return """".join(sorted(vals, reverse=True))
        
        return fn(0, len(s))","// The rand7() API is already defined for you.
// int rand7();
// @return a random integer in the range 1 to 7

class Solution {
 public:
  int rand10() {
    int num = 40;

    while (num >= 40)
      num = (rand7() - 1) * 7 + rand7() - 1;

    return num % 10 + 1;
  }
};"
"class Solution:
    def countPrimeSetBits(self, left: int, right: int) -> int:
        count=0
        s=[2,3,5,7,11,13,17,19,23,29,31]
        for i in range(left,right+1):
            if(bin(i).count('1') in s):
                count+=1
        return count","class Solution {
 public:
  string encode(string s) {
    const int n = s.length();
    // dp[i][j] := shortest encoded string of s[i..j]
    dp.resize(n, vector<string>(n));
    return encode(s, 0, n - 1);
  }

 private:
  vector<vector<string>> dp;

  string encode(const string& s, int i, int j) {
    if (!dp[i][j].empty())
      return dp[i][j];

    const string& curr = s.substr(i, j - i + 1);
    dp[i][j] = curr;

    if (dp[i][j].length() < 5)
      return dp[i][j];

    // Try all possible partitions
    for (int k = i; k < j; ++k) {
      const string& l = encode(s, i, k);
      const string& r = encode(s, k + 1, j);
      if (l.length() + r.length() < dp[i][j].length())
        dp[i][j] = l + r;
    }

    // Try to compress the string
    // E.g. s = aabaabaab -> 3[aab]
    for (int k = i; k <= j; ++k) {
      const string& pattern = s.substr(i, k - i + 1);
      if (curr.length() % pattern.length() == 0 &&
          regex_replace(curr, regex(pattern), """").empty()) {
        const string& candidate = to_string(curr.length() / pattern.length()) +
                                  '[' + encode(s, i, k) + ']';
        if (candidate.length() < dp[i][j].length())
          dp[i][j] = candidate;
      }
    }

    return dp[i][j];
  }
};"
"class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        
        # calculate last window index of each character in string
        # This will help to define the current window boundary
        last_idx = {c:i for i,c in enumerate(s)}    
                
        # Start with window size 1             
        res = [1]
        # define the boundary based on first character
        end = last_idx[s[0]]     
        
        # Following loop is similar to merge intervals
        # start the loop at index 1
        for i in range(1, len(s)):            
            if i <= end:
                # update current window boundary
                # and also the current window length
                end = max(end, last_idx[s[i]])
                res[-1] += 1
            else:
                # add the next window 
                res.append(1)
                end = last_idx[s[i]]
        
        return res","class Solution {
 public:
  vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
    vector<string> ans;
    unordered_set<string> wordSet{begin(words), end(words)};
    unordered_map<string, bool> memo;

    for (const string& word : words)
      if (isConcat(word, wordSet, memo))
        ans.push_back(word);

    return ans;
  }

 private:
  bool isConcat(const string& s, const unordered_set<string>& wordSet,
                unordered_map<string, bool>& memo) {
    if (const auto it = memo.find(s); it != cend(memo))
      return it->second;

    for (int i = 1; i < s.length(); ++i) {
      const string prefix = s.substr(0, i);
      const string suffix = s.substr(i);
      if (wordSet.count(prefix) &&
          (wordSet.count(suffix) || isConcat(suffix, wordSet, memo)))
        return memo[s] = true;
    }

    return memo[s] = false;
  }
};"
"class Solution:
    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:
        dp = [[n] * n for _ in range(n)]
        for i, j in mines:
            dp[i][j] = 0
        
        for i in range(n):
            left = up = right = down = 0
            for j in range(n):
                if dp[i][j] == 0:
                    left = 0
                else:
                    left += 1
                    dp[i][j] = min(dp[i][j], left)
                
                if dp[j][i] == 0:
                    up = 0
                else:
                    up += 1
                    dp[j][i] = min(dp[j][i], up)
                
                j = ~j
                if dp[i][j] == 0:
                    right = 0
                else:
                    right += 1
                    dp[i][j] = min(dp[i][j], right)
                
                if dp[j][i] == 0:
                    down = 0
                else:
                    down += 1
                    dp[j][i] = min(dp[j][i], down)
        
        return max(val for row in dp for val in row)","class Solution {
 public:
  bool makesquare(vector<int>& matchsticks) {
    if (matchsticks.size() < 4)
      return false;

    const int perimeter = accumulate(begin(matchsticks), end(matchsticks), 0);
    if (perimeter % 4 != 0)
      return false;

    sort(begin(matchsticks), end(matchsticks), greater<int>());
    return dfs(matchsticks, 0, vector<int>(4, perimeter / 4));
  }

 private:
  bool dfs(const vector<int>& matchsticks, int selected, vector<int>&& edges) {
    if (selected == matchsticks.size())
      return all_of(begin(edges), end(edges),
                    [](int edge) { return edge == 0; });

    for (int i = 0; i < 4; ++i) {
      if (matchsticks[selected] > edges[i])
        continue;
      edges[i] -= matchsticks[selected];
      if (dfs(matchsticks, selected + 1, move(edges)))
        return true;
      edges[i] += matchsticks[selected];
    }

    return false;
  }
};"
"class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        d = {v: k for k, v in enumerate(row)} # get the number->position dictionary
        count = 0
        for i in range(0, len(row), 2):
            pair = row[i]^1 # use XOR to find pair number
            if row[i+1] == pair: continue
            pos = d[pair]
            row[i+1], row[pos] = row[pos], row[i+1] # find the pair of row[i]
            d[row[pos]] = pos # update row[pos] position in dictionary
            count += 1
        return count","class Solution {
 public:
  int findMaxForm(vector<string>& strs, int m, int n) {
    // dp[i][j] := max size of the subset given i 0's and j 1's are available
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (const string& s : strs) {
      const int count0 = count(begin(s), end(s), '0');
      const int count1 = s.length() - count0;
      for (int i = m; i >= count0; --i)
        for (int j = n; j >= count1; --j)
          dp[i][j] = max(dp[i][j], dp[i - count0][j - count1] + 1);
    }

    return dp[m][n];
  }
};"
"class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        for i in range(1 ,len(matrix)):
            for j in range(1, len(matrix[0])):
                if matrix[i - 1][j - 1] != matrix[i][j]:
                        return False
        return True","class Solution {
 public:
  int findRadius(vector<int>& houses, vector<int>& heaters) {
    sort(begin(houses), end(houses));
    sort(begin(heaters), end(heaters));

    int ans = 0;
    int i = 0;  // Point to the heater that currently used

    for (const int house : houses) {
      while (i + 1 < heaters.size() &&
             house - heaters[i] > heaters[i + 1] - house)
        ++i;  // Next heater is better
      ans = max(ans, abs(heaters[i] - house));
    }

    return ans;
  }
};"
"class Solution:
    def reorganizeString(self, S: str) -> str:
        L, A, m, B = len(S), [0]*len(S), 1-len(S) % 2, []
        for k,v in collections.Counter(S).most_common(): B += k*v
        for i,c in enumerate(B):
            I = (2*i + (2*i >= L)*m) % L
            A[I] = c
            if I != 0 and A[I-1] == c: return ''
        return """".join(A)
		
		
- Junaid Mansuri","class Solution {
 public:
  int findComplement(long num) {
    for (long i = 1; i <= num; i <<= 1)
      num ^= i;
    return num;
  }
};"
"class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        n=len(arr)
        que=[]
        res=0
        for i in range(n-1,-1,-1):
            if not que or arr[i]<=que[0]:
                que.insert(0,arr[i])
                res+=1
            else:
                a=bisect_left(que,arr[i])
                if len(que)-1-a<0:
                    que=que[0:1]
                    res=1
                elif a-1!=0:
                    res=len(que)-a+1
                    que=que[0:1]+que[a:]
        return res","class Solution {
 public:
  int totalHammingDistance(vector<int>& nums) {
    int ans = 0;
    int mask = 1;

    for (int i = 0; i < 30; ++i) {
      const int onesCount = count_if(begin(nums), end(nums),
                                     [&mask](int num) { return num & mask; });
      const int zerosCount = nums.size() - onesCount;
      ans += onesCount * zerosCount;
      mask <<= 1;
    }

    return ans;
  }
};"
"class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        largest_chunk=0
        start=0
        for i in range(len(arr)):
            visited=[False]*len(arr)
            for j in range(start,i+1):
                visited[arr[j]]=True
            if all(visited[start:i+1]):
                largest_chunk+=1
                start=i+1
        return largest_chunk","class Solution {
 public:
  Solution(double radius, double x_center, double y_center)
      : radius(radius), x_center(x_center), y_center(y_center) {}

  vector<double> randPoint() {
    const double length = sqrt(distribution(generator)) * radius;
    const double degree = distribution(generator) * 2 * M_PI;
    const double x = x_center + length * cos(degree);
    const double y = y_center + length * sin(degree);
    return {x, y};
  }

 private:
  const double radius;
  const double x_center;
  const double y_center;
  default_random_engine generator;
  uniform_real_distribution<double> distribution =
      uniform_real_distribution<double>(0.0, 1.0);
};"
"class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        count = 0
        for s in jewels:
            count += stones.count(s)
        return count","class Solution {
 public:
  int largestPalindrome(int n) {
    if (n == 1)
      return 9;

    constexpr int kMod = 1337;
    const int upper = pow(10, n) - 1;
    const int lower = pow(10, n - 1) - 1;

    for (int i = upper; i > lower; --i) {
      const long cand = getPalindromeCandidate(i);
      for (long j = upper; j * j >= cand; --j)
        if (cand % j == 0)
          return cand % kMod;
    }

    throw;
  }

 private:
  long getPalindromeCandidate(int i) {
    string reversed = to_string(i);
    reverse(begin(reversed), end(reversed));
    return stol(to_string(i) + reversed);
  }
};"
"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        board = board[0] + board[1] # flatten into vector 
        
        ans = 0 
        seen = set([tuple(board)])
        queue = [board]
        while queue: 
            newq = []
            for x in queue: 
                if x == [1,2,3,4,5,0]: return ans 
                k = x.index(0)
                for kk in (k-1, k+1, k-3, k+3): 
                    if 0 <= kk < 6 and (k, kk) not in ((2, 3), (3, 2)):
                        xx = x.copy()
                        xx[k], xx[kk] = xx[kk], xx[k]
                        if tuple(xx) not in seen: 
                            seen.add(tuple(xx))
                            newq.append(xx)
            queue = newq 
            ans += 1
        return -1","class Solution {
 public:
  vector<double> medianSlidingWindow(vector<int>& nums, int k) {
    vector<double> ans;
    multiset<double> window(begin(nums), begin(nums) + k);
    auto it = next(begin(window), (k - 1) / 2);

    for (int i = k;; ++i) {
      const double median = k & 1 ? *it : (*it + *next(it)) / 2.0;
      ans.push_back(median);
      if (i == nums.size())
        break;
      window.insert(nums[i]);
      if (nums[i] < *it)
        --it;
      if (nums[i - k] <= *it)
        ++it;
      window.erase(window.lower_bound(nums[i - k]));
    }

    return ans;
  }
};"
"class Solution:
    def isIdealPermutation(self, A: List[int]) -> bool:
        m=float('inf')
        for i in range(len(A)-1,1,-1):
            m=min(m,A[i])
            if A[i-2]>m:
                return False
        return True","class Solution {
 public:
  int magicalString(int n) {
    string s = "" 122"";

    for (int i = 3; i <= n; ++i)
      if (i & 1)
        s.append(s[i] - '0', '1');
      else
        s.append(s[i] - '0', '2');

    return count(begin(s), begin(s) + n + 1, '1');
  }
};"
"class Solution:
    def canTransform(self, start: str, end: str) -> bool: 
        ret_0 = collections.defaultdict(int)
        ret_1 = collections.defaultdict(int)
        lst_0, lst_1 = [[]]*2
        r0, r1 = [""""]*2 
        i = 0
        while i < len(start):
            if start[i] in ""LR"":
                ret_0[start[i]] += 1
                r0 += start[i]
            if end[i] in ""LR"":
                ret_1[end[i]] += 1
                r1 += end[i]
            if ret_0[""R""] >= ret_1[""R""] and ret_0[""L""] <= ret_1[""L""]:
                pass
            else:
                return False
            i += 1
                 
        return True if r0 == r1 else False","class Solution {
 public:
  string licenseKeyFormatting(string s, int k) {
    string ans;
    int length = 0;

    for (int i = s.length() - 1; i >= 0; --i) {
      if (s[i] == '-')
        continue;
      if (length > 0 && length % k == 0)
        ans += ""-"";
      ans += toupper(s[i]);
      ++length;
    }

    return {rbegin(ans), rend(ans)};
  }
};"
"class Solution:
    def swimInWater(self, grid) -> int:
        rows = len(grid)
        cols = len(grid[0])
        T = [[float('-inf') for _ in range(cols)] for _ in range(rows)]
        stack = [(grid[0][0], 0,0)]

        visited = {}

        while stack:
            time,x,y = heapq.heappop(stack)
            nei = [(1,0), (-1,0), (0,1),(0,-1)]
            for dx,dy in nei:
                nx, ny = x+dx, y+dy
                if (nx,ny) not in visited and nx >= 0 and nx < rows and ny >= 0 and ny < cols:
                    T[nx][ny] = max(grid[nx][ny], time)
                    visited[(nx,ny)] = True
                    if nx == rows-1 and ny == cols-1:
                        return T[-1][-1]
                    heapq.heappush(stack, (max(grid[nx][ny], time), nx, ny))

        return T[-1][-1]","class Solution {
 public:
  string smallestGoodBase(string n) {
    const long num = stol(n);

    for (int m = log2(num); m >= 2; --m) {
      const int k = pow(num, 1.0 / m);
      long sum = 1;
      long prod = 1;
      for (int i = 0; i < m; ++i) {
        prod *= k;
        sum += prod;
      }
      if (sum == num)
        return to_string(k);
    }

    return to_string(num - 1);
  }
};"
"class Solution:
    def kthGrammar(self, N: int, K: int) -> int:
        memo = {(1,1): 0}
        def helper(n,k):
            if (n,k) in memo: 
                return memo[(n,k)]
                
            if k==1: return 0
            
            t = helper(n-1, math.ceil(k/2))
            if t==0:
                if k%2==0: return 1
                else: return 0
                
            if t==1:
                if k%2==0: return 0
                else: return 1
                
        return helper(N,K)","class Solution {
 public:
  vector<int> findPermutation(string s) {
    vector<int> ans;
    stack<int> stack;

    for (int i = 0; i < s.length(); ++i) {
      stack.push(i + 1);
      if (s[i] == 'I')
        while (!stack.empty())
          ans.push_back(stack.top()), stack.pop();
    }
    stack.push(s.length() + 1);

    while (!stack.empty())
      ans.push_back(stack.top()), stack.pop();

    return ans;
  }
};"
"class Solution:
    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:
        # if both of sx, sy are even, only evens can be generated, but not all evens can be generated 
        # as such, if you have any odds only in the end target, return false 
        if (sx % 2 == sy % 2 == 0) and ((tx % 2 != 0) or (ty % 2 != 0)) : 
            return False 
        # or if you have matches that are exactly equal, return True 
        elif (sx == sy == tx == ty) or (sx == tx and sy == ty) : 
            return True
        else : 
            # otherwise, return the euclidean gcd procession 
            return self.euclidean_gcd(sx, sy, tx, ty)

    def euclidean_gcd(self, sx, sy, tx, ty) : 
        # loop while tx and ty are greater than or equaal to their target 
        # count = 0 
        # loop zero printing can be commented out 
        # self.print_euclidean_progression(sx, sy, tx, ty, count)
        while (tx >= sx) and (ty >= sy) :
            # if these are equal to each other, break 
            if tx == ty : 
                break
            # otherwise, depending on which is larger 
            elif tx > ty : 
                # if the other target is above their start still 
                if ty > sy : 
                    # modulo reduction to remainder 
                    tx %= ty 
                else : 
                    # if it is at the target, return the modulo result for gcd 
                    return (tx - sx) % ty == 0 
            else : 
                # see above section for logic breakdown 
                if tx > sx : 
                    ty %= tx 
                else : 
                    return (ty - sy) % tx == 0 
            # increment count 
            # count += 1 
            # loop repeats with new values 
            # self.print_euclidean_progression(sx, sy, tx, ty, count)
        # either you broke early due to tx == ty or you completed thee loop when they are less than the valuation 
        # could still be the case that sx == tx and sy == ty 
        # handled by above edge cases for non-loop progression variant 
        # return (sx == tx and sy == ty)
        return False 
    
    def print_euclidean_progression(self, sx, sy, tx, ty, count) : 
        print(""At count "", count, "" the values of sx, sy are "", (sx, sy), "" and the values of tx, ty are "", (tx, ty))","class Solution {
 public:
  int findMaxConsecutiveOnes(vector<int>& nums) {
    int ans = 0;
    int sum = 0;

    for (const int num : nums)
      if (num == 1)
        ans = max(ans, ++sum);
      else
        sum = 0;

    return ans;
  }
};"
"class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        ans = 0
        cnt = defaultdict(int)
        for x in answers: 
            if not cnt[x] % (1 + x): ans += 1 + x # reached capacity &amp; update ans
            cnt[x] += 1
        return ans","class Solution {
 public:
  bool PredictTheWinner(vector<int>& nums) {
    const int n = nums.size();
    // dp[i][j] := max number you can get more than your opponent in nums[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = nums[i];

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
      }

    return dp[0][n - 1] >= 0;
  }
};"
"class Solution:
    def movesToChessboard(self, board: List[List[int]]) -> int:
        n = len(board)
        
        def fn(vals): 
            """"""Return min moves to transform to chessboard.""""""
            total = odd = 0 
            for i, x in enumerate(vals): 
                if vals[0] == x: 
                    total += 1
                    if i&amp;1: odd += 1
                elif vals[0] ^ x != (1 << n) - 1: return inf
            ans = inf 
            if len(vals) <= 2*total <= len(vals)+1: ans = min(ans, odd)
            if len(vals)-1 <= 2*total <= len(vals): ans = min(ans, total - odd)
            return ans 
        
        rows, cols = [0]*n, [0]*n
        for i in range(n): 
            for j in range(n): 
                if board[i][j]: 
                    rows[i] ^= 1 << j 
                    cols[j] ^= 1 << i
        ans = fn(rows) + fn(cols)
        return ans if ans < inf else -1","class Solution {
 public:
  int findMaxConsecutiveOnes(vector<int>& nums) {
    int ans = 0;
    int zeros = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (nums[r] == 0)
        ++zeros;
      while (zeros == 2)
        if (nums[l++] == 0)
          --zeros;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};"
"class Solution:
    def minDiffInBST(self, root: TreeNode) -> int:
        low = []
        def inorder (root):
            if root is None:
                return 
            inorder(root.left)
            low.append(root.val)
            inorder(root.right)
        inorder(root)
        print(low)
        return min(low[i+1] - low[i]
                   for i in range(len(low) - 1))","class Solution {
 public:
  int findMinStep(string board, string hand) {
    const int ans = dfs(board + ""#"", hand, {});
    return ans == INT_MAX ? -1 : ans;
  }

 private:
  int dfs(string&& board, const string& hand,
          unordered_map<string, int>&& memo) {
    const string hashKey = board + '#' + hand;
    if (const auto it = memo.find(hashKey); it != cend(memo))
      return it->second;
    board = deDup(board);
    if (board == ""#"")
      return 0;

    unordered_set<char> boardSet = unordered_set(begin(board), end(board));

    string hs;  // Hand that in board
    for (const char h : hand)
      if (boardSet.count(h))
        hs += h;
    if (hs.empty())  // Infeasible
      return INT_MAX;

    int ans = INT_MAX;

    for (int i = 0; i < board.size(); ++i)
      for (int j = 0; j < hs.size(); ++j) {
        // Place hs[j] in board[i]
        const string& newHand = hs.substr(0, j) + hs.substr(j + 1);
        string newBoard = board.substr(0, i) + hs[j] + board.substr(i);
        const int res = dfs(move(newBoard), newHand, move(memo));
        if (res < INT_MAX)
          ans = min(ans, 1 + res);
      }

    return memo[hashKey] = ans;
  }

  string deDup(string board) {
    int start = 0;  // Start index of a color sequenece
    for (int i = 0; i < board.size(); ++i)
      if (board[i] != board[start]) {
        if (i - start >= 3)
          return deDup(board.substr(0, start) + board.substr(i));
        start = i;  // Meet a new sequence
      }
    return board;
  }
};"
"class Solution:
    def letterCasePermutation(self, S: str) -> List[str]:
        
        # ending condition
        if len(S)==1:
            if S.isdigit(): return [S]
            else: return [S.lower(), S.upper()]
        
        first_char, remain = S[0], S[1:]
        remain_permutation = self.letterCasePermutation(remain)
        # if digit
        if first_char.isdigit():
            return [str(first_char) + item for item in remain_permutation]
        # if letter
        else:
            return [first_char.lower() + item for item in remain_permutation] + [first_char.upper() + item for item in remain_permutation]","/**
 * // This is the robot's control interface.
 * // You should not implement it, or speculate about its implementation
 * class Robot {
 *  public:
 *   // Returns true if the cell in front is open and robot moves into the cell.
 *   // Returns false if the cell in front is blocked and robot stays in the
 *   // Current cell. bool move();
 *
 *   // Robot will stay in the same cell after calling turnLeft/turnRight.
 *   // Each turn will be 90 degrees.
 *   void turnLeft();
 *   void turnRight();
 *
 *   // Clean the current cell.
 *   void clean();
 * };
 */

class Solution {
 public:
  void cleanRoom(Robot& robot) {
    dfs(robot, 0, 0, 0, unordered_set<pair<int, int>, pairHash>());
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};

  struct pairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };

  void dfs(Robot& robot, int i, int j, int d,
           unordered_set<pair<int, int>, pairHash>&& seen) {
    seen.insert({i, j});
    robot.clean();

    // Explore clockwise: 0: ^, 1: >, 2: v, 3: <
    // The order is important since the idea is always turn right
    for (int k = 0; k < 4; ++k) {
      const int newD = (d + k) % 4;
      const int x = i + dirs[newD];
      const int y = j + dirs[newD + 1];
      if (!seen.count({x, y}) && robot.move()) {
        dfs(robot, x, y, newD, move(seen));
        // Go back to the previous cell
        robot.turnRight();
        robot.turnRight();
        robot.move();
        // Go back to the original direction
        robot.turnRight();
        robot.turnRight();
      }
      robot.turnRight();  // Always turn the robot clockwise
    }
  }
};"
"class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:      
        colors = [0]*len(graph)                         # 0: no color, 1: red, -1: green

        def dfs(node: int, node_color: int) -> bool:    # node: current node, node_color: current node's color
            if colors[node] != 0:                       # if current node was already colored
                return colors[node] == node_color       # return True if current node was colored the same
            
            colors[node] = node_color                   # color current node
            for neighbor in graph[node]:                # iterate current node's neighbor nodes
                if not dfs(neighbor, -1*node_color):    # DFS neighbor nodes with different color
                    return False                        # return False if neighbors are non-bipartite (short-circuit)
            return True

        for node in range(len(graph)):
            if colors[node] == 0 and not dfs(node, 1):  # iterate for nodes that are not connected 
                return False                            # return False if a connected nodes are non-bipartite (short-circuit)
            
        return True","class Solution {
 public:
  bool hasPath(vector<vector<int>>& maze, vector<int>& start,
               vector<int>& destination) {
    const int m = maze.size();
    const int n = maze[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<pair<int, int>> q{{{start[0], start[1]}}};
    vector<vector<bool>> seen(m, vector<bool>(n));
    seen[start[0]][start[1]] = true;

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        int x = i;
        int y = j;
        while (isValid(maze, x + dirs[k], y + dirs[k + 1])) {
          x += dirs[k];
          y += dirs[k + 1];
        }
        if (x == destination[0] && y == destination[1])
          return true;
        if (seen[x][y])
          continue;
        q.emplace(x, y);
        seen[x][y] = true;
      }
    }

    return false;
  }

 private:
  bool isValid(const vector<vector<int>>& maze, int x, int y) {
    return 0 <= x && x < maze.size() && 0 <= y && y < maze[0].size() &&
           maze[x][y] == 0;
  }
};"
"class Solution:
    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:
        pq = [(arr[i]/arr[-1], i, -1) for i in range(len(arr)-1)]
        for _ in range(k): 
            _, i, j = heappop(pq)
            if i - j + 1 < len(arr): heappush(pq, (arr[i]/arr[j-1], i, j-1))
        return [arr[i], arr[j]]","class Solution {
 public:
  vector<vector<int>> findSubsequences(vector<int>& nums) {
    vector<vector<int>> ans;
    dfs(nums, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, int s, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (path.size() > 1)
      ans.push_back(path);

    unordered_set<int> used;

    for (int i = s; i < nums.size(); ++i) {
      if (used.count(nums[i]))
        continue;
      if (path.empty() || nums[i] >= path.back()) {
        used.insert(nums[i]);
        path.push_back(nums[i]);
        dfs(nums, i + 1, move(path), ans);
        path.pop_back();
      }
    }
  }
};"
"class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        dist_price = [float('inf') for _ in range(n)]
        dist_price[src]=0
        
        for source,dest,cost in flights:
            if src==source:
                dist_price[dest] = cost
        
        for times in range(0,K):
            
            temp = [*dist_price]
            
            for srce,dest,cost in flights:
                temp[dest] = min(temp[dest] , cost + dist_price[srce])
            dist_price = temp
        
        if dist_price[dst] == float('inf'):
            return -1
        return dist_price[dst]","class Solution {
 public:
  vector<int> constructRectangle(int area) {
    int width = sqrt(area);

    while (area % width)
      --width;

    return {area / width, width};
  }
};"
"class Solution:
    def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:
        l = [abs(ghost[0]-target[0])+abs(ghost[1]-target[1]) for ghost in ghosts]
        return min(l)>abs(target[0])+abs(target[1])","class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  int reversePairs(vector<int>& nums) {
    int ans = 0;
    unordered_map<long, int> ranks;
    getRanks(nums, ranks);
    FenwickTree tree(ranks.size());

    for (int i = nums.size() - 1; i >= 0; --i) {
      const long num = nums[i];
      ans += tree.get(ranks[num] - 1);
      tree.update(ranks[num * 2], 1);
    }

    return ans;
  }

 private:
  void getRanks(const vector<int>& nums, unordered_map<long, int>& ranks) {
    set<long> sorted(begin(nums), end(nums));
    for (const long num : nums)
      sorted.insert(num * 2);
    int rank = 0;
    for (const long num : sorted)
      ranks[num] = ++rank;
  }
};"
"class Solution:
    def numTilings(self, N: int) -> int:
        f0, f1, f2 = 0, 1, 1
        for i in range(N-1): f0, f1, f2 = f1, f2, (2*f2 + f0) % 1_000_000_007
        return f2","class Solution {
 public:
  int findTargetSumWays(vector<int>& nums, int target) {
    const int sum = accumulate(begin(nums), end(nums), 0);
    if (sum < abs(target) || (sum + target) & 1)
      return 0;
    return knapsack(nums, (sum + target) / 2);
  }

 private:
  int knapsack(const vector<int>& nums, int target) {
    const int n = nums.size();
    // dp[i][j] := # of ways to sum to j by nums[0..i)
    vector<vector<int>> dp(n + 1, vector<int>(target + 1));
    dp[0][0] = 1;

    for (int i = 1; i <= n; ++i) {
      const int num = nums[i - 1];
      for (int j = 0; j <= target; ++j)
        if (j < num)
          dp[i][j] = dp[i - 1][j];
        else
          dp[i][j] = dp[i - 1][j] + dp[i - 1][j - num];
    }

    return dp[n][target];
  }
};"
"class Solution:
    def customSortString(self, S: str, T: str) -> str:
        letter_count = collections.Counter(T)
        other_letters = set(string.ascii_lowercase) - set(S)
        order = S + ''.join(other_letters)
        result = []
        for letter in order:
            result.extend([letter * letter_count[letter]])
        return ''.join(result)","class Solution {
 public:
  int findPoisonedDuration(vector<int>& timeSeries, int duration) {
    if (duration == 0)
      return 0;

    int ans = 0;

    for (int i = 0; i + 1 < timeSeries.size(); ++i)
      ans += min(timeSeries[i + 1] - timeSeries[i], duration);

    return ans + duration;
  }
};"
"class Solution:
    def numMatchingSubseq(self, s: str, words: List[str]) -> int:
        def isSubSeq(s1, s2):
            iter = 0
            
            for index, val in enumerate(s1):
                if val == s2[iter]:
                    iter += 1
                    
                if iter == len(s2):
                    break
            
            return iter == len(s2)
        
        return sum([1 if isSubSeq(s, w) else 0 for w in words])","class Solution {
 public:
  vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
    vector<int> ans;
    unordered_map<int, int> numToNextGreater;
    stack<int> stack;  // decreasing stack

    for (const int num : nums2) {
      while (!stack.empty() && stack.top() < num)
        numToNextGreater[stack.top()] = num, stack.pop();
      stack.push(num);
    }

    for (const int num : nums1)
      if (const auto it = numToNextGreater.find(num);
          it != cend(numToNextGreater))
        ans.push_back(it->second);
      else
        ans.push_back(-1);

    return ans;
  }
};"
"class Solution:

    def preimageSizeFZF(self, k: int) -> int:
        if k < 5:
            return 5
        elif k == 5:
            return 0
        left, right = 4, 5 * k
        while left < right:
            middle = (left + right) // 2
            zeros = sum(middle // pow(5, p)
                        for p in range(1, int(log(middle, 5)) + 1))
            if zeros < k:
                left = middle + 1
            elif zeros > k:
                right = middle - 1
            else:
                return 5
        return 0","class Solution {
 public:
  vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<int> ans(m * n);
    int d = 1;  // Left-bottom -> right-top
    int row = 0;
    int col = 0;

    for (int i = 0; i < m * n; ++i) {
      ans[i] = matrix[row][col];
      row -= d;
      col += d;
      // Out of bound
      if (row == m)
        row = m - 1, col += 2, d = -d;
      if (col == n)
        col = n - 1, row += 2, d = -d;
      if (row < 0)
        row = 0, d = -d;
      if (col < 0)
        col = 0, d = -d;
    }

    return ans;
  }
};"
"class Solution:
    def validTicTacToe(self, b: List[str]) -> bool:
    	T, w = {'XXX':0, 'OOO':0}, """".join(b).count('X') - """".join(b).count('O')
    	for i in [0,1,2]: T[b[0][i]+b[1][i]+b[2][i]], T[b[i][0]+b[i][1]+b[i][2]], T[b[0][2*i//2]+b[1][1]+b[2][2*(1-i//2)]] = 1, 1, 1
    	return False if (w not in [0,1]) or (T['XXX'] == 1 and w != 1) or (T['OOO'] == 1 and w != 0) else True
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  string findShortestWay(vector<vector<int>>& maze, vector<int>& ball,
                         vector<int>& hole) {
    string ans = ""impossible"";
    dfs(maze, ball[0], ball[1], hole, 0, 0, 0, INT_MAX, """", ans);
    return ans;
  }

 private:
  void dfs(vector<vector<int>>& maze, int i, int j, const vector<int>& hole,
           int dx, int dy, int steps, int&& minSteps, string&& path,
           string& ans) {
    if (steps >= minSteps)
      return;

    if (dx != 0 || dy != 0) {  // Both are zero for the initial ball position
      while (i + dx >= 0 && i + dx < maze.size() && j + dy >= 0 &&
             j + dy < maze[0].size() && maze[i + dx][j + dy] != 1) {
        i += dx;
        j += dy;
        ++steps;
        if (i == hole[0] && j == hole[1] && steps < minSteps) {
          minSteps = steps;
          ans = path;
        }
      }
    }

    if (maze[i][j] == 0 || steps + 2 < maze[i][j]) {
      maze[i][j] = steps + 2;  // +2 to because of maze[i][j] == 0 || 1
      if (dx == 0)
        dfs(maze, i, j, hole, 1, 0, steps, move(minSteps), path + ""d"", ans);
      if (dy == 0)
        dfs(maze, i, j, hole, 0, -1, steps, move(minSteps), path + ""l"", ans);
      if (dy == 0)
        dfs(maze, i, j, hole, 0, 1, steps, move(minSteps), path + ""r"", ans);
      if (dx == 0)
        dfs(maze, i, j, hole, -1, 0, steps, move(minSteps), path + ""u"", ans);
    }
  }
};"
"class Solution:
    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:
        ans, prev = 0, 0
        i, j = 0, 0
        n = len(nums)
        
        for j in range(n):
            if left <= nums[j] <= right:
                prev = (j-i+1)
                ans += prev
            elif nums[j] < left:
                ans += prev
            else:
                i, prev = j+1, 0
        
        return ans","class Solution {
 public:
  vector<string> findWords(vector<string>& words) {
    vector<string> ans;
    const vector<int> rows{2, 3, 3, 2, 1, 2, 2, 2, 1, 2, 2, 2, 3,
                           3, 1, 1, 1, 1, 2, 1, 1, 3, 1, 3, 1, 3};

    for (const string& word : words) {
      string lowerWord = word;
      transform(begin(lowerWord), end(lowerWord), begin(lowerWord), ::tolower);
      const int row = rows[lowerWord[0] - 'a'];
      const bool isValid = all_of(begin(lowerWord), end(lowerWord),
                                  [&](int c) { return rows[c - 'a'] == row; });
      if (isValid)
        ans.push_back(word);
    }

    return ans;
  }
};"
"class Solution:
    def rotateString(self, s: str, goal: str) -> bool:
        if len(s) == len(goal):
            x = 2*s
            return goal in x
        return False","class Solution {
 public:
  vector<int> findMode(TreeNode* root) {
    vector<int> ans;
    int count = 0;
    int maxCount = 0;

    inorder(root, count, maxCount, ans);
    return ans;
  }

 private:
  TreeNode* pred = nullptr;

  void inorder(TreeNode* root, int& count, int& maxCount, vector<int>& ans) {
    if (root == nullptr)
      return;

    inorder(root->left, count, maxCount, ans);
    updateCount(root, count, maxCount, ans);
    inorder(root->right, count, maxCount, ans);
  }

  void updateCount(TreeNode* root, int& count, int& maxCount,
                   vector<int>& ans) {
    if (pred && pred->val == root->val)
      ++count;
    else
      count = 1;

    if (count > maxCount) {
      maxCount = count;
      ans = {root->val};
    } else if (count == maxCount) {
      ans.push_back(root->val);
    }

    pred = root;
  }
};"
"class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        total = [[0]]
        ans = []
        target = len(graph) - 1
        while total: # start BFS
            itr = total.pop(0)
            last = itr[-1]
            possible = graph[last]
            if not possible: #not possible means no valid edge stars with the end of this path
                continue
            for i in possible:
                if i == target: #find valid path, concact the target, and append it to answer
                    ans.append(itr + [target])
                    continue
                total.append(itr + [i]) #add all pending path to the end of the queue
        return ans","struct T {
  int pro;
  int cap;
  T(int pro, int cap) : pro(pro), cap(cap) {}
};

class Solution {
 public:
  int findMaximizedCapital(int k, int W, vector<int>& Profits,
                           vector<int>& Capital) {
    auto compareC = [](const T& a, const T& b) { return a.cap > b.cap; };
    auto compareP = [](const T& a, const T& b) { return a.pro < b.pro; };
    priority_queue<T, vector<T>, decltype(compareC)> minHeap(compareC);
    priority_queue<T, vector<T>, decltype(compareP)> maxHeap(compareP);

    for (int i = 0; i < Capital.size(); ++i)
      minHeap.emplace(Profits[i], Capital[i]);

    while (k--) {
      while (!minHeap.empty() && minHeap.top().cap <= W)
        maxHeap.push(minHeap.top()), minHeap.pop();
      if (maxHeap.empty())
        break;
      W += maxHeap.top().pro, maxHeap.pop();
    }

    return W;
  }
};"
"class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        diff = [1] * len(nums)
        for i, x in enumerate(nums): 
            diff[(i-x+1) % len(nums)] -= 1
        prefix = list(accumulate(diff))
        return prefix.index(max(prefix))","class Solution {
 public:
  vector<int> nextGreaterElements(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n, -1);
    stack<int> stack;  // decreasing stack storing indices

    for (int i = 0; i < n * 2; ++i) {
      const int num = nums[i % n];
      while (!stack.empty() && nums[stack.top()] < num)
        ans[stack.top()] = num, stack.pop();
      if (i < n)
        stack.push(i);
    }

    return ans;
  }
};"
"class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        
        
        dp =[ [0]*row for row in range(1,100+2) ]
        
        
        dp[0][0] = poured
        
        
        for i in range(query_row+1):
            
            for j in range(i+1):# calculating the amount of liquid which will left after completely filling this cup
                
                left = (dp[i][j] -1)/2
                
                if left >0:
                    dp[i+1][j]+=left
                    dp[i+1][j+1]+=left
                    
        return min(1, dp[query_row][query_glass])","class Solution {
 public:
  string convertToBase7(int num) {
    if (num < 0)
      return ""-"" + convertToBase7(-num);
    if (num < 7)
      return to_string(num);
    return convertToBase7(num / 7) + to_string(num % 7);
  }
};"
"class Solution:
    def minSwap(self, nums1: List[int], nums2: List[int]) -> int:
        dp = [[-1]*2 for i in range(len(nums1))]
        
        def solve(prev1, prev2, i, swaped):
            if i >= len(nums1): return 0
            if dp[i][swaped] != -1: return dp[i][swaped]
                        
            ans = 2**31
            
            # No Swap
            if nums1[i] > prev1 and nums2[i] > prev2:
                ans = solve(nums1[i], nums2[i], i+1, 0) 
            
            # Swap
            if nums1[i] > prev2 and nums2[i] > prev1:
                ans = min(ans, 1 + solve(nums2[i], nums1[i], i+1, 1)) 
            
            dp[i][swaped] = ans
            return ans
        
        return solve(-1, -1, 0, 0)","class Solution {
 public:
  int shortestDistance(vector<vector<int>>& maze, vector<int>& start,
                       vector<int>& destination) {
    const int m = maze.size();
    const int n = maze[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<pair<int, int>> q{{{start[0], start[1]}}};
    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
    dist[start[0]][start[1]] = 0;

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        int x = i;
        int y = j;
        int steps = dist[i][j];
        while (isValid(maze, x + dirs[k], y + dirs[k + 1])) {
          x += dirs[k];
          y += dirs[k + 1];
          ++steps;
        }
        if (steps < dist[x][y]) {
          dist[x][y] = steps;
          if (x == destination[0] && y == destination[1])
            continue;
          q.emplace(x, y);
        }
      }
    }

    return dist[destination[0]][destination[1]] == INT_MAX
               ? -1
               : dist[destination[0]][destination[1]];
  }

 private:
  bool isValid(const vector<vector<int>>& maze, int x, int y) {
    return x >= 0 && x < maze.size() && y >= 0 && y < maze[0].size() &&
           maze[x][y] == 0;
  }
};"
"class Solution:
    
    def is_cycle(self, graph: List[List[int]], node: int, is_visited: Set, is_safe: Set) -> bool:
        
        # IF node is already visited, return cycle detected true
        if node in is_visited:
            return True
        
        # IF node is already explored, and no cycle detected, return False
        if node in is_safe:
            return False
        
        # Add node to is_visited set
        is_visited.add(node)
        
        # Try to detect cycle in path of adjacent nodes
        for adj_node in graph[node]:
            if self.is_cycle(graph, adj_node, is_visited, is_safe):
                return True
        
        # Backtrack: Very important, as there can be many paths going through the same node.
        # And we might not have explored all of them. So remove the node from the visited set
        # and mark it as safe
        is_visited.remove(node)
        
        # Mark node as safe, as no cycle detected in its path
        is_safe.add(node)
        
        return False
    
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        
        # Init
        is_safe = set()
        is_visited = set()
        
        # Try to detect cycle for all the nodes
        for node in range(len(graph)):
            if node not in is_visited:
                self.is_cycle(graph, node, is_visited, is_safe)
                
        # Make sorted array of is_safe set
        is_safe = sorted(list(is_safe))
        
        return is_safe","class Solution {
 public:
  vector<string> findRelativeRanks(vector<int>& nums) {
    const int n = nums.size();
    vector<string> ans(n);
    vector<int> indices(n);

    iota(begin(indices), end(indices), 0);

    sort(begin(indices), end(indices),
         [&](const int a, const int b) { return nums[a] > nums[b]; });

    for (int i = 0; i < n; ++i)
      if (i == 0)
        ans[indices[0]] = ""Gold Medal"";
      else if (i == 1)
        ans[indices[1]] = ""Silver Medal"";
      else if (i == 2)
        ans[indices[2]] = ""Bronze Medal"";
      else
        ans[indices[i]] = to_string(i + 1);

    return ans;
  }
};"
"class Solution:
    def uniqueMorseRepresentations(self, words: List[str]) -> int:
        code=["".-"",""-..."",""-.-."",""-.."",""."",""..-."",""--."",""...."","".."","".---"",""-.-"","".-.."",""--"",""-."",""---"","".--."",""--.-"","".-."",""..."",""-"",""..-"",""...-"","".--"",""-..-"",""-.--"",""--..""]
        transformation=set()
        for word in words:
            s=''
            for letter in word:
                s=s+code[ord(letter)-97]
            transformation.add(s)
        return len(transformation)","class Solution {
 public:
  bool checkPerfectNumber(int num) {
    if (num == 1)
      return false;

    int sum = 1;

    for (int i = 2; i <= sqrt(num); ++i)
      if (num % i == 0)
        sum += i + num / i;

    return sum == num;
  }
};"
"class Solution:
    def splitArraySameAverage(self, A: List[int]) -> bool:
        A.sort()
        DP=[set() for _ in range(len(A)//2+1)]    #DP[i] stores the all available sum with i items in a bracket
        all_sum=sum(A)
        DP[0]=set([0])
        for item in A:                  #iterate over items in the list
            for count in range(len(DP)-2,-1,-1):          # iterate backwards w.r.t. the bracket size
                if len(DP[count])>0:                             # if DP[i] is not empty, then update DP[i+1] by adding the current item into all sums in DP[i]
                    for a in DP[count]:
                        DP[count+1].add(a+item)
        for size in range(1,len(DP)):
            if all_sum*size/len(A) in DP[size]:
                return True
        return False","class Solution {
 public:
  vector<int> findFrequentTreeSum(TreeNode* root) {
    vector<int> ans;
    unordered_map<int, int> count;
    int maxCount = 0;

    sumDownFrom(root, count);

    for (const auto& [_, freq] : count)
      maxCount = max(maxCount, freq);

    for (const auto& [sum, freq] : count)
      if (freq == maxCount)
        ans.push_back(sum);

    return ans;
  }

 private:
  int sumDownFrom(TreeNode* root, unordered_map<int, int>& count) {
    if (root == nullptr)
      return 0;

    const int sum = root->val + sumDownFrom(root->left, count) +
                    sumDownFrom(root->right, count);
    ++count[sum];
    return sum;
  }
};"
"class Solution:
    def numberOfLines(self, widths: List[int], s: str) -> List[int]:
        letter_w = {chr(97 + i): widths[i] for i in range(26)}
        n_lines = line_len = 0
        for c in s:
            line_len += letter_w[c]
            if line_len > 100:
                n_lines += 1
                line_len = letter_w[c]
        return [n_lines + (line_len > 0), line_len]","class Solution {
 public:
  int fib(int n) {
    if (n < 2)
      return n;

    vector<int> dp{0, 0, 1};

    for (int i = 2; i <= n; ++i) {
      dp[0] = dp[1];
      dp[1] = dp[2];
      dp[2] = dp[0] + dp[1];
    }

    return dp.back();
  }
};"
"class Solution:
    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        # the vertical skyline is the max # of each column
        # the horizontal skyline is the max # of each row
        
        # a building's height should be min(max of that row, max of that column)
        
        size = len(grid)
        
        columns = rows_to_columns(grid)
        
        row_maxs = list(max(row) for row in grid) # horizontal skyline
        
        column_maxs = list(max(column) for column in columns) # vertical skyline
        
        total_increase = 0
        
        for row in range(size):
            row_max = row_maxs[row]
            for column in range(size):
                column_max = column_maxs[column]
                max_height = min(column_max, row_max)
                actual_height = grid[row][column]
                total_increase += max_height - actual_height
                
        return total_increase
                
def rows_to_columns(grid: List[List[int]]):
    columns = []
    for i in range(len(grid)):
        column = []
        for row in grid:
            column.append(row[i])
        columns.append(column)
    return columns","class Solution {
 public:
  Node* inorderSuccessor(Node* node) {
    // The successor is somewhere lower in the right subtree
    if (node->right) {
      node = node->right;
      while (node->left)
        node = node->left;
      return node;
    }

    // The successor is somewhere upper in the tree
    while (node->parent && node->parent->left != node)
      node = node->parent;
    return node->parent;
  }
};"
"class Solution:
    def soupServings(self, n: int) -> float:
        if n >= 4276: return 1.0

        @lru_cache(None)
        def f(a: int, b: int)->float:
            if a <= 0 and b <= 0: return 0.5
            if a <= 0: return 1
            if b <= 0: return 0
            return (f(a-100,b) + f(a-75,b-25) + f(a-50,b-50) + f(a-25,b-75))*.25
        
        return f(n,n)","class Solution {
 public:
  int findBottomLeftValue(TreeNode* root) {
    queue<TreeNode*> q{{root}};
    TreeNode* node = nullptr;

    while (!q.empty()) {
      node = q.front();
      q.pop();
      if (node->right)
        q.push(node->right);
      if (node->left)
        q.push(node->left);
    }

    return node->val;
  }
};"
"class Solution:
    def expressiveWords(self, S: str, W: List[str]) -> int:
        LW, C, n = len(W), [], 0
        for s in [S]+W:
            C.append([[],[]])
            for k,g in itertools.groupby(s): C[-1][0].append(k), C[-1][1].append(len(list(g)))
        LC = len(C[0][0])
        for i in range(1,LW+1):
            if C[0][0] != C[i][0]: continue
            for j in range(LC):
                if C[i][1][j] > C[0][1][j] or (C[i][1][j] < C[0][1][j] and C[0][1][j] == 2): break
            else: n += 1
        return n
                
				
- Junaid Mansuri","class Solution {
 public:
  int findRotateSteps(string ring, string key) {
    return dfs(ring, key, 0, {}) + key.length();
  }

 private:
  // # of rotates of ring to match key[index:]
  int dfs(const string& ring, const string& key, int index,
          unordered_map<string, int>&& memo) {
    if (index == key.length())
      return 0;
    // Add the index to prevent duplicate
    const string hashKey = ring + to_string(index);
    if (const auto it = memo.find(hashKey); it != cend(memo))
      return it->second;

    int ans = INT_MAX;

    // For each ring[i] == key[index]
    // We rotate the ring to match ring[i] w/ key[index]
    // Then recursively match newRing w/ key[index + 1:]
    for (size_t i = 0; i < ring.length(); ++i)
      if (ring[i] == key[index]) {
        const int minRotates = min(i, ring.length() - i);
        const string& newRing = ring.substr(i) + ring.substr(0, i);
        const int remainingRotates = dfs(newRing, key, index + 1, move(memo));
        ans = min(ans, minRotates + remainingRotates);
      }

    return memo[hashKey] = ans;
  }
};"
"class Solution:
    def xorGame(self, nums: List[int]) -> bool:
        return reduce(xor, nums) == 0 or not len(nums)&amp;1","class Solution {
 public:
  vector<int> largestValues(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      int maxi = INT_MIN;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        maxi = max(maxi, node->val);
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(maxi);
    }

    return ans;
  }
};"
"class Solution:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        d= {}
        for cpdomain in cpdomains:
            page = """"      
            count, full_page = cpdomain.split(' ')
            sub_doms = full_page.split('.')[::-1]
            curr_page =""""
            for dom in  sub_doms:
                curr_page = dom + curr_page
                if curr_page in d:
                    d[curr_page]  += int(count)
                else:
                    d[curr_page]  = int(count)
                curr_page = '.' + curr_page                
        return [  "" "".join([str(count), site]) for site,count in d.items()]","class Solution {
 public:
  int longestPalindromeSubseq(string s) {
    const int n = s.length();
    // dp[i][j] := LPS's length in s[i..j]
    dp.resize(n, vector<int>(n));
    return lps(s, 0, n - 1);
  }

 private:
  vector<vector<int>> dp;

  int lps(const string& s, int i, int j) {
    if (i > j)
      return 0;
    if (i == j)
      return 1;
    if (dp[i][j] > 0)
      return dp[i][j];

    if (s[i] == s[j])
      dp[i][j] = 2 + lps(s, i + 1, j - 1);
    else
      dp[i][j] = max(lps(s, i + 1, j), lps(s, i, j - 1));

    return dp[i][j];
  }
};"
"class Solution:
    def largestTriangleArea(self, points: List[List[int]]) -> float:
        def area(x1, y1, x2, y2, x3, y3):
            return abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2
        
        n = len(points)
        res = 0
        for i in range(n - 2):
            x1, y1 = points[i]
            for j in range(i + 1, n - 1):
                x2, y2 = points[j]
                for k in range(j + 1, n):
                    x3, y3 = points[k]
                    res = max(res, area(x1, y1, x2, y2, x3, y3))
        
        return res","class Solution {
 public:
  int findMinMoves(vector<int>& machines) {
    const int dresses = accumulate(begin(machines), end(machines), 0);
    if (dresses % machines.size() != 0)
      return -1;

    int ans = 0;
    int inout = 0;
    const int average = dresses / machines.size();

    for (const int dress : machines) {
      inout += dress - average;
      ans = max({ans, abs(inout), dress - average});
    }

    return ans;
  }
};"
"class Solution:
    def largestSumOfAverages(self, A: List[int], K: int) -> float:
        s=[0]
        for i in A:
            s.append(i+s[-1]);
        n=len(s);
        mini= -200000
        d={};
        def fun(old,new,k):
            temp=(old,new,k);
            if(temp in d.keys()): return d[temp]
            if(new>=n) or (old>=n):
                return mini;
            if(k==1):
                return (s[-1]-s[old])/(n-1-old);
            d[temp]= max(fun(old,new+1,k),fun(new,new+1,k-1)+((s[new]-s[old])/(new-old)) );
            return d[temp]
        return fun(0,1,K);
		```","class Solution {
 public:
  int change(int amount, vector<int>& coins) {
    vector<int> dp(amount + 1);
    dp[0] = 1;

    for (const int coin : coins)
      for (int i = coin; i <= amount; ++i)
        dp[i] += dp[i - coin];

    return dp[amount];
  }
};"
"class Solution:
    def pruneTree(self, root: TreeNode) -> TreeNode:
		# Base case - return None if node does not exist
        if root is None:
            return None
        else:
			# recursively traverse the left and right subtrees 
            root.left = self.pruneTree(root.left)
            root.right = self.pruneTree(root.right)
			
			# Condition to check if subtree doesn't have 1 as node value i.e root.val == 0
            if root.left is None and root.right is None and root.val == 0:
                return None
            else:
                return root","class Solution {
 public:
  Solution(int n_rows, int n_cols)
      : rows(n_rows), cols(n_cols), total(n_rows * n_cols) {}

  vector<int> flip() {
    // All candidates are used out
    if (used.size() == total)
      return {};

    int index = rand() % total;
    while (used.count(index))
      index = ++index % total;
    used.insert(index);

    return {index / cols, index % cols};
  }

  void reset() {
    used = {};
  }

 private:
  unordered_set<int> used;
  int rows;
  int cols;
  int total;
};"
"class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        if source == target:
            return 0
        set_routes = [set(route) for route in routes]
        start_buses = [i for i, s in enumerate(set_routes) if source in s]
        state = set()
        for i in start_buses[::-1]:
            state.update(set_routes.pop(i))
        if target in state:
            return 1
        n_buses = 1
        while state:
            new_state = set()
            n_buses += 1
            new_busses = [i for i, s in enumerate(set_routes) if state &amp; s]
            for i in new_busses[::-1]:
                new_state.update(set_routes.pop(i))
            if target in new_state:
                return n_buses
            state = new_state
        return -1","class Solution {
 public:
  bool detectCapitalUse(string word) {
    for (int i = 1; i < word.length(); ++i)
      if (isupper(word[1]) != isupper(word[i]) ||
          islower(word[0]) && isupper(word[i]))
        return false;
    return true;
  }
};"
"class Solution:
    def ambiguousCoordinates(self, s: str) -> List[str]:
        s = s[1:-1]
        sp = [(s[:x], s[x:]) for x in range(1,len(s))]
        o = []
        for left, right in sp:
            la = []
            if left[0] == '0' and len(left) > 1 and set(left) != set([""0""]):
                if left[1:][-1] != '0':                
                    la.append((left[:1] + '.' + left[1:]))
            else:
                if (len(left) > 1 and set(left) != set([""0""])) or len(left) == 1:
                    la.append(left)
                    for y in range(1, len(left)):
                        if int(left[y:]) != 0 and left[y:][-1] != '0':
                            la.append((left[:y] + '.' + left[y:]))
                            
            ra = []
            if right[0] == '0' and len(right) > 1 and set(right) != set([""0""]):
                if right[1:][-1] != '0':
                    o += [""(%s, %s)""%(i, (right[:1] + '.' + right[1:])) for i in la]
            else:
                if (len(right) > 1 and set(right) != set([""0""])) or len(right) == 1:                 
                    o += [""(%s, %s)""%(i, right) for i in la]
                    for y in range(1, len(right)):
                        if int(right[y:]) != 0 and right[y:][-1] != '0':
                            rightside = right[:y] + '.' + right[y:]
                            o += [""(%s, %s)""%(i, rightside) for i in la]
                    
        return o","class Solution {
 public:
  int findLUSlength(string a, string b) {
    return a == b ? -1 : max(a.length(), b.length());
  }
};"
"class Solution:
    def racecar(self, target: int) -> int:
        dq=deque([(0,0,1)])
        while dq:
            move,pos,speed=dq.popleft()
            if pos==target:
                return move
            dq.append((move+1,pos+speed,speed*2))
            if (pos+speed>target and speed>0) or pos+speed<target and speed<0:
                speed=-1 if speed>0 else 1
                dq.append((move+1,pos,speed))
            else:
                continue","class Solution {
 public:
  int findLUSlength(vector<string>& strs) {
    unordered_set<string> seen;
    unordered_set<string> duplicates;

    for (const string& str : strs)
      if (seen.count(str))
        duplicates.insert(str);
      else
        seen.insert(str);

    sort(begin(strs), end(strs),
         [](const auto& a, const auto& b) { return a.length() > b.length(); });

    for (int i = 0; i < strs.size(); ++i) {
      if (duplicates.count(strs[i]))
        continue;
      bool isASubsequence = false;
      for (int j = 0; j < i; ++j)
        isASubsequence |= isSubsequence(strs[i], strs[j]);
      if (!isASubsequence)
        return strs[i].length();
    }

    return -1;
  }

 private:
  // Returns true if a is a subsequence of b
  bool isSubsequence(const string& a, const string& b) {
    int i = 0;
    for (const char c : b)
      if (i < a.length() && c == a[i])
        ++i;
    return i == a.length();
  };
};"
"class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        result = ''
        word_count = {}
        
        # Replace all puctuations with white spaces
        paragraph = paragraph.lower()\
                             .replace('!', ' ')\
                             .replace('?', ' ')\
                             .replace('\'', ' ')\
                             .replace(',', ' ')\
                             .replace(';', ' ')\
                             .replace('.', ' ')
        
        # Split paragraph by white spaces (irrespective of the nubmer of white spaces)
        for w in paragraph.split():
            if w not in banned: # Optional: can use set() to drop duplicates in banned
                # Increase word count
                word_count[w] = word_count.get(w, 0) + 1
                
                # If new word has a count greater than previous word then replace resulting word
                if word_count[w] > word_count.get(result, 0): 
                    result = w
        
        return result","class Solution {
 public:
  bool checkSubarraySum(vector<int>& nums, int k) {
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i];
      if (k != 0)
        prefix %= k;
      if (const auto it = prefixToIndex.find(prefix);
          it != cend(prefixToIndex)) {
        if (i - it->second > 1)
          return true;
      } else {
        // Only add if absent, because the previous index is better
        prefixToIndex[prefix] = i;
      }
    }

    return false;
  }
};"
"class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        words = sorted(words,key=len)
        #print(words)
        ret = ''
        for w in words[::-1]:
            if (w+'#') not in ret:
                ret = ret + w +'#'
        #print(ret)
        return len(ret)","class Solution {
 public:
  string findLongestWord(string s, vector<string>& d) {
    string ans;

    for (const string& word : d)
      if (isSubsequence(word, s))
        if (word.length() > ans.length() ||
            word.length() == ans.length() && word.compare(ans) < 0)
          ans = word;

    return ans;
  }

 private:
  // Returns true if a is a subsequence of b
  bool isSubsequence(const string& a, const string& b) {
    int i = 0;
    for (const char c : b)
      if (i < a.length() && c == a[i])
        ++i;
    return i == a.length();
  };
};"
"class Solution:
    def shortestToChar(self, S: str, C: str) -> List[int]:
        l=[]
        x=[]
        for i in range(len(S)):
            if(S[i]==C):
                l.append(i)
        a=l[0]
        b=l[len(l)-1]
        k=0
        for i in range(len(S)):
            if(i<a):
                x.append(a-i)
            elif(i>b):
                x.append(i-b)
            else:
                if(i==l[k]):
                    x.append(0)
                    if(k<len(l)-1):
                        k+=1
                        continue
                else:
                    x.append(min(i-l[k-1],l[k]-i))
        return x","class Solution {
 public:
  int findMaxLength(vector<int>& nums) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i] ? 1 : -1;
      if (const auto it = prefixToIndex.find(prefix); it != cend(prefixToIndex))
        ans = max(ans, i - it->second);
      else
        prefixToIndex[prefix] = i;
    }

    return ans;
  }
};"
"class Solution:
    def flipgame(self, f: List[int], b: List[int]) -> int:
    	return min(set(f+b)-set(f[i] for i in range(len(f)) if f[i] == b[i]), default = 0)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int countArrangement(int n) {
    return dfs(n, 1, string(n + 1, 'x'), {});
  }

 private:
  int dfs(int n, int num, string&& filled, unordered_map<string, int>&& memo) {
    if (num == n + 1)
      return 1;
    if (const auto it = memo.find(filled); it != cend(memo))
      return it->second;

    int count = 0;

    for (int i = 1; i <= n; ++i)
      if (filled[i] == 'x' && (num % i == 0 || i % num == 0)) {
        filled[i] = 'o';
        count += dfs(n, num + 1, move(filled), move(memo));
        filled[i] = 'x';
      }

    return memo[filled] = count;
  }
};"
"class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        
        arr.sort()
        
        memo={}
        memo[arr[0]] = 1
        
        for i in range(1, len(arr)):
            count = 1
            for j in range(0, i):
                if arr[i]/arr[j] in memo:
                    count+=memo[arr[j]]*memo[arr[i]/arr[j]]
            memo[arr[i]] = count
        return sum(memo.values()) % (10**9+7)","class Solution {
 public:
  vector<string> wordsAbbreviation(vector<string>& words) {
    const int n = words.size();
    vector<string> ans;
    // prefix[i] := ans[i] takes words[i][0..prefix[i]]
    vector<int> prefix(n);

    for (const string& word : words)
      ans.push_back(getAbbrev(word, 0));

    for (int i = 0; i < n; ++i) {
      while (true) {
        vector<int> dupeIndices;
        for (int j = i + 1; j < n; ++j)
          if (ans[i] == ans[j])
            dupeIndices.push_back(j);
        if (dupeIndices.empty())
          break;
        dupeIndices.push_back(i);
        for (const int index : dupeIndices)
          ans[index] = getAbbrev(words[index], ++prefix[index]);
      }
    }

    return ans;
  }

 private:
  string getAbbrev(const string& s, int prefixIndex) {
    const int n = s.length();
    const int num = n - (prefixIndex + 1) - 1;
    const int numLength = num < 10 ? 1 : num < 100 ? 2 : 3;
    const int abbrevLength = (prefixIndex + 1) + numLength + 1;
    if (abbrevLength >= n)
      return s;
    return s.substr(0, prefixIndex + 1) + to_string(num) + s.back();
  }
};"
"class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        
        #vars
        output = ''
        goatword = ''
        vowles = list(['a', 'e', 'i', 'o', 'u'])

        #enumerate and iterate
        for idx, word in enumerate(sentence.split(' ')):
            goatword = ''
            if word[0:1].lower() in vowles:
                goatword = word+'ma'
            elif word[0:1].lower() not in vowles:
                goatword = word[1:len(word)]+word[0:1]+'ma'

            #add extra a based on word position
            goatword = goatword + 'a'*(idx+1) + ' '

            #update output word
            output = output + goatword

        return(output.rstrip())","class Solution {
 public:
  vector<vector<char>> updateBoard(vector<vector<char>>& board,
                                   vector<int>& click) {
    if (board[click[0]][click[1]] == 'M') {
      board[click[0]][click[1]] = 'X';
      return board;
    }

    dfs(board, click[0], click[1]);
    return board;
  }

 private:
  const vector<pair<int, int>> dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                    {0, 1},   {1, -1}, {1, 0},  {1, 1}};

  void dfs(vector<vector<char>>& board, int i, int j) {
    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())
      return;
    if (board[i][j] != 'E')
      return;

    const int minesCount = getMinesCount(board, i, j);
    board[i][j] = minesCount == 0 ? 'B' : '0' + minesCount;

    if (minesCount == 0)
      for (const auto& [dx, dy] : dirs)
        dfs(board, i + dx, j + dy);
  }

  int getMinesCount(const vector<vector<char>>& board, int i, int j) {
    int minesCount = 0;
    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x == board.size() || y < 0 || y == board[0].size())
        continue;
      if (board[x][y] == 'M')
        ++minesCount;
    }
    return minesCount;
  }
};"
"class Solution:
    def numFriendRequests(self, ages: List[int]) -> int:
        requests = 0
        ages_le = [0 for _ in range(121)]
        for age in ages:
            ages_le[age] += 1
        for index in range(1, 121):
            ages_le[index] += ages_le[index-1]
        for age in ages:
            age_lower_bound = int(age//2) + 8
            age_upper_bound = age
            too_young = 0
            if age_lower_bound > age_upper_bound:
                continue
            if age_lower_bound < 0:
                continue
            elif age_lower_bound > 0:
                too_young = ages_le[age_lower_bound-1]
            requests += ages_le[age_upper_bound] - 1 - too_young
        return requests","class Solution {
 public:
  // Similar to 94. Binary Tree Inorder Traversal
  int getMinimumDifference(TreeNode* root) {
    int ans = INT_MAX;
    int prev = -1;
    stack<TreeNode*> stack;

    while (root || !stack.empty()) {
      while (root) {
        stack.push(root);
        root = root->left;
      }
      root = stack.top(), stack.pop();
      if (prev >= 0)
        ans = min(ans, root->val - prev);
      prev = root->val;
      root = root->right;
    }

    return ans;
  }
};"
"class Solution:
    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:
        d = defaultdict(int)
        for k,v in zip(difficulty,profit):
            d[k] = max(d[k],v)
        bucket = [0 for _ in range(max(worker)+1)]
        val = 0
        for i in range(len(bucket)):
            if i in d:
                val = max(val,d[i])
            bucket[i] = val
        return sum([bucket[w] for w in worker])","class Solution {
 public:
  int findLonelyPixel(vector<vector<char>>& picture) {
    const int m = picture.size();
    const int n = picture[0].size();
    int ans = 0;
    vector<int> rows(m);  // rows[i] := # of Bs in rows i
    vector<int> cols(n);  // cols[i] := # of Bs in cols i

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (picture[i][j] == 'B') {
          ++rows[i];
          ++cols[j];
        }

    for (int i = 0; i < m; ++i)
      if (rows[i] == 1)  // Only have to examine the rows when rows[i] == 1
        for (int j = 0; j < n; ++j)
          // After we met the 'B' in this rows, we break and search the next row
          if (picture[i][j] == 'B') {
            if (cols[j] == 1)
              ++ans;
            break;
          }

    return ans;
  }
};"
"class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        mark = 2
        islands = []
        n = len(grid)
        
        def mark_it(x, y):  # marks island and returns square of that island
            grid[x][y] = mark
            s = 1
            for xn in (x - 1, x + 1):
                if 0 <= xn < n and grid[xn][y] == 1:
                    s += mark_it(xn, y)
            for yn in (y - 1, y + 1):
                if 0 <= yn < n and grid[x][yn] == 1:
                    s += mark_it(x, yn)
            return s
        
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1:
                    islands.append(mark_it(i, j))
                    mark += 1
        
        if not islands: return 1
        
        ret = max(islands)
        
        def check_it(x, y):  # returns sum of adjacent islands to zero cell
            adj = []
            for xn in (x - 1, x + 1):
                if 0 <= xn < n and grid[xn][y] != 0:
                    adj.append(grid[xn][y] - 2)
            for yn in (y - 1, y + 1):
                if 0 <= yn < n and grid[x][yn] != 0:
                    adj.append(grid[x][yn] - 2)
            if not adj: return 0
            return sum([islands[a] for a in set(adj)])
        
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 0:
                    ret = max(ret, 1 + check_it(i, j))
        return ret","class Solution {
 public:
  int findPairs(vector<int>& nums, int k) {
    int ans = 0;
    unordered_map<int, int> numToIndex;

    for (int i = 0; i < nums.size(); ++i)
      numToIndex[nums[i]] = i;

    for (int i = 0; i < nums.size(); ++i) {
      const int target = nums[i] + k;
      if (const auto it = numToIndex.find(target);
          it != cend(numToIndex) && it->second != i) {
        ++ans;
        numToIndex.erase(target);
      }
    }

    return ans;
  }
};"
"class Solution:
		def uniqueLetterString(self, s: str) -> int:
			res = 0
			n = len(s)
			# dp_keys stores all keys in a substring
			dp_keys = [[set() for _ in range(n)] for _ in range(n)]
			# dp_unqs stores all unique characters in a substring
			dp_unqs = [[set() for _ in range(n)] for _ in range(n)]
			# dp_count stores the number of unique characters in a substring
			dp_count = [[0 for _ in range(n)] for _ in range(n)]
			for i in range(n):
				dp_keys[i][i] = set(s[i])
				dp_unqs[i][i] = set(s[i])
				dp_count[i][i] = 1
				res += 1

			for end_i in range(n):
				for start_i in range(end_i - 1, -1, -1):
					if s[start_i] not in dp_keys[start_i + 1][end_i]:
						tmp = copy.deepcopy(dp_keys[start_i + 1][end_i])
						tmp.add(s[start_i])
						dp_keys[start_i][end_i] = tmp
                
						tmp = copy.deepcopy(dp_unqs[start_i + 1][end_i])
						tmp.add(s[start_i])
						dp_unqs[start_i][end_i] = tmp
                
						dp_count[start_i][end_i] = dp_count[start_i + 1][end_i] + 1
						res += dp_count[start_i][end_i] 
					else:
						dp_keys[start_i][end_i] = dp_keys[start_i + 1][end_i]
						if s[start_i] in dp_unqs[start_i + 1][end_i]:
							tmp = copy.deepcopy(dp_unqs[start_i + 1][end_i])
							tmp.remove(s[start_i])   
							dp_unqs[start_i][end_i] = tmp
							dp_count[start_i][end_i] = dp_count[start_i + 1][end_i] - 1
							res += dp_count[start_i][end_i] 
						else:
							dp_unqs[start_i][end_i] = dp_unqs[start_i + 1][end_i]
							dp_count[start_i][end_i] = dp_count[start_i + 1][end_i] 
							res += dp_count[start_i][end_i]
			return res","class Solution {
 public:
  int findBlackPixel(vector<vector<char>>& picture, int target) {
    const int m = picture.size();
    const int n = picture[0].size();
    int ans = 0;
    vector<int> rows(m);
    vector<int> cols(n);
    vector<string> rowStrings(m);
    unordered_map<string, int> countRowStrings;

    for (int i = 0; i < m; ++i) {
      string s;
      for (int j = 0; j < n; ++j) {
        if (picture[i][j] == 'B') {
          ++rows[i];
          ++cols[j];
        }
        s += picture[i][j];
      }
      rowStrings[i] = s;
      ++countRowStrings[s];
    }

    for (int i = 0; i < m; ++i)
      if (rows[i] == target && countRowStrings[rowStrings[i]] == target)
        for (int j = 0; j < n; ++j)
          if (picture[i][j] == 'B' && cols[j] == target)
            ++ans;

    return ans;
  }
};"
"class Solution:
    def consecutiveNumbersSum(self, n: int) -> int:
        ans = 0
        for x in range(1, int(sqrt(2*n))+1): 
            if (n - x*(x+1)//2) % x == 0: ans += 1
        return ans","class Solution {
 public:
  string encode(string longUrl) {
    while (!urlToCode.count(longUrl)) {
      string code;
      for (int i = 0; i < 6; ++i)
        code += alphabets[rand() % alphabets.size()];
      if (!codeToUrl.count(code)) {
        codeToUrl[code] = longUrl;
        urlToCode[longUrl] = code;
        return ""http://tinyurl.com/"" + code;
      }
    }

    throw;
  }

  string decode(string shortUrl) {
    return codeToUrl[shortUrl.substr(19)];
  }

 private:
  const string alphabets =
      ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"";
  unordered_map<string, string> urlToCode;
  unordered_map<string, string> codeToUrl;
};"
"class Solution:
    def maskPII(self, S: str) -> str:
        if ""@"" in S: # email address
            name, domain = S.lower().split(""@"")
            return f""{name[0]}*****{name[-1]}@{domain}""
        else: # phone number 
            d = """".join(c for c in S if c.isdigit())
            ans = f""***-***-{d[-4:]}""
            return ans if len(d) == 10 else f""+{'*'*(len(d)-10)}-"" + ans","class Solution {
 public:
  TreeNode* str2tree(string s) {
    if (s.empty())
      return nullptr;
    int i = 0;
    return str2tree(s, i);
  }

 private:
  TreeNode* str2tree(const string& s, int& i) {
    const int start = i;  // Start index of val
    if (s[i] == '-')
      ++i;
    while (i < s.length() && isdigit(s[i]))
      ++i;

    const int val = stoi(s.substr(start, i - start));
    TreeNode* root = new TreeNode(val);

    // Left child
    if (i < s.length() && s[i] == '(') {
      ++i;  // '('
      root->left = str2tree(s, i);
      ++i;  // ')'
    }

    // Right child
    if (i < s.length() && s[i] == '(') {
      ++i;  // '('
      root->right = str2tree(s, i);
      ++i;  // ')'
    }

    return root;
  }
};"
"class Solution:
    def findReplaceString(self, S: str, indexes: List[int], sources: List[str], targets: List[str]) -> str:
        for i, s, t in sorted(zip(indexes, sources, targets), reverse=True): 
            if S[i:i+len(s)] == s: S = S[:i] + t + S[i+len(s):]
        return S","class Solution {
 public:
  string complexNumberMultiply(string a, string b) {
    const auto& [A, B] = getRealAndImag(a);
    const auto& [C, D] = getRealAndImag(b);
    return to_string(A * C - B * D) + ""+"" + to_string(A * D + B * C) + ""i"";
  }

 private:
  pair<int, int> getRealAndImag(const string& s) {
    const string& real = s.substr(0, s.find_first_of('+'));
    const string& imag = s.substr(s.find_first_of('+') + 1);
    return {stoi(real), stoi(imag)};
  };
};"
"class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        count = [1]*n
        res = [0]*n
                
        g = defaultdict(list)
        
        for s,e in edges:
            g[s].append(e)
            g[e].append(s)
            
        visited = set()
        
        def dfs_count_up_to_0(node):
            visited.add(node)
            
            for c in g[node]:
                if c not in visited:
                    count[node] += dfs_count_up_to_0(c)
                    res[node] += res[c] + count[c]
            return count[node]
        
        
        def dfs_fill_up_rest(node):
            visited.add(node)
            for c in g[node]:
                if c not in visited:
                    res[c] =  res[node] - count[c] + n - count[c]
                    dfs_fill_up_rest(c)
            
        dfs_count_up_to_0(0)
        
        visited.clear()
        
        dfs_fill_up_rest(0)
        
        return res","class Solution {
 public:
  TreeNode* convertBST(TreeNode* root) {
    int prefix = 0;
    reversedInorder(root, prefix);
    return root;
  }

 private:
  void reversedInorder(TreeNode* root, int& prefix) {
    if (root == nullptr)
      return;

    reversedInorder(root->right, prefix);
    prefix += root->val;
    root->val = prefix;
    reversedInorder(root->left, prefix);
  }
};"
"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        n = len(img1)
        reduce_list = lambda lst: sum([1 << i for i,a in enumerate(lst) if a == 1])
        img1, img2 = list(map(reduce_list, img1)), list(map(reduce_list, img2))
        count_bits = lambda num: sum((num>>i)&amp;1 for i in range(n))   
        overlap = lambda lst1, lst2, sx1, sx2, sy1, sy2: sum(count_bits((row1>>sx1) &amp; (row2>>sx2)) for row1,row2 in zip(lst1[sy1:], lst2[sy2:]))
        overlap_xy = lambda lst1, lst2, dx, dy: overlap(lst1, lst2, dx if dx > 0 else 0, 0 if dx > 0 else -dx, dy if dy > 0 else 0, 0 if dy > 0 else -dy )
        return max(overlap_xy(img1, img2, dx, dy) for dx in range(-n+1, n) for dy in range(-n+1, n))","class Solution {
 public:
  int findMinDifference(vector<string>& timePoints) {
    int ans = 24 * 60;
    int first = 24 * 60;
    vector<bool> bucket(24 * 60);

    for (const string& time : timePoints) {
      const int num = stoi(time.substr(0, 2)) * 60 + stoi(time.substr(3));
      first = min(first, num);
      if (bucket[num])
        return 0;
      bucket[num] = true;
    }

    int prev = first;

    for (int i = first + 1; i < bucket.size(); ++i)
      if (bucket[i]) {
        ans = min(ans, i - prev);
        prev = i;
      }

    return min(ans, 24 * 60 - prev + first);
  }
};"
"class Solution(object):
    def isRectangleOverlap(self, rec1, rec2):
        if (rec1[0] == rec1[2] or rec1[1] == rec1[3] or rec2[0] == rec2[2] or rec2[1] == rec2[3]):
            return False

        return not (rec1[2] <= rec2[0] or rec1[3] <= rec2[1] or rec1[0] >= rec2[2] or rec1[1] >= rec2[3])","class Solution {
 public:
  int singleNonDuplicate(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      int m = (l + r) / 2;
      if (m & 1)
        --m;
      if (nums[m] == nums[m + 1])
        l = m + 2;
      else
        r = m;
    }

    return nums[l];
  }
};"
"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        dp = collections.deque([float(i <= n) for i in range(k, k + maxPts)])
        s = sum(dp)
        for i in range(k):
            dp.appendleft(s / maxPts)
            s += dp[0] - dp.pop()
        
        return dp[0]","class Solution {
 public:
  string reverseStr(string s, int k) {
    for (size_t i = 0; i < s.length(); i += 2 * k) {
      int l = i;
      int r = min(i + k - 1, s.length() - 1);
      while (l < r)
        swap(s[l++], s[r--]);
    }

    return s;
  }
};"
"class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        mp = [0]*len(dominoes)
        ii = len(dominoes)
        for i in reversed(range(len(dominoes))): 
            if dominoes[i] != ""."": ii = i 
            mp[i] = ii 
            
        ans = []
        ii = -1 
        for i, x in enumerate(dominoes): 
            if dominoes[i] in ""LR"": 
                ans.append(dominoes[i])
                ii = i 
            else: 
                ll = ""L"" if ii == -1 else dominoes[ii]
                rr = ""R"" if mp[i] == len(dominoes) else dominoes[mp[i]]
                if ll == rr: ans.append(ll)
                elif ll == ""L"": ans.append(""."")
                else: 
                    if i - ii < mp[i] - i: ans.append(""R"")
                    elif i - ii > mp[i] - i: ans.append(""L"")
                    else: ans.append(""."")
        return """".join(ans)","class Solution {
 public:
  vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<pair<int, int>> q;
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (mat[i][j] == 0) {
          q.emplace(i, j);
          seen[i][j] = true;
        }

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        mat[x][y] = mat[i][j] + 1;
        q.emplace(x, y);
        seen[x][y] = true;
      }
    }

    return mat;
  }
};"
"class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        def similar(word1, word2):
            diff = []
            for a,b in zip(word1, word2):
                if a != b:
                    diff.append((a,b))
                    if diff and len(diff) > 2:
                        return False
            if diff and sorted(diff[0]) != sorted(diff[1]):
                return False
            return True
        
        graph = {}
        for i in range(len(strs)):
            graph[strs[i]] = []
            for j in range(len(strs)):
                if i != j and similar(strs[i], strs[j]):
                    graph[strs[i]].append(strs[j])
        # print(graph)
        
        visited = set()
        q = deque()
        group_count = 0
        for i in range(len(strs)):
            if strs[i] not in visited:
                group = []
                q.append(strs[i])
                while q:
                    node = q.popleft()
                    visited.add(node)
                    group.append(node)
                    for sim in graph[node]:
                        if sim not in visited:
                            q.append(sim)
                # print(group, visited)
                group_count += 1
        return group_count","class Solution {
 public:
  int diameterOfBinaryTree(TreeNode* root) {
    int ans = 0;
    maxDepth(root, ans);
    return ans;
  }

 private:
  int maxDepth(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = maxDepth(root->left, ans);
    const int r = maxDepth(root->right, ans);
    ans = max(ans, l + r);
    return 1 + max(l, r);
  }
};"
"class Solution:
    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimension 
        
        def fn(i, j): 
            """"""Return True if grid[i-1:i+2][j-1:j+2] is a magic squre.""""""
            seen = set()
            row, col = [0]*3, [0]*3 # row sum &amp; column sum 
            diag = anti = 0
            for ii in range(i-1, i+2):
                for jj in range(j-1, j+2):
                    if not 0 <= grid[ii][jj] < 10 or grid[ii][jj] in seen: return False 
                    seen.add(grid[ii][jj])
                    row[ii-i+1] += grid[ii][jj]
                    col[jj-j+1] += grid[ii][jj]
                    if ii-jj == i-j: diag += grid[ii][jj]
                    if ii+jj == i+j: anti += grid[ii][jj]
            return len(set(row)) == 1 and len(set(col)) == 1 and row[0] == col[0] == diag == anti
        
        ans = 0
        for i in range(1, m-1):
            for j in range(1, n-1): 
                if grid[i][j] == 5 and fn(i, j): ans += 1
        return ans","class Solution {
 public:
  string findContestMatch(int n) {
    vector<string> matches(n);

    for (int i = 0; i < n; ++i)
      matches[i] = to_string(i + 1);

    return generateMatches(matches);
  }

 private:
  string generateMatches(const vector<string>& matches) {
    if (matches.size() == 1)
      return matches[0];

    vector<string> nextMatches;

    for (int i = 0; i < matches.size() / 2; ++i)
      nextMatches.push_back(""("" + matches[i] + "","" +
                            matches[matches.size() - 1 - i] + "")"");

    return generateMatches(nextMatches);
  }
};"
"class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        A, B = [0], []
        visited_room_set = set()
        while A:
            B = set([k for r in A for k in rooms[r] if k not in visited_room_set])
            visited_room_set.update(A)
            A, B = B, []
            
        return len(visited_room_set) == len(rooms)","class Solution {
 public:
  vector<int> boundaryOfBinaryTree(TreeNode* root) {
    if (root == nullptr)
      return {};
    vector<int> ans{root->val};
    dfs(root->left, true, false, ans);
    dfs(root->right, false, true, ans);
    return ans;
  }

 private:
  /**
   * 1. root->left is left boundary if root is left boundary
   *    root->right if left boundary if root->left == nullptr
   * 2. same applys for right boundary
   * 3. if root is left boundary, add it before 2 children - preorder
   *    if root is right boundary, add it after 2 children - postorder
   * 4. a leaf that is neighter left/right boundary belongs to the bottom
   */
  void dfs(TreeNode* root, bool lb, bool rb, vector<int>& ans) {
    if (root == nullptr)
      return;
    if (lb)
      ans.push_back(root->val);
    if (!lb && !rb && root->left == nullptr && root->right != nullptr)
      ans.push_back(root->val);

    dfs(root->left, lb, rb && root->right == nullptr, ans);
    dfs(root->right, lb && root->left == nullptr, rb, ans);
    if (rb)
      ans.push_back(root->val);
  }
};"
"class Solution:
    def splitIntoFibonacci(self, S: str) -> List[int]:
        L, T, t = len(S), """", []
        for i in range(1,L-2):
        	for j in range(1,L-i-1):
        		if (i > 1 and S[0] == '0') or (j > 1 and S[i] == '0'): continue
        		a, b = int(S[:i]), int(S[i:i+j])
        		T, t = S[:i+j], [a,b]
        		while len(T) < L:
        			c = a + b
        			T += str(c)
        			t += [c]
        			a, b = b, c
        		if len(T) == L and T == S and len(t) > 2 and t[-1] < 2**31 - 1: return t
        return []
		
		
- Junaid Mansuri
(Leet Code ID)@hotmail.com","class Solution {
 public:
  int removeBoxes(vector<int>& boxes) {
    const int n = boxes.size();
    // dp[i][j][k] := max score of boxes[i..j] if k boxes eqaul to boxes[j]
    dp.resize(n, vector<vector<int>>(n, vector<int>(n)));
    return removeBoxes(boxes, 0, n - 1, 0);
  }

 private:
  vector<vector<vector<int>>> dp;

  int removeBoxes(const vector<int>& boxes, int i, int j, int k) {
    if (i > j)
      return 0;
    if (dp[i][j][k] > 0)
      return dp[i][j][k];

    int r = j;
    int sameBoxes = k + 1;
    while (r > 0 && boxes[r - 1] == boxes[r]) {
      --r;
      ++sameBoxes;
    }
    dp[i][j][k] = removeBoxes(boxes, i, r - 1, 0) + sameBoxes * sameBoxes;

    for (int p = i; p < r; ++p)
      if (boxes[p] == boxes[r])
        dp[i][j][k] = max(dp[i][j][k], removeBoxes(boxes, i, p, sameBoxes) +
                                           removeBoxes(boxes, p + 1, r - 1, 0));

    return dp[i][j][k];
  }
};"
"class Solution:
    def findSecretWord(self, wordlist: List[str], master: 'Master') -> None:
        master.guess(master._Master__secret)","class UnionFind {
 public:
  UnionFind(int n) : count(n), id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
    --count;
  }

  int getCount() const {
    return count;
  }

 private:
  int count;
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  int findCircleNum(vector<vector<int>>& isConnected) {
    const int n = isConnected.size();
    UnionFind uf(n);

    for (int i = 0; i < n; ++i)
      for (int j = i; j < n; ++j)
        if (isConnected[i][j] == 1)
          uf.unionByRank(i, j);

    return uf.getCount();
  }
};"
"class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        stack1 = [] # taking empty stack
        stack2 = [] # taking another empty stack
        
        for i in range(len(s)): # traversing through string s.
            if s[i] is not ""#"": # if the elem is not #
                stack1.append(s[i]) # will push it to the stack1
            else: # if it is ""#"" and there is some elem in stack1 then we`ll pop it else we`ll pass.
                if len(stack1)>0: 
                    stack1.pop()
                else:
                    pass
                
        for i in range(len(t)): # traversing through string t.       
            if t[i] is not ""#"": # if the elem is not #
                stack2.append(t[i]) # will push it to the stack2
            else: # if it is ""#"" and there is some elem in stack2 then we`ll pop it else we`ll pass.
                if len(stack2)>0:
                    stack2.pop()
                else:
                    pass
                
        return stack1 == stack2 # returning if they are equal when both are typed into empty text editors","class Solution {
 public:
  bool splitArray(vector<int>& nums) {
    const int n = nums.size();
    if (n < 7)
      return false;

    vector<int> prefix(n);

    partial_sum(begin(nums), end(nums), begin(prefix));

    for (int j = 3; j < n - 3; ++j) {
      unordered_set<int> seen;
      for (int i = 1; i < j - 1; ++i)
        if (prefix[i - 1] == prefix[j - 1] - prefix[i])
          seen.insert(prefix[i - 1]);
      for (int k = j + 2; k < n - 1; ++k)
        if (prefix[n - 1] - prefix[k] == prefix[k - 1] - prefix[j] &&
            seen.count(prefix[k - 1] - prefix[j]))
          return true;
    }

    return false;
  }
};"
"class Solution:
""""""
192ms 40.16% time
14.7MB 86.68% space
""""""
    def longestMountain(self, A: List[int]) -> int:
        if len(A)<3:return 0
        curr=-1
        itr=1
        while itr+1<len(A):
            if A[itr-1]<A[itr] and A[itr]>A[itr+1]:
                j,k=itr-1,itr+1
                temp=3
                while j-1>=0:
                    if A[j-1]<A[j]:
                        temp+=1
                        j-=1
                    else:break
                while k+1<len(A):
                    if A[k+1]<A[k]:
                        temp+=1
                        k+=1
                    else:break
                curr=max(curr,temp)
            itr+=1
        return curr if curr!=-1 else 0



Java Solution: 2ms beat 96.71%, 40.2MB beats 92.82%

class Solution {
    public int longestMountain(int[] A) {
        if(A.length<3){return 0;}
        int curr=-1;
        int itr=1;
        while(itr+1<A.length){
            if(A[itr]>A[itr+1]&amp;&amp;A[itr]>A[itr-1]){
                int j=itr-1;
                int k=itr+1;
                int temp=3;
                while(j-1>=0){
                    if(A[j-1]<A[j]){
                        temp+=1;
                        j-=1;
                    }
                    else{break;}
                }
                while(k+1<A.length){
                    if(A[k+1]<A[k]){
                        temp+=1;
                        k+=1;
                    }
                    else{break;}
                }
                curr=(curr<temp)?temp:curr;
            }
            itr+=1;
        }
        return (curr!=-1)?curr:0;
    }
}","struct T {
  int inc;  // Length of longest incrementing branch
  int dec;  // Length of longest decrementing branch
};

class Solution {
 public:
  int longestConsecutive(TreeNode* root) {
    int ans = 0;
    longestPath(root, ans);
    return ans;
  }

 private:
  // Returns (longest increment, longest decrement)
  T longestPath(TreeNode* root, int& ans) {
    if (root == nullptr)
      return {0, 0};

    int inc = 1;
    int dec = 1;

    if (root->left) {
      T l = longestPath(root->left, ans);
      if (root->val + 1 == root->left->val)
        inc = l.inc + 1;
      else if (root->val - 1 == root->left->val)
        dec = l.dec + 1;
    }

    if (root->right) {
      T r = longestPath(root->right, ans);
      if (root->val + 1 == root->right->val)
        inc = max(inc, r.inc + 1);
      else if (root->val - 1 == root->right->val)
        dec = max(dec, r.dec + 1);
    }

    ans = max(ans, inc + dec - 1);
    return {inc, dec};
  }
};"
"class Solution:
    def isNStraightHand(self, hand, W):
        """"""
        :type hand: List[int]
        :type W: int
        :rtype: bool
        """"""
        cnt=collections.Counter(hand)
        _h=[]
        for h in hand:
            heapq.heappush(_h,h)
        
        while _h:
            curEle=heapq.heappop(_h)
            if cnt[curEle]==0:
                continue            
            for i in range(W):
                if cnt[curEle+i]<=0:
                    return False   
                else:
                    cnt[curEle+i]-=1
        return True","class Solution {
 public:
  bool checkRecord(string s) {
    int countA = 0;
    int countL = 0;

    for (const char c : s) {
      if (c == 'A' && ++countA > 1)
        return false;
      if (c != 'L')
        countL = 0;
      else if (++countL > 2)
        return false;
    }

    return true;
  }
};"
"class Solution:
    def shortestPathLength(self, graph: List[List[int]]) -> int:
        q = []
        n = len(graph)
        for i in range(n):
            visit = set()
            visit.add(i)
            q.append([i, visit])
        
        steps = 0
        while q:
            num = len(q)
            for i in range(num):
                node, visit = q.pop(0)
                #print(node, visit)
                if len(visit) == n:
                    return steps
                for nei in graph[node]:
                    temp = visit.copy()
                    temp.add(nei)
                    q.append([nei, temp])
            if q:steps += 1","class Solution {
 public:
  int checkRecord(int n) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j] := length so far w/ i A's and the latest chars are j L's
    vector<vector<long>> dp(2, vector<long>(3));
    dp[0][0] = 1;

    while (n--) {
      const auto prev(dp);

      // Append P
      dp[0][0] = (prev[0][0] + prev[0][1] + prev[0][2]) % kMod;

      // Append L
      dp[0][1] = prev[0][0];

      // Append L
      dp[0][2] = prev[0][1];

      // Append A or append P
      dp[1][0] = (prev[0][0] + prev[0][1] + prev[0][2] +  //
                  prev[1][0] + prev[1][1] + prev[1][2]) %
                 kMod;

      // Append L
      dp[1][1] = prev[1][0];

      // Append L
      dp[1][2] = prev[1][1];
    }

    return accumulate(begin(dp), end(dp), 0, [](int s, vector<long>& row) {
      return (s + accumulate(begin(row), end(row), 0L)) % kMod;
    });
  }
};"
"class Solution:
    def shiftingLetters(self, S: str, shifts: List[int]) -> str:
        for i in range(len(shifts)-2, -1, -1):
            shifts[i] += shifts[i+1]
        return ''.join(chr((ord(c) - ord('a') + shift) % 26 + ord('a'))
                       for c, shift in zip(S, shifts))","class Solution {
 public:
  string optimalDivision(vector<int>& nums) {
    string ans = to_string(nums[0]);

    if (nums.size() == 1)
      return ans;
    if (nums.size() == 2)
      return ans + ""/"" + to_string(nums[1]);

    ans += ""/("" + to_string(nums[1]);
    for (int i = 2; i < nums.size(); ++i)
      ans += ""/"" + to_string(nums[i]);
    ans += "")"";
    return ans;
  }
};"
"class Solution:
    def rectangleArea(self, rectangles: List[List[int]]) -> int:
        line = []
        for x1, y1, x2, y2 in rectangles: 
            line.append((y1, x1, x2, 1))
            line.append((y2, x1, x2, 0))
        
        ans = yy = val = 0
        seg = []
        for y, x1, x2, tf in sorted(line): 
            ans += val * (y - yy)
            yy = y 
            if tf: insort(seg, (x1, x2))
            else: seg.remove((x1, x2))
            val = 0 
            prev = -inf 
            for x1, x2 in seg: 
                val += max(0, x2 - max(x1, prev))
                prev = max(prev, x2)
        return ans % 1_000_000_007","class Solution {
 public:
  int leastBricks(vector<vector<int>>& wall) {
    int maxCount = 0;
    unordered_map<int, int> count;

    for (const vector<int>& row : wall) {
      int prefix = 0;
      for (int i = 0; i < row.size() - 1; ++i) {
        prefix += row[i];
        maxCount = max(maxCount, ++count[prefix]);
      }
    }

    return wall.size() - maxCount;
  }
};"
"class Solution:
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        #Let len(richer) = n and let len(quiet) = m!
        #Time: O(n + m + m + m*m + m +  m) -> O(m^2 + n)
        #Space: O(m*m + m + m + m*m + m) -> O(m^2)
        #step 1: build adjacency list representation and update indegrees of every node initially!
        adj = [[] for _ in range(len(quiet))]
        indegrees = [0] * len(quiet)
        #we want edges to go from richer to poorer so that ancestors of every node are all people
        #who have more money than the node person!
        for rel in richer:
            richer, poorer = rel[0], rel[1]
            adj[richer].append(poorer)
            indegrees[poorer] += 1
        
        queue = deque()
        ancestors = []
        for i in range(len(quiet)):
            new = set()
            new.add(i)
            ancestors.append(new)
        #step 2: fill in the queue all nodes that have indegrees of 0!

        #step 3: proceeding with Kahn's algorithm and recording list of all ancestors to every node!
        while queue:
            cur = queue.pop()
            for neighbor in adj[cur]:
                ancestors[neighbor].add(cur)
                ancestors[neighbor].update(ancestors[cur])
                indegrees[neighbor] -= 1
                if(indegrees[neighbor] == 0):
                    queue.append(neighbor)
        
        ancestors = [list(s) for s in ancestors]
        output = []
        #step 4:for each person, find the least quiet person who also has more money than the current               #person we're iterating on!
        for a in range(len(ancestors)):
            cur_ancestors = ancestors[a]
            if(len(cur_ancestors) == 1):
                output.append(a)
                continue
            minimum = cur_ancestors[0]
            for ancestor in cur_ancestors:
                #check if current person with more money than person a has lower quiet level!
                if(quiet[ancestor] < quiet[minimum]):
                    minimum = ancestor
            output.append(minimum)
        return output","class Solution {
 public:
  string splitLoopedString(vector<string>& strs) {
    string ans;
    vector<string> sortedStrs;

    for (const string& s : strs)
      sortedStrs.push_back(max(s, {rbegin(s), rend(s)}));

    for (int i = 0; i < sortedStrs.size(); ++i)
      for (const string& s :
           {sortedStrs[i], {rbegin(sortedStrs[i]), rend(sortedStrs[i])}})
        for (int j = 0; j <= s.length(); ++j)
          ans = max(ans, s.substr(j) + join(sortedStrs, i) + s.substr(0, j));

    return ans;
  }

 private:
  string reversed(const string& s) {
    string r = s;
    reverse(begin(r), end(r));
    return r;
  }

  string join(const vector<string>& sortedStrs, int i) {
    string joined;
    for (int j = i + 1; j < sortedStrs.size(); ++j)
      joined += sortedStrs[j];
    for (int j = 0; j < i; ++j)
      joined += sortedStrs[j];
    return joined;
  }
};"
"class Solution:
    def peakIndexInMountainArray(self, arr: List[int]) -> int:
        s,e=0,len(arr)-1
        while s<e:
            m=s+(e-s)//2
            if arr[m]<arr[m+1]:
                s=m+1
            else:
                e=m
        return s","class Solution {
 public:
  int nextGreaterElement(int n) {
    const string& s = nextPermutation(to_string(n));
    const long ans = stol(s);
    return ans > INT_MAX || ans <= n ? -1 : ans;
  }

 private:
  // Similar to 31. Next Permutation
  string nextPermutation(string s) {
    const int n = s.length();

    int i;
    for (i = n - 2; i >= 0; --i)
      if (s[i] < s[i + 1])
        break;

    if (i >= 0) {
      for (int j = n - 1; j > i; --j)
        if (s[j] > s[i]) {
          swap(s[i], s[j]);
          break;
        }
    }

    reverse(s, i + 1, n - 1);
    return s;
  }

  void reverse(string& s, int l, int r) {
    while (l < r)
      swap(s[l++], s[r--]);
  }
};"
"class Solution:  # O(NlogN)
    
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        stack = [] # no. of fleet
        
        # pair of distance and speed to sort it
        pair = [(p,s) for p,s in zip(position,speed) ]
        
        # sort the pair based on positions and travesing from reverse order
        for p,s in sorted(pair)[::-1]:
            
            # find the time
            t = (target - p) /s
            
            stack.append(t)
            
            if len(stack) >= 2 and stack[-1] <= stack[-2]:  #  fleet
                stack.pop()
        
        return len(stack)
		```
		feel free to ask Q...
		#happytohelpu","class Solution {
 public:
  string reverseWords(string s) {
    int i = 0;
    int j = 0;

    while (i < s.length()) {
      while (i < j || i < s.length() && s[i] == ' ')
        ++i;
      while (j < i || j < s.length() && s[j] != ' ')
        ++j;
      reverse(begin(s) + i, begin(s) + j);
    }

    return s;
  }
};"
"class Solution:
    def kSimilarity(self, A: str, B: str) -> int:
        la = []
        lb = []
        for a, b in zip(A, B):
            if a != b:
                la.append(a)
                lb.append(b)
        queue = {''.join(la): 0}
        while lb:
            q = {}
            for pre, swap in queue.items():
                if pre[-1] != lb[-1]:
                    eq = []
                    for i, ch in enumerate(pre[:-1]):
                        if ch == lb[-1] and lb[i] != ch:
                            eq.append(i)
                            if lb[i] == pre[-1]:
                                eq = [i]
                                break
                    for i in eq:
                        tmp = pre[:i] + pre[-1] + pre[i + 1:-1]
                        q[tmp] = min(swap + 1, q.get(tmp, float('inf')))
                else:
                    q[pre[:-1]] = min(swap, q.get(pre[:-1], float('inf')))
            lb.pop()
            queue = q
        return list(queue.values())[0]","class Solution {
 public:
  Node* intersect(Node* quadTree1, Node* quadTree2) {
    if (quadTree1->isLeaf)
      return quadTree1->val ? quadTree1 : quadTree2;
    if (quadTree2->isLeaf)
      return quadTree2->val ? quadTree2 : quadTree1;

    Node* topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);
    Node* topRight = intersect(quadTree1->topRight, quadTree2->topRight);
    Node* bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);
    Node* bottomRight =
        intersect(quadTree1->bottomRight, quadTree2->bottomRight);

    if (topLeft->val == topRight->val &&        //
        topLeft->val == bottomLeft->val &&      //
        topLeft->val == bottomRight->val &&     //
        topLeft->isLeaf && topRight->isLeaf &&  //
        bottomLeft->isLeaf && bottomRight->isLeaf)
      return new Node(topLeft->val, true);
    return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight);
  }
};"
"class Solution:
    def scoreOfParentheses(self, S: str) -> int:
        left_parenthesis_count = 0
        score = 0
        score_flag = False
        for c in S:
            if c == '(':
                left_parenthesis_count += 1
                score_flag = True
            else:
                left_parenthesis_count -= 1
                if score_flag:
                    score += pow(2, left_parenthesis_count)
                    
                score_flag = False
        
        return score","class Solution {
 public:
  int maxDepth(Node* root) {
    if (root == nullptr)
      return 0;

    int ans = 0;

    for (Node* child : root->children)
      ans = max(ans, maxDepth(child));

    return 1 + ans;
  }
};"
"class Solution:
    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:
        
        
        workers=[]
        for w,q in zip(wage, quality):
            workers.append([float(w) / q, q] )
        workers.sort()
        print(workers)                   
        res = float('inf')
        qsum = 0
        heap = []
        for r, q in workers:
            
            heapq.heappush(heap, -q)
            #print(heap)
            qsum += q
            if len(heap) > K:
                qsum += heapq.heappop(heap)
            if len(heap) == K:
                res = min(res, qsum * r)
        print(heap)
        return res","class Solution {
 public:
  int subarraySum(vector<int>& nums, int k) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> count{{0, 1}};  // {prefix sum: count}

    for (const int num : nums) {
      prefix += num;
      const int target = prefix - k;
      if (const auto it = count.find(target); it != cend(count))
        ans += it->second;
      ++count[prefix];
    }

    return ans;
  }
};"
"class Solution:
    def mirrorReflection(self, p: int, q: int) -> int:
    	g = math.gcd(p,q)
    	return 2 if not p//g % 2 else q//g % 2
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int arrayPairSum(vector<int>& nums) {
    int ans = 0;

    sort(begin(nums), end(nums));

    for (int i = 0; i < nums.size(); i += 2)
      ans += nums[i];

    return ans;
  }
};"
"class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False
        l = []
        for i in range(len(s)):
            if s[i] != goal[i]:
                l.append(i)
        return (len(l) == 2 and s[l[0]] == goal[l[1]] and s[l[1]] == goal[l[0]]) or (len(l) == 0 and max(Counter(s).values()) > 1)","class Solution {
 public:
  int longestLine(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    int ans = 0;
    // dp[i][j][0] := horizontal
    // dp[i][j][1] := vertical
    // dp[i][j][2] := diagonal
    // dp[i][j][3] := anti-diagonal
    vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(4)));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (mat[i][j] == 1) {
          dp[i][j][0] = j > 0 ? dp[i][j - 1][0] + 1 : 1;
          dp[i][j][1] = i > 0 ? dp[i - 1][j][1] + 1 : 1;
          dp[i][j][2] = (i > 0 && j > 0) ? dp[i - 1][j - 1][2] + 1 : 1;
          dp[i][j][3] = (i > 0 && j < n - 1) ? dp[i - 1][j + 1][3] + 1 : 1;
          ans = max(ans, *max_element(begin(dp[i][j]), end(dp[i][j])));
        }

    return ans;
  }
};"
"class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        # meet 20 , give 10 prior to 5.
        bill_5, bill_10, bill_20 = 0, 0, 0
        for bill in bills:
            if bill == 5:
                bill_5 += 1
            elif bill == 10:
                bill_10 += 1
                bill_5 -= 1
            elif bill == 20:
                if bill_10:
                    bill_10 -= 1
                    bill_5 -= 1
                else:
                    bill_5 -= 3
            if bill_5 < 0:
                return False
        return True","class Solution {
 public:
  int findTilt(TreeNode* root) {
    int ans = 0;
    sum(root, ans);
    return ans;
  }

 private:
  int sum(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = sum(root->left, ans);
    const int r = sum(root->right, ans);
    ans += abs(l - r);
    return root->val + l + r;
  }
};"
"class Solution:
    def matrixScore(self, G: List[List[int]]) -> int:
        G, M, N = list(zip(*[[b^g[0]^1 for b in g] for g in G])), len(G), len(G[0])
        return sum(max(sum(g),M-sum(g))*2**(N-i-1) for i,g in enumerate(G))

		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  string nearestPalindromic(string n) {
    const auto& [prevPalindrome, nextPalindrome] = getPalindromes(n);
    return abs(prevPalindrome - stol(n)) <= abs(nextPalindrome - stol(n))
               ? to_string(prevPalindrome)
               : to_string(nextPalindrome);
  }

 private:
  pair<long, long> getPalindromes(const string& s) {
    const long num = stol(s);
    const int n = s.length();
    pair<long, long> palindromes;
    const string& half = s.substr(0, (n + 1) / 2);
    const string& reversedHalf = reversed(half.substr(0, n / 2));
    const long candidate = stol(half + reversedHalf);

    if (candidate < num)
      palindromes.first = candidate;
    else {
      const string& prevHalf = to_string(stol(half) - 1);
      const string& reversedPrevHalf = reversed(prevHalf.substr(0, n / 2));
      if (n % 2 == 0 && stol(prevHalf) == 0)
        palindromes.first = 9;
      else if (n % 2 == 0 && (stol(prevHalf) + 1) % 10 == 0)
        palindromes.first = stol(prevHalf + '9' + reversedPrevHalf);
      else
        palindromes.first = stol(prevHalf + reversedPrevHalf);
    }

    if (candidate > num)
      palindromes.second = candidate;
    else {
      const string& nextHalf = to_string(stol(half) + 1);
      const string& reversedNextHalf = reversed(nextHalf.substr(0, n / 2));
      palindromes.second = stol(nextHalf + reversedNextHalf);
    }

    return palindromes;
  }

  string reversed(const string& s) {
    return {rbegin(s), rend(s)};
  }
};"
"class Solution:
    def shortestSubarray(self, A: List[int], K: int) -> int:
    	C, m, a = [0]+list(itertools.accumulate(A)), float('inf'), collections.deque()
    	for i, c in enumerate(C):
    		while a and C[a[-1]] >= c: a.pop()
    		while a and c - C[a[0]] >= K: m = min(m, i - a.popleft())
    		a.append(i)
    	return -1 if m == float('inf') else m
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int arrayNesting(vector<int>& nums) {
    int ans = 0;

    for (const int num : nums) {
      if (num == -1)
        continue;
      int index = num;
      int count = 0;
      while (nums[index] != -1) {  // Not yet seen
        const int cache = index;
        index = nums[index];  // Get next index
        nums[cache] = -1;     // Already seen
        ++count;
      }
      ans = max(ans, count);
    }

    return ans;
  }
};"
"class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
        # dfs1: generate parent hashmap { node : prnt }
        # this lets us traverse up as well as down
        # then dfs2 starting from target
        # add seen nodes to set to avoid looping, otherwise take K steps away
        # O(N) time, O(N + H) space including recursive calls to tree height

        # helper function to get parents
        def get_prnts(node, parent):
            if not node: return
            d[node] = parent
            get_prnts(node.left, node)
            get_prnts(node.right, node)

        d = {}
        get_prnts(root, None)

        # helper function to step from target
        def rcrs(node, dist):
            if (not node) or (node in seen): return
            seen.add(node)

            if dist == K:
                res.append(node.val)
            else:
                rcrs(node.left, dist+1)
                rcrs(node.right, dist+1)
                rcrs(d[node], dist+1)

        res = []
        seen = set()
        rcrs(target, 0)
        return res

    def distanceK1(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
        # recursive dfs only: find target, update distance, re-traverse branches
        # dist initially inf until target found
        # O(N) ish time, O(H) recursive call space

        def rcrs(node, dist):
            if node is target:
                dist = 0

            # check distance of kids to target
            lt, rt = float(""inf""), float(""inf"")
            if node.left:  lt = rcrs(node.left, dist+1)
            if node.right: rt = rcrs(node.right, dist+1)

            # update node distance from children if not yet updated
            if dist == float(""inf""): dist = min(lt, rt)

            # add node.val to result list if K steps from target
            if dist == K: self.res.append(node.val)

            # if target found, one branch hasn't seen it, redo said branch
            if dist < float(""inf""):
                if node.left and lt == float(""inf""):  rcrs(node.left, dist+1)
                if node.right and rt == float(""inf""): rcrs(node.right, dist+1)
            return dist+1

        # setup &amp; recursive call
        self.res = []
        rcrs(root, float(""inf""))
        return self.res","class Solution {
 public:
  vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {
    if (nums.empty() || r * c != nums.size() * nums[0].size())
      return nums;

    vector<vector<int>> ans(r, vector<int>(c));
    int k = 0;

    for (const vector<int>& row : nums)
      for (const int num : row) {
        ans[k / c][k % c] = num;
        ++k;
      }

    return ans;
  }
};"
"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:
        dir = [[1,0], [-1,0], [0,1], [0,-1]]
        m = len(grid)
        n = len(grid[0])
        
        q = []
        k = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '@': q.append([i, j, ''])
                elif grid[i][j].islower(): k += 1

        visited = set()
        moves = 0
        while q:
            new_q = []
            for row, col, keys in q:
                if len(keys) == k: return moves
                if ((row, col, keys) in visited): continue
                visited.add((row, col, keys))
                for r, c in dir:
                    nr, nc = row + r, col + c
                    if nr < 0 or nr == m or nc < 0 or nc == n: continue 
                    val = grid[nr][nc]
                    if val == '#': continue
                    if val == '.' or val == '@' or val in keys: new_q.append([nr, nc, keys])
                    elif val.islower(): new_q.append([nr, nc, keys + val])
                    elif val.lower() in keys: new_q.append([nr, nc, keys])
            moves += 1
            q = new_q
        return -1","class Solution {
 public:
  bool checkInclusion(string s1, string s2) {
    vector<int> count(128);
    int required = s1.length();

    for (const char c : s1)
      ++count[c];

    for (int l = 0, r = 0; r < s2.length(); ++r) {
      if (--count[s2[r]] >= 0)
        --required;
      while (required == 0) {
        if (r - l + 1 == s1.length())
          return true;
        if (++count[s2[l++]] > 0)
          ++required;
      }
    }

    return false;
  }
};"
"class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        # recursive dfs approach
        # helper function: pass ""level"" when descending, return (node, max_depth)
        # if left depth == right_depth, return yourself
        # else return the side with greater depth
        # O(N) time, O(H) stack calls

        def rcrs(node, level):
            if not node: return (None, level-1)

            lt_node, lt_depth = rcrs(node.left, level+1)
            rt_node, rt_depth = rcrs(node.right, level+1)

            if not lt_node and not rt_node:
                return (node, level)

            if lt_depth == rt_depth:
                return (node, lt_depth)
            else:
                if lt_depth > rt_depth:
                    return (lt_node, lt_depth)
                else:
                    return (rt_node, rt_depth)

        # setup &amp; recursive call
        return rcrs(root, 0)[0]","class Solution {
 public:
  int maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {
    // dp[i][j] := # of vacations can be taken from i-th city and k-th week
    dp.resize(days.size(), vector<int>(days[0].size(), INT_MIN));
    return maxVacationDays(flights, days, 0, 0);
  }

 private:
  vector<vector<int>> dp;

  int maxVacationDays(const vector<vector<int>>& flights,
                      const vector<vector<int>>& days, int i, int k) {
    if (k == days[0].size())
      return 0;
    if (dp[i][k] != INT_MIN)
      return dp[i][k];

    int ans = 0;

    // Stay at j or fly from i -> j
    for (int j = 0; j < flights.size(); ++j)
      if (j == i || flights[i][j] == 1)
        ans = max(ans, days[j][k] + maxVacationDays(flights, days, j, k + 1));

    return dp[i][k] = ans;
  }
};"
"class Solution:
    def primePalindrome(self, k: int) -> int:
        def is_prime(num):
            if num % 2 is 0: return False
            return all(num%i for i in range(3, int(num**0.5)+1, 2))
        
        if k < 12:
            return next(x for x in [2,3,5,7,11] if x >= k)
        else:
            string_k = str(k)
            string_length = len(string_k)
            
            if string_length % 2:
                starting_root = int(string_k[:string_length-string_length//2])
                for root in range(starting_root, 10**6):
                    root = str(root)
                    palindrome_gen = int(root + root[-2::-1])
                    if is_prime(palindrome_gen) and palindrome_gen >= k:
                        return palindrome_gen
            else:
                starting_root = str(10**(string_length-string_length//2))
                starting_reverse = starting_root[-2::-1]
                for root in range(int(starting_root), 10**6):
                    palindrome_gen = int(str(root) + starting_reverse)
                    if is_prime(palindrome_gen) and palindrome_gen >= k:
                        return palindrome_gen","class Solution {
 public:
  bool isSubtree(TreeNode* s, TreeNode* t) {
    if (s == nullptr)
      return false;
    if (isSameTree(s, t))
      return true;
    return isSubtree(s->left, t) || isSubtree(s->right, t);
  }

 private:
  bool isSameTree(TreeNode* p, TreeNode* q) {
    if (!p || !q)
      return p == q;
    return p->val == q->val &&              //
           isSameTree(p->left, q->left) &&  //
           isSameTree(p->right, q->right);
  }
};"
"class Solution:
    def transpose(self, A: List[List[int]]) -> List[List[int]]:
        A = list(map(list, zip(*A)))
        return A","class Solution {
 public:
  int minDistance(int height, int width, vector<int>& tree,
                  vector<int>& squirrel, vector<vector<int>>& nuts) {
    int totDist = 0;
    int maxSave = INT_MIN;

    for (const vector<int>& nut : nuts) {
      totDist += dist(nut, tree) * 2;
      maxSave = max(maxSave, dist(nut, tree) - dist(nut, squirrel));
    }

    return totDist - maxSave;
  }

 private:
  int dist(const vector<int>& a, const vector<int>& b) {
    return abs(a[0] - b[0]) + abs(a[1] - b[1]);
  }
};"
"class Solution:
    def binaryGap(self, n: int) -> int:
        return max((lambda x: [x[i+1]-x[i] for i in range(len(x)-1)])([i for i,j in enumerate(bin(n)) if j == '1']), default = 0)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int distributeCandies(vector<int>& candies) {
    bitset<200001> bitset;

    for (const int candy : candies)
      bitset.set(candy + 100000);

    return min(candies.size() / 2, bitset.count());
  }
};"
"class Solution:
    def reorderedPowerOf2(self, N: int) -> bool:
        def str2dict(s):
            d = {}
            for i, e in enumerate(s):
                if e in d:
                    d[e] = d[e] + 1
                else:
                    d[e] = 1
            return d
        
        s = str(N)
        l = len(s)
        d = str2dict(s)
        
        i = 0
        result = False
        while not result:
            two_power = 2**i
            s_two_power = str(two_power)
            if len(s_two_power) == l:
                result = str2dict(s_two_power) == d
            elif len(s_two_power) > l:
                break
            i += 1
        return result","class Solution {
 public:
  int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
    this->m = m;
    this->n = n;
    // dp[k][i][j] := # of paths to move the ball (i, j) out of bound w/ k moves
    dp.resize(maxMove + 1, vector<vector<int>>(m, vector<int>(n, -1)));
    return findPaths(maxMove, startRow, startColumn);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  int m;
  int n;
  vector<vector<vector<int>>> dp;

  int findPaths(int k, int i, int j) {
    if (i < 0 || i == m || j < 0 || j == n)
      return 1;
    if (k == 0)
      return 0;
    if (dp[k][i][j] != -1)
      return dp[k][i][j];
    return dp[k][i][j] =
               ((findPaths(k - 1, i + 1, j) + findPaths(k - 1, i - 1, j)) %
                    kMod +
                (findPaths(k - 1, i, j + 1) + findPaths(k - 1, i, j - 1)) %
                    kMod) %
               kMod;
  }
};"
"class Solution:
    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:
        A.sort()
        mp = {}
        for x in sorted(B, reverse=True): 
            if x < A[-1]: mp.setdefault(x, []).append(A.pop())
        
        ans = []
        for x in B: 
            if x in mp and mp[x]: 
                ans.append(mp[x].pop())
            else: 
                ans.append(A.pop())
        return ans","class Solution {
 public:
  int findUnsortedSubarray(vector<int>& nums) {
    const int n = nums.size();
    int mini = INT_MAX;
    int maxi = INT_MIN;
    bool meetDecrease = false;
    bool meetIncrease = false;

    for (int i = 1; i < n; ++i) {
      if (nums[i] < nums[i - 1])
        meetDecrease = true;
      if (meetDecrease)
        mini = min(mini, nums[i]);
    }

    for (int i = n - 2; i >= 0; --i) {
      if (nums[i] > nums[i + 1])
        meetIncrease = true;
      if (meetIncrease)
        maxi = max(maxi, nums[i]);
    }

    int l;
    for (l = 0; l < n; ++l)
      if (nums[l] > mini)
        break;

    int r;
    for (r = n - 1; r >= 0; --r)
      if (nums[r] < maxi)
        break;

    return l < r ? r - l + 1 : 0;
  }
};"
"class Solution:
    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        ans = k = 0 
        total = startFuel 
        pq = [] 
        while total < target: 
            while k < len(stations) and stations[k][0] <= total: 
                heappush(pq, -stations[k][1]) 
                k += 1
            if not pq: return -1 
            total -= heappop(pq)
            ans += 1
        return ans","class Solution {
 public:
  vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {
    vector<int> ans;
    unordered_map<int, vector<int>> tree;

    for (int i = 0; i < pid.size(); ++i) {
      if (ppid[i] == 0)
        continue;
      tree[ppid[i]].push_back(pid[i]);
    }

    dfs(tree, kill, ans);
    return ans;
  }

 private:
  void dfs(const unordered_map<int, vector<int>>& tree, int u,
           vector<int>& ans) {
    ans.push_back(u);
    if (!tree.count(u))
      return;
    for (const int v : tree.at(u))
      dfs(tree, v, ans);
  }
};"
"class Solution:
	def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
		return self.helper(root1)==self.helper(root2)       
	def helper(self,root):
		res=[]
		if not root:
			return []
		if not root.left and not root.right:
			res.append(root.val)
		res+=self.helper(root.left)
		res+=self.helper(root.right)
		return res","class Solution {
 public:
  int minDistance(string word1, string word2) {
    const int k = lcs(word1, word2);
    return (word1.length() - k) + (word2.length() - k);
  }

 private:
  int lcs(const string& A, const string& B) {
    const int m = A.length();
    const int n = B.length();
    // dp[i][j] := LCS's length of A[0..i) and B[0..j)
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (A[i - 1] == B[j - 1])
          dp[i][j] = 1 + dp[i - 1][j - 1];
        else
          dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);

    return dp[m][n];
  }
};"
"class Solution:
    def lenLongestFibSubseq(self, A: List[int]) -> int:
    	L, M, AA = len(A), 0, {i for i in A}
    	for i in range(L-1):
    		for j in range(i+1,L):
    			a, b, s = A[i], A[j], 0
    			while a in AA: a, b, s = b, a + b, s + 1
    			if s > M: M = s
    			if a > A[-1]:
    				if j == i + 1:
    					return 0 if M == 2 else M
    				break
					
					
- Junaid Mansuri
(LeetCode ID)@hotmail.com","// Monotone Chain
class Solution {
 public:
  vector<vector<int>> outerTrees(vector<vector<int>>& trees) {
    vector<vector<int>> hull;

    sort(begin(trees), end(trees), [](const auto& a, const auto& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0];
    });

    // Build lower hull: left-to-right scan
    for (const auto& tree : trees) {
      while (hull.size() > 1 &&
             cross(hull.back(), hull[hull.size() - 2], tree) > 0)
        hull.pop_back();
      hull.push_back(tree);
    }
    hull.pop_back();

    // Build upper hull: right-to-left scan
    for (int i = trees.size() - 1; i >= 0; --i) {
      while (hull.size() > 1 &&
             cross(hull.back(), hull[hull.size() - 2], trees[i]) > 0)
        hull.pop_back();
      hull.push_back(trees[i]);
    }

    // Remove redundant elements from the stack
    sort(begin(hull), end(hull), [](const auto& a, const auto& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0];
    });
    hull.erase(
        unique(begin(hull), end(hull),
               [](const auto& a,
                  const auto& b) { return a[0] == b[0] && a[1] == b[1]; }),
        end(hull));
    return hull;
  }

 private:
  int cross(const vector<int>& p, const vector<int>& q, const vector<int>& r) {
    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
  }
};"
"class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        # 0) Keep obstacke in set for future reference
        obstacle_set = set()
        for o in obstacles:
            obstacle_set.add((o[0], o[1]))

        # 1) Define movement functions and way to turn direction
        up = lambda pos: (pos[0], pos[1]+1)
        down = lambda pos: (pos[0], pos[1]-1)
        left = lambda pos: (pos[0]-1, pos[1])
        right = lambda pos: ((pos[0]+1, pos[1]))
        moves = [up, right, down, left]
        cpos = (0, 0)
        mi = 0
        def turn(mi, v):
            return (mi + 1) % 4 if v == -1 else (mi - 1 + 4) % 4

        move = lambda pos: moves[mi](cpos)
        
        # 2) Execute the command(s)
        max_dist = 0
        for cmd in commands:
            if cmd < 0:
                mi = turn(mi, cmd)                
            else:
                for _ in range(cmd):
                    next_pos = move(cpos)
                    if next_pos in obstacle_set:
                        break

                    cpos = next_pos
        
            max_dist = max(max_dist, pow(cpos[0], 2) + pow(cpos[1], 2))
            
        # 3) Return the result
        return max_dist","struct TrieNode {
  map<string, shared_ptr<TrieNode>> children;  // Map: lexicographical
  bool isFile = false;
  string content;
};

class FileSystem {
 public:
  vector<string> ls(string path) {
    auto [node, lastDir] = createDirAndGetPair(path);
    if (node->isFile)
      return {lastDir};

    vector<string> ans;

    for (const auto& [file, _] : node->children)
      ans.push_back(file);

    return ans;
  }

  void mkdir(string path) {
    createDirAndGetPair(path);
  }

  void addContentToFile(string filePath, string content) {
    shared_ptr<TrieNode> node = createDirAndGetPair(filePath).first;
    node->isFile = true;
    node->content += content;
  }

  string readContentFromFile(string filePath) {
    shared_ptr<TrieNode> node = createDirAndGetPair(filePath).first;
    return node->content;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  // CreateDirAndGetPair(""/a//b"") -> {TrieNode b, string ""b""}
  pair<shared_ptr<TrieNode>, string> createDirAndGetPair(const string& path) {
    const vector<string> dirs = getDirs(path);
    shared_ptr<TrieNode> node = root;

    for (const string& dir : dirs) {
      if (!node->children.count(dir))
        node->children[dir] = make_shared<TrieNode>();
      node = node->children[dir];
    }

    return {node, dirs.empty() ? """" : dirs.back()};
  }

  // GetDirs(""/a//b"") -> [""a"", ""b""]
  vector<string> getDirs(const string& path) {
    vector<string> dirs;
    istringstream iss(path);

    for (string dir; getline(iss, dir, '/');)
      if (!dir.empty())  // ""/a//b"" == ""/a/b""
        dirs.push_back(dir);

    return dirs;
  }
};"
"class Solution:
    def minEatingSpeed(self, piles: List[int], hour: int) -> int:
        l=1
        h=max(piles)
        def fun(speed):
            ans=0
            for i in piles:
                ans+=ceil(i/speed)
            #print(ans)
            if ans>hour:
                return False
            return True
        ans=h
        while(l<=h):
            
            mid=(l+h)//2
           
            if fun(mid):
                ans=min(ans,mid)
                h=mid-1
            else:
                l=mid+1
        return ans","class Solution {
 public:
  vector<int> preorder(Node* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    stack<Node*> stack{{root}};

    while (!stack.empty()) {
      root = stack.top(), stack.pop();
      ans.push_back(root->val);
      for (auto it = rbegin(root->children); it != rend(root->children); ++it)
        stack.push(*it);
    }

    return ans;
  }
};"
"class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pos=0
        curr=head
        while(curr!=None):
            pos+=1
            curr=curr.next
        curr=head
        for i in range(pos//2):
            curr=curr.next
        return curr","class Solution {
 public:
  vector<int> postorder(Node* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    stack<Node*> stack{{root}};

    while (!stack.empty()) {
      root = stack.top(), stack.pop();
      ans.push_back(root->val);
      for (Node* child : root->children)
        stack.push(child);
    }

    reverse(begin(ans), end(ans));
    return ans;
  }
};"
"class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        @functools.cache
        def doIWin(l,r):
            if l > r: return 0
            
            left = piles[l] - doIWin(l+1,r) # `-` because my opponent!
            
            right= piles[r] - doIWin(l,r-1)
            
            return max(left, right)
        
        return (doIWin(0,len(piles)-1) + sum(piles) )//2","class Solution {
 public:
  bool isValid(string code) {
    if (code[0] != '<' || code.back() != '>')
      return false;

    stack<string> stack;

    for (int i = 0; i < code.length(); ++i) {
      int closeIndex = 0;
      if (stack.empty() && containsTag)
        return false;
      if (code[i] == '<') {
        // Inside a tag, so we can check if it's a cdata
        if (!stack.empty() && code[i + 1] == '!') {
          closeIndex = code.find(""]]>"", i + 2);
          if (closeIndex == string::npos ||
              !isValidCdata(code.substr(i + 2, closeIndex - i - 2)))
            return false;
        } else if (code[i + 1] == '/') {  // End tag
          closeIndex = code.find('>', i + 2);
          if (closeIndex == string::npos ||
              !isValidTagName(stack, code.substr(i + 2, closeIndex - i - 2),
                              true))
            return false;
        } else {  // Start tag
          closeIndex = code.find('>', i + 1);
          if (closeIndex == string::npos ||
              !isValidTagName(stack, code.substr(i + 1, closeIndex - i - 1),
                              false))
            return false;
        }
        i = closeIndex;
      }
    }

    return stack.empty() && containsTag;
  }

 private:
  bool containsTag = false;

  bool isValidCdata(const string& s) {
    return s.find(""[CDATA["") == 0;
  }

  bool isValidTagName(stack<string>& stack, const string& tagName,
                      bool isEndTag) {
    if (tagName.empty() || tagName.length() > 9)
      return false;

    for (const char c : tagName)
      if (!isupper(c))
        return false;

    if (isEndTag) {
      if (stack.empty())
        return false;
      if (stack.top() != tagName)
        return false;
      stack.pop();
      return true;
    }

    containsTag = true;
    stack.push(tagName);
    return true;
  }
};"
"class Solution:
    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
        def gcd(x,y):
            if(x==0):
                return y
            return gcd(y%x,x)
        lcm=(a*b)//gcd(a,b)
        s=set()
        x=a
        while(x<=lcm):
            s.add(x)
            x+=a
        x=b
        while(x<=lcm):
            s.add(x)
            x+=b
        
        le=0
        l=[]
   
        for i in s:
            l.append(i)
            le+=1
        l.sort()    #sort all multiples of a and b which are less than their lcm.
        
        #below approach is based on pattern observation. Try to take some example and observer the pattern(e.g n=4,8,9,16,18,41 #a=3, b=7)
        r=n%le
        q=n//(le+1)
      
        if(q==0):
            return l[n-1]
        else:
            q=n//le
            res=  ((q*l[-1])%1000000007)
            if(r>0):
                  res=(res+ l[r-1]) %1000000007
            return res","class Solution {
 public:
  string fractionAddition(string expression) {
    istringstream iss(expression);
    char _;
    int a;
    int b;
    int A = 0;
    int B = 1;

    // Init: A / B = 0 / 1
    // A / B + a / b = (Ab + aB) / Bb
    // So, each round set A = Ab + aB, B = Bb
    while (iss >> a >> _ >> b) {
      A = A * b + a * B;
      B *= b;
      const int g = abs(__gcd(A, B));
      A /= g;
      B /= g;
    }

    return to_string(A) + ""/"" + to_string(B);
  }
};"
"class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:
        MOD = 1_000_000_007
        
        @cache
        def fn(i, n, p): 
            """"""Return count at i with n people remaining and p profit to make.""""""
            if n < 0: return 0
            if i == len(group): return p <= 0 
            return (fn(i+1, n, p) + fn(i+1, n-group[i], p-profit[i])) % MOD

        return fn(0, n, minProfit)","class Solution {
 public:
  bool validSquare(vector<int>& p1, vector<int>& p2,  //
                   vector<int>& p3, vector<int>& p4) {
    unordered_set<int> distSet;
    vector<vector<int>> points{p1, p2, p3, p4};

    for (int i = 0; i < 4; ++i)
      for (int j = i + 1; j < 4; ++j)
        distSet.insert(dist(points[i], points[j]));

    return !distSet.count(0) && distSet.size() == 2;
  }

 private:
  int dist(vector<int>& p1, vector<int>& p2) {
    return (p1[0] - p2[0]) * (p1[0] - p2[0]) +
           (p1[1] - p2[1]) * (p1[1] - p2[1]);
  }
};"
"class Solution:
    def decodeAtIndex(self, S: str, K: int) -> str:
		# e.g. S == 'ab2c3d'
		# ls_len: list of lengths of new patterns [2, 5] (ab, ababc)
		# ls_total_len: list of lengths of times * new pattern [4, 15] (abab, ababcababcababc)
		# ls_pattern: list of new additional pattern ['ab', 'c']
        ls_len = []
        ls_total_len = []
        ls_pattern = []
        tmp = ''
        length = 0
        # flag for string without integer
		prev_num = -1
		
        for i in range(len(S)): 
            value = S[i]
            if i == 0: 
				# first char is letter only
                tmp = value
                length = 1
                continue
            if 50 <= ord(value) <= 57: 
                if tmp: 
					# if not more than one integer appearing together
                    ls_pattern.append(tmp)
                    ls_len.append(length)
                    ls_total_len.append(length * int(value))
                else: 
					# e.g. S = 'a23', here ls_total_len will change from [2] (aa) to [6] (aaaaaa). 
					# The other two lists unchanged.
                    ls_total_len[-1] = length * int(value)
                length = length * int(value)
                tmp = ''
                prev_num = i
            else: 
                tmp += value
                length += 1       
        
		# residual is the last part left with no multiplier, e.g. S = 'ab2c3d', then the last 'd' is the residual
        residual = tmp
		if prev_num < 0: 
			# if no integer is in S, return the (K - 1)th element. 
            return S[K - 1]
       
        if K > ls_total_len[-1]: 
			# if K is within the first pattern
            return residual[K - ls_total_len[-1] - 1]
        if K <= ls_total_len[0]: 
			# if K is in the residual
            ptn = ls_pattern[0]
            len_ptn = ls_len[0]
            return ptn[(K - 1) % len_ptn]
        
        def bs(k, lb, ub, ls): 
			# binary search of K's location in the two lists: ls_len &amp; ls_total_len
            if k <= ls[lb]: 
                return lb - 1
            if k > ls[ub]: 
                return ub
            if ub == lb + 1: 
                return lb
            mid = (lb + ub) // 2
            if k == ls[mid]: 
                return mid - 1
            elif k < ls[mid]:
                return bs(k, lb, mid, ls)
            else: 
                return bs(k, mid + 1, ub, ls)
         
		# due to the nature of the two lists, idx1 >= idx2
        idx1 = bs(K, 0, len(ls_pattern) - 1, ls_len)
        idx2 = bs(K, 0, len(ls_pattern) - 1, ls_total_len)

        while idx1 != idx2 and idx2 != -1: 
			# if idx1 ==  idx2, (K - 1)th element is in the new additional pattern
			# if idx2 == -1, (K - 1)th element is in the first pattern
            K %= ls_len[idx1]
            if not K: 
                K = ls_len[idx1]
            idx1 = bs(K, 0, idx1, ls_len)
            idx2 = bs(K, 0, idx2, ls_total_len)
        if idx2 == -1: 
            return ls_pattern[0][K % ls_len[0] - 1]
        if idx1 == idx2: 
            return ls_pattern[idx1 + 1][K - ls_total_len[idx1] - 1]","class Solution {
 public:
  int findLHS(vector<int>& nums) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[num];

    for (const auto& [num, freq] : count)
      if (const auto it = count.find(num + 1); it != cend(count))
        ans = max(ans, freq + it->second);

    return ans;
  }
};"
"class Solution:
    def numRescueBoats(self, people: List[int], limit: int) -> int:
        people.sort() # ascending 
        
        ans, lo, hi = 0, 0, len(people)-1
        while lo <= hi: 
            ans += 1
            if lo < hi and people[lo] + people[hi] <= limit: lo += 1
            hi -= 1
        return ans","class Solution {
 public:
  int maxCount(int m, int n, vector<vector<int>>& ops) {
    int minY = m;
    int minX = n;

    for (const vector<int>& op : ops) {
      minY = min(minY, op[0]);
      minX = min(minX, op[1]);
    }

    return minX * minY;
  }
};"
"class Solution:
    def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:
        graph = defaultdict(dict)
        dp = defaultdict(dict)
        
        for v1, v2, wt in edges:
            graph[v1][v2] = wt + 1
            graph[v2][v1] = wt + 1
            dp[v1][v2] = 0
            dp[v2][v1] = 0
        
        #print(graph)
        
        def dijkstra(graph, dp):
            
            myheap = [(0, 0)]
            distances = [float(inf)] * n
            distances[0] = 0
            
            while myheap:
                cost, node = heappop(myheap)
                if cost > maxMoves or cost > distances[node]:
                    continue
                    
                for nxtNode, nxtCost in graph[node].items():
                    totalCost = nxtCost + cost
                    remainingMoves = maxMoves - cost
					# nxtCost is the distance bw node and nxtNode so there are nxtCost - 1 new nodes in bw them
					# If remainingMoves are greater than number of new nodes bw them -> it mean we can reach all nodes between the current pair of nodes
                    dp[node][nxtNode] = max(dp[node][nxtNode], min(remainingMoves, nxtCost - 1))
                    
                    if totalCost > distances[nxtNode] or totalCost > maxMoves:
                        continue
                    
                    distances[nxtNode] = totalCost
                    heappush(myheap, (totalCost, nxtNode))
                    #print(nxtNode, distances)
            
            return dp, distances
        
        dp, dist = dijkstra(graph, dp)
        #print(dist)
        #print(dp)
        ans = 0
        for key in dp:
            for node, num in dp[key].items():
                total = dp[node][key] + num
                ans += min(total, graph[key][node] - 1)
		# each pair is counted twice so we need to divide by 2
        ans = ans // 2
        
		# count how many old nodes are reachable
        for elem in dist:
            if elem != float(inf):
                ans += 1
        
        return ans","class Solution {
 public:
  vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {
    vector<string> ans;
    unordered_map<string, int> restaurantToIndex;
    int minSum = INT_MAX;

    for (int i = 0; i < list1.size(); ++i)
      restaurantToIndex[list1[i]] = i;

    for (int i = 0; i < list2.size(); ++i) {
      const string& restaurant = list2[i];
      if (const auto it = restaurantToIndex.find(restaurant);
          it != cend(restaurantToIndex)) {
        const int sum = it->second + i;
        if (sum < minSum) {
          minSum = sum;
          ans = {restaurant};
        } else if (sum == minSum) {
          ans.push_back(restaurant);
        }
      }
    }

    return ans;
  }
};"
"class Solution:
    def uncommonFromSentences(self, A: str, B: str) -> List[str]:
    	S = [collections.Counter(A.split()),collections.Counter(B.split())]
    	return [j for i in range(2) for j in S[i] if S[i][j] == 1 and j not in S[1-i]]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int findIntegers(int num) {
    string bits;
    for (; num; num >>= 1)
      bits += to_string(num & 1);

    const int n = bits.length();
    vector<int> zero(n, 1);
    vector<int> one(n, 1);

    for (int i = 1; i < n; ++i) {
      zero[i] = zero[i - 1] + one[i - 1];
      one[i] = zero[i - 1];
    }

    int ans = zero[n - 1] + one[n - 1];

    for (int i = n - 2; i >= 0; --i) {
      // Numbers greater than num and <= 2^n - 1 are invalid
      if (bits[i] == '1' && bits[i + 1] == '1')
        break;
      if (bits[i] == '0' && bits[i + 1] == '0')
        ans -= one[i];
    }

    return ans;
  }
};"
"class Solution:
    def spiralMatrixIII(self, M: int, N: int, x: int, y: int) -> List[List[int]]:
        A, d = [[x,y]], 0
        while len(A) < M*N:
            for s in 1,-1:
                d += 1
                for y in range(y+s,y+s*(d+1),s):
                    if 0<=x<M and 0<=y<N: A.append([x,y])
                for x in range(x+s,x+s*(d+1),s):
                    if 0<=x<M and 0<=y<N: A.append([x,y])
        return A
        
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  bool canPlaceFlowers(vector<int>& flowerbed, int n) {
    if (n == 0)
      return true;

    for (int i = 0; i < flowerbed.size(); ++i)
      if (flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) &&
          (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {
        flowerbed[i] = 1;
        if (--n == 0)
          return true;
      }

    return false;
  }
};"
"class Solution:
    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:
        
        d = deque([])
        colors = {}
        
        graph = {i: [] for i in range(1, N+1)}
        
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)
            
        for i in graph.keys():
            
            if i not in colors:
                colors[i] = 1
                d.append(i)
                
                while d:
                    
                    item = d.popleft()
                    for ch in graph[item]:
                        
                        if ch in colors:
                            if colors[ch] == colors[item]:
                                return False
                        else:
                            colors[ch] = 1 - colors[item]
                            d.append(ch)
        return True","class Solution {
 public:
  string tree2str(TreeNode* t) {
    return dfs(t);
  }

 private:
  string dfs(TreeNode* root) {
    if (root == nullptr)
      return """";

    const string& rootStr = to_string(root->val);
    if (root->right)
      return rootStr + ""("" + dfs(root->left) + "")("" + dfs(root->right) + "")"";
    if (root->left)
      return rootStr + ""("" + dfs(root->left) + "")"";
    return rootStr + """";
  }
};"
"class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        return self.solve(k,n)
    
    def solve(self,e,f):
        if f == 0 or f == 1:
            return f
        if e == 1:
            return f
        
        ans = float('inf')
        
        for k in range(1,f):
            temp = 1 + max(self.solve(e-1,k-1), self.solve(e,f-k))
            ans = min(ans,temp)
            
        return ans","class Solution {
 public:
  vector<vector<string>> findDuplicate(vector<string>& paths) {
    vector<vector<string>> ans;
    unordered_map<string, vector<string>> contentToFilePaths;

    for (const string& path : paths) {
      istringstream iss(path);
      string rootPath;
      iss >> rootPath;  // ""root/d1/d2/.../dm""

      string fileAndContent;
      while (iss >> fileAndContent) {  // ""fn.txt(fn_content)""
        const int l = fileAndContent.find('(');
        const int r = fileAndContent.find(')');
        // ""fn.txt""
        const string file = fileAndContent.substr(0, l);
        // ""fn_content""
        const string content = fileAndContent.substr(l + 1, r - l - 1);
        // ""root/d1/d2/.../dm/fn.txt""
        const string filePath = rootPath + '/' + file;
        contentToFilePaths[content].push_back(filePath);
      }
    }

    for (const auto& [_, filePaths] : contentToFilePaths)
      if (filePaths.size() > 1)
        ans.push_back(filePaths);

    return ans;
  }
};"
"class Solution:
    def fairCandySwap(self, A, B):
        Sa = sum(A)
        Sb = sum(B)
        setB = set(B)
        for x in A:
            if x + (Sb - Sa) / 2 in setB:
                return [x, x + (Sb - Sa) / 2]","class Solution {
 public:
  int triangleNumber(vector<int>& nums) {
    if (nums.size() < 3)
      return 0;

    int ans = 0;

    sort(begin(nums), end(nums));

    for (int k = nums.size() - 1; k > 1; --k) {
      int i = 0;
      int j = k - 1;
      while (i < j)
        if (nums[i] + nums[j] > nums[k]) {
          // (nums[i], nums[j], nums[k])
          // (nums[i + 1], nums[j], nums[k])
          // ...
          // (nums[j - 1], nums[j], nums[k])
          ans += j - i;
          --j;
        } else {
          ++i;
        }
    }

    return ans;
  }
};"
"class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> TreeNode:
        pre_index, post_index  = 0, 0
        def dfs(prev_val):
            nonlocal pre_index
            nonlocal post_index

            if prev_val == postorder[post_index]:
                return None
            
            node = TreeNode(preorder[pre_index])
            pre_index += 1

            node.left = dfs(node.val)
            node.right = dfs(node.val)

            post_index += 1

            return node
        return dfs(-1)","class Solution {
 public:
  string addBoldTag(string s, vector<string>& words) {
    const int n = s.length();
    string ans;
    // bold[i] := true if s[i] should be bolded
    vector<bool> bold(n);

    int boldEnd = -1;  // s[i:boldEnd] should be bolded
    for (int i = 0; i < n; ++i) {
      for (const string& word : words)
        if (s.substr(i).find(word) == 0)  // StartsWith
          boldEnd = max(boldEnd, i + static_cast<int>(word.length()));
      bold[i] = boldEnd > i;
    }

    // Construct the string with bold tags
    int i = 0;
    while (i < n)
      if (bold[i]) {
        int j = i;
        while (j < n && bold[j])
          ++j;
        // s[i:j] should be bolded
        ans += ""<b>"" + s.substr(i, j - i) + ""</b>"";
        i = j;
      } else {
        ans += s[i++];
      }

    return ans;
  }
};"
"class Solution:
    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:
        
        
        
        ans=[]
        
        for j in words:
            
            if len(j)==len(pattern):
                if len(set(j)) == len(set(pattern)):
                    
                    pe={}
                    we={}
                    
                    h=0
                    for i in range(1,len(pattern)):
                        
                        if pattern[i]==pattern[i-1]:
                            if j[i-1]!=j[i]:
                                h+=1
                                break
                        elif pattern[i]!=pattern[i-1]:
                            if j[i-1]==j[i]:
                                h+=1
                                break
                        
                        if pattern[i] not in pe:
                            pe[pattern[i]]=1
                            if j[i] in we:
                                h+=1
                                break
                            else:
                                we[j[i]]=1
                        
                        if pattern[i] in pe:
                            pe[pattern[i]]+=1
                            
                            if j[i] not in we:
                                h+=1
                                break
                            else:
                                we[j[i]]+=1
                                
                    
                        
                    if h==0 and sorted(list(we.values()))==sorted(list(pe.values())):
                        ans.append(j)
                        
        return ans","class Solution {
 public:
  TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    if (root1 == nullptr && root2 == nullptr)
      return nullptr;
    const int val = (root1 == nullptr ? 0 : root1->val) +
                    (root2 == nullptr ? 0 : root2->val);
    TreeNode* root = new TreeNode(val);
    root->left = mergeTrees(root1 == nullptr ? nullptr : root1->left,
                            root2 == nullptr ? nullptr : root2->left);
    root->right = mergeTrees(root1 == nullptr ? nullptr : root1->right,
                             root2 == nullptr ? nullptr : root2->right);
    return root;
  }
};"
"class Solution:
    def sumSubseqWidths(self, nums: List[int]) -> int:
        MOD = 1_000_000_007
        ans = 0 
        for i, x in enumerate(sorted(nums)): 
            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))
        return ans % MOD","class Solution {
 public:
  int leastInterval(vector<char>& tasks, int n) {
    if (n == 0)
      return tasks.size();

    vector<int> count(26);

    for (const char task : tasks)
      ++count[task - 'A'];

    const int maxFreq = *max_element(begin(count), end(count));
    // Put the most frequent task in the slot first
    const int maxFreqTaskOccupy = (maxFreq - 1) * (n + 1);
    // Get # of tasks with same frequency as maxFreq,
    // we'll append them after maxFreqTaskOccupy
    const int nMaxFreq = std::count(begin(count), end(count), maxFreq);
    // Max(
    //   the most frequent task is frequent enough to force some idle slots,
    //   the most frequent task is not frequent enough to force idle slots
    // )
    return max(maxFreqTaskOccupy + nMaxFreq, static_cast<int>(tasks.size()));
  }
};"
"class Solution:
    def surfaceArea(self, G: List[List[int]]) -> int:
        N, C = len(G), [(1,0),(0,-1),(-1,0),(0,1)]
        G, S = [[0]*(N+2)] + [[0]+g+[0] for g in G] + [[0]*(N+2)], 2*N**2 - 2*sum(G,[]).count(0)
        for i,j in itertools.product(range(1,N+1),range(1,N+1)): S += sum(max(0,G[i][j]-G[i+x][j+y]) for x,y in C)
        return S
		
		
- Junaid Mansuri","class MyCircularQueue {
 public:
  /** Initialize your data structure here. Set the size of the queue to be k. */
  MyCircularQueue(int k) : k(k), q(k), rear(k - 1) {}

  /** Insert an element into the circular queue. Return true if the operation is
   * successful. */
  bool enQueue(int value) {
    if (isFull())
      return false;

    rear = ++rear % k;
    q[rear] = value;
    ++size;
    return true;
  }

  /** Delete an element from the circular queue. Return true if the operation is
   * successful. */
  bool deQueue() {
    if (isEmpty())
      return false;

    front = ++front % k;
    --size;
    return true;
  }

  /** Get the front item from the queue. */
  int Front() {
    return isEmpty() ? -1 : q[front];
  }

  /** Get the last item from the queue. */
  int Rear() {
    return isEmpty() ? -1 : q[rear];
  }

  /** Checks whether the circular queue is empty or not. */
  bool isEmpty() {
    return size == 0;
  }

  /** Checks whether the circular queue is full or not. */
  bool isFull() {
    return size == k;
  }

 private:
  const int k;
  vector<int> q;
  int size = 0;
  int front = 0;
  int rear;
};"
"class Solution:        
    def numSpecialEquivGroups(self, A: List[str]) -> int:
        return len(set(''.join(sorted(stri[i] for i in range(len(stri)) if i%2==0)) + ''.join(sorted(stri[i] for i in range(len(stri)) if i%2!=0)) for stri in A))","class Solution {
 public:
  TreeNode* addOneRow(TreeNode* root, int v, int d) {
    if (d == 1) {
      TreeNode* newRoot = new TreeNode(v);
      newRoot->left = root;
      return newRoot;
    }

    int depth = 0;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      ++depth;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
        if (depth == d - 1) {
          TreeNode* cachedLeft = node->left;
          TreeNode* cachedRight = node->right;
          node->left = new TreeNode(v);
          node->right = new TreeNode(v);
          node->left->left = cachedLeft;
          node->right->right = cachedRight;
        }
      }
      if (depth == d - 1)
        break;
    }

    return root;
  }
};"
"class Solution:
    def allPossibleFBT(self, N: int) -> List[TreeNode]:
        #impossible to satisfy the conditions
        if N % 2 == 0:
            return []
        
        full_list = {}
        
        #base cases
        full_list[1] = [TreeNode(0)]
        temp = TreeNode(0)
        temp.left = full_list[1][0]
        temp.right = full_list[1][0]
        full_list[3] = [temp]
        
        for x in range(5, N+1, 2):
            full_list[x] = []
            n_left = 1
            n_right = (x - 1) - n_left  # x-1 to exclude the root node
            
            #go through all combinations of children trees that add to x-1
            while n_right >= 1:
                for l_tree in full_list[n_left]:
                    for r_tree in full_list[n_right]:
                        temp = TreeNode(0)
                        temp.left = l_tree
                        temp.right = r_tree
                        #print(temp)
                        full_list[x].append(temp)
                
                n_left += 2
                n_right -= 2
        
        #print(len(full_list[N]))
        return full_list[N]","class Solution {
 public:
  int maxDistance(vector<vector<int>>& arrays) {
    int ans = 0;
    int min = 10000;
    int max = -10000;

    for (const vector<int>& A : arrays) {
      ans = std::max({ans, A.back() - min, max - A.front()});
      min = std::min(min, A.front());
      max = std::max(max, A.back());
    }

    return ans;
  }
};"
"class Solution:
    
    def is_increasing(self, items):
        start_value = items[0]
        for value in items: 
            if value > start_value:
                return True
            if value < start_value:
                return False
            
    def get_comparison_function(self, is_increasing):
        def is_asscending(a, b):
            return a <= b
        
        def is_decending(a, b):
            return a >= b
        
        if is_increasing: 
            return is_asscending
        return is_decending
    
    def isMonotonic(self, A: List[int]) -> bool:
        is_increasing = self.is_increasing(A)
        is_monotonic = self.get_comparison_function(is_increasing)
        
        for index in range(1, len(A)):
            previous_item = A[index - 1]
            item = A[index]
            if not is_monotonic(previous_item, item):
                return False
            
        return True","class Solution {
 public:
  int smallestFactorization(int num) {
    if (num == 1)
      return 1;

    long ans = 0;
    long base = 1;

    for (int i = 9; i > 1; --i)
      while (num % i == 0) {
        num /= i;
        ans = base * i + ans;
        base *= 10;
      }

    return num == 1 && ans <= INT_MAX ? ans : 0;
  }
};"
"class Solution(object):
    def increasingBST(self, root):
        """"""
        :type root: TreeNode
        :rtype: TreeNode
        """"""
        self.all_nodes = []

        def find_all_nodes(root):
            if root:
                self.all_nodes.append(root.val)
                find_all_nodes(root.left)
                find_all_nodes(root.right)

        find_all_nodes(root)
        self.all_nodes.sort()

        tree = TreeNode(self.all_nodes.pop())
        while len(self.all_nodes) > 0:
            t = TreeNode(self.all_nodes.pop())
            t.left = None
            t.right = tree
            tree = t

        return tree","class Solution {
 public:
  int maximumProduct(vector<int>& nums) {
    const int n = nums.size();
    sort(begin(nums), end(nums));
    return max(nums[n - 1] * nums[0] * nums[1],
               nums[n - 1] * nums[n - 2] * nums[n - 3]);
  }
};"
"class Solution:
    def subarrayBitwiseORs(self, A: List[int]) -> int:
        ans, vals = set(), set()
        for x in A: 
            vals = {x | xx for xx in vals} | {x}
            ans |= vals
        return len(ans)","class Solution {
 public:
  int kInversePairs(int n, int k) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j] := # of permutations of numbers 1..i with j inverse pairs
    vector<vector<int>> dp(n + 1, vector<int>(k + 1));

    // If there's no inverse pair, the permutation is unique ""123..i""
    for (int i = 0; i <= n; ++i)
      dp[i][0] = 1;

    for (int i = 1; i <= n; ++i)
      for (int j = 1; j <= k; ++j) {
        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % kMod;
        if (j - i >= 0)
          dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + kMod) % kMod;
      }

    return dp[n][k];
  }
};"
"class Solution:
    def calcS(self,s):
        res = 0
        for x in s:
            res *= 26
            res += (ord(x)-96)

        return res

    def orderlyQueue(self, s: str, k: int) -> str:

        if k == 1:
            least = inf
            indx = 0
            ss = s*2
            d = len(s)
            for l in range(d):
                if least>self.calcS(ss[l:l+d]):
                    least = self.calcS(ss[l:l+d])
                    indx = l
            return ss[indx:indx+d]
                 
        else:
            D = defaultdict(int)
        
            for x in s:
                D[x] += 1
            
            abc = ""abcdefghijklmnopqrstuvwxyz""
            res = """"

            for x in abc:
                res += x*D[x]

            return res","class Solution {
 public:
  int scheduleCourse(vector<vector<int>>& courses) {
    int time = 0;
    sort(begin(courses), end(courses),
         [](const auto& a, const auto& b) { return a[1] < b[1]; });
    priority_queue<int> maxHeap;

    for (const vector<int>& c : courses) {
      const int duration = c[0];
      const int lastDay = c[1];
      maxHeap.push(duration);
      time += c[0];
      // If current course could not be taken, check if it's able to swap with a
      // Previously taken course with larger duration, to increase the time
      // Available to take upcoming courses
      if (time > lastDay)
        time -= maxHeap.top(), maxHeap.pop();
    }

    return maxHeap.size();
  }
};"
"class Solution:
    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:
        limit = str(n)
        limit_len = len(limit)
        digits_len = len(digits)
        res = 0
        
        for idx in range(1, limit_len):
            res += pow(digits_len, idx)
        
        for idx in range(limit_len):
            is_start_eq_digit = False
            for digit in digits:
                if digit < limit[idx]:
                    res += pow(digits_len, limit_len - idx - 1)
                elif digit == limit[idx]:
                    is_start_eq_digit = True
            
            if not is_start_eq_digit:
                return res
        
        return res + 1","struct T {
  int i;
  int j;
  int num;  // nums[i][j]
  T(int i, int j, int num) : i(i), j(j), num(num) {}
};

class Solution {
 public:
  vector<int> smallestRange(vector<vector<int>>& nums) {
    auto compare = [&](const T& a, const T& b) { return a.num > b.num; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    int mini = INT_MAX;
    int maxi = INT_MIN;

    for (int i = 0; i < nums.size(); ++i) {
      const int num = nums[i][0];
      minHeap.emplace(i, 0, num);
      mini = min(mini, num);
      maxi = max(maxi, num);
    }

    int minRange = mini;
    int maxRange = maxi;

    while (minHeap.size() == nums.size()) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      if (j + 1 < nums[i].size()) {
        minHeap.emplace(i, j + 1, nums[i][j + 1]);
        maxi = max(maxi, nums[i][j + 1]);
        mini = minHeap.top().num;
        if (maxi - mini < maxRange - minRange) {
          minRange = mini;
          maxRange = maxi;
        }
      }
    }

    return {minRange, maxRange};
  }
};"
"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        myStore = [1]
        
        for index, val in enumerate(s):
            if val == 0:
                continue
            temp = []
            for i in range(index + 2):
                if val == ""I"":
                    curr = sum(myStore[i:])
                else:
                    curr = sum(myStore[:i])
                temp.append(curr)
            myStore = temp
        return sum(myStore) % (10**9+7)","class Solution {
 public:
  bool judgeSquareSum(int c) {
    unsigned l = 0;
    unsigned r = sqrt(c);

    while (l <= r) {
      const unsigned sum = l * l + r * r;
      if (sum == c)
        return true;
      if (sum < c)
        ++l;
      else
        --r;
    }

    return false;
  }
};"
"class Solution:
    def totalFruit(self, tree: List[int]) -> int:
        ans = ii = 0
        freq = {}
        for i, x in enumerate(tree): 
            freq[x] = 1 + freq.get(x, 0)
            while len(freq) > 2: 
                freq[tree[ii]] -= 1
                if freq[tree[ii]] == 0: freq.pop(tree[ii])
                ii += 1
            ans = max(ans, i - ii + 1)
        return ans","class Solution {
 public:
  int findDerangement(int n) {
    dp.resize(n + 1);
    return find(n);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<int> dp;

  int find(int i) {
    if (i == 0)
      return 1;
    if (i == 1)
      return 0;
    if (dp[i])
      return dp[i];
    return dp[i] = (i - 1L) * (find(i - 1) + find(i - 2)) % kMod;
  }
};"
"class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        even = 0                                                    # The index currently contain odd, waiting for accepting a even num
        
        for odd in range(len(nums)):
            if nums[odd] % 2 == 0:                                  # if index-odd encounter a even num, swap it with index-even.
                nums[even], nums[odd] = nums[odd], nums[even]       # Indices at and before index-even are even num now,
                even += 1                                           # so even-index should go 1 step further 
                                                                    # ready to accept next even num
        return nums","class Solution {
 public:
  vector<int> exclusiveTime(int n, vector<string>& logs) {
    vector<int> ans(n);
    stack<int> stack;  // [oldest_id, ..., latest_id]
    int prevTime;

    for (const string& log : logs) {
      // Get seperators' indices.
      const int colon1 = log.find_first_of(':');
      const int colon2 = log.find_last_of(':');
      // Get function_id, label, and timestamp.
      const int id = stoi(log.substr(0, colon1));  // {function_id}
      const char label = log[colon1 + 1];  // {""s"" (""start"") | ""e"" (""end"") }
      const int timestamp = stoi(log.substr(colon2 + 1));  // {timestamp}
      if (label == 's') {
        if (!stack.empty())
          ans[stack.top()] += timestamp - prevTime;
        stack.push(id);
        prevTime = timestamp;
      } else {
        ans[stack.top()] += timestamp - prevTime + 1, stack.pop();
        prevTime = timestamp + 1;
      }
    }

    return ans;
  }
};"
"class Solution:
    def superpalindromesInRange(self, left: str, right: str) -> int:
        '''
        1. For each number in the range [floor(square root of integer value of left), floor(square root of integer value of right)], 
                - need to check if the number is palindrome and (number^2) is palindrome
        2. One possible way to do this quicker is 
                - to generate all the palindromes within the range [floor(square root of integer value of left), floor(square root of integer value of right)]
                - and check whether the square of this palindrome is also a palindrome
        3. If [floor(square root of integer value of left)] is of x digits and [floor(square root of integer value of right)] is of y digits, then
                - if x>1: start generating palindrome from the lowest number of x digits that is divisible by 10, else: start generating palindrome from 1
                - generate palindrome upto the highest number of y digits that is 999...9 (y 9's) 
        4. To generate palindromes of x and y digits, we need to check only the first ceil(x/2) digits and ceil(y/2) digits 
                of [floor(square root of integer value of left)] and [floor(square root of integer value of right)] respectively
        '''
        
        cnt = 0
        lft = str(int(int(left)**0.5))
        rght = str(int(int(right)**0.5))
        
        lft_1 = lft
        rght_1 = rght
        
        if len(lft)%2:
            lft = ""1""+""0""*((len(lft)//2))
        else:
            lft = ""1""+""0""*((len(lft)//2)-1)                                                 #getting the value from where palindromes are started to be generated
            
        if len(rght)%2:
            rght = ""9""*((len(rght)//2)+1)
        else:
            rght = ""9""*(len(rght)//2)                                                       #getting the value upto which palindromes are generated
        
        for num in range(int(lft),int(rght)+1):
            num=str(num)
            len_string=len(num)
            
            if (len_string*2)-1 >= len(lft_1):                                              #length of palindrome must be greater than or equal the given 'left' string parameter
                str_N_1 = num[0:len_string-1]+num[len_string-1]+num[0:len_string-1][::-1]   #generate an odd length palindrome by appending the num string in two opposite orders, and keep the middle character fixed 
                sq_1 = str(int(str_N_1)**2)                                                 #generate the string representation of the square of the palindrome integer
                if int(left) <= int(sq_1) <= int(right) and sq_1==sq_1[::-1]:               #square is palindrome and within the given left and right parameters
                    cnt+=1                                                                  #increment the result by 1
            
            if len_string*2 <= len(rght_1):                                                 #length of palindrome must be less than or equal the given 'right' string parameter 
                str_N_2 = num+num[::-1]                                                     #generate an even length palindrome by appending the num string in two opposite orders
                sq_2 = str(int(str_N_2)**2)
                if int(left) <= int(sq_2) <= int(right) and sq_2==sq_2[::-1]:
                    cnt+=1
                
        return cnt","class Solution {
 public:
  vector<double> averageOfLevels(TreeNode* root) {
    vector<double> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      long sum = 0;
      const int size = q.size();
      for (int i = 0; i < size; ++i) {
        TreeNode* node = q.front();
        q.pop();
        sum += node->val;
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(sum / (double)size);
    }

    return ans;
  }
};"
"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:

        # get the index of the first previous value that is less than the current one. 
        # if there is no value less than the current one in the previous array
        # set the index as -1 which means all previous values are larger than 
        # the current one so we can include all the previous array in the subarray
        # with current index as the minimun.
        prev_less_index = [-1] * len(arr)
        stack = []
        for i, val in enumerate(arr):
            while stack and arr[stack[-1]] > val:
                stack.pop()
            prev_less_index[i] = stack[-1] if stack else - 1
            stack.append(i)

        # with similar logtic, get the first index of following values that is less than
        # the current one.
        next_less_index = [len(arr)] * len(arr)
        stack = []
        for i, val in enumerate(arr):
            while stack and arr[stack[-1]] > val:
                next_less_index[stack.pop()] = i
            stack.append(i)
        res = 0
        for i, val in enumerate(arr):
            res = (res + val * (i - prev_less_index[i]) * (next_less_index[i] - i)) % 1_000_000_007

        return res","class Solution {
 public:
  int shoppingOffers(vector<int>& price, vector<vector<int>>& special,
                     vector<int>& needs) {
    return dfs(price, special, needs, 0);
  }

 private:
  int dfs(const vector<int>& price, const vector<vector<int>>& special,
          vector<int>& needs, int s) {
    int ans = 0;
    for (int i = 0; i < price.size(); ++i)
      ans += price[i] * needs[i];

    for (int i = s; i < special.size(); ++i)
      if (isValid(special[i], needs)) {
        // Use special[i]
        for (int j = 0; j < needs.size(); ++j)
          needs[j] -= special[i][j];
        ans = min(ans, special[i].back() + dfs(price, special, needs, i));
        // Backtracking - unuse special[i]
        for (int j = 0; j < needs.size(); ++j)
          needs[j] += special[i][j];
      }

    return ans;
  }

  // Check if this special offer is a valid one
  bool isValid(const vector<int>& offer, const vector<int>& needs) {
    for (int i = 0; i < needs.size(); ++i)
      if (needs[i] < offer[i])
        return false;
    return true;
  }
};"
"class Solution:
    def smallestRangeI(self, A: List[int], K: int) -> int:
        return max(0,max(A)-min(A)-2*K)","class Solution {
 public:
  int numDecodings(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    // dp[i] := # of ways to decode s[i:n]
    vector<long> dp(n + 1);
    dp.back() = 1;
    dp[n - 1] = count(s[n - 1]);

    for (int i = n - 2; i >= 0; --i) {
      dp[i] += count(s[i], s[i + 1]) * dp[i + 2];
      dp[i] += count(s[i]) * dp[i + 1];
      dp[i] %= kMod;
    }

    return dp[0];
  }

 private:
  int count(char c) {
    if (c == '*')
      return 9;
    return c != '0';
  }

  int count(char c1, char c2) {
    if (c1 == '*' && c2 == '*')  // C1c2: [11-19, 21-26]
      return 15;
    if (c1 == '*') {
      if ('0' <= c2 && c2 <= '6')  // C1: [1-2]
        return 2;
      else  // C1: [1]
        return 1;
    }
    if (c2 == '*') {
      if (c1 == '1')  // C2: [1-9]
        return 9;
      if (c1 == '2')  // C2: [1-6]
        return 6;
      return 0;
    }
    return c1 == '1' || (c1 == '2' && c2 <= '6');
  }
};"
"class Solution:
    def snakesAndLadders(self, board: List[List[int]]) -> int:
        n = len(board)
        ans = 0
        queue = [1]
        seen = {1}
        while queue: 
            newq = []
            for x in queue: 
                if x == n*n: return ans 
                for xx in range(x+1, x+7): 
                    if xx <= n*n:
                        i, j = divmod(xx-1, n)
                        if board[~i][~j if i&amp;1 else j] != -1: xx = board[~i][~j if i&amp;1 else j]
                        if xx not in seen: 
                            newq.append(xx)
                            seen.add(xx)
            ans += 1
            queue = newq 
        return -1","class Solution {
 public:
  string solveEquation(string equation) {
    const string lhsEquation = equation.substr(0, equation.find('='));
    const string rhsEquation = equation.substr(equation.find('=') + 1);
    const auto& [lhsCoefficient, lhsConstant] = calculate(lhsEquation);
    const auto& [rhsCoefficient, rhsConstant] = calculate(rhsEquation);
    const int coefficient = lhsCoefficient - rhsCoefficient;
    const int constant = rhsConstant - lhsConstant;

    if (coefficient == 0 && constant == 0)
      return ""Infinite solutions"";
    if (coefficient == 0 && constant != 0)
      return ""No solution"";
    return ""x="" + to_string(constant / coefficient);
  }

 private:
  pair<int, int> calculate(const string& s) {
    int coefficient = 0;
    int constant = 0;
    int num = 0;
    int sign = 1;

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (isdigit(c))
        num = num * 10 + (c - '0');
      else if (c == '+' || c == '-') {
        constant += sign * num;
        sign = c == '+' ? 1 : -1;
        num = 0;
      } else {
        if (i > 0 && num == 0 && s[i - 1] == '0')
          continue;
        coefficient += num == 0 ? sign : sign * num;
        num = 0;
      }
    }

    return {coefficient, constant + sign * num};
  }
};"
"class Solution:
    def smallestRangeII(self, nums: List[int], k: int) -> int:
        
        # Remove duplicates and sort
        arr = sorted(list(set(nums)))
        
        res = arr[-1] - arr[0]
        for i in range(len(arr) - 1):
            res = min(res, max(arr[i] + k, arr[-1] - k) - min(arr[0] + k, arr[i + 1] - k))
        
        return res","class MyCircularDeque {
 public:
  /** Initialize your data structure here. Set the size of the deque to be k. */
  MyCircularDeque(int k) : k(k), q(k), rear(k - 1) {}

  /** Adds an item at the front of Deque. Return true if the operation is
   * successful. */
  bool insertFront(int value) {
    if (isFull())
      return false;

    front = (--front + k) % k;
    q[front] = value;
    ++size;
    return true;
  }

  /** Adds an item at the rear of Deque. Return true if the operation is
   * successful. */
  bool insertLast(int value) {
    if (isFull())
      return false;

    rear = ++rear % k;
    q[rear] = value;
    ++size;
    return true;
  }

  /** Deletes an item from the front of Deque. Return true if the operation is
   * successful. */
  bool deleteFront() {
    if (isEmpty())
      return false;

    front = ++front % k;
    --size;
    return true;
  }

  /** Deletes an item from the rear of Deque. Return true if the operation is
   * successful. */
  bool deleteLast() {
    if (isEmpty())
      return false;

    rear = (--rear + k) % k;
    --size;
    return true;
  }

  /** Get the front item from the deque. */
  int getFront() {
    return isEmpty() ? -1 : q[front];
  }

  /** Get the last item from the deque. */
  int getRear() {
    return isEmpty() ? -1 : q[rear];
  }

  /** Checks whether the circular deque is empty or not. */
  bool isEmpty() {
    return size == 0;
  }

  /** Checks whether the circular deque is full or not. */
  bool isFull() {
    return size == k;
  }

 private:
  const int k;
  vector<int> q;
  int size = 0;
  int front = 0;
  int rear;
};"
"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:

	
        return sorted(nums)   #1
		```
		```
		#2
import heapq
class Solution:
def sortArray(self, nums: List[int]) -> List[int]:
        heapq.heapify(nums)
        l=[]
        while(nums):
            l.append(heapq.heappop(nums))
        return l
 
		```","class Solution {
 public:
  double findMaxAverage(vector<int>& nums, int k) {
    double sum = accumulate(begin(nums), begin(nums) + k, 0);
    double ans = sum;

    for (int i = k; i < nums.size(); ++i) {
      sum += nums[i] - nums[i - k];
      ans = max(ans, sum);
    }

    return ans / k;
  }
};"
"class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        
        @cache
        def fn(i, m, c): 
            """"""Return """"""
            if i == 2*n: return 0 # tie 
            if m == 0: return 1 # mouse wins
            if m == c: return 2 # cat wins 
            if i&amp;1: # cat's turn 
                tie = 0 
                for cc in graph[c]: 
                    if cc != 0: 
                        x = fn(i+1, m, cc)
                        if x == 2: return 2 
                        if x == 0: tie = 1
                if tie: return 0 
                return 1
            else: # mouse's turn 
                tie = 0 
                for mm in graph[m]: 
                    x = fn(i+1, mm, c)
                    if x == 1: return 1 
                    if x == 0: tie = 1
                if tie: return 0
                return 2 
        
        return fn(0, 1, 2)","class Solution {
 public:
  double findMaxAverage(vector<int>& nums, int k) {
    constexpr double kErr = 1e-5;
    double l = *min_element(begin(nums), end(nums));
    double r = *max_element(begin(nums), end(nums));

    while (r - l > kErr) {
      const double m = (l + r) / 2;
      if (check(nums, k, m))
        l = m;
      else
        r = m;
    }

    return l;
  }

 private:
  // Returns true if there's a subarray with length >= k and average sum >= m.
  bool check(const vector<int>& nums, int k, double m) {
    double sum = 0;
    double prevSum = 0;
    double minPrevSum = 0;

    for (int i = 0; i < nums.size(); ++i) {
      // Trick: -m for each num so that we can check if the sum of the
      // Subarray >= 0
      sum += nums[i] - m;
      if (i >= k) {
        prevSum += nums[i - k] - m;
        minPrevSum = min(minPrevSum, prevSum);
      }
      // If sum - minPrevSum >= 0,
      // We know there's a subarray with length >= k and average sum >= m
      if (i + 1 >= k && sum >= minPrevSum)
        return true;
    }

    return false;
  };
};"
"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        C=Counter(deck).values()
        for i in range(2,len(deck)+1):
            if all([c%i==0 for c in C]): return True
        return False","class Solution {
 public:
  vector<int> findErrorNums(vector<int>& nums) {
    int duplicate;

    for (const int num : nums)
      if (nums[abs(num) - 1] < 0)
        duplicate = abs(num);
      else
        nums[abs(num) - 1] *= -1;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] > 0)
        return {duplicate, i + 1};

    throw;
  }
};"
"class Solution:
    def partitionDisjoint(self, A: List[int]) -> int:
        n = len(A)
        large, small = [0] * n, [0] * n
        l, s = -sys.maxsize, sys.maxsize
        for i in range(n):
            large[i], small[n-1-i] = (l:=max(l, A[i])), (s:=min(s, A[n-1-i]))
        for i in range(n):   
            if large[i] <= small[i+1]: return i+1
        return -1","class Solution {
 public:
  int findLongestChain(vector<vector<int>>& pairs) {
    int ans = 0;
    int prevEnd = INT_MIN;

    sort(begin(pairs), end(pairs),
         [](const auto& a, const auto& b) { return a[1] < b[1]; });

    for (const vector<int>& pair : pairs)
      if (pair[0] > prevEnd) {
        ++ans;
        prevEnd = pair[1];
      }

    return ans;
  }
};"
"class Solution:
    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:
   
        ans=[]
        maind={}
        
        for i in B:
            d={}
            for j in i:
                if j in d:
                    d[j]+=1
                else:
                    d[j]=1
            for j in i:
                if j not in maind:
                    maind[j]=d[j]
                if j not in d:
                    d[j]=0
                maind[j]=max(maind[j],d[j])
        # print(maind)
        
        for i in A:
            d1={}
            f=True
            for j in i:
                if j in d1:
                    d1[j]+=1
                else:
                    d1[j]=1
            # print(d1)
            for j in maind:
                
                if j not in d1:
                    d1[j]=-1
                # print( maind[j],d1[j])
                if maind[j]>d1[j]:
                    f=False
                    break
            if  f:
                ans.append(i)
                
        return ans","class Solution {
 public:
  int countSubstrings(string s) {
    int ans = 0;

    for (int i = 0; i < s.length(); ++i) {
      ans += extendPalindromes(s, i, i);
      ans += extendPalindromes(s, i, i + 1);
    }

    return ans;
  }

 private:
  int extendPalindromes(const string& s, int l, int r) {
    int count = 0;

    while (l >= 0 && r < s.length() && s[l] == s[r]) {
      ++count;
      --l;
      ++r;
    }

    return count;
  }
};"
"class Solution:
    def kadane_max(self, nums):
        for i in range(1, len(nums)):
            if nums[i-1] > 0:
                nums[i] += nums[i-1]
        return max(nums)
    
    def kadane_min(self, nums):
        for i in range(1, len(nums)):
            if nums[i-1] < 0:
                nums[i] += nums[i-1]
        return min(nums)
    
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        x = self.kadane_max(nums[::])
        y = sum(nums) - self.kadane_min(nums[::])
        if y == 0:
            y = max(nums)
        return max(x, y)","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  const string* word = nullptr;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  string replaceWords(vector<string>& dictionary, string sentence) {
    for (const string& word : dictionary)
      insert(word);

    string ans;
    istringstream iss(sentence);

    for (string s; iss >> s;)
      ans += search(s) + ' ';
    ans.pop_back();

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->word = &word;
  }

  string search(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      if (node->word)
        return *node->word;
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        return word;
      node = node->children[i];
    }
    return word;
  }
};"
"class Solution:
    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:
        
        @cache
        def fn(i, x): 
            """"""Return number starting from ith position with x songs already appeared.""""""
            if i == goal: return x == n 
            ans = 0 
            if x < n: ans += (n-x) * fn(i+1, x+1) # a new song
            if k < x: ans += (x-k) * fn(i+1, x) # an old song
            return ans % 1_000_000_007
        
        return fn(0, 0)","class Solution {
 public:
  string predictPartyVictory(string senate) {
    const int n = senate.length();
    queue<int> qR;
    queue<int> qD;

    for (int i = 0; i < n; ++i)
      if (senate[i] == 'R')
        qR.push(i);
      else
        qD.push(i);

    while (!qR.empty() && !qD.empty()) {
      const int indexR = qR.front();
      qR.pop();
      const int indexD = qD.front();
      qD.pop();
      if (indexR < indexD)
        qR.push(indexR + n);
      else
        qD.push(indexD + n);
    }

    return qR.empty() ? ""Dire"" : ""Radiant"";
  }
};"
"class Solution:
    def minAddToMakeValid(self, S: str) -> int:
        op = cl = 0 # open and closed parenthesis needed 
        for c in S: 
            cl += 1 if c == ""("" else -1 # need ) to balance extra (
            if cl < 0: 
                cl = 0
                op += 1 # need ( to balance extra )
        return op + cl","class Solution {
 public:
  int minSteps(int n) {
    if (n <= 1)
      return 0;

    // dp[i] := min steps to get i 'A'
    vector<int> dp(n + 1);

    // Copy 'A', then paste 'A' i - 1 times
    iota(begin(dp), end(dp), 0);

    for (int i = 2; i <= n; ++i)
      for (int j = i / 2; j > 2; --j)
        if (i % j == 0) {
          dp[i] = dp[j] + i / j;  // Paste dp[j] i / j times
          break;
        }

    return dp[n];
  }
};"
"class Solution:
    def sortArrayByParityII(self, A: List[int]) -> List[int]:
        ev, od = 0, 1
        sol = [0] * len(A)
        for el in A:
            if el % 2 == 0: 
                sol[ev] = el
                ev += 2
            else:
                sol[od] = el
                od += 2
        return sol","class Solution {
 public:
  int maxA(int n) {
    int ans = n;

    for (int i = 1; i <= n - 3; ++i)
      ans = max(ans, maxA(i) * (n - i - 1));

    return ans;
  }
};"
"class Solution:
    def threeSumMulti(self, arr: List[int], target: int) -> int:
        freq = {}
        for x in arr: 
            freq[x] = 1 + freq.get(x, 0)
        
        ans = 0
        vals = list(freq)
        
        for i in range(len(vals)):
            for ii in range(i+1): 
                x = target - vals[i] - vals[ii]
                if x in freq: 
                    if vals[i] == vals[ii] == x: 
                        ans += comb(freq[x], 3)
                    elif vals[i] == vals[ii] != x: 
                        ans += comb(freq[vals[i]], 2) * freq[x]
                    elif vals[i] < x and vals[ii] < x: 
                        ans += freq[vals[i]] * freq[vals[ii]] * freq[x]
        return ans % 1_000_000_007","class Solution {
 public:
  vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
    vector<TreeNode*> ans;
    unordered_map<string, int> count;
    encode(root, count, ans);
    return ans;
  }

 private:
  string encode(TreeNode* root, unordered_map<string, int>& count,
                vector<TreeNode*>& ans) {
    if (root == nullptr)
      return """";

    const string encoded = to_string(root->val) + ""#"" +
                           encode(root->left, count, ans) + ""#"" +
                           encode(root->right, count, ans);
    if (++count[encoded] == 2)
      ans.push_back(root);
    return encoded;
  }
};"
"class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial = set(initial)
        
        def dfs(i):
            nodes.add(i)
            for j, conn in enumerate(graph[i]):
                if conn and j not in nodes:
                    dfs(j)
        
        maxRemoval, minNode = -1, float('inf')
        for node in initial:
            nodes = set()
            dfs(node)
            
            if nodes &amp; initial == {node}:
                l = len(nodes)
                if l > maxRemoval or (l == maxRemoval and node < minNode):
                    minNode = node
                    maxRemoval = l
                    
        return minNode if maxRemoval > -1 else min(initial)","class BSTIterator {
 public:
  BSTIterator(TreeNode* root, bool leftToRight) : leftToRight(leftToRight) {
    pushUntilNull(root);
  }

  int next() {
    TreeNode* root = stack.top();
    stack.pop();
    pushUntilNull(leftToRight ? root->right : root->left);
    return root->val;
  }

 private:
  stack<TreeNode*> stack;
  bool leftToRight;

  void pushUntilNull(TreeNode* root) {
    while (root != nullptr) {
      stack.push(root);
      root = leftToRight ? root->left : root->right;
    }
  }
};

class Solution {
 public:
  bool findTarget(TreeNode* root, int k) {
    if (root == nullptr)
      return false;

    BSTIterator left(root, true);
    BSTIterator right(root, false);

    for (int l = left.next(), r = right.next(); l < r;) {
      const int sum = l + r;
      if (sum == k)
        return true;
      if (sum < k)
        l = left.next();
      else
        r = right.next();
    }

    return false;
  }
};"
"class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
    	name, typed, c, N = name+'0', typed+'0', 1, []
    	for s in [name,typed]:
    		for i in range(len(s)-1):
    			if s[i] == s[i+1]:
    				c += 1
    			else:
    				N.append([s[i],c])
    				c = 1
    	return all([N[i][0] == N[i+len(N)//2][0] and N[i][1] <= N[i+len(N)//2][1] for i in range(len(N)//2)])

		
		
- Python 3
- Junaid Mansuri","class Solution {
 public:
  TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
    return build(nums, 0, nums.size() - 1);
  }

 private:
  TreeNode* build(const vector<int>& nums, int i, int j) {
    if (i > j)
      return nullptr;

    const auto it = max_element(begin(nums) + i, begin(nums) + j + 1);
    const int maxNum = *it;
    const int maxIndex = it - begin(nums);

    TreeNode* root = new TreeNode(maxNum);
    root->left = build(nums, i, maxIndex - 1);
    root->right = build(nums, maxIndex + 1, j);
    return root;
  }
};"
"class Solution:
    def minFlipsMonoIncr(self, S: str) -> int:
    	return min(2*j-i for i,j in enumerate([0]+list(itertools.accumulate([int(i) for i in S]))))+len(S)-S.count('1')
		
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  vector<vector<string>> printTree(TreeNode* root) {
    const int m = maxHeight(root);
    const int n = pow(2, m) - 1;
    vector<vector<string>> ans(m, vector<string>(n));
    dfs(root, 0, 0, ans[0].size() - 1, ans);
    return ans;
  }

 private:
  int maxHeight(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + max(maxHeight(root->left), maxHeight(root->right));
  }

  void dfs(TreeNode* root, int row, int left, int right,
           vector<vector<string>>& ans) {
    if (root == nullptr)
      return;

    const int mid = (left + right) / 2;
    ans[row][mid] = to_string(root->val);
    dfs(root->left, row + 1, left, mid - 1, ans);
    dfs(root->right, row + 1, mid + 1, right, ans);
  }
};"
"class Solution:
    def threeEqualParts(self, arr: List[int]) -> List[int]:
        ones = [i for i, x in enumerate(arr) if x]
        n, r = divmod(len(ones), 3)
        if r: return -1, -1
        if not n: return 0, 2
        a, b, c = ones[0], ones[n], ones[2*n]
        r = len(arr) - c
        if r > max(b-a, c-b) or not arr[a+1:a+r] == arr[b+1:b+r] == arr[c+1:]:
            return -1, -1
        return a + r - 1, b + r","class Solution {
 public:
  vector<int> cheapestJump(vector<int>& coins, int maxJump) {
    if (coins.back() == -1)
      return {};

    const int n = coins.size();
    vector<int> next(n, -1);

    // dp[i] := min cost to jump from i to n - 1
    dp.resize(n, INT_MAX);
    cheapestJump(coins, maxJump, 0, next);

    if (dp[0] == INT_MAX)
      return {};
    return constructPath(next, 0);
  }

 private:
  vector<int> dp;

  int cheapestJump(const vector<int>& coins, int maxJump, int i,
                   vector<int>& next) {
    if (i == coins.size() - 1)
      return dp[i] = coins[i];
    if (dp[i] < INT_MAX)
      return dp[i];
    if (coins[i] == -1)
      return INT_MAX;

    for (int j = i + 1; j <= i + maxJump && j < coins.size(); ++j) {
      const int res = cheapestJump(coins, maxJump, j, next);
      if (res == INT_MAX)
        continue;
      const int cost = coins[i] + res;
      if (cost < dp[i]) {
        dp[i] = cost;
        next[i] = j;
      }
    }

    return dp[i];
  }

  vector<int> constructPath(const vector<int>& next, int i) {
    vector<int> ans;
    while (i != -1) {
      ans.push_back(i + 1);  // 1-indexed
      i = next[i];
    }
    return ans;
  }
};"
"class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial = set(initial)
        
        def dfs(i):
            for j, conn in enumerate(graph[i]):
                if conn and j not in initial and j not in nodes:
                    nodes.add(j)
                    dfs(j)
        
        sourceDict = defaultdict(list)
        for node in initial:
            nodes = set()
            dfs(node)
            
            for i in nodes:
                sourceDict[i].append(node)
        
        counter = defaultdict(int)
        maxVal, minNode = -1, float('inf')
        for infected, sources in sourceDict.items():
            if len(sources) == 1:
                src = sources[0]
                counter[src] += 1
                if counter[src] > maxVal or (counter[src] == maxVal and src < minNode):
                    minNode = src
                    maxVal = counter[src]
                    
        return minNode if maxVal > -1 else min(initial)","class Solution {
 public:
  bool judgeCircle(string moves) {
    int right = 0;
    int up = 0;

    for (const char move : moves) {
      switch (move) {
        case 'R':
          ++right;
          break;
        case 'L':
          --right;
          break;
        case 'U':
          ++up;
          break;
        case 'D':
          --up;
          break;
      }
    }

    return right == 0 && up == 0;
  }
};"
"class Solution(object):
    def numUniqueEmails(self, emails):
        """"""
        :type emails: List[str]
        :rtype: int
        """"""

        results = set()
        for email in emails:
            local, domain = email.split(""@"")
            local = local[:local.index(""+"")].replace(""."", """") if ""+"" in local else local.replace(""."", """")
            results.add(local + ""@"" + domain)

        return len(results)","class Solution {
 public:
  vector<int> findClosestElements(vector<int>& arr, int k, int x) {
    int l = 0;
    int r = arr.size() - k;

    while (l < r) {
      const int m = (l + r) / 2;
      if (x - arr[m] <= arr[m + k] - x)
        r = m;
      else
        l = m + 1;
    }

    return {begin(arr) + l, begin(arr) + l + k};
  }
};"
"class Solution:
    def numSubarraysWithSum(self, A: List[int], S: int) -> int:
        zgaps,gap = [],0
        for v in A:
            if v:
                zgaps+=[gap]
                gap=0
            else:
                gap+=1
        zgaps+=[gap]
        if S==0:
            return sum([(g*(g+1))//2 for g in zgaps])
        return sum([(zgaps[i]+1)*(zgaps[i+S]+1) for i in range(len(zgaps)-S)])","class Solution {
 public:
  bool isPossible(vector<int>& nums) {
    unordered_map<int, int> count;
    vector<int> starts;  // Start index of subsequence
    vector<int> ends;    // End index of subsequence

    for (const int num : nums)
      ++count[num];

    for (int i = 0; i < nums.size(); ++i) {
      if (i > 0 && nums[i] == nums[i - 1])
        continue;
      const int num = nums[i];
      const int currCount = count[num];
      const int prevCount = count.count(num - 1) ? count[num - 1] : 0;
      const int nextCount = count.count(num + 1) ? count[num + 1] : 0;
      for (int j = 0; j < currCount - prevCount; ++j)
        starts.push_back(num);
      for (int j = 0; j < currCount - nextCount; ++j)
        ends.push_back(num);
    }

    for (int i = 0; i < starts.size(); ++i)
      if (ends[i] - starts[i] < 2)
        return false;

    return true;
  }
};"
"class Solution:
    def minFallingPathSum(self, A: List[List[int]]) -> int:
    	L, A, m = len(A), [[math.inf] + i + [math.inf] for i in A], math.inf
    	for i,j in itertools.product(range(1,L),range(1,L+1)): A[i][j] += min(A[i-1][j-1],A[i-1][j],A[i-1][j+1])
    	return min(A[-1])
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int newInteger(int n) {
    string ans;
    while (n) {
      ans = to_string(n % 9) + ans;
      n /= 9;
    }
    return stoi(ans);
  }
};"
"class Solution:
    def beautifulArray(self, n: int) -> List[int]:
        return (
            [1, 2][:n]
            if n < 3
            else [x * 2 - 1 for x in self.beautifulArray((n + 1) // 2)]
            + [x * 2 for x in self.beautifulArray(n // 2)]
        )","class Solution {
 public:
  vector<vector<int>> imageSmoother(vector<vector<int>>& M) {
    const int m = M.size();
    const int n = M[0].size();
    vector<vector<int>> ans(m, vector<int>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        int ones = 0;
        int count = 0;
        for (int x = max(0, i - 1); x < min(m, i + 2); ++x)
          for (int y = max(0, j - 1); y < min(n, j + 2); ++y) {
            ones += M[x][y];
            ++count;
          }
        ans[i][j] = ones / count;
      }

    return ans;
  }
};"
"class Solution:
	def shortestBridge(self, grid: List[List[int]]) -> int:       
		rows, cols = len(grid), len(grid[0])

  # Mark the first island with '#'s
    def dfs(row, col):
        if row not in range(rows) or col not in range(cols) or grid[row][col] != 1:
            return False
        
        grid[row][col] = '#'
        dfs(row+1, col)
        dfs(row-1, col)
        dfs(row, col+1)
        dfs(row, col-1)
             

# If the inner loop does not break, the outer loop will not either. 
# The for-else clause only happens if the inner loop does not break. Then continue avoids the outer break too. 
    for row in range(rows):
        for col in range(cols):
            if grid[row][col] == 1:
                dfs(row,col)
                break
        else:
            continue # only executed if the inner loop did NOT break
        break  # only executed if the inner loop DID break
    
	
	# Now let's expand from the first island we just marked and return the second we see the second island
    shortest_bridge_distance = 0
    q = deque([(r,c,shortest_bridge_distance) for r in range(rows) for c in range(cols) if grid[r][c] == '#'])     

    visited = set()
    while q:
        row, col, shortest_bridge_distance  = q.popleft()
        directions = ((row+1,col),(row-1,col),(row,col+1),(row,col-1))
		
        for new_row, new_col in directions:
            if new_row in range(rows) and new_col in range(cols) and (new_row,new_col) not in visited:
                if grid[new_row][new_col] == 1:
                    return shortest_bridge_distance
					
                q.append((new_row, new_col, shortest_bridge_distance+1))
                visited.add((new_row,new_col))","class Solution {
 public:
  int widthOfBinaryTree(TreeNode* root) {
    if (root == nullptr)
      return 0;

    int ans = 0;
    queue<pair<TreeNode*, int>> q{{{root, 1}}};  // {node, index}

    while (!q.empty()) {
      const int offset = q.front().second * 2;
      ans = max(ans, q.back().second - q.front().second + 1);
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [node, index] = q.front();
        q.pop();
        if (node->left)
          q.emplace(node->left, index * 2 - offset);
        if (node->right)
          q.emplace(node->right, index * 2 + 1 - offset);
      }
    }

    return ans;
  }
};"
"class Solution:
    NEIGHBORS_MAP = {
            1: (6, 8),
            2: (7, 9),
            3: (4, 8),
            4: (3, 9, 0),
            5: tuple(),
            6: (1, 7, 0),
            7: (2, 6),
            8: (1, 3),
            9: (2, 4),
            0: (4, 6),
        }
        
    def getNeighbors(self, position):
        return self.NEIGHBORS_MAP[position]

    def knightDialer(self, N: int, memo={}) -> int:
        return sum(self.helper(neigh, N-1, memo) for neigh in self.NEIGHBORS_MAP.keys()) % (10**9 + 7)
    
    def helper(self, current, hops, memo):
        if (current, hops) in memo:
            return memo[(current, hops)]
        if hops == 0:
            return 1
        res = sum(self.helper(neigh, hops - 1, memo) for neigh in self.getNeighbors(current))
        memo[(current, hops)] = res
        return res","class Solution {
 public:
  bool checkEqualTree(TreeNode* root) {
    if (root == nullptr)
      return false;

    unordered_set<int> seen;
    const int sum = root->val + dfs(root->left, seen) + dfs(root->right, seen);
    return sum % 2 == 0 && seen.count(sum / 2);
  }

 private:
  int dfs(TreeNode* root, unordered_set<int>& seen) {
    if (root == nullptr)
      return 0;

    const int sum = root->val + dfs(root->left, seen) + dfs(root->right, seen);
    seen.insert(sum);
    return sum;
  }
};"
"class Solution:
    # O(n(n-m) * m) time,
    # O(n-m) space,
    # Approach: sliding window, 
    def movesToStamp(self, stamp: str, target: str) -> List[int]:
        n = len(target)
        m = len(stamp)
        target = list(target)
        ans = []
        vstd_indexes = set()
        
        
        def isStamped(subarray):
            for index,ch in enumerate(subarray):
                if not (ch == '?' or ch == stamp[index]):
                    return False
                
            return True
        
        
        def replaceToPlaceholder(start):
            non_questionmark = 0
            for i in range(m):
                if target[start+i] != '?':
                    non_questionmark += 1
                    target[start+i] = '?'
                
            return non_questionmark
        
        
        reversed = 0     # number of reversed characters back to '?' 
        l, r = 0, m
        stampExists = False     # if stamp exists in one traversal of target
        
        while reversed != n:
            while r <= n:
                if l not in vstd_indexes and isStamped(target[l:r]):
                    stampExists = True
                    ans.append(l)
                    vstd_indexes.add(l)
                    break
                l +=1
                r +=1
            if stampExists:
                reversed +=replaceToPlaceholder(ans[-1])
                stampExists = False
                l, r = 0, m
            else:
                return []
            
        ans.reverse()
        return ans","class Solution {
 public:
  int strangePrinter(string s) {
    const int n = s.length();
    // dp[i][j] := min # of turns to print s[i..j]
    dp.resize(n, vector<int>(n));
    return strangePrinter(s, 0, n - 1);
  }

 private:
  vector<vector<int>> dp;

  int strangePrinter(const string& s, int i, int j) {
    if (i > j)
      return 0;
    if (dp[i][j] > 0)
      return dp[i][j];

    // Print s[i]
    dp[i][j] = strangePrinter(s, i + 1, j) + 1;

    for (int k = i + 1; k <= j; ++k)
      if (s[k] == s[i])
        dp[i][j] = min(dp[i][j], strangePrinter(s, i, k - 1) +
                                     strangePrinter(s, k + 1, j));

    return dp[i][j];
  }
};"
"class Solution:
    def reorderLogFiles(self, logs: List[str]) -> List[str]:
        res=[]
        digi=[]
        letter=[]
        for i in logs:
            k=i.split()
            if k[1].isdigit():
                digi.append(i)
            else:
                letter.append(i)
        d={}
        for i in letter:
            k=i.split()
            m=d.get(tuple(k[1:]),[])
            m.append(k[0])
            d[tuple(k[1:])]=m
        for i in sorted(list(d.keys())):
            x=[x for x in i]
            s=''
            for j in x:
                s+=j+' '
            s=s.strip()
            for j in sorted(d[i]):
                res.append(j+' '+s)
        return(res+digi)","class Solution {
 public:
  bool checkPossibility(vector<int>& nums) {
    bool modified = false;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] < nums[i - 1]) {
        if (modified)
          return false;
        if (i == 1 || nums[i] >= nums[i - 2])
          nums[i - 1] = nums[i];  // Decrease previous value
        else
          nums[i] = nums[i - 1];  // Increase current value
        modified = true;
      }

    return true;
  }
};"
"class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        cursum = 0
        if root.val != None:
            cursum = root.val if low <= root.val <= high else 0
        if root.left and root.val >= low:
            cursum += self.rangeSumBST(root.left, low, high)
        if root.right and root.val <= high:
            cursum += self.rangeSumBST(root.right, low, high)

        return cursum","class Solution {
 public:
  int pathSum(vector<int>& nums) {
    int ans = 0;
    vector<vector<int>> tree(4, vector<int>(8, -1));

    for (const int num : nums) {
      const int d = num / 100 - 1;
      const int p = (num % 100) / 10 - 1;
      const int v = num % 10;
      tree[d][p] = v;
    }

    dfs(tree, 0, 0, 0, ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& tree, int i, int j, int path, int& ans) {
    if (tree[i][j] == -1)
      return;
    if (i == 3 || max(tree[i + 1][j * 2], tree[i + 1][j * 2 + 1]) == -1) {
      ans += path + tree[i][j];
      return;
    }

    dfs(tree, i + 1, j * 2, path + tree[i][j], ans);
    dfs(tree, i + 1, j * 2 + 1, path + tree[i][j], ans);
  }
};"
"class Solution:
    def minAreaRect(self, points: List[List[int]]) -> int:
        ans = inf
        seen = {(x, y) for x, y in points}
        for x, y in points: 
            for xx, yy in points: 
                if x != xx and y != yy and (x, yy) in seen and (xx, y) in seen: 
                    ans = min(ans, abs((xx-x)*(yy-y)))
        return ans if ans < inf else 0","class Solution {
 public:
  vector<int> constructArray(int n, int k) {
    vector<int> ans;

    for (int i = 0; i < n - k; ++i)
      ans.push_back(i + 1);

    for (int i = 0; i < k; ++i)
      if (i % 2 == 0)
        ans.push_back(n - i / 2);
      else
        ans.push_back(n - k + (i + 1) / 2);

    return ans;
  }
};"
"class Solution:
    def distinctSubseqII(self, s: str) -> int:
        freq = [0]*26 
        for i in reversed(range(len(s))): freq[ord(s[i])-97] = (1 + sum(freq)) % 1_000_000_007
        return sum(freq) % 1_000_000_007","class Solution {
 public:
  int findKthNumber(int m, int n, int k) {
    int l = 1;
    int r = m * n;

    auto numsNoGreaterThan = [&](int target) {
      int count = 0;
      // For each row i, count # of numbers <= target
      for (int i = 1; i <= m; ++i)
        count += min(target / i, n);
      return count;
    };

    while (l < r) {
      const int mid = (l + r) / 2;
      if (numsNoGreaterThan(mid) >= k)
        r = mid;
      else
        l = mid + 1;
    }

    return l;
  }
};"
"class Solution:
    def validMountainArray(self, arr: List[int]) -> bool:
        increased = decreased = False
        
        for i in range(1, len(arr)):
            if arr[i] > arr[i-1]:
                if decreased:
                    return False
                increased = True
            elif arr[i] < arr[i-1]:
                if not increased:
                    return False
                decreased = True
            else:
                return False
            
        return decreased","class Solution {
 public:
  TreeNode* trimBST(TreeNode* root, int L, int R) {
    if (root == nullptr)
      return nullptr;
    if (root->val < L)
      return trimBST(root->right, L, R);
    if (root->val > R)
      return trimBST(root->left, L, R);
    root->left = trimBST(root->left, L, R);
    root->right = trimBST(root->right, L, R);
    return root;
  }
};"
"class Solution:
    def diStringMatch(self, s: str) -> List[int]:
        
        a=0
        b=len(s)
        
        ans=[]
        for j in s:
            
            if j=='I':
                ans.append(a)
                a+=1
            else:
                ans.append(b)
                b-=1
                
        ans.append(a)
        return ans","class Solution {
 public:
  int maximumSwap(int num) {
    string s = to_string(num);
    vector<int> lastIndex(10, -1);  // {digit: last index}

    for (int i = 0; i < s.length(); ++i)
      lastIndex[s[i] - '0'] = i;

    for (int i = 0; i < s.length(); ++i)
      for (int d = 9; d > s[i] - '0'; --d)
        if (lastIndex[d] > i) {
          swap(s[i], s[lastIndex[d]]);
          return stoi(s);
        }

    return num;
  }
};"
"class Solution:
    def shortestSuperstring(self, words: List[str]) -> str:
        n = len(words)
        graph = [[0]*n for _ in range(n)] # graph as adjacency matrix 
        
        for i in range(n):
            for j in range(n): 
                if i != j: 
                    for k in range(len(words[j])): 
                        if words[i].endswith(words[j][:k]): 
                            graph[i][j] = len(words[j]) - k 
                            
        @cache
        def fn(prev, mask): 
            """"""Return length of shortest superstring &amp; current choice of word.""""""
            if mask == 0: return 0, None
            vv, kk = inf, None
            for k in range(n): 
                if mask &amp; 1<<k: 
                    v, _ = fn(k, mask ^ 1<<k)
                    offset = len(words[k]) if prev == -1 else graph[prev][k]
                    if v + offset < vv: vv, kk = v + offset, k
            return vv, kk
        
        ans = []
        prev = -1 
        mask = (1<<n) - 1
        while mask: 
            _, k = fn(prev, mask)
            if ans: ans.append(words[k][-graph[prev][k]:])
            else: ans.append(words[k])
            prev = k
            mask ^= 1<<k 
        return """".join(ans)","class Solution {
 public:
  int findSecondMinimumValue(TreeNode* root) {
    if (root == nullptr)
      return -1;
    return findSecondMinimumValue(root, root->val);
  }

 private:
  int findSecondMinimumValue(TreeNode* root, int mini) {
    if (root == nullptr)
      return -1;
    if (root->val > mini)
      return root->val;

    const int leftMin = findSecondMinimumValue(root->left, mini);
    const int rightMin = findSecondMinimumValue(root->right, mini);

    if (leftMin == -1 || rightMin == -1)
      return max(leftMin, rightMin);
    return min(leftMin, rightMin);
  }
};"
"class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        
        deletionIndices=[]
        x=[]
        
        length=len(A[0])
        counter=-1
        for i in range(length):
            check=[]
            acheck=[]
            for j in range(len(A)):
                check.append(A[j][i])
                acheck=sorted(check)
                if check!=acheck:
                    deletionIndices.append(i)
                    break
              
        return len(deletionIndices)","class Solution {
 public:
  int flipLights(int n, int m) {
    n = min(n, 3);

    if (m == 0)
      return 1;
    if (m == 1)
      return vector{2, 3, 4}[n - 1];
    if (m == 2)
      return vector{2, 4, 7}[n - 1];

    return pow(2, n);
  }
};"
"class Solution:
    def minIncrementForUnique(self, A: List[int]) -> int:
        m, c, _ = -math.inf, 0, A.sort()
        for a in A: (c, m) = (c + (1 + m - a), m + 1) if a <= m else (c, a)
        return c
		
		
- Junaid Mansuri","class Solution {
 public:
  int findNumberOfLIS(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    int maxLength = 0;
    vector<int> length(n, 1);  // length[i] := LIS's length ending w/ nums[i]
    vector<int> count(n, 1);   // count[i] := # of the LIS ending w/ nums[i]

    // Calculate length and count arrays
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < i; ++j)
        if (nums[j] < nums[i])
          if (length[i] < length[j] + 1) {
            length[i] = length[j] + 1;
            count[i] = count[j];
          } else if (length[i] == length[j] + 1) {
            count[i] += count[j];
          }

    // Get # of LIS
    for (int i = 0; i < n; ++i)
      if (length[i] > maxLength) {
        maxLength = length[i];
        ans = count[i];
      } else if (length[i] == maxLength) {
        ans += count[i];
      }

    return ans;
  }
};"
"class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        i = 0
        stack = []
        for x in pushed: 
            stack.append(x)
            while stack and stack[-1] == popped[i]: 
                stack.pop()
                i += 1
        return not stack","class Solution {
 public:
  int findLengthOfLCIS(vector<int>& nums) {
    int ans = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (r > 0 && nums[r] <= nums[r - 1])
        l = r;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};"
"class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        root = set()
        parent = {}
        rank = {}
        for x, y in stones:
            self.set_param(x, parent, rank)
            self.set_param(~y, parent, rank)
            self.union(x, ~y, parent, rank)
        # get parent for all nodes
        for p in parent:
            root.add(self.find(parent[p], parent))
        # Answer is: no. of stones - no. of components
        # Since we can't remove all stones from a components, there we be number of components number of stones left
        return len(stones) - len(root)
        
    def set_param(self, x, parent, rank):
        if(x not in parent):
            parent[x] = x
            rank[x] = 0

    def find(self, x, parent):
        if(x != parent[x]):
            parent[x] = self.find(parent[x], parent)
        return parent[x]
    
    def union(self, x, y, parent, rank):
        parent_x = self.find(x, parent)
        parent_y = self.find(y, parent)
        
        if(parent_x == parent_y):
            return
        rank_x = rank[parent_x]
        rank_y = rank[parent_y]
        
        if(rank_x > rank_y):
            parent[parent_y] = parent_x
        elif(rank_x < rank_y):
            parent[parent_x] = parent_y
        else:
            parent[parent_y] = parent_x
            rank[parent_x] += 1","struct T {
  int i;
  int j;
  int height;
  T(int i, int j, int height) : i(i), j(j), height(height) {}
};

class Solution {
 public:
  int cutOffTree(vector<vector<int>>& forest) {
    auto compare = [&](const T& a, const T& b) { return a.height > b.height; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < forest.size(); ++i)
      for (int j = 0; j < forest[0].size(); ++j)
        if (forest[i][j] > 1)
          minHeap.emplace(i, j, forest[i][j]);

    int ans = 0;
    int x = 0;
    int y = 0;

    while (!minHeap.empty()) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      // Walk from (x, y) to (i, j).
      const int steps = bfs(forest, x, y, i, j);
      if (steps < 0)
        return -1;
      ans += steps;
      x = i;
      y = j;
    }

    return ans;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};

  int bfs(const vector<vector<int>>& forest, int si, int sj, int ei, int ej) {
    const int m = forest.size();
    const int n = forest[0].size();
    int steps = 0;
    queue<pair<int, int>> q{{{si, sj}}};
    vector<vector<bool>> seen(m, vector<bool>(n));
    seen[si][sj] = true;

    while (!q.empty()) {
      for (int s = q.size(); s > 0; --s) {
        const auto [i, j] = q.front();
        q.pop();
        if (i == ei && j == ej)
          return steps;
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (seen[x][y] || forest[x][y] == 0)
            continue;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
      ++steps;
    }

    return -1;
  };
};"
"class Solution:
    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:
        tokens.sort()
        score = 0
        while len(tokens) > 0:
            if P >= tokens[0]:
                P -= tokens[0]
                score += 1
                tokens.pop(0)
            elif len(tokens) > 2 and score > 0:
                score -= 1
                P += tokens[-1]
                tokens.pop()
            else:
                break
        return score","class Solution {
 public:
  bool checkValidString(const string& s) {
    int low = 0;   // Lower bound of valid '(' count
    int high = 0;  // Upper bound of valid '(' count

    for (const char c : s) {
      switch (c) {
        case '(':
          ++low;
          ++high;
          break;
        case ')':
          low = max(0, --low);
          --high;
          break;
        case '*':
          low = max(0, --low);
          ++high;
          break;
      }
      if (high < 0)
        return false;
    }

    return low == 0;
  }
};"
"class Solution:
    def largestTimeFromDigits(self, A: List[int]) -> str:
        
            return ''.join(result[-1]) if (result := sorted([[*p[:2]]+[':']+[*p[2:]] for p in itertools.permutations([str(n) for n in A]) if int(''.join(p[:2])) < 24 and int(''.join(p[2:])) < 60], key=lambda p: int(''.join(p[:2]))*100 + int(''.join(p[3:])))) else """"","class Solution {
 public:
  bool validPalindrome(string s) {
    for (int l = 0, r = s.length() - 1; l < r; ++l, --r)
      if (s[l] != s[r])
        return validPalindrome(s, l + 1, r) ||  //
               validPalindrome(s, l, r - 1);
    return true;
  }

 private:
  bool validPalindrome(const string& s, int l, int r) {
    while (l < r)
      if (s[l++] != s[r--])
        return false;
    return true;
  }
};"
"class Solution:
    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:
        ans = [0]*len(deck)
        idx = deque(range(len(deck)))
        for x in sorted(deck): 
            ans[idx.popleft()] = x
            if idx: idx.append(idx.popleft())
        return ans","class Solution {
 public:
  string nextClosestTime(string time) {
    const set<char> digitsSet{time[0], time[1], time[3], time[4]};
    string ans = time;

    ans[4] = nextClosest(digitsSet, ans[4], '9');
    if (time[4] < ans[4])
      return ans;

    ans[3] = nextClosest(digitsSet, ans[3], '5');
    if (time[3] < ans[3])
      return ans;

    ans[1] = nextClosest(digitsSet, ans[1], ans[0] == '2' ? '3' : '9');
    if (time[1] < ans[1])
      return ans;

    ans[0] = nextClosest(digitsSet, ans[0], '2');
    return ans;
  }

 private:
  char nextClosest(const set<char>& digitsSet, char digit, char limit) {
    auto it = digitsSet.upper_bound(digit);
    return it == end(digitsSet) || *it > limit ? *begin(digitsSet) : *it;
  }
};"
"class Solution:
    def flipEquiv(self, root1: TreeNode, root2: TreeNode) -> bool:
        
        def fn(n1, n2):
            """"""Return True if n1 is a flip of n2.""""""
            if not n1 or not n2: return n1 is n2
            return n1.val == n2.val and (fn(n1.left, n2.right) and fn(n1.right, n2.left) or fn(n1.left, n2.left) and fn(n1.right, n2.right))
        
        return fn(root1, root2)","class Solution {
 public:
  int kEmptySlots(vector<int>& bulbs, int k) {
    const int n = bulbs.size();
    int ans = INT_MAX;
    // day[i] := the day when bulbs[i] is turned on
    vector<int> day(n);

    for (int i = 0; i < n; ++i)
      day[bulbs[i] - 1] = i + 1;

    // Find a subarray of day[l..r], where its length is k + 2
    // For all that l < i < r, day[i] > max(day[l], day[r])
    int l = 0;
    int r = l + k + 1;
    for (int i = 1; r < n; ++i)
      if (i == r) {
        ans = min(ans, max(day[l], day[r]));
        l = i;
        r = i + k + 1;
      } else if (day[i] < max(day[l], day[r])) {
        l = i;
        r = i + k + 1;
      }

    return ans == INT_MAX ? -1 : ans;
  }
};"
"class Solution:
    def largestComponentSize(self, nums: List[int]) -> int:
        
        def find(node):
            if parent[node] == -1: return node
            else:
                parent[node] = find(parent[node])
                return parent[node]
        
        def union(idx1,idx2):
            par1,par2 = find(idx1),find(idx2)
            if par1!=par2:
                if rank[par1] > rank[par2]:
                    parent[par2] = par1
                elif rank[par2] > rank[par1]:
                    parent[par1] = par2
                else:
                    parent[par2] = par1
                    rank[par1] += 1
        
        n = len(nums)
        parent = defaultdict(lambda:-1)
        rank = defaultdict(lambda:0)
        for i in range(n):
            limit = int(nums[i]**0.5)
            for j in range(2,limit+1):
                if nums[i] % j == 0:
                    union(nums[i],j)
                    union(nums[i],nums[i]//j)
        count = defaultdict(lambda:0)
        best = -1
        for num in nums:
            par = find(num)
            tmp = count[par] + 1
            if tmp > best: best = tmp
            count[par] = tmp
        return best","class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  bool unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return false;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
    return true;
  }

 private:
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  vector<int> findRedundantConnection(vector<vector<int>>& edges) {
    UnionFind uf(edges.size() + 1);

    for (const vector<int>& edge : edges)
      if (!uf.unionByRank(edge[0], edge[1]))
        return edge;

    throw;
  }
};"
"class Solution:
    
    def compare(self, cache, word1, word2):
        i, j = 0,0
        while i < len(word1) and j < len(word2):
            if cache[word1[i]] < cache[word2[j]]:
                return True
            elif cache[word1[i]] > cache[word2[j]]:
                return False
            else: #letters equal case
                i += 1
                j += 1

        if i < len(word1):
            return False
        """"""
            why false?
            In some cases word1 can be aaa, word2 can be aa
            here we must return false becoz they are not in lexicographic order
            becoz word2 appears first than word1
        """"""
        
        return True #same words case and shorter words case like aa, aaa i will definitely reach end 
    
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        """"""
            Main Idea behind this is,
            How we see our Oxford or Some english Dictionary (So called lexicographic order)
            
            Eg:
            Case 1:
                Assume we have words like ad, af, ag, ba, bba, bbaaaag in our oxford Dictionary
                at diff page numbers Now compare the page numbers of these words once it is for sure
                pageNumber(ad) < pageNumber(af) < pageNumber(ag) < ... pageNumber(bbaaag)
            Case 2:
                if we go in depth
                if two 2 words are in same page, say x, xy
                it is for sure LineNumber(x) < lineNumber(xy) (Note < operator is Strictly lesser)
            Case 3:
                Words like a, aa, aaa, aaaa are in our dictionary
                definitly appearance(a) < appearance(aa) < appearance(aaa) < appearance(aaaa)
                appearance may be a line number or page number
        """"""
        
        """"""
            In our Question there are asking for a different alphabetical order and asking us to check 
            whether appearance(word1) < appearance(word2) < appearance(word3) < ... < appearance(wordn) or not
            Just compare 
                word1 with word2 
                word2 with word3
                word3 with word4
                ....
                wordn-1 with wordn
            Reason: if word1 < word2 it is for sure lesser than word3 and so on
        """"""
        cache = {}
        for i in range(len(order)):
            cache[order[i]] = i
        
        for i in range(1, len(words)):
            if not self.compare(cache, words[i-1], words[i]):
                return False
        return True","class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  bool unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return false;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
    return true;
  }

 private:
  vector<int> id;
  vector<int> rank;
  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
    vector<int> ids(edges.size() + 1);
    int nodeWithTwoParents = 0;

    for (const vector<int>& edge : edges) {
      const int v = edge[1];
      if (++ids[v] == 2) {
        nodeWithTwoParents = v;
        break;
      }
    }

    // If there is no edge with two ids
    // We don't have to skip any edge
    if (nodeWithTwoParents == 0)
      return findRedundantDirectedConnection(edges, -1);

    for (int i = edges.size() - 1; i >= 0; --i)
      if (edges[i][1] == nodeWithTwoParents)
        // Try to delete edges[i]
        if (findRedundantDirectedConnection(edges, i).empty())
          return edges[i];

    throw;
  }

  vector<int> findRedundantDirectedConnection(const vector<vector<int>>& edges,
                                              int skippedEdgeIndex) {
    UnionFind uf(edges.size() + 1);

    for (int i = 0; i < edges.size(); ++i) {
      if (i == skippedEdgeIndex)
        continue;
      if (!uf.unionByRank(edges[i][0], edges[i][1]))
        return edges[i];
    }

    return {};
  }
};"
"class Solution:
    def canReorderDoubled(self, A: List[int]) -> bool:
        A = sorted([-i if i < 0 else i for i in A], reverse=True)
        n, c, cnt = len(A), collections.Counter(A), 0
        for i in range(n):
            if c[2*A[i]] > 0:
                c[2*A[i]] -= 1
                c[A[i]] -= 1
                cnt += 1
        return cnt >= n // 2","class Solution {
 public:
  int repeatedStringMatch(string a, string b) {
    const int n = ceil((double)b.length() / a.length());
    string s;

    for (int i = 0; i < n; ++i)
      s += a;

    if (s.find(b) != string::npos)
      return n;
    if ((s + a).find(b) != string::npos)
      return n + 1;
    return -1;
  }
};"
"class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        m, n = len(strs), len(strs[0]) # dimensions 
        ans, grp = 0, [0]*m
        for j in range(n): 
            for i in range(1, m): 
                if grp[i-1] == grp[i] and strs[i-1][j] > strs[i][j]: 
                    ans += 1
                    break
            else: 
                for i in range(1, m): 
                    grp[i] = max(grp[i-1], grp[i])
                    if grp[i-1] == grp[i] and strs[i-1][j] < strs[i][j]: grp[i] = i
        return ans","class Solution {
 public:
  int longestUnivaluePath(TreeNode* root) {
    int ans = 0;
    longestUnivaluePathDownFrom(root, ans);
    return ans;
  }

 private:
  int longestUnivaluePathDownFrom(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = longestUnivaluePathDownFrom(root->left, ans);
    const int r = longestUnivaluePathDownFrom(root->right, ans);
    const int arrowLeft =
        root->left && root->left->val == root->val ? l + 1 : 0;
    const int arrowRight =
        root->right && root->right->val == root->val ? r + 1 : 0;
    ans = max(ans, arrowLeft + arrowRight);
    return max(arrowLeft, arrowRight);
  }
};"
"class Solution:
    def tallestBillboard(self, rods: List[int]) -> int:
        
        def fn(arr): 
            """"""Possible a mapping from diff to length""""""
            mp = defaultdict(int)
            for t in range(1, len(arr)+1): 
                for total in combinations(arr, t): 
                    tt = sum(total)
                    for p in range(0, t+1): 
                        for part in combinations(total, p): 
                            pp = sum(part)
                            mp[pp*2 - tt] = max(mp[pp*2 - tt], pp)
            return mp 
        
        left = rods[:len(rods)//2]
        right = rods[len(rods)//2:]
        
        mp = fn(left)
        keys = sorted(mp.keys())
        
        ans = 0 
        for diff, v in fn(right).items(): 
            k = bisect_left(keys, -diff)
            if k < len(keys) and keys[k] == -diff: 
                ans = max(ans, mp[-diff] + v)
        return ans","class Solution {
 public:
  double knightProbability(int n, int K, int r, int c) {
    constexpr double kProb = 0.125;
    const vector<pair<int, int>> dirs{{-2, 1}, {-1, 2}, {1, 2},   {2, 1},
                                      {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};

    // dp[i][j] := probability to stand on (i, j)
    vector<vector<double>> dp(n, vector<double>(n));
    dp[r][c] = 1.0;

    for (int k = 0; k < K; ++k) {
      vector<vector<double>> newDp(n, vector<double>(n));
      for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
          if (dp[i][j] > 0.0) {
            for (const auto& [dx, dy] : dirs) {
              const int x = i + dx;
              const int y = j + dy;
              if (x < 0 || x >= n || y < 0 || y >= n)
                continue;
              newDp[x][y] += dp[i][j] * kProb;
            }
          }
      dp = move(newDp);
    }

    return accumulate(begin(dp), end(dp), 0.0,
                      [](double s, const vector<double>& row) {
      return s + accumulate(begin(row), end(row), 0.0);
    });
  }
};"
"class Solution:
    def prisonAfterNDays(self, cells: List[int], n: int) -> List[int]:
        counter = 0
        bitmap = 0
		# cells to bitmap
        for b in cells:
            bitmap = (bitmap<<1)|b
		# memory table
        idToCount = {bitmap:counter}
        countToCells = {counter:bitmap}
        for j in range(n):
			# bin(126) = 1111110
            bitmap = ~((bitmap<<1)^(bitmap>>1))&amp;126
            counter += 1
            if bitmap in idToCount:
                dis = idToCount[bitmap]
				# mod
                bitmap = countToCells[(n-dis)%(counter-dis)+dis]
                break
            else:
                idToCount[bitmap] = counter
                countToCells[counter] = bitmap
		# bitmap to cells
        for i in range(8):
            cells[7-i] = (bitmap>>i)&amp;1
        return cells","class Solution {
 public:
  vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
    const int n = nums.size() - k + 1;
    vector<int> sums(n);  // sums[i] := sum of nums[i..i + k)
    vector<int> l(n);     // l[i] := index in [0..i] having max sums[i]
    vector<int> r(n);     // r[i] := index in [i..n) having max sums[i]

    int sum = 0;
    for (int i = 0; i < nums.size(); ++i) {
      sum += nums[i];
      if (i >= k)
        sum -= nums[i - k];
      if (i >= k - 1)
        sums[i - k + 1] = sum;
    }

    int maxIndex = 0;
    for (int i = 0; i < n; ++i) {
      if (sums[i] > sums[maxIndex])
        maxIndex = i;
      l[i] = maxIndex;
    }

    maxIndex = n - 1;
    for (int i = n - 1; i >= 0; --i) {
      if (sums[i] >= sums[maxIndex])
        maxIndex = i;
      r[i] = maxIndex;
    }

    vector<int> ans{-1, -1, -1};

    for (int i = k; i < n - k; ++i)
      if (ans[0] == -1 || sums[ans[0]] + sums[ans[1]] + sums[ans[2]] <
                              sums[l[i - k]] + sums[i] + sums[r[i + k]]) {
        ans[0] = l[i - k];
        ans[1] = i;
        ans[2] = r[i + k];
      }

    return ans;
  }
};"
"class Solution:
    def isCompleteTree(self, root: TreeNode) -> bool:
        queue = [root]
        while queue[0]:
            node = queue[0]
            queue = queue[1:]
            queue.append(node.left)
            queue.append(node.right)
        return not any(queue)","class Solution {
 public:
  int getImportance(vector<Employee*> employees, int id) {
    unordered_map<int, Employee*> idToEmployee;

    for (Employee* employee : employees)
      idToEmployee[employee->id] = employee;

    return dfs(id, idToEmployee);
  }

 private:
  int dfs(int id, const unordered_map<int, Employee*>& idToEmployee) {
    int values = 0;

    for (const int subId : idToEmployee.at(id)->subordinates)
      values += dfs(subId, idToEmployee);

    return idToEmployee.at(id)->importance + values;
  }
};"
"class Solution:
    def regionsBySlashes(self, grid: List[str]) -> int:
	'''
	--------
	| \ 0 / |
	| 3\ /  |
	|  /\ 1 |
	|/  2 \ |
	|-------|

	'''
        self.N = len(grid)
        # m_ = [i for i in range(self.N * self.N * 4)]
        m_ = list(range(self.N * self.N * 4))
        self.count = self.N * self.N * 4
        for r in range(self.N):
            line = grid[r]
            for c in range(self.N):
                w = line[c]
                if r > 0:  # no horizontal line '-'
                    self.u(m_, self.g(r - 1, c, 2), self.g(r, c, 0))
                if c > 0:  # no vertical line '|'
                    self.u(m_, self.g(r, c - 1, 1), self.g(r, c, 3))
                if w != '/':  # if not '/', then region 0 and 1 will be in the same region(set)
                    self.u(m_, self.g(r, c, 0), self.g(r, c, 1))
                    self.u(m_, self.g(r, c, 3), self.g(r, c, 2))
                if w != '\\': # if not '\\', then region 1 and 2 will be in the same region(set)
                    self.u(m_, self.g(r, c, 0), self.g(r, c, 3))
                    self.u(m_, self.g(r, c, 1), self.g(r, c, 2))
        return self.count

    def f(self, m_, a):  # find set
        if m_[a] == a:   # if parent found, return, else continue finding
            return a
        return self.f(m_, m_[a])
    
    def u(self, m_, a, b):  # union sets
        pa = self.f(m_, a)
        pb = self.f(m_, b)
        if (pa == pb):
            return
        m_[pa] = pb
        self.count -= 1
    
    def g(self, r, c, i):  # find exact region(set) for every element in grid
        return (r * self.N + c) * 4 + i","class Solution {
 public:
  int minStickers(vector<string>& stickers, string target) {
    const int n = target.size();
    const int maxMask = 1 << n;
    // dp[i] := min # of stickers to spell out i, where i is the bit mask of
    // target.
    vector<int> dp(maxMask, INT_MAX);
    dp[0] = 0;

    for (int mask = 0; mask < maxMask; ++mask) {
      if (dp[mask] == INT_MAX)
        continue;
      // Try to expand from `mask` by using each sticker.
      for (const string& sticker : stickers) {
        int superMask = mask;
        for (const char c : sticker)
          for (int i = 0; i < n; ++i)
            // Try to apply it on a missing char.
            if (c == target[i] && !(superMask >> i & 1)) {
              superMask |= 1 << i;
              break;
            }
        dp[superMask] = min(dp[superMask], dp[mask] + 1);
      }
    }

    return dp.back() == INT_MAX ? -1 : dp.back();
  }
};"
"class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        m, n = len(strs), len(strs[0]) # dimensions
        
        @cache 
        def fn(k, prev):
            """"""Return min deleted columns to make sorted.""""""
            if k == n: return 0 
            ans = 1 + fn(k+1, prev) # delete kth column
            if prev == -1 or all(strs[i][prev] <= strs[i][k] for i in range(m)): 
                ans = min(ans, fn(k+1, k)) # retain kth column
            return ans 
        
        return fn(0, -1)","class Solution {
 public:
  vector<string> topKFrequent(vector<string>& words, int k) {
    const int n = words.size();
    vector<string> ans;
    vector<vector<string>> bucket(n + 1);
    unordered_map<string, int> count;

    for (const string& word : words)
      ++count[word];

    for (const auto& [word, freq] : count)
      bucket[freq].push_back(word);

    for (int freq = n; freq > 0; --freq) {
      sort(begin(bucket[freq]), end(bucket[freq]));
      for (const string& word : bucket[freq]) {
        ans.push_back(word);
        if (ans.size() == k)
          return ans;
      }
    }

    throw;
  }
};"
"class Solution:
    def repeatedNTimes(self, A: List[int]) -> int:
        length = len(A)
        for i in A:
            if A.count(i)>1:
                return i","class Solution {
 public:
  int numDistinctIslands(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    set<vector<pair<int, int>>> islands;  // All different islands
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        vector<pair<int, int>> island;
        dfs(grid, i, j, i, j, seen, island);
        if (!island.empty())
          islands.insert(island);
      }

    return islands.size();
  }

 private:
  void dfs(const vector<vector<int>>& grid, int i, int j, int i0, int j0,
           vector<vector<bool>>& seen, vector<pair<int, int>>& island) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] == 0 || seen[i][j])
      return;

    seen[i][j] = true;
    island.emplace_back(i - i0, j - j0);

    dfs(grid, i + 1, j, i0, j0, seen, island);
    dfs(grid, i - 1, j, i0, j0, seen, island);
    dfs(grid, i, j + 1, i0, j0, seen, island);
    dfs(grid, i, j - 1, i0, j0, seen, island);
  }
};"
"class Solution:
    def maxWidthRamp(self, nums: List[int]) -> int:
        if not nums: return 0
        
        max_vals = self.create_max_vals(nums)
        max_width = 0
        i = 0
        
        while i + max_width < len(nums):
            j = i + max_width
            
            while j < len(nums) and nums[i] <= max_vals[j]:
                j += 1
            
            max_width = max(max_width, j - i - 1)
            i += 1
        
        return max_width
        
    def create_max_vals(self, nums: List[int]) -> List[int]:
        max_val = 0
        max_vals = [0] * len(nums)
        
        for i in range(len(nums)-1, -1, -1):
            max_val = max(max_val, nums[i])
            max_vals[i] = max_val
        
        return max_vals","class Solution {
 public:
  int maxAreaOfIsland(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        ans = max(ans, dfs(grid, i, j));

    return ans;
  }

 private:
  int dfs(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return 0;
    if (grid[i][j] != 1)
      return 0;

    grid[i][j] = 2;

    return 1 +                                          //
           dfs(grid, i + 1, j) + dfs(grid, i - 1, j) +  //
           dfs(grid, i, j + 1) + dfs(grid, i, j - 1);
  }
};"
"class Solution:
    def minAreaFreeRect(self, points: List[List[int]]) -> float:
        N = len(points)
        
        seen = set()
        for point in points:
            seen.add(tuple(point))

        # length^2
        def length2(a, b):
            return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])
        
        best = 1e30
        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                
                lij = length2(points[i], points[j])
                for k in range(N):
                    if i == k or j == k:
                        continue
                    
                    # given i->j line, add to k to find l
                    dx, dy = points[j][0] - points[i][0], points[j][1] - points[i][1]
                    
                    pl = (points[k][0] + dx, points[k][1] + dy)
                    if pl not in seen:
                        continue
                    
                    lik = length2(points[i], points[k])
                    ljk = length2(points[j], points[k])

                    lil = length2(points[i], pl)
                    ljl = length2(points[j], pl)
                    lkl = length2(points[k], pl)
                    
                    if lij == lkl and lik == ljl and lil == ljk:
                        best = min(best, sqrt(lij * lik * lil) / sqrt(max(lij, lik, lil)))
                    
        if best >= 1e29:
            return 0
        return best","class Solution {
 public:
  int countBinarySubstrings(string s) {
    int ans = 0;
    int prevEquals = 0;
    int currEquals = 1;

    for (int i = 0; i + 1 < s.length(); ++i)
      if (s[i] == s[i + 1])
        ++currEquals;
      else {
        ans += min(prevEquals, currEquals);
        prevEquals = currEquals;
        currEquals = 1;
      }

    return ans + min(prevEquals, currEquals);
  }
};"
"class Solution:
    def solve(self,x,target):
        if target in self.dp : return self.dp[target]
        
        # when target == 1 we can solve just by doing x/x  
        if target == 1: return 1
        
         # current value = x and operations performed  = 0
        cur = x
        op = 0
       
        # if cur < target : the best decision is to multiply
        while cur < target:    
            cur *= x
            op += 1
        
        # if cur == target : we reached using minimum possible operations 
        if cur == target :
            return op
        
        if op == 0:
            # cur is already larger than target
            # x/x + make(target-1) : make 2 operations + solve(target-1)
            ans = 2 + self.solve(x,target - 1)
        else:
            # we try to reach nearest val via multiply less than target
            # and find ans for remaining i.e. target - cur/x 
            # here op becomes op - 1 so op - 1 + 1 becomes op
            ans = op + self.solve(x,target-(cur//x))
            
        if cur - target < target :
            # diff between cur and target is less than target
            # i.e. we can make cur and remove cur - target
            tmp = op + 1 + self.solve(x,cur - target)
            if tmp < ans : ans = tmp
        
        # finally use dp for memoization
        self.dp[target] = ans
        return ans","class Solution {
 public:
  int findShortestSubArray(vector<int>& nums) {
    int ans = 0;
    int degree = 0;
    unordered_map<int, int> debut;
    unordered_map<int, int> count;

    for (int i = 0; i < nums.size(); ++i) {
      const int num = nums[i];
      if (!debut.count(num))
        debut[num] = i;
      if (++count[num] > degree) {
        degree = count[num];
        ans = i - debut[num] + 1;
      } else if (count[num] == degree) {
        ans = min(ans, i - debut[num] + 1);
      }
    }

    return ans;
  }
};"
"class Solution:
    def isUnivalTree(self, root: TreeNode) -> bool:
        if root is None:
            return True
        self.cons=root.val
        def dfs(node):
            if node:
                if node.val!=self.cons:
                    return False
                dfs(node.left)
                dfs(node.right)
        
        dfs(root)
        return True","class Solution {
 public:
  bool canPartitionKSubsets(vector<int>& nums, int k) {
    const int sum = accumulate(begin(nums), end(nums), 0);
    if (sum % k != 0)
      return false;

    const int t = sum / k;  // Each subset's target sum
    return dfs(nums, 0, k, t, t, vector<bool>(nums.size()));
  }

 private:
  bool dfs(const vector<int>& nums, int s, int k, int target,
           const int subsetTargetSum, vector<bool>&& seen) {
    if (k == 0)
      return true;
    if (target < 0)
      return false;
    if (target == 0)
      return dfs(nums, 0, k - 1, subsetTargetSum, subsetTargetSum, move(seen));

    for (int i = s; i < nums.size(); ++i) {
      if (seen[i])
        continue;
      seen[i] = true;
      if (dfs(nums, i + 1, k, target - nums[i], subsetTargetSum, move(seen)))
        return true;
      seen[i] = false;
    }

    return false;
  }
};"
"class Solution:
    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:
        original_hash, lowercase_hash, ignore_vowel_hash = {}, {}, {}
        for index, word in enumerate(wordlist):
            original_hash[word] = index
            lowercase_word = word.lower()
            if lowercase_word not in lowercase_hash:
                lowercase_hash[lowercase_word] = index
            trans_vowel_word = self.trans_vowel(lowercase_word)
            if trans_vowel_word not in ignore_vowel_hash:
                ignore_vowel_hash[trans_vowel_word] = index
        check_result = []
        for query in queries:
            if query in original_hash:
                check_result.append(query)
            elif query.lower() in lowercase_hash:
                check_result.append(wordlist[lowercase_hash[query.lower()]])
            else:
                trans = self.trans_vowel(query.lower())
                if trans in ignore_vowel_hash:
                    check_result.append(wordlist[ignore_vowel_hash[trans]])
                else:
                    check_result.append("""")
        return check_result

    @classmethod
    def trans_vowel(cls, word):
        list_word = list(word)
        for i, c in enumerate(word):
            if c in ('a', 'e', 'i', 'o', 'u'):
                list_word[i] = 0
        return str(list_word)","class Solution {
 public:
  vector<int> fallingSquares(vector<vector<int>>& positions) {
    vector<int> ans;
    map<pair<int, int>, int> xsToHeight;  // {{xStart, xEnd}, height}
    int maxHeight = INT_MIN;

    for (const vector<int>& p : positions) {
      const int left = p[0];
      const int sideLength = p[1];
      const int right = left + sideLength;
      // First range intersect with [left, right)
      auto it = xsToHeight.upper_bound({left, right});
      if (it != begin(xsToHeight) && (--it)->first.second <= left)
        ++it;
      int maxHeightInRange = 0;
      vector<tuple<int, int, int>> ranges;
      while (it != end(xsToHeight) && it->first.first < right) {
        const int l = it->first.first;
        const int r = it->first.second;
        const int h = it->second;
        if (l < left)
          ranges.emplace_back(l, left, h);
        if (right < r)
          ranges.emplace_back(right, r, h);
        maxHeightInRange = max(maxHeightInRange, h);
        it = xsToHeight.erase(it);
      }
      const int newHeight = maxHeightInRange + sideLength;
      xsToHeight[{left, right}] = newHeight;
      for (const auto& [l, r, h] : ranges)
        xsToHeight[{l, r}] = h;
      maxHeight = max(maxHeight, newHeight);
      ans.push_back(maxHeight);
    }

    return ans;
  }
};"
"class Solution:
    def numsSameConsecDiff(self, n: int, k: int) -> List[int]:
        
        def fn(i, x):
            """"""Return numbers with same consecutive differences.""""""
            if i == n-1: return [str(x)]
            ans = []
            if x+k < 10: ans += [str(x) + xx for xx in fn(i+1, x+k)]
            if k and 0 <= x-k: ans += [str(x) + xx for xx in fn(i+1, x-k)] 
            return ans 
        
        return sum((fn(0, x) for x in range(1, 10)), [])","class Solution {
 public:
  TreeNode* searchBST(TreeNode* root, int val) {
    if (root == nullptr)
      return nullptr;
    if (root->val == val)
      return root;
    if (root->val > val)
      return searchBST(root->left, val);
    return searchBST(root->right, val);
  }
};"
"class Solution:
    def minCameraCover(self, root: TreeNode) -> int:
        # Post order traversal to make sure we transit left, right and root so that camera's can be assigned in the right order.
        def postorder(root, parent):
            if not root:
                return 0
            
            L = postorder(root.left, root)
            R = postorder(root.right, root)
            
            # check if something is a tail node. 
            tail_node = (not root.left and not root.right)
            
            # Camera coverage is there if either a camera exists or if a camera cover node
            # however, if we discovered coverage to children or camera with children, 
            # we dont want to assign camera too root but to its parent. 
            # Only case need covering in the root node. 
            left_camera = (not root.left) or (root.left and root.left.val >= 1)
            right_camera = (not root.right) or (root.right and root.right.val >= 1)
            iscovered = left_camera and right_camera 

            # check if either children is not having coverage == 0 
            # usecase : root has left chld covered by its children but on right side its not covered the the root needs to have a camera. 
            either_zero = False
            
            if root.left and root.left.val == 0:
                either_zero = True
            if root.right and root.right.val == 0:
                either_zero = True
                
            if not parent and (root.val == 2 or root.val == 0):
                return L + R + (1 if (either_zero or not root.val) else 0)
            elif not tail_node and not iscovered:
                root.val = 1
                # if root needs camera, then propagate coverate to its parent and children.
                if parent:
                    parent.val = 2 if parent.val == 0 else parent.val
                
                if root.left:
                    root.left.val = 2 if root.left.val == 0 else root.left.val
                    
                if root.right:
                    root.right.val = 2 if root.right.val == 0 else root.right.val
                
                L += 1                
                            
            return L + R 
                        
        mc = postorder(root, None)

        return mc","class Solution {
 public:
  TreeNode* insertIntoBST(TreeNode* root, int val) {
    if (root == nullptr)
      return new TreeNode(val);
    if (root->val > val)
      root->left = insertIntoBST(root->left, val);
    else
      root->right = insertIntoBST(root->right, val);
    return root;
  }
};"
"class Solution:
    def pancakeSort(self, A: List[int]) -> List[int]:
        sort_k_list = []
        ''' sorting k used for pancake flip '''
        for i in range(len(A), 0, -1):
            v = A[i-1]
            if v != i:
                # Start pancake sorting
                # 0) Look for value as `v`
                vi = A.index(i)

                # 1) Performing pancake flip twice to move value `v` into
                #    destined position `i`
                if vi >= 1:
                    sort_k_list.append(vi+1)    # 1.1 Move value `v` to first position
                    A[:vi+1] = A[:vi+1][::-1]
                    sort_k_list.append(i)       # 1.2 Move value `v` from first position to target position `i`
                    A[:i] = A[:i][::-1]                    
                else:
                    # value `v` is already at first position
                    # so swap it to the destined position
                    sort_k_list.append(i)
                    A[:i] = A[:i][::-1]                    
            
        return sort_k_list","/**
 * // This is the ArrayReader's API interface.
 * // You should not implement it, or speculate about its implementation
 * class ArrayReader {
 *  public:
 *   int get(int index);
 * };
 */

class Solution {
 public:
  int search(const ArrayReader& reader, int target) {
    int l = 0;
    int r = 10'000;

    while (l < r) {
      const int m = (l + r) / 2;
      if (reader.get(m) >= target)
        r = m;
      else
        l = m + 1;
    }

    return reader.get(l) == target ? l : -1;
  }
};"
"class Solution:
    def powerfulIntegers(self, x, y, bound):
        answer = []
        cnt1 = 0
        cnt2 = 0
        while x**(cnt1+1) <= bound:
            if x == 1:
                break
            cnt1 += 1
        while y**(cnt2+1) <= bound:
            if y == 1:
                break
            cnt2 += 1
        for i in range(cnt1+1):
            for j in range(cnt2+1):
                if x**(i) +y**(j) <= bound:
                    answer.append((x**(i) +y**(j)))
        answer = set(answer)
        answer = list(answer)
        return (answer)



x = 1
y = 2
bound = 100
Solution().powerfulIntegers(x,y, bound)","class KthLargest {
 public:
  KthLargest(int k, vector<int>& nums) : k(k) {
    for (const int num : nums)
      heapify(num);
  }

  int add(int val) {
    heapify(val);
    return minHeap.top();
  }

 private:
  const int k;
  priority_queue<int, vector<int>, greater<>> minHeap;

  void heapify(int val) {
    minHeap.push(val);
    if (minHeap.size() > k)
      minHeap.pop();
  }
};"
"class Solution:
    def flipMatchVoyage(self, root: TreeNode, voyage: List[int]) -> List[int]:
        ans = []
        stack = [root]
        i = 0 
        while stack: 
            node = stack.pop()
            if node: 
                if node.val != voyage[i]: return [-1]
                i += 1
                if node.left and node.right and voyage[i] == node.right.val: 
                    ans.append(node.val)
                    node.left, node.right = node.right, node.left 
                stack.extend([node.right, node.left])
        return ans","class MyHashSet {
 public:
  /** Initialize your data structure here. */
  MyHashSet() : set(1000001) {}

  void add(int key) {
    set[key] = true;
  }

  void remove(int key) {
    set[key] = false;
  }

  /** Returns true if this set contains the specified element */
  bool contains(int key) {
    return set[key];
  }

 private:
  vector<bool> set;
};"
"class Solution:

    def to_float(self, n: str) -> float:
        if ""."" not in n:
            return float(n)
        whole, dec = n.split(""."")
        if dec:
            if ""("" in dec:
                idx_bracket = dec.index(""("")
                return float(f""{whole}.{dec[:idx_bracket]}{dec[idx_bracket + 1: -1] * 17}"")
            return float(f""{whole}.{dec}"")
        return float(f""{whole}."")

    def isRationalEqual(self, s: str, t: str) -> bool:
        return abs(self.to_float(s) - self.to_float(t)) < 1e-16","class MyHashMap {
 public:
  /** Initialize your data structure here. */
  MyHashMap() : lists(kSize) {}

  /** value will always be non-negative. */
  void put(int key, int value) {
    auto& pairs = lists[key % kSize];
    for (auto& [k, v] : pairs)
      if (k == key) {
        v = value;
        return;
      }
    pairs.emplace_back(key, value);
  }

  /** Returns the value to which the specified key is mapped, or -1 if this map
   * contains no mapping for the key */
  int get(int key) {
    const list<pair<int, int>>& pairs = lists[key % kSize];
    for (const auto& [k, v] : pairs)
      if (k == key)
        return v;
    return -1;
  }

  /** Removes the mapping of the specified value key if this map contains a
   * mapping for the key */
  void remove(int key) {
    auto& pairs = lists[key % kSize];
    for (auto it = begin(pairs); it != end(pairs); ++it)
      if (it->first == key) {
        pairs.erase(it);
        return;
      }
  }

 private:
  static constexpr int kSize = 10000;
  vector<list<pair<int, int>>> lists;  // Each slot store (key, value) list
};"
"class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        return sorted(points, key = lambda x: x[0] ** 2 + x[1] ** 2)[:k]","class MyLinkedList {
  struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
  };

 public:
  int get(int index) {
    if (index < 0 || index >= length)
      return -1;
    ListNode* curr = dummy.next;
    for (int i = 0; i < index; ++i)
      curr = curr->next;
    return curr->val;
  }

  void addAtHead(int val) {
    ListNode* head = dummy.next;
    ListNode* node = new ListNode(val);
    node->next = head;
    dummy.next = node;
    ++length;
  }

  void addAtTail(int val) {
    ListNode* curr = &dummy;
    while (curr->next)
      curr = curr->next;
    curr->next = new ListNode(val);
    ++length;
  }

  void addAtIndex(int index, int val) {
    if (index > length)
      return;
    ListNode* curr = &dummy;
    for (int i = 0; i < index; ++i)
      curr = curr->next;
    ListNode* cache = curr->next;
    ListNode* node = new ListNode(val);
    node->next = cache;
    curr->next = node;
    ++length;
  }

  void deleteAtIndex(int index) {
    if (index < 0 || index >= length)
      return;
    ListNode* curr = &dummy;
    for (int i = 0; i < index; ++i)
      curr = curr->next;
    ListNode* cache = curr->next;
    curr->next = cache->next;
    --length;
    delete cache;
  }

 private:
  int length = 0;
  ListNode dummy = ListNode(0);
};"
"class Solution:
    def subarraysDivByK(self, A: List[int], K: int) -> int:
    	D, s = {0:1}, 0
    	for a in A:
    		s = (s + a) % K
    		if s in D: D[s] += 1
    		else: D[s] = 1
    	return sum(i*(i-1)//2 for i in D.values())
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  Node* insert(Node* head, int insertVal) {
    if (head == nullptr) {
      Node* newNode = new Node(insertVal);
      newNode->next = newNode;
      return newNode;
    }

    Node* prev = head;
    Node* curr = head->next;

    while (curr != head) {
      // Case 1: min <= insertVal <= max
      // Case 2: insertVal >= max or insertVal <= min
      if ((prev->val <= insertVal && insertVal <= curr->val) ||
          (prev->val > curr->val &&  // Prev is max, curr is min
           (insertVal >= prev->val || insertVal <= curr->val))) {
        // Insert the node between prev and curr
        prev->next = new Node(insertVal, curr);
        return head;
      }
      prev = prev->next;
      curr = curr->next;
    }

    // All vals in the list are identical
    prev->next = new Node(insertVal, curr);
    return head;
  }
};"
"class Solution:
    def oddEvenJumps(self, arr: List[int]) -> int:
        large = [-1] * len(arr)
        small = [-1] * len(arr)
        
        stack = []
        for i, x in sorted(enumerate(arr), key=lambda x: (x[1], x[0])): 
            while stack and stack[-1] < i: large[stack.pop()] = i 
            stack.append(i)
        
        stack = []
        for i, x in sorted(enumerate(arr), key=lambda x: (-x[1], x[0])): 
            while stack and stack[-1] < i: small[stack.pop()] = i
            stack.append(i)
        
        odd = [0] * len(arr)
        even = [0] * len(arr)
        odd[-1] = even[-1] = 1
        for i in reversed(range(len(arr))): 
            if 0 <= large[i]: odd[i] = even[large[i]]
            if 0 <= small[i]: even[i] = odd[small[i]]
        return sum(odd)","class Solution {
 public:
  string toLowerCase(string str) {
    const int diff = 'A' - 'a';

    for (char& c : str)
      if (c >= 'A' && c <= 'Z')
        c -= diff;

    return str;
  }
};"
"class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        # Condition of a triangle a<(b+c) and a>=b>=c
        nums=sorted(nums,reverse=True)
        for i in range(len(nums)-2):
            if nums[i]<nums[i+1]+nums[i+2]:
                return nums[i] + nums[i+1] + nums[i+2]
        return 0","class Solution {
 public:
  Solution(int n, vector<int>& blacklist) : validRange(n - blacklist.size()) {
    for (const int b : blacklist)
      map[b] = -1;

    int maxAvailable = n - 1;

    for (const int b : blacklist)
      if (b < validRange) {
        while (map.count(maxAvailable))  // Find the slot that haven't been used
          --maxAvailable;
        map[b] = maxAvailable--;
      }
  }

  int pick() {
    const int num = rand() % validRange;
    const auto it = map.find(num);
    return it == cend(map) ? num : it->second;
  }

 private:
  const int validRange;
  unordered_map<int, int> map;
};"
"class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            nums[i] = nums[i]**2
        nums.sort()
        return nums","class Solution {
 public:
  int numDistinctIslands2(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    set<vector<pair<int, int>>> islands;  // All different shape islands
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        vector<pair<int, int>> island;
        dfs(grid, i, j, seen, island);
        if (!island.empty())
          islands.insert(normalize(island));
      }

    return islands.size();
  }

 private:
  void dfs(const vector<vector<int>>& grid, int i, int j,
           vector<vector<bool>>& seen, vector<pair<int, int>>& island) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] == 0 || seen[i][j])
      return;

    seen[i][j] = true;
    island.emplace_back(i, j);

    dfs(grid, i + 1, j, seen, island);
    dfs(grid, i - 1, j, seen, island);
    dfs(grid, i, j + 1, seen, island);
    dfs(grid, i, j - 1, seen, island);
  }

  vector<pair<int, int>> normalize(const vector<pair<int, int>>& island) {
    // points[i] := 8 different rotations/reflections of island
    vector<vector<pair<int, int>>> points(8);

    for (const auto& [i, j] : island) {
      points[0].emplace_back(i, j);
      points[1].emplace_back(i, -j);
      points[2].emplace_back(-i, j);
      points[3].emplace_back(-i, -j);
      points[4].emplace_back(j, i);
      points[5].emplace_back(j, -i);
      points[6].emplace_back(-j, i);
      points[7].emplace_back(-j, -i);
    }

    for (vector<pair<int, int>>& p : points)
      sort(begin(p), end(p));

    // Normalize each p by minus p[1:] w/ p[0]
    for (vector<pair<int, int>>& p : points) {
      for (int i = 1; i < island.size(); ++i)
        p[i] = {p[i].first - p[0].first, p[i].second - p[0].second};
      p[0] = {0, 0};
    }

    sort(begin(points), end(points));
    return points[0];
  }
};"
"class Solution:
    def maxTurbulenceSize(self, A: List[int]) -> int:
        index = 0
        A_len = len(A)
        A_len_ = A_len - 1
        current_length = 1
        max_length = 1
        
        
        while (A_len - index > max_length):
            while (index < A_len_ and A[index + 1] == A[index]):
                index += 1
             
            
            if (A_len - index > max_length):    
                faktor = 1 if A[index] > A[index + 1] else -1
                index += 1
                current_length = 2


                while (index < A_len_ and faktor * A[index] < faktor * A[index + 1]):
                    faktor = -faktor
                    current_length += 1
                    index += 1


                if (current_length > max_length):
                    max_length = current_length
                    
        return max_length","class Solution {
 public:
  int minimumDeleteSum(string s1, string s2) {
    const int m = s1.length();
    const int n = s2.length();
    // dp[i][j] := min cost to make s1[0..i) and s2[0..j) equal
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    // Delete s1[i - 1]
    for (int i = 1; i <= m; ++i)
      dp[i][0] = dp[i - 1][0] + s1[i - 1];

    // Delete s2[j - 1]
    for (int j = 1; j <= n; ++j)
      dp[0][j] = dp[0][j - 1] + s2[j - 1];

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (s1[i - 1] == s2[j - 1])
          dp[i][j] = dp[i - 1][j - 1];
        else
          dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);

    return dp[m][n];
  }
};"
"class Solution:
    def distributeCoins(self, root: TreeNode) -> int:
        
        def fn(node):
            """"""Return flux (surplus/deficit) of node.""""""
            nonlocal ans 
            if not node: return 0
            left, right = fn(node.left), fn(node.right)
            ans += abs(left) + abs(right)
            return node.val - 1 + left + right # surplus/deficit 
        
        ans = 0
        fn(root)
        return ans","class Solution {
 public:
  int numSubarrayProductLessThanK(vector<int>& nums, int k) {
    if (k <= 1)
      return 0;

    int ans = 0;
    int prod = 1;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      prod *= nums[r];
      while (prod >= k)
        prod /= nums[l++];
      ans += r - l + 1;
    }

    return ans;
  }
};"
"class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
        moves = ((1, 0), (-1, 0), (0, 1), (0, -1))
        ans = 0

        # ----------------------------------------------
        def dfs(grid, r, c, vertexSet):
            nonlocal ans, moves

            vertexSet.remove((r, c))
            if grid[r][c] == 2:
                if len(vertexSet) == 0:
                    ans += 1
                return

            for x, y in moves:
                x, y = r + x, c + y
                if (x, y) in vertexSet:
                    dfs(grid, x, y, vertexSet.copy())
        # -----------------------------------------------
        
        vertexSet = set()
        r1, r2 = 0, 0
        for r in range(len(grid)):                  # Add (row, col) in set if it is not onstacle
            for c in range(len(grid[0])):
                if grid[r][c] != -1:
                    if grid[r][c] == 1:
                        r1, c1 = r, c
                    vertexSet.add((r, c))
                    
        dfs(grid, r1, c1, vertexSet)                # Start DFS from start - (row, col) 
        return ans","class Solution {
 public:
  int maxProfit(vector<int>& prices, int fee) {
    int sell = 0;
    int hold = INT_MIN;

    for (const int price : prices) {
      sell = max(sell, hold + price);
      hold = max(hold, sell - price - fee);
    }

    return sell;
  }
};"
"class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        ans = 0
        mem = [0] * (1 << 16)
        size = len(nums)

        for i in range(size):
            for j in range(i, size):
                mem[nums[i]&amp;nums[j]] += 2 if i != j else 1
        
        for ij in range(1 << 16):
            if mem[ij] > 0:
                for k in nums:
                    if k &amp; ij == 0:
                        ans += mem[ij]
        return ans","class Solution {
 public:
  bool isOneBitCharacter(vector<int>& bits) {
    const int n = bits.size();

    int i = 0;
    while (i < n - 1)
      if (bits[i] == 0)
        i += 1;
      else
        i += 2;

    return i == n - 1;
  }
};"
"class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        dp = [0]*(days[-1]+1)
        for i in range(len(dp)):
            if i in days:
                dp[i] = min(dp[max(0, i-1)]+costs[0],
                            dp[max(0, i-7)]+costs[1], dp[max(0, i-30)]+costs[2])
            else:
                dp[i] = dp[i-1]
        return dp[-1]","class Solution {
 public:
  int findLength(vector<int>& nums1, vector<int>& nums2) {
    const int m = nums1.size();
    const int n = nums2.size();
    int ans = 0;
    // dp[i][j] := max length of nums1[i:] and nums2[j:]
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = m - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j)
        if (nums1[i] == nums2[j]) {
          dp[i][j] = dp[i + 1][j + 1] + 1;
          ans = max(ans, dp[i][j]);
        }

    return ans;
  }
};"
"class Solution:
    def strWithout3a3b(self, a: int, b: int) -> str:
		# n = current # of consecutive chracters in res that are the same
		# positive if it's consecutive as, negative if it's bs
        n = 0
        res = ''
        while a and b:
            if n == -2 or (n != 2 and a >= b):
                res += 'a'
                a -= 1
                n = max(1, n + 1)
            else:
                res += 'b'
                b -= 1
                n = min(-1, n - 1)
        return res + (a * 'a') + (b * 'b')","class Solution {
 public:
  int smallestDistancePair(vector<int>& nums, int k) {
    sort(begin(nums), end(nums));

    int l = 0;
    int r = nums.back() - nums.front();

    while (l < r) {
      const int m = (l + r) / 2;
      if (pairDistancesNoGreaterThan(nums, m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int pairDistancesNoGreaterThan(const vector<int>& nums, int m) {
    int count = 0;
    int j = 1;
    // For each index i, find the first index j s.t. nums[j] > nums[i] + m,
    // So pairDistancesNoGreaterThan for index i will be j - i - 1
    for (int i = 0; i < nums.size(); ++i) {
      while (j < nums.size() && nums[j] <= nums[i] + m)
        ++j;
      count += j - i - 1;
    }
    return count;
  }
};"
"class Solution:
    def sumEvenAfterQueries(self, A: List[int], queries: List[List[int]]) -> List[int]:
        s=0
        a=[0]*len(queries)
        for i in A:
            if i%2==0:
                s+=i
                
        for i in range(len(queries)):
            indx=queries[i][1]
            val=queries[i][0]
            
            if val%2==0:
                if A[indx]%2==0:
                    s+=val


            else:
                if A[indx]%2==0:
                    s-=A[indx]
                   

                else:
                    s+=A[indx]+val
                
            A[indx]+=val
            a[i]=s
                
            
        return a","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  const string* word = nullptr;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  string longestWord(vector<string>& words) {
    for (const string& word : words)
      insert(word);
    return longestWordFrom(root);
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->word = &word;
  }

  string longestWordFrom(shared_ptr<TrieNode> node) {
    string ans = node->word ? *node->word : """";

    for (shared_ptr<TrieNode> child : node->children)
      if (child && child->word) {
        string childWord = longestWordFrom(child);
        if (childWord.length() > ans.length())
          ans = childWord;
      }

    return ans;
  }
};"
"class Solution:
    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        LA, LB, I, i, j = len(A), len(B), [], 0, 0
        while i < LA and j < LB:
            a, b, i = A[i], B[j], i + 1
            if a[1] > b[1]: a, b, i, j = b, a, i - 1, j + 1
            if b[0] <= a[1]: I.append([max(a[0],b[0]),a[1]])
        return I
		
		
- Junaid Mansuri
- Chicago, IL","class UnionFind {
 public:
  UnionFind(int n) : id(n), sz(n, 1) {
    iota(begin(id), end(id), 0);
  }

  void unionBySize(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (sz[i] < sz[j]) {
      sz[j] += sz[i];
      id[i] = j;
    } else {
      sz[i] += sz[j];
      id[j] = i;
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> sz;
};

class Solution {
 public:
  vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
    vector<vector<string>> ans;
    unordered_map<string, int> emailToIndex;        // {email: index}
    unordered_map<int, set<string>> indexToEmails;  // {index: {emails}}
    UnionFind uf(accounts.size());

    for (int i = 0; i < accounts.size(); ++i) {
      const string name = accounts[i][0];
      for (int j = 1; j < accounts[i].size(); ++j) {
        const string email = accounts[i][j];
        const auto it = emailToIndex.find(email);
        if (it == emailToIndex.end()) {
          // Only record if it's the first time we see thie email
          emailToIndex[email] = i;
        } else {
          // Otherwise, union i w/ emailToIndex[index]
          uf.unionBySize(i, it->second);
        }
      }
    }

    for (const auto& [email, index] : emailToIndex)
      indexToEmails[uf.find(index)].insert(email);

    for (const auto& [index, emails] : indexToEmails) {
      const string name = accounts[index][0];
      vector<string> row{name};
      row.insert(end(row), begin(emails), end(emails));
      ans.push_back(row);
    }

    return ans;
  }
};"
"class Solution:
    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:
        cols_hash_map = collections.defaultdict(lambda : collections.defaultdict(list))
        min_col = math.inf
        max_col = -math.inf
        max_row = -math.inf
        def traverse(root, row, col):
            nonlocal min_col, max_col, max_row
            if not root:
                return
            min_col = min(min_col, col)
            max_col = max(max_col, col)
            max_row = max(max_row, row)
            bisect.insort(cols_hash_map[col][row], root.val)
            
            traverse(root.left, row + 1, col - 1)
            traverse(root.right, row + 1, col + 1)
            
        traverse(root, 0, 0)
        res = []
        for i in range(min_col, max_col + 1):
            tmp = []
            for j in range(max_row + 1):
                tmp.extend(cols_hash_map[i][j])
            res.append(tmp)
        return res","class Solution {
 public:
  vector<string> removeComments(vector<string>& source) {
    vector<string> ans;
    bool commenting = false;
    string modified;

    for (const string& line : source) {
      for (int i = 0; i < line.length();) {
        if (i + 1 == line.length()) {
          if (!commenting)
            modified += line[i];
          ++i;
          break;
        }
        const string& twoChars = line.substr(i, 2);
        if (twoChars == ""/*"" && !commenting) {
          commenting = true;
          i += 2;
        } else if (twoChars == ""*/"" && commenting) {
          commenting = false;
          i += 2;
        } else if (twoChars == ""//"") {
          if (!commenting)
            break;
          else
            i += 2;
        } else {
          if (!commenting)
            modified += line[i];
          ++i;
        }
      }
      if (modified.length() > 0 && !commenting) {
        ans.push_back(modified);
        modified = """";
      }
    }

    return ans;
  }
};"
"class Solution:
    stack = []
    best = None
    
    def lexorder(s1,s2):
        if s1 == None:
            return s2
        for i in range(min(len(s1),len(s2))):
            if s1[i] < s2[i]:
                return s1
            elif s1[i] > s2[i]:
                return s2
        if len(s1) < len(s2):
            return s1
        return s2
    
    def dfs(self, root):
        Solution.stack.append(root.val)
        if root.left:
            self.dfs(root.left)
        if root.right:
            self.dfs(root.right)
        if root.left == None and root.right == None:
            Solution.best = Solution.lexorder(Solution.best, Solution.stack[::-1])
        Solution.stack.pop()
        
    def smallestFromLeaf(self, root: TreeNode) -> str:
        self.dfs(root)
        return """".join([chr(x+97) for x in Solution.best])","class Solution {
 public:
  vector<vector<int>> candyCrush(vector<vector<int>>& board) {
    const int m = board.size();
    const int n = board[0].size();
    bool haveCrushes = true;

    while (haveCrushes) {
      haveCrushes = false;

      for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j) {
          const int val = abs(board[i][j]);
          if (val == 0)
            continue;
          // Crush vertical candies
          if (j + 2 < n && abs(board[i][j + 1]) == val &&
              abs(board[i][j + 2]) == val) {
            haveCrushes = true;
            for (int k = j; k < j + 3; ++k)
              board[i][k] = -val;
          }
          // Crush horizontal candies
          if (i + 2 < m && abs(board[i + 1][j]) == val &&
              abs(board[i + 2][j]) == val) {
            haveCrushes = true;
            for (int k = i; k < i + 3; ++k)
              board[k][j] = -val;
          }
        }

      if (haveCrushes) {
        // For each column, drop candies
        for (int j = 0; j < n; ++j) {
          int nextIndex = m - 1;
          for (int i = m - 1; i >= 0; --i)
            if (board[i][j] > 0)
              board[nextIndex--][j] = board[i][j];
          // Set board[0..nextIndex][j] to 0s
          for (int i = nextIndex; i >= 0; --i)
            board[i][j] = 0;
        }
      }
    }

    return board;
  }
};"
"class Solution(object):
    def addToArrayForm(self, A, K):
        """"""
        :type A: List[int]
        :type K: int
        :rtype: List[int]
        """"""
        A = int(''.join(map(str, A)))
        B = A + K
        C = list(map(int, str(B)))
        return C","class Solution {
 public:
  int pivotIndex(vector<int>& nums) {
    const int sum = accumulate(begin(nums), end(nums), 0);
    int prefix = 0;

    for (int i = 0; i < nums.size(); ++i) {
      if (prefix == sum - prefix - nums[i])
        return i;
      prefix += nums[i];
    }

    return -1;
  }
};"
"class Solution:
    def __init__(self):
        self.id_ = [i for i in range(26)]
    
    def find(self,x):
        while x != self.id_[x]:
            self.id_[x] = self.id_[self.id_[x]]
            x = self.id_[x]
        return x
    
    def union(self,x,y):
        x = self.find(x)
        y = self.find(y)
        self.id_[x] = self.id_[y]
    
    def equationsPossible(self, equations: List[str]) -> bool:
        for a,sign,_,b in equations:
            if sign == '=':
                self.union(ord(a)-97,ord(b)-97)
        for a,sign,_,b in equations:
            if sign == '!':
                if self.find(ord(a)-97) == self.find(ord(b)-97):
                    return False
        return True","class Solution {
 public:
  vector<ListNode*> splitListToParts(ListNode* root, int k) {
    vector<ListNode*> ans(k);
    const int length = getLength(root);
    const int subLength = length / k;
    int remainder = length % k;

    ListNode* prev = nullptr;
    ListNode* head = root;

    for (int i = 0; i < k; ++i, --remainder) {
      ans[i] = head;
      for (int j = 0; j < subLength + (remainder > 0); ++j) {
        prev = head;
        head = head->next;
      }
      if (prev != nullptr)
        prev->next = nullptr;
    }

    return ans;
  }

 private:
  int getLength(ListNode* root) {
    int length = 0;
    for (ListNode* curr = root; curr; curr = curr->next)
      ++length;
    return length;
  }
};"
"class Solution:
    def brokenCalc(self, X: int, Y: int) -> int:
        c = 0
        while Y>X:
            if Y%2: Y += 1
            else: Y //= 2     
            c += 1
        return c + (X - Y)","class Solution {
 public:
  string countOfAtoms(string formula) {
    string ans;
    int i = 0;

    for (const auto& [elem, freq] : parse(formula, i)) {
      ans += elem;
      if (freq > 1)
        ans += to_string(freq);
    }

    return ans;
  }

 private:
  map<string, int> parse(const string& s, int& i) {
    map<string, int> count;

    while (i < s.length())
      if (s[i] == '(') {
        for (const auto& [elem, freq] : parse(s, ++i))
          count[elem] += freq;
      } else if (s[i] == ')') {
        const int num = getNum(s, ++i);
        for (auto&& [_, freq] : count)
          freq *= num;
        return count;  // Returns back to previous scope
      } else {         // s[i] must be uppercased
        const string& elem = getElem(s, i);
        const int num = getNum(s, i);
        count[elem] += num;
      }

    return count;
  }

  string getElem(const string& s, int& i) {
    const int elemStart = i++;  // s[elemStart] is uppercased
    while (i < s.length() && islower(s[i]))
      ++i;
    return s.substr(elemStart, i - elemStart);
  }

  int getNum(const string& s, int& i) {
    const int numStart = i;
    while (i < s.length() && isdigit(s[i]))
      ++i;
    const string& numString = s.substr(numStart, i - numStart);
    return numString.empty() ? 1 : stoi(numString);
  }
};"
"class Solution:
    def atMostK(self, nums, k):
        good_count = 0
        counter = collections.Counter()
        
        begin = 0
        for end in range(len(nums)):
            if counter[nums[end]] == 0:
                k -= 1
            counter[nums[end]] += 1
            
            while k < 0:
                counter[nums[begin]] -= 1
                if counter[nums[begin]] == 0:
                    k += 1
                
                begin += 1
            
            good_count += end - begin + 1
        
        return good_count
            
    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        return self.atMostK(nums, k) - self.atMostK(nums, k - 1)","class Solution {
 public:
  string minWindow(string s1, string s2) {
    const int m = s2.length();
    const int n = s1.length();
    // dp[i][j] := start index (1-indexed) of the min window of s2[0..i] and
    // s1[0..j).
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    // Fill in placeholder values
    for (int j = 0; j <= n; ++j)
      dp[0][j] = j + 1;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (s2[i - 1] == s1[j - 1])
          dp[i][j] = dp[i - 1][j - 1];
        else
          dp[i][j] = dp[i][j - 1];

    int bestLeft = 0;
    int minLength = INT_MAX;

    for (int j = 1; j <= n; ++j)
      if (dp[m][j] > 0 && j - dp[m][j] + 1 < minLength) {
        bestLeft = dp[m][j] - 1;
        minLength = j - dp[m][j] + 1;
      }

    return minLength == INT_MAX ? """" : s1.substr(bestLeft, minLength);
  }
};"
"class Solution(object):
    def isCousins(self, root, x, y):
        """"""
        :type root: TreeNode
        :type x: int
        :type y: int
        :rtype: bool
        """"""
        def f(root, v, p):
            if root.val == v:
                _d = 1
                _p = p
                return _d, _p
            
            if root.left!=None:
                l_d, l_p = f(root.left, v, root.val)
                if l_d!=None:
                    return l_d+1, l_p
                
            if root.right!=None:
                r_d, r_p = f(root.right, v, root.val)
                if r_d!=None:
                    return r_d+1, r_p             
            return None, p
			
        _x = f(root, x, None)
        _y = f(root, y, None)
        return (_x[0] == _y[0]) and (_x[1] != _y[1])","class Solution {
 public:
  vector<int> selfDividingNumbers(int left, int right) {
    vector<int> ans;

    for (int num = left; num <= right; ++num)
      if (selfDividingNumbers(num))
        ans.push_back(num);

    return ans;
  }

 private:
  bool selfDividingNumbers(int num) {
    for (int n = num; n > 0; n /= 10)
      if (n % 10 == 0 || num % (n % 10) != 0)
        return false;
    return true;
  }
};"
"class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        # 0  =  means empty
        # 1  =  fresh orange
        # 2  =  rotten orange
        # every minute any every rotten orange infects its adjacent fresh orange
        # min no of minutes to make all rotten else -1
            
        fresh_oranges = 0
        rotten_oranges = []
        rows = len(grid)
        cols = len(grid[0])
        steps = 0
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 1:
                    fresh_oranges += 1
                elif grid[r][c] == 2:
                    rotten_oranges.append((r,c))
        if fresh_oranges == 0: return 0            
        while rotten_oranges:
            tmp = []
            while rotten_oranges:
                r,c = rotten_oranges.pop(0)
                paths = ((r+1,c),(r-1,c),(r,c+1),(r,c-1))
                for x,y in paths:
                    if 0<=x<rows and 0<=y<cols and grid[x][y] == 1:
                        grid[x][y] = 2
                        fresh_oranges -=1
                        if fresh_oranges == 0: return steps + 1
                        tmp.append((x,y))
            steps += 1
            rotten_oranges = tmp
        
        return -1","class MyCalendar {
 public:
  bool book(int start, int end) {
    for (const auto& [s, e] : timeline)
      if (max(start, s) < min(end, e))
        return false;
    timeline.emplace_back(start, end);
    return true;
  }

 private:
  vector<pair<int, int>> timeline;
};"
"class Solution:
    def minKBitFlips(self, nums: List[int], k: int) -> int:
        ans = flip = 0 
        queue = deque()
        for i, x in enumerate(nums):
            if queue and i == queue[0]: 
                flip ^= 1
                queue.popleft()
            if x == flip: 
                if len(nums) - i < k: return -1
                ans += 1
                flip ^= 1
                queue.append(i+k)
        return ans","class Solution {
 public:
  int countPalindromicSubsequences(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();

    // dp[i][j] := # of different non-empty palindromic subseqs in s[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j]) {
          int lo = i + 1;
          int hi = j - 1;
          while (lo <= hi && s[lo] != s[i])
            ++lo;
          while (lo <= hi && s[hi] != s[i])
            --hi;
          if (lo > hi)
            dp[i][j] = dp[i + 1][j - 1] * 2 + 2;
          else if (lo == hi)
            dp[i][j] = dp[i + 1][j - 1] * 2 + 1;
          else
            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1];
        } else {
          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1];
        }
        dp[i][j] = (dp[i][j] + kMod) % kMod;
      }

    return dp[0][n - 1];
  }
};"
"class Solution:
def numSquarefulPerms(self, A: List[int]) -> int:
     
    res = []
    visited = [0] * len(A)
    A.sort()
    def helper(nums,out, res):
        if len(out) == len(nums):
            res.append(out[:])
            return
        else:
             
            for i in range(len(A)):
                if visited[i]:
                    continue
                if i > 0 and A[i] == A[i-1] and visited[i -1]:
                    continue
                if len(out) >= 2 and (out[-1] +out[-2])**0.5 != int((out[-1] +out[-2])**0.5):
                    continue
                if len(out) >= 1 and (out[-1] +A[i])**0.5 != int((out[-1] +A[i])**0.5):
                    continue
                visited[i] = 1
                out.append(A[i])
                helper(nums,out, res)
                out.pop()
                visited[i] = 0
    helper(A,[], res)
    #print(res)
    return len(res)","class MyCalendarThree {
 public:
  int book(int start, int end) {
    ++timeline[start];
    --timeline[end];

    int ans = 0;
    int activeEvents = 0;

    for (const auto& [_, count] : timeline) {
      activeEvents += count;
      ans = max(ans, activeEvents);
    }

    return ans;
  }

 private:
  map<int, int> timeline;
};"
"class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        if n == 1:
            return 1
        
        d = {}
        trusted = set()
        
        for t in trust:
            if t[1] not in d:
                d[t[1]] = []
            d[t[1]].append(t[0])
            trusted.add(t[0])
        
        for key in d:
            if len(d[key]) == n - 1 and key not in trusted:
                return key
        
        return -1

class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        count = [0] * (n + 1)
        
        for t in trust:
            count[t[0]] -= 1
            count[t[1]] += 1
        
        for i in range(1, n + 1):
            if count[i] == n - 1:
                return i
        
        return -1","class Solution {
 public:
  vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc,
                                int newColor) {
    dfs(image, sr, sc,
        vector<vector<bool>>(image.size(), vector<bool>(image[0].size())),
        image[sr][sc], newColor);
    return image;
  }

 private:
  void dfs(vector<vector<int>>& image, int i, int j,
           vector<vector<bool>>&& seen, int startColor, int newColor) {
    if (i < 0 || i == image.size() || j < 0 || j == image[0].size())
      return;
    if (image[i][j] != startColor || seen[i][j])
      return;

    image[i][j] = newColor;
    seen[i][j] = true;

    dfs(image, i + 1, j, move(seen), startColor, newColor);
    dfs(image, i - 1, j, move(seen), startColor, newColor);
    dfs(image, i, j + 1, move(seen), startColor, newColor);
    dfs(image, i, j - 1, move(seen), startColor, newColor);
  }
};"
"class Solution:
    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:
        prev, node = None, root
        while node and val < node.val: prev, node = node, node.right
        
        temp = TreeNode(val, left=node)
        if prev: prev.right = temp 
        else: root = temp 
        return root","class Solution {
 public:
  bool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2,
                           vector<vector<string>>& similarPairs) {
    if (sentence1.size() != sentence2.size())
      return false;

    // map[key] := all similar words of key
    unordered_map<string, unordered_set<string>> map;

    for (const vector<string>& pair : similarPairs) {
      map[pair[1]].insert(pair[0]);
      map[pair[0]].insert(pair[1]);
    }

    for (int i = 0; i < sentence1.size(); ++i) {
      if (sentence1[i] == sentence2[i])
        continue;
      if (!map.count(sentence1[i]))
        return false;
      if (!map[sentence1[i]].count(sentence2[i]))
        return false;
    }

    return true;
  }
};"
"class Solution:
    def numRookCaptures(self, board: List[List[str]]) -> int:
        # At first find position of rook and save in 'iR' and 'jR' variables
        for i in range(len(board)):
            for j in range(len(board[i])):
                if board[i][j] == 'R':
                    iR = i
                    jR = j
        # find all first figures on line and row
        res = []
        for j in range(jR + 1, len(board)):
            if board[iR][j] != '.':
                res.append(board[iR][j])
                break
        for j in range(jR - 1, -1, -1):
            if board[iR][j] != '.':
                res.append(board[iR][j])
                break
        for i in range(iR + 1, len(board)):
            if board[i][jR] != '.':
                res.append(board[i][jR])
                break
        for i in range(iR - 1, -1, -1):
            if board[i][jR] != '.':
                res.append(board[i][jR])
                break
        # calculate how many pawns
        resCount = 0
        for i in range(len(res)):
            if res[i] == 'p':
                resCount += 1
        return resCount","class Solution {
 public:
  vector<int> asteroidCollision(vector<int>& asteroids) {
    vector<int> stack;

    for (const int a : asteroids)
      if (a > 0) {
        stack.push_back(a);
      } else {  // A < 0
        // Destroy previous positive one(s)
        while (!stack.empty() && stack.back() > 0 && stack.back() < -a)
          stack.pop_back();
        if (stack.empty() || stack.back() < 0)
          stack.push_back(a);
        else if (stack.back() == -a)
          stack.pop_back();  // Both explode
        else                 // Stack.back() > current
          ;                  // Destroy current, so do nothing
      }

    return stack;
  }
};"
"class Solution:
    @cache
    def dp(self, l, r, piles) -> int:
        if r - l < piles:
            return inf
        if r - l == piles:
            return 0
        if piles == 1:
            return self.dp(l, r, self.k) + self.prefix_sum[r] - self.prefix_sum[l]
        return min(self.dp(l, m, i) + self.dp(m, r, piles - i) for i in range(1, piles) for m in range(l+i, r-i+1))
            
    def mergeStones(self, stones: List[int], k: int) -> int:
        if (len(stones) - k) % (k - 1) != 0:
            return -1
        self.k = k
        self.prefix_sum = [0]
        for i in range(0, len(stones)):
            self.prefix_sum.append(self.prefix_sum[-1] + stones[i])
        return self.dp(0, len(stones), 1)","class Solution {
 public:
  int evaluate(string expression) {
    return evaluate(expression, unordered_map<string, int>());
  }

 private:
  int evaluate(const string& e, unordered_map<string, int> scope) {
    if (isdigit(e[0]) || e[0] == '-')
      return stoi(e);
    if (const auto it = scope.find(e); it != cend(scope))
      return it->second;

    const int spaceIndex = e.find_first_of(' ');
    const string nextExpression =
        e.substr(spaceIndex + 1, e.length() - spaceIndex - 2);  // -2: ""()""
    const vector<string> tokens = split(nextExpression);

    // Note that e[0] == '('
    if (e[1] == 'm')  // Mult
      return evaluate(tokens[0], scope) * evaluate(tokens[1], scope);
    if (e[1] == 'a')  // Add
      return evaluate(tokens[0], scope) + evaluate(tokens[1], scope);

    // Let
    for (int i = 0; i + 1 < tokens.size(); i += 2)
      scope[tokens[i]] = evaluate(tokens[i + 1], scope);
    return evaluate(tokens.back(), scope);
  };

  vector<string> split(const string& e) {
    vector<string> tokens;
    string s;
    int parenthesis = 0;

    for (const char c : e) {
      if (c == '(')
        ++parenthesis;
      else if (c == ')')
        --parenthesis;
      if (parenthesis == 0 && c == ' ') {
        tokens.push_back(s);
        s = """";
      } else {
        s += c;
      }
    }

    if (!s.empty())
      tokens.push_back(s);
    return tokens;
  }
};"
"class Solution:
def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:
    
    row,col,dig1,dig2 = defaultdict(int),defaultdict(int),defaultdict(int),defaultdict(int)
    
    def switch(i,j,isOn):
        val = 1 if isOn else -1
        row[i] += val
        col[j] += val
        dig1[i+j]+=val
        dig2[i-j]+=val
    
    def check(x,y):
        return 1 if row[x] or col[y] or dig1[x+y] or dig2[x-y] else 0
    
    seen = set()
    for x,y in set([tuple(lamp) for lamp in lamps]):
        seen.add((x,y))
        switch(x,y,1)
    
    res = []
    for x,y in queries:
        res.append(check(x,y))
        for dx,dy in [(0,0),(0,1),(0,-1),(1,0),(-1,0),(1,1),(-1,-1),(1,-1),(-1,1)]:
            if (x+dx,y+dy) in seen:
                seen.remove((x+dx,y+dy))
                switch(x+dx,y+dy,0)
    return res","class Solution {
 public:
  bool areSentencesSimilarTwo(vector<string>& words1, vector<string>& words2,
                              vector<vector<string>>& pairs) {
    if (words1.size() != words2.size())
      return false;

    // graph[key] := all similar words of key
    unordered_map<string, unordered_set<string>> graph;

    for (const vector<string>& pair : pairs) {
      graph[pair[1]].insert(pair[0]);
      graph[pair[0]].insert(pair[1]);
    }

    for (int i = 0; i < words1.size(); ++i) {
      if (words1[i] == words2[i])
        continue;
      if (!graph.count(words1[i]))
        return false;
      if (!dfs(graph, words1[i], words2[i], {}))
        return false;
    }

    return true;
  }

 private:
  bool dfs(const unordered_map<string, unordered_set<string>>& graph,
           const string& source, const string& target,
           unordered_set<string>&& seen) {
    if (graph.at(source).count(target))
      return true;

    seen.insert(source);

    for (const string& child : graph.at(source)) {
      if (seen.count(child))
        continue;
      if (dfs(graph, child, target, move(seen)))
        return true;
    }

    return false;
  }
};"
"class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        n = len(A)
        if n == 0:
            return []
        master = None
        
        for word in A:
            freq = get_freq(word)
            if master is None:
                master = freq
            else:
                master = get_new_master(master, freq)
        output = []
        for char in master:
            output = output + [char]*master[char]
        return output
                
def get_new_master(m, s):
    dict = {}
    for char in m:
        if char in s:
            if s[char] >= m[char]:
                dict[char] = m[char]
            else:
                dict[char] = s[char]
    return dict
        
def get_freq(word):
    dict = {}
    for char in word:
        if char in dict:
            dict[char]+=1
        else:
            dict[char] = 1
    return dict","class Solution {
 public:
  int monotoneIncreasingDigits(int n) {
    string s = to_string(n);
    const int n = s.length();
    int k = n;  // s[k:] -> '9'

    for (int i = n - 1; i > 0; --i)
      if (s[i] < s[i - 1]) {
        --s[i - 1];
        k = i;
      }

    for (int i = k; i < n; ++i)
      s[i] = '9';

    return stoi(s);
  }
};"
"class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s: 
            if c == ""c"" and stack[-2:] == [""a"", ""b""]:
                stack.pop()
                stack.pop()
            else: stack.append(c)
        return not stack","class Solution {
 public:
  vector<int> dailyTemperatures(vector<int>& temperatures) {
    vector<int> ans(temperatures.size());
    stack<int> stack;  // decreasing stack

    for (int i = 0; i < temperatures.size(); ++i) {
      while (!stack.empty() && temperatures[stack.top()] < temperatures[i]) {
        const int index = stack.top();
        stack.pop();
        ans[index] = i - index;
      }
      stack.push(i);
    }

    return ans;
  }
};"
"class Solution:
    def longestOnes(self, A: List[int], K: int) -> int:
        ans = ii = cnt = 0
        for i, x in enumerate(A):
            if not x: cnt += 1
            while ii <= i and cnt > K: 
                if not A[ii]: cnt -= 1
                ii += 1
            ans = max(ans, i - ii + 1)
        return ans","class Solution {
 public:
  int deleteAndEarn(vector<int>& nums) {
    // Reduce to 198. House Robber
    vector<int> bucket(10001);

    for (const int num : nums)
      bucket[num] += num;

    int prev1 = 0;
    int prev2 = 0;

    for (const int num : bucket) {
      const int dp = max(prev1, prev2 + num);
      prev2 = prev1;
      prev1 = dp;
    }

    return prev1;
  }
};"
"class Solution:
    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
        heapq.heapify(A)
        for i in range(K):
            heapq.heappush(A,-1 * heapq.heappop(A))
        return sum(A)","class Solution {
 public:
  int cherryPickup(vector<vector<int>>& grid) {
    // The problem is identical as two people start picking cherries
    // From grid[0][0] simultaneously
    n = grid.size();
    // dp[x1][y1][x2] := max cherries we could pick from
    // g[0][0] -> g[x1 - 1][y1 - 1] + g[0][0] -> g[x2 - 1][y2 - 1],
    // Where y2 = x1 + y1 - x2 (reduce states from 4 to 3)
    dp.resize(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, INT_MIN)));
    return max(0, cherryPickup(grid, 0, 0, 0));
  }

 private:
  int n;
  vector<vector<vector<int>>> dp;

  int cherryPickup(const vector<vector<int>>& grid, int x1, int y1, int x2) {
    const int y2 = x1 + y1 - x2;
    if (x1 == n || y1 == n || x2 == n || y2 == n)
      return -1;
    if (x1 == n - 1 && y1 == n - 1)
      return grid[x1][y1];
    if (grid[x1][y1] == -1 || grid[x2][y2] == -1)
      return -1;
    int& ans = dp[x1][y1][x2];
    if (ans > INT_MIN)
      return ans;

    ans = max({cherryPickup(grid, x1 + 1, y1, x2),
               cherryPickup(grid, x1 + 1, y1, x2 + 1),
               cherryPickup(grid, x1, y1 + 1, x2),
               cherryPickup(grid, x1, y1 + 1, x2 + 1)});
    if (ans == -1)
      return ans;

    ans += grid[x1][y1];  // Do pick some cherries
    if (x1 != x2)         // Two people are on different grids
      ans += grid[x2][y2];

    return ans;
  }
};"
"class Solution:
    def clumsy(self, n: int) -> int:
        if n == 1 or n == 2:
            return n
        if n >= 3:
            fact = n * (n - 1) // (n - 2)
            n -= 3
        while n - 4 >= 0:
            fact = fact + n - (n - 1) * (n - 2) // (n - 3)
            n -= 4
        if n > 0:
            fact += n
            n = n - 1
            if n > 0:
                fact -= n
                n = n- 1
        return fact","class Solution {
 public:
  int findClosestLeaf(TreeNode* root, int k) {
    int ans = -1;
    int minDist = 1000;
    // {node: distance to TreeNode(k)}
    unordered_map<TreeNode*, int> nodeToDist;

    getDists(root, k, nodeToDist);
    getClosestLeaf(root, 0, nodeToDist, minDist, ans);

    return ans;
  }

 private:
  void getDists(TreeNode* root, int k,
                unordered_map<TreeNode*, int>& nodeToDist) {
    if (root == nullptr)
      return;
    if (root->val == k) {
      nodeToDist[root] = 0;
      return;
    }

    getDists(root->left, k, nodeToDist);
    if (const auto it = nodeToDist.find(root->left); it != cend(nodeToDist)) {
      // The TreeNode(k) is in the left subtree
      nodeToDist[root] = it->second + 1;
      return;
    }

    getDists(root->right, k, nodeToDist);
    if (const auto it = nodeToDist.find(root->right); it != cend(nodeToDist))
      // The TreeNode(k) is in the right subtree
      nodeToDist[root] = it->second + 1;
  }

  void getClosestLeaf(TreeNode* root, int dist,
                      unordered_map<TreeNode*, int>& nodeToDist, int& minDist,
                      int& ans) {
    if (root == nullptr)
      return;
    if (nodeToDist.count(root))
      dist = nodeToDist[root];
    if (root->left == nullptr && root->right == nullptr) {  // Is leaf
      if (dist < minDist) {
        minDist = dist;
        ans = root->val;
      }
      return;
    }

    getClosestLeaf(root->left, dist + 1, nodeToDist, minDist, ans);
    getClosestLeaf(root->right, dist + 1, nodeToDist, minDist, ans);
  }
};"
"class Solution(object):
    def minDominoRotations(self, A, B):
        """"""
        :type A: List[int]
        :type B: List[int]
        :rtype: int
        """"""
        for x in range(1, 7):
            ca = cb = 0
            for i in range(len(A)):
                if A[i] != x and B[i] != x:
                    break
            else:
                for i in range(len(A)):
                    if A[i] != x:
                        ca += 1
                    if B[i] != x:
                        cb += 1
                return min(ca, cb)
        return -1","class Solution {
 public:
  int networkDelayTime(vector<vector<int>>& times, int n, int k) {
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& time : times) {
      const int u = time[0] - 1;
      const int v = time[1] - 1;
      const int w = time[2];
      graph[u].emplace_back(v, w);
    }

    return dijkstra(graph, k - 1);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src) {
    vector<int> dist(graph.size(), INT_MAX);
    using P = pair<int, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[src] = 0;
    minHeap.emplace(dist[src], src);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      for (const auto& [v, w] : graph[u])
        if (d + w < dist[v]) {
          dist[v] = d + w;
          minHeap.emplace(dist[v], v);
        }
    }

    const int maxDist = *max_element(begin(dist), end(dist));
    return maxDist == INT_MAX ? -1 : maxDist;
  }
};"
"class Solution:
    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        if not preorder:
            return None
        root = None
        for i in range(len(preorder)):
            node = preorder[i]
            root = self.handle(root, node)
        return root
        
    def handle(self, root, x):
        if not root:
            return TreeNode(x)
        if x < root.val:
            root.left = self.handle(root.left, x)
        else:
            root.right = self.handle(root.right, x)
        return root","class Solution {
 public:
  char nextGreatestLetter(vector<char>& letters, char target) {
    int l = 0;
    int r = letters.size();

    while (l < r) {
      const int m = (l + r) / 2;
      if (letters[m] > target)
        r = m;
      else
        l = m + 1;
    }

    return letters[l % letters.size()];
  }
};"
"class Solution:
    def bitwiseComplement(self, N: int) -> int:
        position_value = 1
        ret = 0
        
        
        if (N == 0):
            return 1
        
        
        while (N > 0):
            if (not N &amp; 1):
                ret += position_value
            
            N //= 2
            position_value *= 2
                     
        return ret","class WordFilter {
 public:
  WordFilter(vector<string>& words) {
    for (int i = 0; i < words.size(); ++i) {
      const string& word = words[i];
      vector<string> prefixes;
      vector<string> suffixes;
      for (int j = 0; j <= word.length(); ++j) {
        const string prefix = word.substr(0, j);
        const string suffix = word.substr(j);
        prefixes.push_back(prefix);
        suffixes.push_back(suffix);
      }
      for (const string& prefix : prefixes)
        for (const string& suffix : suffixes)
          keyToIndex[prefix + '_' + suffix] = i;
    }
  }

  int f(string prefix, string suffix) {
    const string key = prefix + '_' + suffix;
    if (const auto it = keyToIndex.find(key); it != cend(keyToIndex))
      return it->second;
    return -1;
  }

 private:
  unordered_map<string, int> keyToIndex;
};"
"class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        count=0
        d={}
        for i in time:
            k=i%60
            if k in d:
                d[k]+=[i]
            else:
                d[k]=[i]
        for i in d:
            if i==30 or i==0 :count+=int(((len(d[i])**2)-len(d[i]))//2)
            elif 60-i in d:
                count+=len(d[i])*len(d[60-i])
                d[i]=[]
                d[60-i]=[]
        return count","class Solution {
 public:
  int minCostClimbingStairs(vector<int>& cost) {
    const int n = cost.size();

    for (int i = 2; i < n; ++i)
      cost[i] += min(cost[i - 1], cost[i - 2]);

    return min(cost[n - 1], cost[n - 2]);
  }
};"
"class Solution:
    def shipWithinDays(self, weights: List[int], D: int) -> int:
        
        def canShip(capacity: int) -> bool:
            nonlocal D
            count = 1
            loaded = 0 
            for w in weights:
                if loaded + w <= capacity:
                    loaded += w
                else:
                    count += 1
                    loaded = w
            return count <= D
            
        
        maxWeight = max(weights)
        lo = sum(weights) // D
        hi = maxWeight * len(weights) // D + 1
        while lo < hi:
            mid = (lo + hi) // 2
            if mid < maxWeight or not canShip(mid):
                lo = mid + 1
            else:
                hi = mid
        return lo","class Solution {
 public:
  int dominantIndex(vector<int>& nums) {
    int ans;
    int max = 0;
    int secondMax = 0;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] > max) {
        secondMax = max;
        max = nums[i];
        ans = i;
      } else if (nums[i] > secondMax) {
        secondMax = nums[i];
      }

    return max >= 2 * secondMax ? ans : -1;
  }
};"
"class Solution:
    def numDupDigitsAtMostN(self, N: int) -> int:
    	T = [9,261,4725,67509,831429,9287109,97654149,994388229]
    	t = [99,999,9999,99999,999999,9999999,99999999,999999999]
    	if N < 10:
    		return 0
    	L = len(str(N))
    	m, n = [1], []
    	g = 11-L
    	for i in range(L):
    		n.append(int(str(N)[i]))
    		m.append(g)
    		g = g*(12-L+i)
    	S = 0
    	for i in range(L):
    		if len(set(n[:L-i-1])) != len(n)-i-1:
    			continue
    		k = 0
    		for j in range(10):
    			if j not in n[:L-i-1] and j > n[L-i-1]:
    				k += 1
    		S += k*m[i]
    	return(T[L-2]-(t[L-2]-N-S))
	
- Python 3
- Junaid Mansuri","class Solution {
 public:
  string shortestCompletingWord(string licensePlate, vector<string>& words) {
    string ans(16, '.');
    vector<int> count(26);

    for (const char c : licensePlate)
      if (isalpha(c))
        ++count[tolower(c) - 'a'];

    for (const string& word : words)
      if (word.length() < ans.length() && isComplete(count, getCount(word)))
        ans = word;

    return ans;
  }

 private:
  // Check if c1 is a subset of c2
  bool isComplete(const vector<int>& c1, const vector<int> c2) {
    for (int i = 0; i < 26; ++i)
      if (c1[i] > c2[i])
        return false;
    return true;
  }

  vector<int> getCount(const string& word) {
    vector<int> count(26);
    for (const char c : word)
      ++count[c - 'a'];
    return count;
  }
};"
"class Solution:
    def canThreePartsEqualSum(self, A):
        A += [0]
        sa = sum(A)
        saby3 = sa // 3
        sdum = 0
        count = 0
        x = 0
        for x in range(len(A)):
            sdum += A[x]
            if sdum == saby3:
                count += 1
                sdum = 0
            if count == 3:
                break
        if count == 3 and sum(A[x:1]) == 0:
            return True
        else:
            return False","struct Region {
  // Given m = # of rows and n = # of cols, (x, y) will be hashed as x * n + y
  unordered_set<int> infected;
  unordered_set<int> noninfected;  // Noninfected neighbors
  int wallsRequired = 0;
};

class Solution {
 public:
  int containVirus(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;

    while (true) {
      vector<Region> regions;
      vector<vector<bool>> seen(m, vector<bool>(n));

      for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
          if (grid[i][j] == 1 && !seen[i][j]) {
            Region region;
            dfs(grid, i, j, region, seen);  // Use DFS to find all regions (1s)
            if (!region.noninfected.empty())
              regions.push_back(region);
          }

      if (regions.empty())
        break;  // No region causes further infection

      // Region which infects most neighbors is in the back
      sort(begin(regions), end(regions), [](const auto& a, const auto& b) {
        return a.noninfected.size() < b.noninfected.size();
      });

      // Build walls around the region which infects most neighbors
      Region mostInfectedRegion = regions.back();
      regions.pop_back();
      ans += mostInfectedRegion.wallsRequired;

      for (const int neighbor : mostInfectedRegion.infected) {
        const int i = neighbor / n;
        const int j = neighbor % n;
        // The grid is now contained and won't be infected anymore
        grid[i][j] = 2;
      }

      // For remaining regions, expand (infect their neighbors)
      for (const Region& region : regions)
        for (const int neighbor : region.noninfected) {
          const int i = neighbor / n;
          const int j = neighbor % n;
          grid[i][j] = 1;
        }
    }

    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& grid, int i, int j, Region& region,
           vector<vector<bool>>& seen) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (seen[i][j] || grid[i][j] == 2)
      return;
    if (grid[i][j] == 0) {
      region.noninfected.insert(i * grid[0].size() + j);
      ++region.wallsRequired;
      return;
    }

    // grid[i][j] == 1
    seen[i][j] = true;
    region.infected.insert(i * grid[0].size() + j);

    dfs(grid, i + 1, j, region, seen);
    dfs(grid, i - 1, j, region, seen);
    dfs(grid, i, j + 1, region, seen);
    dfs(grid, i, j - 1, region, seen);
  }
};"
"class Solution:
    def maxScoreSightseeingPair(self, values: List[int]) -> int:
        prev, res = values[0], 0
        
        for i in range(1, len(values)):
            res = max(res, prev + values[i] - i)
            prev = max(prev, values[i] + i)
        
        return res","class Solution {
 public:
  int countCornerRectangles(vector<vector<int>>& grid) {
    int ans = 0;

    for (int row1 = 0; row1 < grid.size() - 1; ++row1)
      for (int row2 = row1 + 1; row2 < grid.size(); ++row2) {
        int count = 0;
        for (int j = 0; j < grid[0].size(); ++j)
          if (grid[row1][j] && grid[row2][j])
            ++count;
        ans += count * (count - 1) / 2;
      }

    return ans;
  }
};"
"class Solution:
    def smallestRepunitDivByK(self, K: int) -> int:
    	if K % 2 == 0 or K % 5 == 0: return -1
    	i = n = 1
    	while n % K != 0: n, i = (10*n + 1) % K, i + 1
    	return i
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  vector<string> ipToCIDR(string ip, int n) {
    vector<string> ans;
    long num = getNum(ip);

    while (n > 0) {
      const long lowbit = num & -num;
      const long count = lowbit == 0 ? maxLow(n) : firstFit(lowbit, n);
      ans.push_back(getCIDR(num, getPrefix(count)));
      n -= count;
      num += count;
    }

    return ans;
  }

 private:
  long getNum(const string& ip) {
    istringstream iss(ip);
    long num = 0;
    for (string token; getline(iss, token, '.');)
      num = num * 256 + stol(token);
    return num;
  }

  // Returns max i s.t. 2^i < n
  int maxLow(int n) {
    for (int i = 0; i < 32; ++i)
      if (1 << i + 1 > n)
        return 1 << i;
    throw;
  }

  long firstFit(long lowbit, long n) {
    while (lowbit > n)
      lowbit >>= 1;
    return lowbit;
  }

  string getCIDR(long num, long prefix) {
    const long d = num & 255;
    num >>= 8;
    const long c = num & 255;
    num >>= 8;
    const long b = num & 255;
    num >>= 8;
    const long a = num & 255;
    return to_string(a) + '.' + to_string(b) + '.' + to_string(c) + '.' +
           to_string(d) + '/' + to_string(prefix);
  }

  // E.g. count = 8 = 2^3 -> prefix = 32 - 3 = 29
  //      count = 1 = 2^0 -> prefix = 32 - 0 = 32
  int getPrefix(long count) {
    for (int i = 0; i < 32; ++i)
      if (count == 1 << i)
        return 32 - i;
    throw;
  }
};"
"class Solution:
    def queryString(self, S: str, N: int) -> bool:
        
        for i in range(1,N+1):
            x=str(bin(i).replace(""0b"", """"))
            
            if S.find(x)==-1:
                return False
            
        return True","class Solution {
 public:
  int openLock(vector<string>& deadends, string target) {
    unordered_set<string> seen{begin(deadends), end(deadends)};
    if (seen.count(""0000""))
      return -1;
    if (target == ""0000"")
      return 0;

    int ans = 0;
    queue<string> q{{""0000""}};

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        string word = q.front();
        q.pop();
        for (int i = 0; i < 4; ++i) {
          const char cache = word[i];
          // Increase i-th digit by 1
          word[i] = word[i] == '9' ? '0' : word[i] + 1;
          if (word == target)
            return ans;
          if (!seen.count(word)) {
            q.push(word);
            seen.insert(word);
          }
          word[i] = cache;
          // Decrease i-th digit by 1
          word[i] = word[i] == '0' ? '9' : word[i] - 1;
          if (word == target)
            return ans;
          if (!seen.count(word)) {
            q.push(word);
            seen.insert(word);
          }
          word[i] = cache;
        }
      }
    }

    return -1;
  }
};"
"class Solution:
    def baseNeg2(self, N: int) -> str:
        ans = []
        while N: 
            ans.append(N &amp; 1)
            N = -(N >> 1)
        return """".join(map(str, ans[::-1] or [0]))","class Solution {
 public:
  string crackSafe(int n, int k) {
    string ans(n, '0');
    dfs(pow(k, n), n, k, {ans}, ans);
    return ans;
  }

 private:
  bool dfs(int passwordSize, int n, int k, unordered_set<string>&& seen,
           string& path) {
    if (seen.size() == passwordSize)
      return true;

    string prefix = path.substr(path.length() - n + 1);

    for (char c = '0'; c < '0' + k; ++c) {
      prefix.push_back(c);
      if (!seen.count(prefix)) {
        seen.insert(prefix);
        path.push_back(c);
        if (dfs(passwordSize, n, k, move(seen), path))
          return true;
        path.pop_back();
        seen.erase(prefix);
      }
      prefix.pop_back();
    }

    return false;
  }
};"
"class Solution:
    def prefixesDivBy5(self, A: List[int]) -> List[bool]:
        
        state = 0
        answer = []
        for a in A:
            if a == 0:
                state = ( 2*state ) % 5
            else:
                state = ( 2*state+1 ) % 5
            answer.append(state==0)
        return answer","class Solution {
 public:
  int reachNumber(int target) {
    const int newTarget = abs(target);
    int ans = 0;
    int pos = 0;

    while (pos < newTarget)
      pos += ++ans;
    while ((pos - newTarget) & 1)
      pos += ++ans;

    return ans;
  }
};"
"class Solution:
    def nextLargerNodes(self, head: ListNode) -> List[int]:
        prev, node = None, head
        while node: node.next, node, prev = prev, node.next, node
        
        node = prev 
        ans, stack = [], []
        while node: 
            while stack and stack[-1] <= node.val: stack.pop()
            ans.append(stack[-1] if stack else 0)
            stack.append(node.val)
            node = node.next 
        return ans[::-1]","class Solution {
 public:
  vector<int> pourWater(vector<int>& heights, int volume, int k) {
    int i = k;

    while (volume-- > 0) {
      while (i > 0 && heights[i] >= heights[i - 1])
        --i;
      while (i + 1 < heights.size() && heights[i] >= heights[i + 1])
        ++i;
      while (i > k && heights[i] == heights[i - 1])
        --i;
      ++heights[i];
    }

    return heights;
  }
};"
"class Solution:
    
    # Generates all coordinates on boundaries
    def boundary_coordinates(self, grid):
        rows = len(grid)
        cols = len(grid[0])
        for row_index in range(rows):
            yield (row_index, 0) 
            yield (row_index, cols - 1)
        for col_index in range(1, cols - 1):
            yield (0, col_index)
            yield (rows - 1, col_index)
    
    # Returns a set of all 1's on boundaries.
    def ones_on_boundaries(self, grid):
        coordinates = self.boundary_coordinates(grid)
        return {(row, col) for row, col in coordinates if grid[row][col] == 1} 
    
    # Generates the neighbours of a given cell
    def get_neighbours(self, row, col, grid):
        if row > 0:
            yield (row - 1, col)
        if col > 0:
            yield (row, col - 1)
        if row < len(grid) - 1:
            yield (row + 1, col)
        if col < len(grid[0]) - 1:
            yield (row, col + 1)
    
    # Counts the number of enclaves.
    def numEnclaves(self, A: List[List[int]]) -> int:
        total_ones = sum([sum(row) for row in A])
        reachable_ones = 0
        visited = self.ones_on_boundaries(A)
        ones_reachable_on_boundary = list(visited)
        while ones_reachable_on_boundary:
            row, col = ones_reachable_on_boundary.pop()
            reachable_ones += 1
            for adj_row, adj_col in self.get_neighbours(row, col, A):
                if (adj_row, adj_col) not in visited and A[adj_row][adj_col] == 1:
                    visited.add((adj_row, adj_col))
                    ones_reachable_on_boundary.append((adj_row, adj_col))
        return total_ones - reachable_ones","class Solution {
 public:
  bool pyramidTransition(string bottom, vector<string>& allowed) {
    unordered_map<string, vector<char>> prefixToBlocks;

    for (const string& a : allowed)
      prefixToBlocks[a.substr(0, 2)].push_back(a[2]);

    return dfs(bottom, """", 0, prefixToBlocks);
  }

 private:
  bool dfs(const string& row, const string& nextRow, int i,
           const unordered_map<string, vector<char>>& prefixToBlocks) {
    if (row.length() == 1)
      return true;
    if (nextRow.length() + 1 == row.length())
      return dfs(nextRow, """", 0, prefixToBlocks);

    const string& prefix = row.substr(i, 2);

    if (const auto it = prefixToBlocks.find(prefix); it != cend(prefixToBlocks))
      for (const char c : it->second)
        if (dfs(row, nextRow + c, i + 1, prefixToBlocks))
          return true;

    return false;
  }
};"
"class Solution:
    def removeOuterParentheses(self, S: str) -> str:
        if not S:
            return ''
        # find the outmost Paretheses index
        opened = 0
        result = []
        left = 0
        for index,item in enumerate(S):
            opened += 1 if item == '(' else -1
            if opened == 0:
                result.append(S[left+1:index])
                left = index +1
                
        return """".join(result)","class Solution {
 public:
  int intersectionSizeTwo(vector<vector<int>>& intervals) {
    int ans = 0;
    int max = -1;
    int secondMax = -1;

    sort(begin(intervals), end(intervals), [](const auto& a, const auto& b) {
      return a[1] == b[1] ? a[0] > b[0] : a[1] < b[1];
    });

    for (const vector<int>& interval : intervals) {
      const int a = interval[0];
      const int b = interval[1];
      // Max and 2nd max still satisfy
      if (max >= a && secondMax >= a)
        continue;
      if (max >= a) {  // Max still satisfy
        secondMax = max;
        max = b;  // Add b to the set S
        ans += 1;
      } else {              // Max and 2nd max can't satisfy
        max = b;            // Add b to the set S
        secondMax = b - 1;  // Add b - 1 to the set S
        ans += 2;
      }
    }

    return ans;
  }
};"
"class Solution:
    def sumRootToLeaf(self, root: TreeNode) -> int:
        binaryNumbers = self.pathFinder(root)
        s = 0
        for num in binaryNumbers:
            s += int(num, 2)
        return s
    
    def pathFinder(self, root):
        if root is None:
            return []
        if root.left is None and root.right is None:
            return [str(root.val)]
        lp = self.pathFinder(root.left)
        rp = self.pathFinder(root.right)
        left = [str(root.val) + str(p) for p in lp]
        right = [str(root.val) + str(p) for p in rp]
        return left + right","class Solution {
 public:
  string boldWords(vector<string>& words, string s) {
    const int n = s.length();
    string ans;
    // bold[i] := true if s[i] should be bolded
    vector<bool> bold(n);

    int boldEnd = -1;  // s[i:boldEnd] should be bolded
    for (int i = 0; i < n; ++i) {
      for (const string& word : words)
        if (s.substr(i).find(word) == 0)  // StartsWith
          boldEnd = max(boldEnd, i + static_cast<int>(word.length()));
      bold[i] = boldEnd > i;
    }

    // Construct the string with bold tags
    int i = 0;
    while (i < n)
      if (bold[i]) {
        int j = i;
        while (j < n && bold[j])
          ++j;
        // s[i:j] should be bolded
        ans += ""<b>"" + s.substr(i, j - i) + ""</b>"";
        i = j;
      } else {
        ans += s[i++];
      }

    return ans;
  }
};"
"class Solution:
    def camelMatch(self, queries, pattern):
        return [Solution.match(q, pattern) for q in queries]

    @staticmethod
    def match(query, pattern):
        hit = []
        idx_start = 0

        for p in pattern:
            idx_find = query.find(p, idx_start)
            if idx_find == -1: return False

            for letter in query[idx_start:idx_find]:
                if letter.isupper(): return False

            hit.append(idx_find)
            idx_start = idx_find + 1

        for letter in query[idx_start:]:
            if letter.isupper(): return False

        return True","class Solution {
 public:
  vector<Interval> employeeFreeTime(vector<vector<Interval>> schedule) {
    vector<Interval> ans;
    vector<Interval> intervals;

    for (const vector<Interval>& s : schedule)
      intervals.insert(end(intervals), begin(s), end(s));

    sort(begin(intervals), end(intervals),
         [](const auto& a, const auto& b) { return a.start < b.start; });

    int prevEnd = intervals[0].end;

    for (const auto& [start, end] : intervals) {
      if (start > prevEnd)
        ans.emplace_back(prevEnd, start);
      prevEnd = max(prevEnd, end);
    }

    return ans;
  }
};"
"class Solution:
    def videoStitching(self, clips: List[List[int]], T: int) -> int:
        if not T: return 0 # edge case 
        
        ans = yy = mx = 0
        for x, y in sorted(clips):
            if mx < x: return -1 # gap 
            if yy < x <= mx: ans, yy = ans+1, mx
            mx = max(mx, y)
            if T <= mx: return ans + 1
        return -1 # not reaching T","class Solution {
 public:
  string makeLargestSpecial(string s) {
    vector<string> specials;
    int count = 0;

    for (int i = 0, j = 0; j < s.length(); ++j) {
      count += s[j] == '1' ? 1 : -1;
      if (count == 0) {  // Find a special string
        const string& inner = s.substr(i + 1, j - i - 1);
        specials.push_back('1' + makeLargestSpecial(inner) + '0');
        i = j + 1;
      }
    }

    sort(begin(specials), end(specials), greater<>());
    return join(specials);
  }

 private:
  string join(const vector<string>& specials) {
    string joined;
    for (const string& special : specials)
      joined += special;
    return joined;
  }
};"
"class Solution:
    winnums = []
    losenums = [1]
    
    def divisorGame(self, N: int) -> bool:
        if self.calcGame(N) >=0 :
            return True
        else:
            return False

    def calcGame(self, N):
        divisors = []
        
        if N in self.winnums:
            return 1
        if N in self.losenums:
            return -1

        for num in range(1,N):
            if N % num == 0:
                divisors.append(num)
        if len(divisors)==0:
            self.losenums.append(N)
            return -1

        
        for divisor in divisors:
            newNum = N-divisor
            profit = - self.calcGame(newNum)
            
            if profit == 0:
                continue
            if profit >= 0:
                self.winnums.append(N)
                return 1
       
        self.losenums.append(N)
        return -1","class Solution {
 public:
  int countPrimeSetBits(int L, int R) {
    // { 2, 3, 5, 7, 11, 13, 17, 19 }th bits are 1s
    // (10100010100010101100)2 = (665772)10
    constexpr int magic = 665772;
    int ans = 0;

    for (int n = L; n <= R; ++n)
      if (magic & 1 << __builtin_popcountll(n))
        ++ans;

    return ans;
  }
};"
"class Solution:
    def maxAncestorDiff(self, root: TreeNode) -> int:
        return self._max_ancestor_diff(root, root.val, root.val)

    def _max_ancestor_diff(self, root: TreeNode, max_ancestor_val: int, min_ancestor_val: int) -> int:
        if root is None:
            return 0
        return max(
            abs(max_ancestor_val - root.val),
            abs(min_ancestor_val - root.val),
            self._max_ancestor_diff(
                root.left, max(max_ancestor_val, root.val), min(min_ancestor_val, root.val)),
            self._max_ancestor_diff(
                root.right, max(max_ancestor_val, root.val), min(min_ancestor_val, root.val))
        )","class Solution {
 public:
  vector<int> partitionLabels(string s) {
    vector<int> ans;
    vector<int> rightmost(128);

    for (int i = 0; i < s.length(); ++i)
      rightmost[s[i]] = i;

    int l = 0;  // First index of current running string
    int r = 0;  // Right most so far

    for (int i = 0; i < s.length(); ++i) {
      r = max(r, rightmost[s[i]]);
      if (r == i) {
        ans.push_back(i - l + 1);
        l = i + 1;
      }
    }

    return ans;
  }
};"
"class Solution(object):
  def longestArithSeqLength(self, A):
    idx = collections.defaultdict(list)
    for i, v in enumerate(A):
      idx[v].append(i)
    c = {}
    ans = 0
    for k in range(len(A)):   # last
      for j in range(k):      # middle
        v = 2 * A[j] - A[k]   
        if v in idx:
          for i in idx[v]:    # list of first
            if i >= j: 
              break
            r = 1
            if (i, j) in c:
              r = max(r, c[i, j] + 1)
            ans = max(ans, r)
            c[j, k] = r
    return ans + 2","class Solution {
 public:
  int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {
    vector<vector<int>> grid(n, vector<int>(n, n));

    for (const vector<int>& mine : mines)
      grid[mine[0]][mine[1]] = 0;

    // Extend four directions, if meet 0, need to start over from 0
    for (int i = 0; i < n; ++i) {
      for (int j = 0, leftToRight = 0; j < n; ++j) {
        leftToRight = (grid[i][j] == 0 ? 0 : leftToRight + 1);
        grid[i][j] = min(grid[i][j], leftToRight);
      }
      for (int j = n - 1, rightToLeft = 0; j >= 0; --j) {
        rightToLeft = (grid[i][j] == 0 ? 0 : rightToLeft + 1);
        grid[i][j] = min(grid[i][j], rightToLeft);
      }
      for (int j = 0, upToDown = 0; j < n; ++j) {
        upToDown = (grid[j][i] == 0 ? 0 : upToDown + 1);
        grid[j][i] = min(grid[j][i], upToDown);
      }
      for (int j = n - 1, downToUp = 0; j >= 0; --j) {
        downToUp = (grid[j][i] == 0) ? 0 : downToUp + 1;
        grid[j][i] = min(grid[j][i], downToUp);
      }
    }

    int ans = 0;

    for (const vector<int>& row : grid)
      ans = max(ans, *max_element(begin(row), end(row)));

    return ans;
  }
};"
"class Solution:
    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:
        i = 0
        stack = []
        
        fake = TreeNode(0)
        stack.append(fake)
        
        while i < len(traversal):
            lvl = 0
            while i < len(traversal) and traversal[i] == '-':
                lvl += 1
                i += 1
            
            beg = i
            while i < len(traversal) and traversal[i] != '-':
                i += 1
            
            val = int(traversal[beg:i])
            
            while len(stack)  - 1 > lvl:
                stack.pop()
                
            children = TreeNode(val)
            node = stack[-1]
            
            if node.left == None:
                node.left = children
            else:
                node.right = children
            
            stack.append(children)
        
        return stack[0].left","class UnionFind {
 public:
  UnionFind(int n) : count(n), id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
    --count;
  }

  int getCount() const {
    return count;
  }

 private:
  int count;
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  int minSwapsCouples(vector<int>& row) {
    const int n = row.size() / 2;
    UnionFind uf(n);

    for (int i = 0; i < n; ++i) {
      const int a = row[2 * i];
      const int b = row[2 * i + 1];
      uf.unionByRank(a / 2, b / 2);
    }

    return n - uf.getCount();
  }
};"
"class Solution:
	def twoCitySchedCost(self, costs: List[List[int]]) -> int:
		res=0
		size=len(costs)/2
		CityA=0
		CityB=0
		costs=sorted(costs, key=lambda x:abs(x[0]-x[1]),reverse=True)
		for i in costs:
			if CityB<size and i[0]>=i[1]:
				res+=i[1]
				CityB+=1
			elif CityA<size and i[1]>=i[0]:
				res+=i[0]
				CityA+=1
			elif CityA==size:
				res+=i[1]
			elif CityB==size:
				res+=i[0]       
		return res","class Solution {
 public:
  bool isToeplitzMatrix(vector<vector<int>>& matrix) {
    for (int i = 0; i + 1 < matrix.size(); ++i)
      for (int j = 0; j + 1 < matrix[0].size(); ++j)
        if (matrix[i][j] != matrix[i + 1][j + 1])
          return false;
    return true;
  }
};"
"class Solution:
    def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:
        res = []
        for r in range(0, R):
            for c in range(0, C):
                res.append([r,c])
        return sorted(res, key=lambda x: abs(x[0] - r0) + abs(x[1] - c0))","class Solution {
 public:
  string reorganizeString(string s) {
    unordered_map<char, int> count;
    int maxFreq = 0;

    for (const char c : s)
      maxFreq = max(maxFreq, ++count[c]);

    if (maxFreq > (s.length() + 1) / 2)
      return """";

    string ans;
    priority_queue<pair<int, char>> maxHeap;  // (freq, c)
    int prevFreq = 0;
    char prevChar = '@';

    for (const auto& [c, freq] : count)
      maxHeap.emplace(freq, c);

    while (!maxHeap.empty()) {
      // Get the most freq letter
      const auto [freq, c] = maxHeap.top();
      maxHeap.pop();
      ans += c;
      // Add the previous letter back so that
      // Any two adjacent characters are not the same
      if (prevFreq > 0)
        maxHeap.emplace(prevFreq, prevChar);
      prevFreq = freq - 1;
      prevChar = c;
    }

    return ans;
  }
};"
"class Solution:
    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
        if L<M:
            L,M=M,L
        res=-float('inf')
        for i in range(len(A)-L+1):
            temp1=sum(A[i:i+L])
            #if left
            if i>=M:
                for j in range(i-M+1):
                    t2=sum(A[j:j+M])
                    res=max(res,temp1+t2)
            #if right
            if len(A)-i-L>=M:
                for j in range(i+L,len(A)):
                    t2=sum(A[j:j+M])
                    res=max(res,temp1+t2)
        return res","class Solution {
 public:
  int maxChunksToSorted(vector<int>& arr) {
    const int n = arr.size();
    int ans = 0;
    vector<int> maxL(n);  // l[i] := max(arr[0..i])
    vector<int> minR(n);  // r[i] := min(arr[i..n))

    for (int i = 0; i < n; ++i)
      maxL[i] = i == 0 ? arr[i] : max(arr[i], maxL[i - 1]);

    for (int i = n - 1; i >= 0; --i)
      minR[i] = i == n - 1 ? arr[i] : min(arr[i], minR[i + 1]);

    for (int i = 0; i + 1 < n; ++i)
      if (maxL[i] <= minR[i + 1])
        ++ans;

    return ans + 1;
  }
};"
"class Solution:
    def numMovesStones(self, a: int, b: int, c: int) -> List[int]:
        a,b,c = sorted([a,b,c])
        d1 = abs(b-a)-1 
        d2 = abs(c-b)-1
        mi = 2
        if d1 == 0 and d2 == 0: mi = 0
        elif d1 <= 1 or d2 <= 1: mi =1    
        ma = c - a - 2
        return [mi,ma]","class Solution {
 public:
  int maxChunksToSorted(vector<int>& arr) {
    int ans = 0;
    int maxi = INT_MIN;

    for (int i = 0; i < arr.size(); ++i) {
      maxi = max(maxi, arr[i]);
      if (maxi == i)
        ++ans;
    }

    return ans;
  }
};"
"class Solution:
    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        orig = grid[r0][c0]
        seen = {(r0, c0)}
        stack = [(r0, c0)]
        while stack: 
            i, j = stack.pop()
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if (ii, jj) not in seen:
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == orig: 
                        stack.append((ii, jj))
                        seen.add((ii, jj))
                    else: grid[i][j] = color 
        return grid","class Poly {
  friend Poly operator+(const Poly& lhs, const Poly& rhs) {
    Poly res(lhs);
    for (const auto& [term, coef] : rhs.terms)
      res.terms[term] += coef;
    return res;
  }

  friend Poly operator-(const Poly& lhs, const Poly& rhs) {
    Poly res(lhs);
    for (const auto& [term, coef] : rhs.terms)
      res.terms[term] -= coef;
    return res;
  }

  friend Poly operator*(const Poly& lhs, const Poly& rhs) {
    Poly res;
    for (const auto& [a, aCoef] : lhs.terms)
      for (const auto& [b, bCoef] : rhs.terms)
        res.terms[merge(a, b)] += aCoef * bCoef;
    return res;
  }

  // Friend ostream& operator<<(ostream& os, const Poly& poly) {
  //   os << ""{"";
  //   for (const auto& [term, coef] : poly.terms)
  //     os << term << "": "" << coef << "", "";
  //   os << ""}"";
  //   return os;
  // }

 public:
  vector<string> toList() {
    vector<string> res;
    vector<string> keys;
    for (const auto& [term, _] : terms)
      keys.push_back(term);
    sort(begin(keys), end(keys), [&](const auto& a, const auto& b) {
      // Smallest degree is the last
      if (a == ""1"")
        return false;
      if (b == ""1"")
        return true;
      const vector<string> as = split(a, '*');
      const vector<string> bs = split(b, '*');
      // Largest degree is the first
      // Breaking ties by lexicographic order
      return as.size() == bs.size() ? a < b : as.size() > bs.size();
    });
    auto concat = [&](const string& term) -> string {
      if (term == ""1"")
        return to_string(terms[term]);
      return to_string(terms[term]) + '*' + term;
    };
    for (const string& key : keys)
      if (terms[key])
        res.push_back(concat(key));
    return res;
  }

  Poly() = default;
  Poly(const string& term, int coef) {
    terms[term] = coef;
  }

 private:
  unordered_map<string, int> terms;

  // E.g. merge(""a*b"", ""a*c"") -> ""a*a*b*c""
  static string merge(const string& a, const string& b) {
    if (a == ""1"")
      return b;
    if (b == ""1"")
      return a;
    string res;
    vector<string> A = split(a, '*');
    vector<string> B = split(b, '*');
    int i = 0;  // A's index
    int j = 0;  // B's index
    while (i < A.size() && j < B.size())
      if (A[i] < B[j])
        res += '*' + A[i++];
      else
        res += '*' + B[j++];
    while (i < A.size())
      res += '*' + A[i++];
    while (j < B.size())
      res += '*' + B[j++];
    return res.substr(1);
  }

  static vector<string> split(const string& token, char c) {
    vector<string> vars;
    istringstream iss(token);
    for (string var; getline(iss, var, c);)
      vars.push_back(var);
    return vars;
  }
};

class Solution {
 public:
  vector<string> basicCalculatorIV(string expression, vector<string>& evalvars,
                                   vector<int>& evalints) {
    vector<string> tokens = getTokens(expression);
    unordered_map<string, int> evalMap;

    for (int i = 0; i < evalvars.size(); ++i)
      evalMap[evalvars[i]] = evalints[i];

    for (string& token : tokens)
      if (const auto it = evalMap.find(token); it != cend(evalMap))
        token = to_string(it->second);

    const vector<string>& postfix = infixToPostfix(tokens);
    return evaluate(postfix).toList();
  }

 private:
  vector<string> getTokens(const string& s) {
    vector<string> tokens;
    int i = 0;
    for (int j = 0; j < s.length(); ++j)
      if (s[j] == ' ') {
        if (i < j)
          tokens.push_back(s.substr(i, j - i));
        i = j + 1;
      } else if (string(""()+-*"").find(s[j]) != string::npos) {
        if (i < j)
          tokens.push_back(s.substr(i, j - i));
        tokens.push_back(s.substr(j, 1));
        i = j + 1;
      }
    if (i < s.length())
      tokens.push_back(s.substr(i));
    return tokens;
  }

  bool isOperator(const string& token) {
    return token == ""+"" || token == ""-"" || token == ""*"";
  }

  vector<string> infixToPostfix(const vector<string>& tokens) {
    vector<string> postfix;
    stack<string> ops;

    auto precedes = [](const string& prevOp, const string& currOp) -> bool {
      if (prevOp == ""("")
        return false;
      return prevOp == ""*"" || currOp == ""+"" || currOp == ""-"";
    };

    for (const string& token : tokens)
      if (token == ""("") {
        ops.push(token);
      } else if (token == "")"") {
        while (ops.top() != ""("")
          postfix.push_back(ops.top()), ops.pop();
        ops.pop();
      } else if (isOperator(token)) {
        while (!ops.empty() && precedes(ops.top(), token))
          postfix.push_back(ops.top()), ops.pop();
        ops.push(token);
      } else {  // IsOperand(token)
        postfix.push_back(token);
      }

    while (!ops.empty())
      postfix.push_back(ops.top()), ops.pop();

    return postfix;
  }

  Poly evaluate(const vector<string>& postfix) {
    vector<Poly> polys;
    for (const string& token : postfix)
      if (isOperator(token)) {
        const Poly b = polys.back();
        polys.pop_back();
        const Poly a = polys.back();
        polys.pop_back();
        if (token == ""+"")
          polys.push_back(a + b);
        else if (token == ""-"")
          polys.push_back(a - b);
        else  // Token == ""*""
          polys.push_back(a * b);
      } else if (token[0] == '-' || all_of(begin(token), end(token),
                                           [](char c) { return isdigit(c); })) {
        polys.push_back(Poly(""1"", stoi(token)));
      } else {
        polys.push_back(Poly(token, 1));
      }
    return polys[0];
  }
};"
"class Solution:
    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:
        ans = [0]*(1 + len(B))
        for i in reversed(range(len(A))): 
            tmp = ans.copy()
            for j in reversed(range(len(B))): 
                if A[i] == B[j]: ans[j] = 1 + tmp[j+1]
                else: ans[j] = max(tmp[j], ans[j+1])
        return ans[0]","class Solution {
 public:
  int numJewelsInStones(string jewels, string stones) {
    int ans = 0;
    unordered_set<char> jewelsSet(begin(jewels), end(jewels));

    for (const char stone : stones)
      if (jewelsSet.count(stone))
        ++ans;

    return ans;
  }
};"
"class Solution:
    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
        blocked = set(map(tuple, blocked))
        
        def dfs(sx, sy, tx, ty): 
            """"""Return True if (x, y) is not looped from (tx, ty).""""""
            seen = {(sx, sy)}
            stack = [(sx, sy)]
            while stack: 
                x, y = stack.pop()
                if abs(x - sx) + abs(y - sy) > 200 or (x, y) == (tx, ty): return True 
                for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): 
                    if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: 
                        seen.add((xx, yy))
                        stack.append((xx, yy))
            return False 
        
        return dfs(*source, *target) and dfs(*target, *source)","class Solution {
 public:
  int calculate(string s) {
    stack<int> nums;
    stack<int> ops;
    bool hasPrevNum = false;

    auto calc = [&]() {
      const int b = nums.top();
      nums.pop();
      const int a = nums.top();
      nums.pop();
      const char op = ops.top();
      ops.pop();
      if (op == '+')
        nums.push(a + b);
      else if (op == '-')
        nums.push(a - b);
      else if (op == '*')
        nums.push(a * b);
      else  // Op == '/'
        nums.push(a / b);
    };

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (isdigit(c)) {
        int num = c - '0';
        while (i + 1 < s.length() && isdigit(s[i + 1]))
          num = num * 10 + (s[i++ + 1] - '0');
        nums.push(num);
        hasPrevNum = true;
      } else if (c == '(') {
        ops.push('(');
        hasPrevNum = false;
      } else if (c == ')') {
        while (ops.top() != '(')
          calc();
        ops.pop();  // Pop '('
      } else if (c == '+' || c == '-' || c == '*' || c == '/') {
        if (!hasPrevNum)
          nums.push(0);
        while (!ops.empty() && precedes(ops.top(), c))
          calc();
        ops.push(c);
      }
    }

    while (!ops.empty())
      calc();

    return nums.top();
  }

 private:
  // Returns true if prevOp is a operator and
  // Priority(prevOp) >= priority(currOp)
  bool precedes(char prevOp, char currOp) {
    if (prevOp == '(')
      return false;
    return prevOp == '*' || prevOp == '/' || currOp == '+' || currOp == '-';
  }
};"
"class Solution:
    def isBoomerang(self, p: List[List[int]]) -> bool:
        return (p[2][1]-p[1][1])*(p[1][0]-p[0][0]) != (p[2][0]-p[1][0])*(p[1][1]-p[0][1])
		
		
- Junaid Mansuri","class Solution {
 public:
  int slidingPuzzle(vector<vector<int>>& board) {
    constexpr int m = 2;
    constexpr int n = 3;
    const vector<int> dirs{0, 1, 0, -1, 0};
    const string goal = ""123450"";
    int steps = 0;
    string start;

    // Hash 2D vector to string
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        start += '0' + board[i][j];

    if (start == goal)
      return 0;

    queue<string> q{{start}};
    unordered_set<string> seen{start};

    while (!q.empty()) {
      ++steps;
      for (int sz = q.size(); sz > 0; --sz) {
        string s = q.front();
        q.pop();
        const int zeroIndex = s.find('0');
        const int i = zeroIndex / n;
        const int j = zeroIndex % n;
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          const int swappedIndex = x * n + y;
          swap(s[zeroIndex], s[swappedIndex]);
          if (s == goal)
            return steps;
          if (!seen.count(s)) {
            q.push(s);
            seen.insert(s);
          }
          swap(s[zeroIndex], s[swappedIndex]);
        }
      }
    }

    return -1;
  }
};"
"class Solution:
    def bstToGst(self, root: TreeNode) -> TreeNode:
        
        def fn(node, val):
            """"""Return updated node's value.""""""
            if node.right: val = fn(node.right, val)
            node.val = val = node.val + val
            if node.left: val = fn(node.left, val)
            return val 
            
        fn(root, 0)
        return root","class Solution {
 public:
  double minmaxGasDist(vector<int>& stations, int k) {
    constexpr double kErr = 1e-6;
    double l = 0;
    double r = stations.back() - stations[0];

    while (r - l > kErr) {
      const double m = (l + r) / 2;
      if (check(stations, k, m))
        r = m;
      else
        l = m;
    }

    return l;
  }

 private:
  // Returns true if can use k or less gas stations to ensure that each adjacent
  // distance between gas stations is at most m.
  bool check(const vector<int>& stations, int k, double m) {
    for (int i = 1; i < stations.size(); ++i) {
      const int diff = stations[i] - stations[i - 1];
      if (diff > m) {
        k -= ceil(diff / m) - 1;
        if (k < 0)
          return false;
      }
    }
    return true;
  };
};"
"class Solution:
    def recursion(self,start,end):
        if start >= end :
            return 0
        
        if self.dp[start][end] != -1 : return self.dp[start][end]

        best = float('inf')
        
        for mid in range(start,end):
            tmp = self.recursion(start,mid) + self.recursion(mid+1,end) + \
            self.values[start-1]*self.values[mid]*self.values[end]
            if tmp < best: best = tmp
        
        self.dp[start][end] = best
        return best
    
    def minScoreTriangulation(self, values: List[int]) -> int:
        n = len(values)
        self.dp = [[-1 for i in range(n)] for j in range(n)]
        self.values = values
        return self.recursion(1,n-1)","class Solution {
 public:
  bool isIdealPermutation(vector<int>& nums) {
    int maxi = -1;  // The most likely to be greater than nums[i + 2].

    for (int i = 0; i + 2 < nums.size(); ++i) {
      maxi = max(maxi, nums[i]);
      if (maxi > nums[i + 2])
        return false;
    }

    return true;
  }
};"
"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        high = max(stones[-1] - stones[1], stones[-2] - stones[0]) - (len(stones) - 2)
        
        ii, low = 0, inf
        for i in range(len(stones)): 
            while stones[i] - stones[ii] >= len(stones): ii += 1
            if i - ii + 1 == stones[i] - stones[ii] + 1 == len(stones) - 1: low = min(low, 2)
            else: low = min(low, len(stones) - (i - ii + 1))
        return [low, high]","class Solution {
 public:
  vector<TreeNode*> splitBST(TreeNode* root, int target) {
    if (root == nullptr)
      return {nullptr, nullptr};
    if (root->val > target) {
      const vector<TreeNode*> res = splitBST(root->left, target);
      root->left = res[1];
      return {res[0], root};
    } else {  // root.val <= target
      const vector<TreeNode*> res = splitBST(root->right, target);
      root->right = res[0];
      return {root, res[1]};
    }
  }
};"
"class Solution:
    def isRobotBounded(self, instructions: str) -> bool:
       
        # Dictionary, which outputs change in direction
        # given the current direction and instruction
        directions = {0: {""G"": 0, ""L"": 3, ""R"": 1}, # North
                      1: {""G"": 1, ""L"": 0, ""R"": 2}, # East
                      2: {""G"": 2, ""L"": 1, ""R"": 3}, # South
                      3: {""G"": 3, ""L"": 2, ""R"": 0}} # West
        
        # Start position
        start = (0,0) # (x,y)
        
        # Function which will run robot once
        def moveRobot(curr, direction):
            
            # Loop for each instruction
            for instruction in instructions:
                
                # Set position
                if instruction == ""G"":
                    if direction == 0: # North
                        curr = (curr[0],curr[1]+1)
                    elif direction == 1: # East
                        curr = (curr[0]+1,curr[1])
                    elif direction == 2: # South
                        curr = (curr[0],curr[1]-1)
                    elif direction == 3: # West
                        curr = (curr[0]-1,curr[1])
                    else:
                        pass

                # Set direction
                direction = directions[direction][instruction]
                
            return (curr, direction)
        
		# Move robot from start position and pointing to North
        curr, direction = moveRobot(start,0)
        
        # Case 1:
        # If robot return to start then it won't leave a cetrain area
        if (curr == start):
            return True
        
        # Case 2:
        # If robot is not pointing towards north, it means it has changed
        # direction, so in next iteration it will change direction again,
        # and in next iteration again, and so on, so it will remain it
        # a certain bounded area no matter what.
        if (direction != 0):
            return True
        
        return False","class Solution {
 public:
  bool canTransform(string start, string end) {
    if (removeX(start) != removeX(end))
      return false;

    int i = 0;  // start's index
    int j = 0;  // end's index

    while (i < start.length() && j < end.length()) {
      while (i < start.length() && start[i] == 'X')
        ++i;
      while (j < end.length() && end[j] == 'X')
        ++j;
      if (i == start.length() && j == end.length())
        return true;
      if (i == start.length() || j == end.length())
        return false;
      if (start[i] == 'L' && i < j)
        return false;
      if (start[i] == 'R' && i > j)
        return false;
      ++i;
      ++j;
    }

    return true;
  }

 private:
  string removeX(const string& s) {
    string t = s;
    t.erase(remove(begin(t), end(t), 'X'), end(t));
    return t;
  }
};"
"class Solution:
    def gardenNoAdj(self, n: int, paths: List[List[int]]) -> List[int]:
        # n gardens 1 to n
        # paths [x,y] bidirectional path between garden x and y
        # in each garden plant one of 4 types of flowers
        # at most 3 paths coming into or leaving it
        # choose flower type -> any two gardens connected by path have different flowers
        # return any choice of answers : answer[i] = flower in (i+1)th garden
        
        nodes = [x for x in range(n)]
        colour = [None]*n
        edges = {x:{} for x in range(n)}
        for x,y in paths:
            edges[x-1][y-1] = True
            edges[y-1][x-1] = True
        for node in range(n):
            adj = edges[node]
            blocked = [False]*n
            size = 4
            for x in adj:
                if colour[x] != None:blocked[colour[x]-1] = True
            if blocked[0] == False:
                colour[node] = 1
            elif blocked[1] == False:
                colour[node] = 2
            elif blocked[2] == False:
                colour[node] = 3
            elif blocked[3] == False:
                 colour[node] = 4
        return colour","class Solution {
 public:
  int swimInWater(vector<vector<int>>& grid) {
    const int n = grid.size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = grid[0][0];
    using T = tuple<int, int, int>;  // (grid[i][j], i, j)
    priority_queue<T, vector<T>, greater<>> minHeap;
    vector<vector<bool>> seen(n, vector<bool>(n));

    minHeap.emplace(grid[0][0], 0, 0);
    seen[0][0] = true;

    while (!minHeap.empty()) {
      const auto [height, i, j] = minHeap.top();
      minHeap.pop();
      ans = max(ans, height);
      if (i == n - 1 && j == n - 1)
        break;
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == n || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        minHeap.emplace(grid[x][y], x, y);
        seen[x][y] = true;
      }
    }

    return ans;
  }
};"
"class Solution:
    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:
        
        @lru_cache(None)
        def fn(i):
            """"""Return maximum sum of arr[:i].""""""
            if i == 0: return 0 # boundary condition 
            ans = 0
            for kk in range(1, min(i, k)+1): 
                ans = max(ans, fn(i-kk) + max(arr[ii] for ii in range(i-kk, i)) * kk)
            return ans 
        
        return fn(len(arr))","class Solution {
 public:
  int kthGrammar(int n, int k) {
    if (n == 1)
      return 0;
    if (k & 1)
      return kthGrammar(n - 1, (k + 1) / 2) != 0;  // Left node
    return kthGrammar(n - 1, k / 2) == 0;          // Right node
  }
};"
"class Solution:
    def longestDupSubstring(self, s: str) -> str:
        results = set()
        window = len(s)//2
        largest = """"
        while window > len(largest):
            for right in range(window, len(s)+1):
                substr = s[right-window:right]
                if substr in results:
                    if len(substr) > len(largest):
                        largest = substr
                        window += (len(s)-window)//2+1
                        results.clear()
                        continue
                else:
                    results.add(substr)
            else:
                if window == len(largest) + 1:
                    break
                window = max(window//2, len(largest)+1)
        return largest","class Solution {
 public:
  bool reachingPoints(int sx, int sy, int tx, int ty) {
    while (sx < tx && sy < ty)
      if (tx > ty)
        tx %= ty;
      else
        ty %= tx;

    return sx == tx && sy <= ty && (ty - sy) % sx == 0 ||
           sy == ty && sx <= tx && (tx - sx) % sy == 0;
  }
};"
"class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        for i, stone in enumerate(stones):
            stones[i] = -stone
        heapq.heapify(stones)

        while len(stones) > 1:
            y, x = heapq.heappop(stones), heapq.heappop(stones)
            if x != y:
                heapq.heappush(stones, y - x)
        
        return -stones[0] if stones else 0","class Solution {
 public:
  int numRabbits(vector<int>& answers) {
    int ans = 0;
    vector<int> count(1000);

    for (const int answer : answers) {
      if (count[answer] % (answer + 1) == 0)
        ans += answer + 1;
      ++count[answer];
    }

    return ans;
  }
};"
"class Solution:
    def removeDuplicates(self, s: str) -> str:
        stack = []
        for char in s:
            if stack:
                # check if last element in stack
                # equals current char
                if char == stack[-1]:
                    stack.pop()
                    continue
                else:
                    stack.append(char)
            else:
                stack.append(char)

        return """".join(stack)","class Solution {
 public:
  int movesToChessboard(vector<vector<int>>& board) {
    const int n = board.size();
    int rowSum = 0;
    int colSum = 0;
    int rowSwaps = 0;
    int colSwaps = 0;

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j] == 1)
          return -1;

    for (int i = 0; i < n; ++i) {
      rowSum += board[0][i];
      colSum += board[i][0];
    }

    if (rowSum != n / 2 && rowSum != (n + 1) / 2)
      return -1;
    if (colSum != n / 2 && colSum != (n + 1) / 2)
      return -1;

    for (int i = 0; i < n; ++i) {
      rowSwaps += board[i][0] == (i & 1);
      colSwaps += board[0][i] == (i & 1);
    }

    if (n & 1) {
      if (rowSwaps & 1)
        rowSwaps = n - rowSwaps;
      if (colSwaps & 1)
        colSwaps = n - colSwaps;
    } else {
      rowSwaps = min(rowSwaps, n - rowSwaps);
      colSwaps = min(colSwaps, n - colSwaps);
    }

    return (rowSwaps + colSwaps) / 2;
  }
};"
"class Solution:
    def longestStrChain(self, words: List[str]) -> int:
        words.sort(key = lambda x : len(x))
        dis_map = collections.defaultdict(int)
        for w in words:
            maybe = [w[:i] + w[i + 1:] for i in range(len(w))]
            for m in maybe:
                dis_map[w] = max(dis_map[m] + 1, dis_map[w])
        return max(dis_map.values())","class Solution {
 public:
  int minDiffInBST(TreeNode* root) {
    int ans = INT_MAX;
    inorder(root, ans);
    return ans;
  }

 private:
  int pred = -1;

  void inorder(TreeNode* root, int& ans) {
    if (root == nullptr)
      return;

    inorder(root->left, ans);
    if (pred >= 0)
      ans = min(ans, root->val - pred);
    pred = root->val;
    inorder(root->right, ans);
  }
};"
"class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        if len(stones) == 1:
            return stones[0]
        
        S = sum(stones)
        half = sum(stones) // 2
        
        mat = [False for _ in range(half+1)]
        
        for i in stones:
            arr = []
            for j in range(len(mat)):
                if j == i:
                    arr.append(i)
                elif i < j and not mat[j] and mat[j-i]:
                    arr.append(j)
            for x in arr: # simultaneous update
                mat[x] = True
        
        s2 = max([i for i in range(len(mat)) if mat[i]])
        return abs(S-2*s2)","class Solution {
 public:
  vector<string> letterCasePermutation(string s) {
    vector<string> ans;
    dfs(s, 0, ans);
    return ans;
  }

 private:
  void dfs(string& s, int i, vector<string>& ans) {
    if (i == s.length()) {
      ans.push_back(s);
      return;
    }
    if (isdigit(s[i])) {
      dfs(s, i + 1, ans);
      return;
    }

    s[i] = tolower(s[i]);
    dfs(s, i + 1, ans);
    s[i] = toupper(s[i]);
    dfs(s, i + 1, ans);
  }
};"
"class Solution(object):
    def heightChecker(self, heights):
        """"""
        :type heights: List[int]
        :rtype: int
        """"""
        count =0
        k =heights[:]
        heights.sort()
        for i in range(len(heights)):
            if heights[i] != k[i]:
                count +=1
        return count","enum class Color { kWhite, kRed, kGreen };

class Solution {
 public:
  bool isBipartite(vector<vector<int>>& graph) {
    vector<Color> colors(graph.size(), Color::kWhite);

    for (int i = 0; i < graph.size(); ++i) {
      // Already colored, do nothing
      if (colors[i] != Color::kWhite)
        continue;
      // colors[i] == Color::kWhite
      colors[i] = Color::kRed;  // Always paint w/ Color::kRed
      // BFS
      queue<int> q{{i}};
      while (!q.empty()) {
        const int u = q.front();
        q.pop();
        for (const int v : graph[u]) {
          if (colors[v] == colors[u])
            return false;
          if (colors[v] == Color::kWhite) {
            colors[v] = colors[u] == Color::kRed ? Color::kGreen : Color::kRed;
            q.push(v);
          }
        }
      }
    }

    return true;
  }
};"
"class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:
        accC = [0]
        n = len(customers)
        for x in customers:
            accC.append(x + accC[-1])
        for i, x in enumerate(grumpy):
            if x == 1: customers[i] = 0
        accCG = [0]   
        for x in customers:
            accCG.append(x + accCG[-1])
        return max(accC[min(i+X-1, n)]-accC[i-1] + accCG[-1] - (accCG[min(i+X-1, n)]-accCG[i-1]) for i in range(1, n+1))","class Solution {
 public:
  vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {
    const int n = arr.size();
    double l = 0.0;
    double r = 1.0;

    while (l < r) {
      const double m = (l + r) / 2.0;
      int fractionsNoGreaterThanM = 0;
      int p = 0;
      int q = 1;

      // For each index i, find the first index j s.t. arr[i] / arr[j] <= m,
      // So fractionsNoGreaterThanM for index i will be n - j
      for (int i = 0, j = 1; i < n; ++i) {
        while (j < n && arr[i] > m * arr[j])
          ++j;
        if (j == n)
          break;
        fractionsNoGreaterThanM += n - j;
        if (p * arr[j] < q * arr[i]) {
          p = arr[i];
          q = arr[j];
        }
      }

      if (fractionsNoGreaterThanM == k)
        return {p, q};
      if (fractionsNoGreaterThanM > k)
        r = m;
      else
        l = m;
    }

    throw;
  }
};"
"class Solution:
    def prevPermOpt1(self, arr: List[int]) -> List[int]:
        for i in reversed(range(len(arr)-1)):
            if arr[i] > arr[i+1]: break 
        else: return arr 
        
        ii, val = i, 0
        for k in range(i+1, len(arr)): 
            if val < arr[k] < arr[i]: ii, val = k, arr[k]
        
        arr[i], arr[ii] = arr[ii], arr[i]
        return arr","class Solution {
 public:
  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst,
                        int k) {
    vector<vector<pair<int, int>>> graph(n);
    using T = tuple<int, int, int>;  // (d, u, stops)
    priority_queue<T, vector<T>, greater<>> minHeap;
    vector<vector<int>> dist(n, vector<int>(k + 2, INT_MAX));

    minHeap.emplace(0, src, k + 1);  // Start with node src with d == 0
    dist[src][k + 1] = 0;

    for (const vector<int>& flight : flights) {
      const int u = flight[0];
      const int v = flight[1];
      const int w = flight[2];
      graph[u].emplace_back(v, w);
    }

    return dijkstra(graph, src, dst, k);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst,
               int k) {
    vector<vector<int>> dist(graph.size(), vector<int>(k + 2, INT_MAX));
    using T = tuple<int, int, int>;  // (d, u, stops)
    priority_queue<T, vector<T>, greater<>> minHeap;

    dist[src][k + 1] = 0;
    minHeap.emplace(dist[src][k + 1], src, k + 1);

    while (!minHeap.empty()) {
      const auto [d, u, stops] = minHeap.top();
      minHeap.pop();
      if (u == dst)
        return d;
      if (stops == 0)
        continue;
      for (const auto& [v, w] : graph[u])
        if (d + w < dist[v][stops - 1]) {
          dist[v][stops - 1] = d + w;
          minHeap.emplace(dist[v][stops - 1], v, stops - 1);
        }
    }

    return -1;
  }
};"
"class Solution:
    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:
        # Get the counts of all of our barcode elements.
        cnts = collections.Counter(barcodes)
		# Put the -'ve counts along with themselves into a min heap.
		# For those new to this we use -'ve because this is a min heap, so largest cnt pop'd first.
        heap = [(-v, k) for k,v in cnts.items()]
        heapq.heapify(heap)
        res = []
        # While we have elements on our heap.
        while heap:
		    # pop the top element.
            cnt1, num1 = heapq.heappop(heap)
			# If the top element was the last we used, we need something different.
            if res and res[-1] == num1:
			    # pop the next highest cnt element. 
                cnt, num = heapq.heappop(heap)
                res.append(num)
                cnt += 1
				# If there's still elements left we put them back on the heap.
                if cnt != 0:
                    heapq.heappush(heap, (cnt, num))
				# We can also add the first that we popped, and push it back on the heap as well.
                res.append(num1)
                cnt1 += 1
                if cnt1 != 0:
                    heapq.heappush(heap, (cnt1, num1))
			# else we just add the highest cnt element and put the remaining back on.
            else:
                res.append(num1)
                cnt1 += 1
                if cnt1 != 0:
                    heapq.heappush(heap, (cnt1, num1))
            
        return res","class Solution {
 public:
  int rotatedDigits(int n) {
    int ans = 0;

    for (int i = 1; i <= n; ++i)
      if (isGoodNumber(i))
        ++ans;

    return ans;
  }

 private:
  bool isGoodNumber(int i) {
    bool isRotated = false;

    for (const char c : to_string(i)) {
      if (c == '0' || c == '1' || c == '8')
        continue;
      if (c == '2' || c == '5' || c == '6' || c == '9')
        isRotated = true;
      else
        return false;
    }

    return isRotated;
  }
};"
"class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        strings = [str1, str2] if len(str1) > len(str2) else [str2, str1]
        
        
        for length in range(len(strings[1]), 0, -1):
            if (not len(strings[0]) % length and not len(strings[1]) % length):
                substring = strings[1][:length]
                number_substrings_1 = len(strings[0]) // length
                number_substrings_2 = len(strings[1]) // length
                
                
                if (number_substrings_1 == strings[0].count(substring) and
                   number_substrings_2 == strings[1].count(substring)):
                    return substring
                
        return """"","class Solution {
 public:
  bool escapeGhosts(vector<vector<int>>& ghosts, vector<int>& target) {
    const int d = abs(target[0]) + abs(target[1]);

    for (const vector<int>& ghost : ghosts)
      if (d >= abs(ghost[0] - target[0]) + abs(ghost[1] - target[1]))
        return false;

    return true;
  }
};"
"class Solution:
    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:
        d = collections.defaultdict(int)                # hashmap for counting
        m, n = len(matrix), len(matrix[0])
        for i in range(m):
            reverse = not matrix[i][0]                  # decide whether need to reverse bit
            cur = ''                                    # expanded version of above 1 liner
            for j in range(n):
                if reverse:
                    cur += '0' if matrix[i][j] else '1'
                else:    
                    cur += '1' if matrix[i][j] else '0'
            d[cur] += 1                                 # count frequency
        return max(d.values())","class Solution {
 public:
  int numTilings(int n) {
    constexpr int kMod = 1'000'000'007;
    vector<long> dp(1001, 0);
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 5;

    for (int i = 4; i <= n; ++i)
      dp[i] = (2 * dp[i - 1] + dp[i - 3]) % kMod;

    return dp[n];
  }
};"
"class Solution:
    def addNegabinary(self, arr1: List[int], arr2: List[int]) -> List[int]:
        x = reduce(lambda x, y: x*(-2) + y, arr1)
        x += reduce(lambda x, y: x*(-2) + y, arr2)
        ans = []
        while x: 
            ans.append(x &amp; 1)
            x = -(x >> 1)
        return ans[::-1] or [0]","class Solution {
 public:
  string customSortString(string order, string s) {
    string ans;
    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (const char c : order)
      while (count[c]-- > 0)
        ans += c;

    for (char c = 'a'; c <= 'z'; ++c)
      while (count[c]-- > 0)
        ans += c;

    return ans;
  }
};"
"class Solution:
    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:
        if not matrix:
            return 0
        
        def num_for_one_row(nums):
            prev = {}
            prev[0] = 1
            cur_sum = 0
            ans = 0
            for num in nums:
                cur_sum += num
                if cur_sum - target in prev:
                    ans += prev[cur_sum - target]
                if cur_sum not in prev:
                    prev[cur_sum] = 1
                else:
                    prev[cur_sum] += 1
            return ans 
        
        res = 0
        m = len(matrix)
        n = len(matrix[0])
        
        for i in range(m):
            nums = [0]*n
            for j in range(i,m):
                for k in range(n):
                    nums[k]+=matrix[j][k]
                res += num_for_one_row(nums)
                
        return res","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int count = 0;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  int numMatchingSubseq(string s, vector<string>& words) {
    for (const string& word : words)
      insert(word);
    return dfs(s, 0, root);
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    ++node->count;
  }

  int dfs(const string& s, int i, shared_ptr<TrieNode> node) {
    int ans = node->count;
    if (i >= s.length())
      return ans;

    for (int j = 0; j < 26; ++j)
      if (node->children[j]) {
        const int index = s.find('a' + j, i);
        if (index != -1)
          ans += dfs(s, index + 1, node->children[j]);
      }

    return ans;
  }
};"
"class Solution:
    def numTilePossibilities(self, tiles: str) -> int:
        res=[]
        def rec(t,now,k):
            nonlocal res
            if k==1:
                for i in t:
                    res.append(now+i)
                return
            for i in range(len(t)):
                rec(t[:i]+t[i+1:],now+t[i],k-1)
        for i in range(1,len(tiles)+1):
            rec(tiles,'',i)
        return(len(set(res)))","class Solution {
 public:
  int preimageSizeFZF(int k) {
    long l = 0;
    long r = 5L * k;

    while (l < r) {
      const long m = (l + r) / 2;
      if (trailingZeroes(m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return trailingZeroes(l) == k ? 5 : 0;
  }

 private:
  // 172. Factorial Trailing Zeroes
  int trailingZeroes(long n) {
    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);
  }
};"
"class Solution:
    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:
        cands = set()
        def dfs(node, s):
            if node.left is None and node.right is None:
                if (s + node.val) < limit:
                    return True
                else:
                    return False
            else:
                if node.left:
                    left = dfs(node.left, s + node.val)
                    if left:
                        node.left = None
                else:
                    left = True
                if node.right:
                    right = dfs(node.right, s + node.val)
                    if right:
                        node.right = None
                else:
                    right = True
                return left and right
        if dfs(root, 0):
            return None
        return root","class Solution {
 public:
  bool validTicTacToe(vector<string>& board) {
    const int countX = sum(board, 'X');
    const int countO = sum(board, 'O');

    if (countX < countO || countX - countO > 1)
      return false;
    if (isWinned(board, 'X') && countX == countO ||
        isWinned(board, 'O') && countX != countO)
      return false;

    return true;
  }

 private:
  int sum(const vector<string>& board, char c) {
    int ans = 0;

    for (const string& row : board)
      ans += count(begin(row), end(row), c);

    return ans;
  }

  bool isWinned(const vector<string>& board, char c) {
    vector<string> rotated = rotate(board);

    auto equalsToThree = [&c](const string& row) {
      return count(begin(row), end(row), c) == 3;
    };

    return any_of(begin(board), end(board), equalsToThree) ||
           any_of(begin(rotated), end(rotated), equalsToThree) ||
           board[0][0] == c && board[1][1] == c && board[2][2] == c ||
           board[0][2] == c && board[1][1] == c && board[2][0] == c;
  }

  vector<string> rotate(const vector<string>& board) {
    vector<string> rotated(3);

    for (const string& row : board)
      for (int i = 0; i < 3; ++i)
        rotated[i].push_back(row[i]);

    return rotated;
  }
};"
"class Solution:
    def smallestSubsequence(self, s: str) -> str:
        stack = []
        for i, c in enumerate(s):
            if c in stack:
                continue
            while stack and stack[-1] in s[i:] and c < stack[-1]:
                stack.pop()
            if c not in stack:
                stack.append(c)
        return ''.join(stack)","class Solution {
 public:
  int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
    int ans = 0;
    int l = -1;
    int r = -1;

    for (int i = 0; i < nums.size(); ++i) {
      if (nums[i] > right)  // Handle reset value
        l = i;
      if (nums[i] >= left)  // Handle reset and needed value
        r = i;
      ans += r - l;
    }

    return ans;
  }
};"
"class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """"""
        Do not return anything, modify arr in-place instead.
        """"""
        temp = []
        for i in arr:
            if i == 0:
                temp.append(0)
                temp.append(0)
            else:
                temp.append(i)
        for i in range(len(arr)):
            arr[i] = temp[i]","class Solution {
 public:
  bool rotateString(string A, string B) {
    return A.length() == B.length() && (A + A).find(B) != string::npos;
  }
};"
"class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        N, M = len(grid), len(grid[0])
        directions = ((1,1),(1,0),(0,1),(1,-1),(-1,1),(0,-1),(-1,0),(-1,-1))
        
        Coordinate = namedtuple('Coordinate', ['x', 'y'])
        start = Coordinate(0,0)
        goal = Coordinate(N-1, M-1)
        
        if grid[start.x][start.y] != 0:
            return -1
        
        def withinBounds(curr):
            return 0 <= curr.x < N and 0 <= curr.y < M
        
        queue = deque([(start)])
        grid[start.x][start.y] = 1
        pathLength = 1
        
        while queue:
            for _ in range(len(queue)):
                curr = queue.popleft()

                if curr == goal:
                    return pathLength

                for r, c in directions:
                    neigh = Coordinate(curr.x + r, curr.y + c)
                    if withinBounds(neigh) and grid[neigh.x][neigh.y] == 0:
                        grid[neigh.x][neigh.y] = 1
                        queue.append(neigh)
            
            pathLength += 1

        return -1","class Solution {
 public:
  vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
    vector<vector<int>> ans;
    dfs(graph, 0, {0}, ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (u == graph.size() - 1) {
      ans.push_back(path);
      return;
    }

    for (const int v : graph[u]) {
      path.push_back(v);
      dfs(graph, v, move(path), ans);
      path.pop_back();
    }
  }
};"
"class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        
        @lru_cache(None)
        def fn(i, j): 
            """"""Return min length of common supersequence of str1[i:] and str2[j:].""""""
            if i == len(str1): return len(str2)-j
            if j == len(str2): return len(str1)-i
            if str1[i] == str2[j]: return 1 + fn(i+1, j+1)
            return 1 + min(fn(i+1, j), fn(i, j+1))
        
        ans = []
        i = j = 0 
        while i < len(str1) and j < len(str2): 
            if str1[i] == str2[j]: 
                ans.append(str1[i])
                i += 1
                j += 1
            elif fn(i+1, j) < fn(i, j+1): 
                ans.append(str1[i])
                i += 1
            else: 
                ans.append(str2[j])
                j += 1
        return """".join(ans) + str1[i:] + str2[j:]","class Solution {
 public:
  int bestRotation(vector<int>& nums) {
    const int n = nums.size();
    // rotate[i] := how many points losing after rotating left i times
    vector<int> rotate(n);

    // Rotating i - nums[i] times makes nums[i] == its new index.
    // So, rotating i - nums[i] + 1 times will ""start"" to make nums[i] > its
    // index, Which is the starting index to lose point
    for (int i = 0; i < n; ++i)
      --rotate[(i - nums[i] + 1 + n) % n];

    // Each time we rotate, we make index 0 to index n - 1, so we get 1 point.
    for (int i = 1; i < n; ++i)
      rotate[i] += rotate[i - 1] + 1;

    return distance(begin(rotate), max_element(begin(rotate), end(rotate)));
  }
};"
"class Solution:
    def sampleStats(self, count: List[int]) -> List[float]:
        total = sum(count)
        mn = med0 = med1 = -1 
        psm = cnt = mode = 0
        for i, x in enumerate(count): 
            if x: 
                if mn < 0: mn = i
                mx = i
                psm += i * x
                cnt += x
                if cnt >= (total+1)//2 and med0 < 0: med0 = i
                if cnt >= (total+2)//2 and med1 < 0: med1 = i
                if x > count[mode]: mode = i
        return [mn, mx, psm/total, (med0+med1)/2, mode]","class Solution {
 public:
  double champagneTower(int poured, int query_row, int query_glass) {
    vector<vector<double>> dp(query_row + 1, vector<double>(query_row + 1));
    dp[0][0] = poured;

    for (int i = 0; i < query_row; ++i)
      for (int j = 0; j <= i; ++j)
        if (dp[i][j] > 1) {
          dp[i + 1][j] += (dp[i][j] - 1) / 2.0;
          dp[i + 1][j + 1] += (dp[i][j] - 1) / 2.0;
        }

    return min(1.0, dp[query_row][query_glass]);
  }
};"
"class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        trips = sorted(trips, key = lambda a: a[1])
        # print(trips)
        i = 0
        j = trips[0][1]
        se = collections.defaultdict(int)
        while i< len(trips):
            capacity+=se[j]
            del se[j]
            if j == trips[i][1]:
                se[trips[i][2]] += trips[i][0]
                capacity-= trips[i][0]
                i+=1
                if capacity<0:
                    return False
            
            else:
                j+=1
        return True","class Solution {
 public:
  int minSwap(vector<int>& nums1, vector<int>& nums2) {
    vector<int> keepAt(nums1.size(), INT_MAX);
    vector<int> swapAt(nums1.size(), INT_MAX);
    keepAt[0] = 0;
    swapAt[0] = 1;

    for (int i = 1; i < nums1.size(); ++i) {
      if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {
        keepAt[i] = keepAt[i - 1];
        swapAt[i] = swapAt[i - 1] + 1;
      }
      if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {
        keepAt[i] = min(keepAt[i], swapAt[i - 1]);
        swapAt[i] = min(swapAt[i], keepAt[i - 1] + 1);
      }
    }

    return min(keepAt.back(), swapAt.back());
  }
};"
"class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        low = 0
        high = mountain_arr.length()
        peak = -1
        
        while (low < high - 1):
            mid = (low + high) // 2
            midVal = mountain_arr.get(mid)
            leftMid = mountain_arr.get(mid - 1)
            rightMid = mountain_arr.get(mid + 1)

            if (midVal > leftMid and midVal > rightMid):
                peak = mid
                break
            elif (midVal > leftMid and midVal < rightMid):
                low = mid 
            else:
                high = mid
        
        low = 0
        high = peak
        while (low <= high):
            mid = (low + high) // 2
            midVal = mountain_arr.get(mid)
            
            if midVal == target:
                return mid
            elif midVal < target:
                low = mid + 1
            else:
                high = mid - 1
                
        low = peak
        high = mountain_arr.length() - 1
        while (low <= high):
            mid = (low + high) // 2
            print(low, mid, high)
            midVal = mountain_arr.get(mid)
            
            if midVal == target:
                return mid
            elif midVal < target:
                high = mid - 1
            else:
                low = mid + 1
        
        return -1","enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
    vector<int> ans;
    vector<State> state(graph.size());

    for (int i = 0; i < graph.size(); ++i)
      if (!hasCycle(graph, i, state))
        ans.push_back(i);

    return ans;
  }

 private:
  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& state) {
    if (state[u] == State::kVisiting)
      return true;
    if (state[u] == State::kVisited)
      return false;

    state[u] = State::kVisiting;
    for (const int v : graph[u])
      if (hasCycle(graph, v, state))
        return true;
    state[u] = State::kVisited;

    return false;
  }
};"
"class Solution:
    def braceExpansionII(self, s: str) -> List[str]:
        def getWord():
            nonlocal i
            word = """"
            while i < len(s) and s[i].isalpha():
                word += s[i]
                i += 1
            return word
        
        
        def dfs():
            nonlocal i
            res = set()
            if s[i] == '{':
                i += 1
                res.update(dfs())
                while i < len(s) and s[i] == ',':
                    i += 1
                    res.update(dfs())
                i += 1
            elif s[i].isalpha():
                res.add(getWord())

            while i < len(s) and (s[i] == '{' or s[i].isalpha()): 
                res = {w + a for a in dfs() for w in res}
            return res

        i = 0
        return sorted(dfs())","class UnionFind {
 public:
  UnionFind(int n) : id(n), sz(n, 1) {
    iota(begin(id), end(id), 0);
  }

  void unionBySize(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (sz[i] < sz[j]) {
      sz[j] += sz[i];
      id[i] = j;
    } else {
      sz[i] += sz[j];
      id[j] = i;
    }
  }

  int getStableSize() {
    // Bricks connected with 0 (top) are stable
    return sz[find(0)];
  }

 private:
  vector<int> id;
  vector<int> sz;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {
    m = grid.size();
    n = grid[0].size();

    UnionFind uf(m * n + 1);  // 0 := top (stable)

    // Mark cells to hit as 2
    for (const vector<int>& hit : hits) {
      const int i = hit[0];
      const int j = hit[1];
      if (grid[i][j] == 1)
        grid[i][j] = 2;
    }

    // Union all 1s
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1)
          unionNeighbors(grid, uf, i, j);

    vector<int> ans(hits.size());
    int stableSize = uf.getStableSize();

    for (int i = hits.size() - 1; i >= 0; --i) {
      const int x = hits[i][0];
      const int y = hits[i][1];
      if (grid[x][y] == 2) {  // Cells marked from 1 to 2
        grid[x][y] = 1;       // Unhit, restore back to 1
        unionNeighbors(grid, uf, x, y);
        const int newStableSize = uf.getStableSize();
        if (newStableSize > stableSize)
          ans[i] = newStableSize - stableSize - 1;  // 1 := the hit cell
        stableSize = newStableSize;
      }
    }

    return ans;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};
  int m;
  int n;

  void unionNeighbors(const vector<vector<int>>& grid, UnionFind& uf, int i,
                      int j) {
    const int hashed = hash(i, j);

    for (int k = 0; k < 4; ++k) {
      const int x = i + dirs[k];
      const int y = j + dirs[k + 1];
      if (x < 0 || x == m || y < 0 || y == n)
        continue;
      if (grid[x][y] != 1)
        continue;
      uf.unionBySize(hashed, hash(x, y));
    }

    if (i == 0)
      uf.unionBySize(hashed, 0);
  }

  int hash(int i, int j) {
    return i * n + j + 1;
  }
};"
"class Solution:
    def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        cycle_offset = num_people * (num_people + 1) // 2
        cycles = 0
        n_2 = num_people ** 2
        required_candies = cycle_offset
        ret = []
        
        
        while (candies >= required_candies):
            cycles += 1
            candies -= required_candies
            required_candies = cycles * n_2 + cycle_offset

        
        if (cycles > 0):
            fixed_candy_size = cycles * (cycles - 1) // 2 * num_people


            for person in range(1, num_people + 1):
                ret.append(fixed_candy_size + cycles * person)
                
            fixed_candy_size = cycles * num_people


            for person in range(num_people):
                person_candies = fixed_candy_size + person + 1


                if (person_candies > candies):
                    ret[person] += candies
                    return ret
                else:
                    ret[person] += person_candies
                    candies -= person_candies
        else:
            skip = False
            
            
            for person in range(1, num_people + 1):
                if (skip):
                    ret.append(0)
                elif (candies < person):
                    ret.append(candies)
                    skip = True
                else:
                    ret.append(person)
                    candies -= person
                    
            return ret","class Solution {
 public:
  int uniqueMorseRepresentations(vector<string>& words) {
    const vector<string> morse{
        "".-"",   ""-..."", ""-.-."", ""-.."",  ""."",   ""..-."", ""--."",  ""...."", "".."",
        "".---"", ""-.-"",  "".-.."", ""--"",   ""-."",  ""---"",  "".--."", ""--.-"", "".-."",
        ""..."",  ""-"",    ""..-"",  ""...-"", "".--"", ""-..-"", ""-.--"", ""--..""};
    unordered_set<string> transformations;

    for (const string& word : words) {
      string transformation;
      for (const char c : word)
        transformation += morse[c - 'a'];
      transformations.insert(transformation);
    }

    return transformations.size();
  }
};"
"class Solution:
    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:
        if not books:
            return 0
        
        # dynamic programming
        # key = (extra_width at the last level, last layer height)
        # value = min_height
        best = dict()
        best[(shelf_width, 0)] = 0
        for width, height in books:
            new_best = dict()
            for (width_left, level_height), total_height in best.items():
                # start new level
                key = (shelf_width - width, height)
                val = total_height + height
                if key in new_best:
                    new_best[key] = min(new_best[key], val)
                else:
                    new_best[key] = val
                # use current level
                if width <= width_left:
                    key = (width_left - width, max(height, level_height))
                    val = total_height + max(height, level_height) - level_height
                    if key in new_best:
                        new_best[key] = min(new_best[key], val)
                    else:
                        new_best[key] = val
            best = new_best
        return min(best.values())","class Solution {
 public:
  bool splitArraySameAverage(vector<int>& nums) {
    const int n = nums.size();
    const int sum = accumulate(begin(nums), end(nums), 0);
    if (!isPossible(sum, n))
      return false;

    vector<unordered_set<int>> sums(n / 2 + 1);
    sums[0].insert(0);

    for (const int num : nums)
      for (int i = n / 2; i > 0; --i)
        for (const int val : sums[i - 1])
          sums[i].insert(num + val);

    for (int i = 1; i < n / 2 + 1; ++i)
      if (i * sum % n == 0 && sums[i].count(i * sum / n))
        return true;

    return false;
  }

 private:
  bool isPossible(int sum, int n) {
    for (int i = 1; i < n / 2 + 1; ++i)
      if (i * sum % n == 0)
        return true;
    return false;
  }
};"
"class Solution:
    def parseBoolExpr(self, expression: str) -> bool:     
        # 0b0000 - ' '
        # 0b0100 - '!'
        # 0b1000 - '&amp;'
        # 0b1100 - '|'
        # 0b0010 (2) - if t in expression
        # 0b0001 (1) - if f in expression
        
        d = { 0b0110:1, 0b0101:2,
               0b1010:2, 0b1001:1, 0b1011:1,
               0b1110:2, 0b1101:1, 0b1111:2,
               0b0010:True, 0b0001:False }        

            
        levels = [0]
        for x in expression:                             
            if x == ',' or x == ""("":
                continue
            elif x == 't':
                levels[-1] |= 2
            elif x == 'f':
                levels[-1] |= 1
            elif x == ')':     
                level = levels.pop()
                levels[-1] |= d[level]
            elif x =='!':
                levels.append(0b0100)
            elif x =='&amp;':
                levels.append(0b1000)
            elif x =='|':
                levels.append(0b1100)                            
                
        return d[levels[0]]","class Solution {
 public:
  int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
    const int n = grid.size();
    int ans = 0;
    vector<int> rowMax(n);
    vector<int> colMax(n);

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        rowMax[i] = max(rowMax[i], grid[i][j]);
        colMax[j] = max(colMax[j], grid[i][j]);
      }

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        ans += min(rowMax[i], colMax[j]) - grid[i][j];

    return ans;
  }
};"
"class Solution:
    def defangIPaddr(self, address: str) -> str:
        return (""[.]"".join(address.split(""."")))","class Solution {
 public:
  double soupServings(int n) {
    return n >= 4800 ? 1.0 : dfs((n + 24) / 25, (n + 24) / 25);
  }

 private:
  vector<vector<double>> memo =
      vector<vector<double>>(4800 / 25, vector<double>(4800 / 25));

  double dfs(int a, int b) {
    if (a <= 0 && b <= 0)
      return 0.5;
    if (a <= 0)
      return 1.0;
    if (b <= 0)
      return 0.0;
    if (memo[a][b] > 0)
      return memo[a][b];
    return memo[a][b] = 0.25 * (dfs(a - 4, b) + dfs(a - 3, b - 1) +
                                dfs(a - 2, b - 2) + dfs(a - 1, b - 3));
  }
};"
"class Solution:
    def corpFlightBookings(self, b: List[List[int]], n: int) -> List[int]:
        res=[0]*n
        for i,j,k in b:
            for m in range(i-1,j):
                res[m]+=k
        return res","class Solution {
 public:
  int expressiveWords(string s, vector<string>& words) {
    int ans = 0;

    for (const string& word : words)
      if (isStretchy(s, word))
        ++ans;

    return ans;
  }

 private:
  bool isStretchy(const string& s, const string& word) {
    const int n = s.length();
    const int m = word.length();

    int j = 0;
    for (int i = 0; i < n; ++i)
      if (j < m && s[i] == word[j])
        ++j;
      else if (i > 1 && s[i] == s[i - 1] && s[i - 1] == s[i - 2])
        continue;
      else if (0 < i && i + 1 < n && s[i - 1] == s[i] && s[i] == s[i + 1])
        continue;
      else
        return false;

    return j == m;
  }
};"
"class Solution:
    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:
        trees = []
        targets = set(to_delete)
        def dfs(root):
            if (not root): return root
            root.left = dfs(root.left)
            root.right = dfs(root.right)
            if (root.val not in targets): return root
            if (root.left): trees.append(root.left)
            if (root.right): trees.append(root.right)
            return None
        dummy = TreeNode(to_delete[0], left=root)
        dfs(dummy)
        return trees","class Solution {
 public:
  bool xorGame(vector<int>& nums) {
    const int xors = accumulate(begin(nums), end(nums), 0, bit_xor<int>());
    return xors == 0 || nums.size() % 2 == 0;
  }
};"
"class Solution:
    def maxDepthAfterSplit(self, seq: str) -> List[int]:
        depths = [0, 0] #depths[0]: A, depths[1]: B
        answer = []
        
        
        for char in seq:
            if (char == '('):
                if (depths[0] < depths[1]):
                    answer.append(0)
                    depths[0] += 1
                else:
                    answer.append(1)
                    depths[1] += 1
            else:
                if (depths[0] > depths[1]):
                    depths[0] -= 1 
                    answer.append(0)
                else:
                    depths[1] -= 1
                    answer.append(1)
            
        return answer","class Solution {
 public:
  vector<string> subdomainVisits(vector<string>& cpdomains) {
    vector<string> ans;
    unordered_map<string, int> count;

    for (const string& cpdomain : cpdomains) {
      const int space = cpdomain.find(' ');
      const int num = stoi(cpdomain.substr(0, space));
      const string& domain = cpdomain.substr(space + 1);
      count[domain] += num;
      for (int i = 0; i < domain.length(); ++i)
        if (domain[i] == '.')
          count[domain.substr(i + 1)] += num;
    }

    for (const auto& [subdomain, freq] : count)
      ans.push_back(to_string(freq) + ' ' + subdomain);

    return ans;
  }
};"
"class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        return sorted(arr1, key=lambda x: (arr2.index(x) if x in arr2 else math.inf, x))","class Solution {
 public:
  double largestTriangleArea(vector<vector<int>>& points) {
    double ans = 0;

    for (const vector<int>& A : points)
      for (const vector<int>& B : points)
        for (const vector<int>& C : points)
          ans = max(ans, 0.5 * abs((B[0] - A[0]) * (C[1] - A[1]) -
                                   (C[0] - A[0]) * (B[1] - A[1])));

    return ans;
  }
};"
"class Solution:
    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:
        
        @lru_cache(None)
        def fn(node):
            """"""Return height of tree rooted at node.""""""
            if not node: return 0 
            return 1 + max(fn(node.left), fn(node.right))
        
        node = root
        while node: 
            left, right = fn(node.left), fn(node.right)
            if left == right: return node
            elif left > right: node = node.left
            else: node = node.right","class Solution {
 public:
  double largestSumOfAverages(vector<int>& nums, int K) {
    const int n = nums.size();
    // dp[i][k] := largest score to partition first i nums into k groups
    dp.resize(n + 1, vector<double>(K + 1));
    prefix.resize(n + 1);

    partial_sum(begin(nums), end(nums), begin(prefix) + 1);
    return largestSumOfAverages(nums, n, K);
  }

 private:
  vector<vector<double>> dp;
  vector<double> prefix;

  double largestSumOfAverages(const vector<int>& A, int i, int k) {
    if (k == 1)
      return prefix[i] / i;
    if (dp[i][k])
      return dp[i][k];

    // Try all possible partitions
    for (int j = k - 1; j < i; ++j)
      dp[i][k] = max(dp[i][k], largestSumOfAverages(A, j, k - 1) +
                                   (prefix[i] - prefix[j]) / (i - j));

    return dp[i][k];
  }
};"
"class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        prefixSum=0
        hmap=defaultdict(int)
        ans=0
        for length,hour in enumerate(hours):
            prefixSum+=1 if hour>8 else -1
            if prefixSum>0:ans=max(ans,length+1)
            if prefixSum not in hmap:
                hmap[prefixSum]=length
            if prefixSum-1 in hmap:
                ans=max(ans,length-hmap[prefixSum-1])
        return ans","class Solution {
 public:
  TreeNode* pruneTree(TreeNode* root) {
    if (root == nullptr)
      return nullptr;
    root->left = pruneTree(root->left);
    root->right = pruneTree(root->right);
    if (root->left == nullptr && root->right == nullptr && root->val == 0)
      return nullptr;
    return root;
  }
};"
"class Solution:
    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:
        
        n_skills = len(req_skills)
        n_people = len(people)
        
        # index skills
        skill_map = {x: i for i, x in enumerate(req_skills)}
        
        # descending sort by length of skills per person
        people = sorted([(i, x) for i, x in enumerate(people)], key=lambda x: -len(x[1]))
        
        # bit people skill
        people_bit = {}
        for i, p in people:
            tmp = 0
            for s in p:
                tmp |= 1 << skill_map[s]
            # if a person skill cannot be covered from pervious people then added
            if all(x | tmp != x for x in people_bit): people_bit[tmp] = i 
        
        # reverse skill set and id
        people_bit = {v: k for k, v in people_bit.items()}
        cands = [*people_bit.keys()]

        # final answer and size for recording minimum team size
        self.ans = None
        self.size = float('inf')

        @lru_cache(None)
        def dp(i, mask, team):
            if mask == (1 << n_skills) - 1 and self.size > len(team):
                self.size = len(team)
                self.ans = team
                return
            if i == len(cands):
                return
            # if current person has skill not covered by previous included skills
            if mask | people_bit[cands[i]] != mask:
                dp(i + 1, mask | people_bit[cands[i]], tuple(set(team)|{cands[i]}))
            dp(i + 1, mask, team)


        dp(0, 0, tuple())
        return self.ans","class Solution {
 public:
  int numBusesToDestination(vector<vector<int>>& routes, int source,
                            int target) {
    if (source == target)
      return 0;

    unordered_map<int, vector<int>> graph;  // {route: [buses]}
    unordered_set<int> usedBuses;

    for (int i = 0; i < routes.size(); ++i)
      for (const int route : routes[i])
        graph[route].push_back(i);

    int ans = 0;
    queue<int> q{{source}};

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const int route = q.front();
        q.pop();
        for (const int bus : graph[route])
          if (usedBuses.insert(bus).second)
            for (const int nextRoute : routes[bus]) {
              if (nextRoute == target)
                return ans;
              q.push(nextRoute);
            }
      }
    }

    return -1;
  }
};"
"class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
    	s, D = 0, {}
    	for d in dominoes:
    		x = tuple(sorted(d))
    		if x in D:
    			D[x] += 1
    		else:
    			D[x] = 0
    	return sum([i*(i+1)//2 for i in list(D.values())])
		
		
- Python 3
- Junaid Mansuri","class Solution {
 public:
  vector<string> ambiguousCoordinates(string s) {
    vector<string> ans;
    s = s.substr(1, s.length() - 2);

    for (int i = 1; i < s.length(); ++i)
      for (const string& x : splits(s.substr(0, i)))
        for (const string& y : splits(s.substr(i)))
          ans.push_back('(' + x + "", "" + y + ')');

    return ans;
  }

 private:
  vector<string> splits(const string& s) {
    if (s.empty() || s.length() > 1 && s.front() == '0' && s.back() == '0')
      return {};
    if (s.back() == '0')
      return {s};
    if (s.front() == '0')
      return {""0."" + s.substr(1)};

    vector<string> candidates{s};
    for (int i = 1; i < s.length(); ++i)
      candidates.push_back(s.substr(0, i) + '.' + s.substr(i));
    return candidates;
  }
};"
"class Solution:
    
    def __init__(self):
        self.m={}
    
    def mctFromLeafValues(self, arr: List[int]) -> int:
        
        def find_max(st,end,arr):
            if arr[st:end+1]==[]:
                return 0
            return max(arr[st:end+1])
        
        def helper(st,en,arr):
            
            if st==en:
                self.m[str(st)+"" ""+str(en)]=0
                return 0
            
            if (en-st)==1:
                self.m[str(st)+"" ""+str(en)]=arr[st]*arr[en]
                return arr[st]*arr[en]
            
            if str(st)+"" ""+str(en) in self.m:
                return self.m[str(st)+"" ""+str(en)] 
            
            ans=float(""inf"")
            
            for i in range(st,en):
                
                a=find_max(st,i,arr)
                b=find_max(i+1,en,arr)
                temp=helper(st,i,arr)+helper(i+1,en,arr)
                
                ans=min(ans,temp+(a*b))
                
            self.m[str(st)+"" ""+str(en)]=ans
            return ans
                
            
        
        
        return helper(0,len(arr)-1,arr)","class Solution {
 public:
  int numComponents(ListNode* head, vector<int>& nums) {
    int ans = 0;
    unordered_set<int> setNums{begin(nums), end(nums)};

    for (; head; head = head->next)
      if (setNums.count(head->val) &&
          (!head->next || !setNums.count(head->next->val)))
        ++ans;

    return ans;
  }
};"
"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
    	M = 0
    	for c in [[1,1],[1,-1],[-1,1],[-1,-1]]:
    		m = float('inf')
    		for i in [arr1[i]*c[0]+arr2[i]*c[1]+i for i in range(len(arr1))]:
    			if i < m: m = i
    			if i - m > M: M = i - m
    	return M
		
		
- Python 3
- Junaid Mansuri","class Solution {
 public:
  int racecar(int target) {
    dp.resize(target + 1, -1);
    return rc(target);
  }

 private:
  vector<int> dp;

  int rc(int i) {
    if (dp[i] >= 0)
      return dp[i];

    int ans = INT_MAX;
    int x = 1;             // XA: (2^x - 1) unit distance
    int j = (1 << x) - 1;  // J = 2^x - 1, k = 2^y - 1

    // (xA + 1R) + (yA + 1R) + rc(i - (j - k))
    for (; j < i; j = (1 << ++x) - 1)
      for (int y = 0, k = 0; k < j; k = (1 << ++y) - 1)
        ans = min(ans, (x + 1) + (y + 1) + rc(i - (j - k)));

    // XA || (xA + 1R) + rc(j - i)
    ans = min(ans, i == j ? x : x + 1 + rc(j - i));
    return dp[i] = ans;
  }
};"
"class Solution:
    def tribonacci(self, n: int) -> int:
        
        if n < 3:
            if n == 0:
                return 0
            if n == 1 or n == 2:
                return 1
        
        t0, t1, t2 = 0, 1, 1

        for i in range(3, n + 1):
            t = t0 + t1 + t2
            t0 = t1
            t1 = t2
            t2 = t

        return t","class Solution {
 public:
  string mostCommonWord(string paragraph, vector<string>& banned) {
    string ans;
    int maxCount = 0;
    unordered_map<string, int> count;
    unordered_set<string> bannedSet{begin(banned), end(banned)};

    // Make paragraph to lowercase and empty punctuations
    for (char& c : paragraph)
      c = isalpha(c) ? tolower(c) : ' ';

    istringstream iss(paragraph);

    for (string word; iss >> word;)
      if (!bannedSet.count(word))
        ++count[word];

    for (const auto& [word, freq] : count)
      if (freq > maxCount) {
        maxCount = freq;
        ans = word;
      }

    return ans;
  }
};"
"class Solution:
    def alphabetBoardPath(self, target):
        hashTable = [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4], [5, 0]]
        OFFSET, current = 97, 0
        res = """"
        
        for t in target:
            v_move = hashTable[current][0] - hashTable[ord(t)-OFFSET][0]
            h_move = hashTable[current][1] - hashTable[ord(t)-OFFSET][1]
            
            while v_move != 0 or h_move != 0:
                #Go vertical direction
                while v_move != 0:
                    if v_move < 0 and current < 21:
                        res += 'D'
                        v_move += 1
                        current += 5
                    elif v_move > 0:
                        res += 'U'
                        v_move -= 1
                        current -= 5
                    else:
                        break
                
                #Go horizontal direction     
                current -= h_move
                while h_move != 0:
                    if h_move < 0:
                        res += 'R'
                        h_move += 1
                    else:
                        res += 'L'
                        h_move -= 1
            res += '!'
        return res","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int depth = 0;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  int minimumLengthEncoding(vector<string>& words) {
    int ans = 0;
    shared_ptr<TrieNode> root = make_shared<TrieNode>();
    vector<shared_ptr<TrieNode>> heads;

    for (const string& word : unordered_set<string>(begin(words), end(words)))
      heads.push_back(insert(root, word));

    for (shared_ptr<TrieNode> head : heads)
      if (all_of(begin(head->children), end(head->children),
                 [](const auto& child) { return child == nullptr; }))
        ans += head->depth + 1;

    return ans;
  }

 private:
  shared_ptr<TrieNode> insert(shared_ptr<TrieNode> root, const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : string(rbegin(word), rend(word))) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->depth = word.length();
    return node;
  }
};"
"class Solution:
    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimensions 
        
        hori = deepcopy(grid)
        vert = deepcopy(grid)
        for i in range(m):
            for j in range(n): 
                if grid[i][j]: 
                    if j: hori[i][j] += hori[i][j-1] # horizontal precipitation
                    if i: vert[i][j] += vert[i-1][j] # vertical precipitation 
        
        ans = 0
        for i in reversed(range(m)):
            for j in reversed(range(n)): 
                val = min(hori[i][j], vert[i][j])
                while val > ans: 
                    if vert[i][j-val+1] >= val and hori[i-val+1][j] >= val: 
                        ans = val 
                    val -= 1
        return ans*ans","class Solution {
 public:
  int flipgame(vector<int>& fronts, vector<int>& backs) {
    int ans = 2001;
    unordered_set<int> same;

    for (int i = 0; i < fronts.size(); ++i)
      if (fronts[i] == backs[i])
        same.insert(fronts[i]);

    for (const int f : fronts)
      if (!same.count(f))
        ans = min(ans, f);

    for (const int b : backs)
      if (!same.count(b))
        ans = min(ans, b);

    return ans == 2001 ? 0 : ans;
  }
};"
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        @functools.cache
        def dp(l, m, i_am_alice): # lets return alice count
            if l == len(piles): return 0
            
            left = []
            taking_now = 0

            for x in range(2*m):
                if l+x == len(piles): break
                
                if i_am_alice:
                    taking_now += piles[l+x]
                taking_later = dp(l+x+1, max(m,x+1), not i_am_alice)
                
                left.append(taking_now + taking_later)
        
            if i_am_alice: # i want to maximize alice
                return max(left)
            
            else: # i am bob, want to minimize alice
                return min(left)
        
        return dp(0,1,True)","class Solution {
 public:
  int numFactoredBinaryTrees(vector<int>& arr) {
    constexpr int kMod = 1'000'000'007;
    const int n = arr.size();
    // dp[i] := # of binary trees with arr[i] as root
    vector<long> dp(n, 1);
    unordered_map<int, int> numToIndex;

    sort(begin(arr), end(arr));

    for (int i = 0; i < n; ++i)
      numToIndex[arr[i]] = i;

    for (int i = 0; i < n; ++i)  // arr[i] is root
      for (int j = 0; j < i; ++j)
        if (arr[i] % arr[j] == 0) {  // arr[j] is left subtree
          const int right = arr[i] / arr[j];
          if (const auto it = numToIndex.find(right); it != cend(numToIndex)) {
            dp[i] += dp[j] * dp[it->second];
            dp[i] %= kMod;
          }
        }

    return accumulate(begin(dp), end(dp), 0L) % kMod;
  }
};"
"class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        dp = [[0] * (len(text1)+1) for _ in range(len(text2)+1)]
        for i in range(1, len(text2)+1):
            for j in range(1, len(text1)+1):
                if text1[j-1] == text2[i-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[len(text2)][len(text1)]","class Solution {
 public:
  string toGoatLatin(string s) {
    string ans;
    const unordered_set<char> vowels{'a', 'e', 'i', 'o', 'u',
                                     'A', 'E', 'I', 'O', 'U'};
    istringstream iss(s);
    string word;
    int i = 1;

    while (iss >> word) {
      if (i > 1)
        ans += ' ';
      if (vowels.count(word[0]))
        ans += word;
      else
        ans += word.substr(1) + word[0];
      ans += ""ma"" + string(i++, 'a');
    }

    return ans;
  }
};"
"class Solution:
    def movesToMakeZigzag(self, nums: List[int]) -> int:
    	L, m, M = len(nums), 0, 0
    	for i in range(1,L-1,2):
    		t = min(nums[i-1],nums[i+1])
    		if nums[i] >= t: m += nums[i] - t + 1
    	if i == L - 3 and nums[-1] >= nums[-2]: m += nums[-1] - nums[-2] + 1
    	for i in range(2,L-1,2):
    		t = min(nums[i-1],nums[i+1])
    		if nums[i] >= t: M += nums[i] - t + 1
    	if nums[0] >= nums[1]: M += nums[0] - nums[1] + 1
    	if (i == L - 3 or i == 1) and nums[-1] >= nums[-2]: M += nums[-1] - nums[-2] + 1
    	return min(m,M)
		
		
- Junaid Mansuri","class Solution {
 public:
  int numFriendRequests(vector<int>& ages) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int age : ages)
      ++count[age];

    for (const auto& [ageA, countA] : count)
      for (const auto& [ageB, countB] : count)
        if (request(ageA, ageB))
          if (ageA == ageB)
            ans += countA * (countB - 1);
          else
            ans += countA * countB;

    return ans;
  }

 private:
  bool request(int ageA, int ageB) {
    return !(ageB <= 0.5 * ageA + 7 || ageB > ageA || ageB > 100 && ageA < 100);
  }
};"
"class Solution:
    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:
        # solution below doesn't use all the info provided
        # namely, total number of nodes
        # do a simple dfs to capture left, right nodes from target x
        # this gives you p1, p2 and p3
        # O(N) time and O(H) tree height call space

        def rcrs(node) -> int:
            if not node: return 0
            lt = rcrs(node.left)
            rt = rcrs(node.right)
            if node.val == x: self.cnts.extend([lt,rt])
            return lt + rt + 1

        self.cnts = []
        rcrs(root)
        self.cnts.append( n - 1 - sum(self.cnts) )
        return (2*max(self.cnts) - sum(self.cnts)) > 1

    def btreeGameWinningMove1(self, root: TreeNode, n: int, x: int) -> bool:
        # draw tree diagrams to find the pattern
        # for any given node, there are three potential paths away
        # Pa, Pb, Pc == (up, left, right)
        # start from chosen X node, find length of path in directions A,B,C
        # if there exists a value P1 > (P2 + P3 + 1), then guaranteed win
        # or P1 - P2 - P3 > 1
        #    max(all) - (sum(all) - max(all)) > 1
        #    2*max(all) - sum(all) > 1

        # traverse tree from root, create parent dict to allow upward travel
        # then start from chosen X and find P_up, P_left, P_right
        # take the max value from paths, if > other two + 1, return true else false
        # recursive dfs helper function
        # repeat three times with each of x.left, x.right, x.prnt
        # O(N) time and space

        d, self.start = {}, None
        def rcrs_dn(node, prnt) -> None:
            if not node: return
            if node.val == x:
                self.start = node
            d[node] = prnt
            rcrs_dn(node.left, node)
            rcrs_dn(node.right, node)
        rcrs_dn(root, None)

        def dfs_away(node, last) -> int:
            if not node: return 0
            cnt = 1
            if node.left and (node.left is not last):
                cnt += dfs_away(node.left, node)
            if node.right and (node.right is not last):
                cnt += dfs_away(node.right, node)
            if d[node] and (d[node] is not last):
                cnt += dfs_away(d[node], node)
            return cnt

        p1 = dfs_away(self.start.left, self.start)
        p2 = dfs_away(self.start.right, self.start)
        p3 = dfs_away(d[self.start], self.start)

        return ( 2*max(p1, p2, p3) - (p1 + p2 + p3) ) > 1","class Solution {
 public:
  int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit,
                          vector<int>& worker) {
    int ans = 0;
    vector<pair<int, int>> jobs;

    for (int i = 0; i < difficulty.size(); ++i)
      jobs.emplace_back(difficulty[i], profit[i]);

    sort(begin(jobs), end(jobs));
    sort(begin(worker), end(worker));

    int i = 0;
    int maxProfit = 0;

    for (const int w : worker) {
      for (; i < jobs.size() && w >= jobs[i].first; ++i)
        maxProfit = max(maxProfit, jobs[i].second);
      ans += maxProfit;
    }

    return ans;
  }
};"
"class Solution:
    def longestDecomposition(self, text: str) -> int:
        import re
        groups = 0
        while True:
            match = re.fullmatch(r'(\w+?).*\1', text)
            if match:
                groups += 2
                subend = match.end(1)
                text = text[subend:-subend]
            else:
                return groups + 1 if text else groups","class Solution {
 public:
  int largestIsland(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int maxSize = 0;
    // sizes[i] := size of i-th connected component (start from 2)
    vector<int> sizes{0, 0};

    // For each 1 in the grid, paint all connected 1 with the next available
    // Color (2, 3, and so on). Also, remember the size of the island we just
    // Painted with that color.
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1)
          sizes.push_back(paint(grid, i, j, sizes.size()));  // Paint 2, 3, ...

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 0) {
          const unordered_set<int> neighborIds{
              getId(grid, i + 1, j), getId(grid, i - 1, j),
              getId(grid, i, j + 1), getId(grid, i, j - 1)};
          maxSize = max(maxSize, 1 + getSize(neighborIds, sizes));
        }

    return maxSize == 0 ? m * n : maxSize;
  }

 private:
  int paint(vector<vector<int>>& grid, int i, int j, int id) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return 0;
    if (grid[i][j] != 1)
      return 0;

    grid[i][j] = id;  // grid[i][j] is part of id-th connected component

    return 1 + paint(grid, i + 1, j, id) + paint(grid, i - 1, j, id) +
           paint(grid, i, j + 1, id) + paint(grid, i, j - 1, id);
  }

  // Get the id of grid[i][j], return 0 if out of bound
  int getId(const vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return 0;  // Invalid
    return grid[i][j];
  }

  int getSize(const unordered_set<int>& neighborIds, const vector<int>& sizes) {
    int size = 0;
    for (const int neighborId : neighborIds)
      size += sizes[neighborId];
    return size;
  }
};"
"class Solution:
    
    di = {1:0, 2:31, 3:59, 4:90, 5:120, 6:151, 7:181, 8:212, 9:243, 10:273, 11:304, 12:334}
    
    def dayOfYear(self, date: str) -> int:
        y, m, d = [int(i) for i in date.split(""-"")]
        a = self.di[m] + int(d) 
        if (m > 2) and ((not y % 4) and (y % 100 or not y % 400)): a += 1
        return a","class Solution {
 public:
  int uniqueLetterString(string s) {
    int ans = 0;
    int count = 0;
    vector<int> lastCount(26);
    vector<int> lastSeen(26, -1);

    for (int i = 0; i < s.length(); ++i) {
      const int c = s[i] - 'A';
      const int currentCount = i - lastSeen[c];
      count = count - lastCount[c] + currentCount;
      lastCount[c] = currentCount;
      lastSeen[c] = i;
      ans += count;
    }

    return ans;
  }
};"
"class Solution:
    def numRollsToTarget(self, n: int, k: int, target: int) -> int:
        if n == 1:
            if target > k: return 0
            else: return 1
        memo = [0 for t in range(target+1)]
        # Note that we do not use memo[0]
        for i in range(1, target+1):
            if i <= k:
                memo[i] = 1
            else:
                break
                
        for _ in range(1, n):
            tmp = [i for i in memo]
            for t in range(1, target+1):
                memo[t] = 0
                for dice in range(1, k+1):
                    if t - dice > 0:
                        memo[t] += tmp[t-dice]
                memo[t] = int(memo[t] % (1e9+7))
        return int(memo[-1] % (1e9+7))","class Solution {
 public:
  int consecutiveNumbersSum(int n) {
    int ans = 0;
    for (int i = 1, triangleNum = i; triangleNum <= n; ++i, triangleNum += i)
      if ((n - triangleNum) % i == 0)
        ++ans;
    return ans;
  }
};"
"class Solution:
    def maxRepOpt1(self, text: str) -> int:
        inuse = collections.defaultdict(int)  # chars used in the repeated substring
        left = collections.defaultdict(int)  # not used chars
        MOVE_TO_THE_NEXT_CHAR = 1
        REPLACE = 0
        LEAVE_AS_IT_IS = -1
        res, i, n = 1, 0, 0

        # initially no chars are used yet
        for ch in text:
            left[ch] += 1
        
        for j, ch in enumerate(text):
            inuse[ch] += 1  # since we use this char
            left[ch] -= 1  # subtract its count from left dict
            n = max(inuse[ch], n)
        
            # this defines action we are going to take
            action = j - i - n
        
            char_exists = False
            if action >= MOVE_TO_THE_NEXT_CHAR:
                inuse[text[i]] -= 1
                left[text[i]] += 1  # add it to the left dict back, since it is no longer in use
                i += 1

            # we can replace only if we have unused char in the left dict    
            elif action == REPLACE:
                char_exists = left[ch] > 0 
                
            elif action == LEAVE_AS_IT_IS:
                char_exists = True
        
            if char_exists and j - i >= res:
                res = j - i + 1
        
        return res","class Solution {
 public:
  vector<vector<int>> largeGroupPositions(string s) {
    const int n = s.length();
    vector<vector<int>> ans;

    for (int i = 0, j = 0; i < n; i = j) {
      while (j < n && s[j] == s[i])
        ++j;
      if (j - i >= 3)
        ans.push_back({i, j - 1});
    }

    return ans;
  }
};"
"class Solution:
    def countCharacters(self, words: List[str], chars: str) -> int:
        
        #vars to hold values
        wordlen = 0
        runningsum = 0
        charedits = chars

        #evaluate words individually
        for word in words:
            wordlen = 0
            charedits = chars

            #Evaluate letters in words
            for letter in word:

                #check the letter in the updating list
                if letter in charedits:
                    wordlen +=1
                    charedits = charedits.replace(letter,' ',1)

            #check word char match
            if len(word) == wordlen:
                runningsum += len(word)

        return(runningsum)","class Solution {
 public:
  string maskPII(string s) {
    const int atIndex = s.find('@');
    if (atIndex != string::npos) {
      transform(begin(s), end(s), begin(s), ::tolower);
      return s.substr(0, 1) + ""*****"" + s.substr(atIndex - 1);
    }

    string ans;
    for (const char c : s)
      if (isdigit(c))
        ans += c;

    if (ans.length() == 10)
      return ""***-***-"" + ans.substr(ans.length() - 4);
    return '+' + string(ans.length() - 10, '*') + ""-***-***-"" +
           ans.substr(ans.length() - 4);
  }
};"
"class Solution:
    def maxLevelSum(self, root: TreeNode) -> int:
        from collections import deque
        if not root: return []
        queue, res = deque([root]), []
        
        while queue:
            cur_level, size = [], len(queue)
            for i in range(size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                cur_level.append(node.val)
            res.append(cur_level)
        res = [sum(i) for i in res]
        return res.index(max(res))+1","class Solution {
 public:
  vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {
    const int n = A.size();

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < (n + 1) / 2; ++j) {
        const int temp = A[i][j];
        A[i][j] = A[i][n - j - 1] ^ 1;
        A[i][n - j - 1] = temp ^ 1;
      }

    return A;
  }
};"
"class Solution:
    def maxDistance(self, grid: List[List[int]]) -> int:
        rows = len(grid)
        cols = len(grid[0])
        
        q = collections.deque()
        zeros = 0
        # Get our number of zeros and our 1 starting locations.
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == 0:
                    zeros += 1
                if grid[row][col] == 1:
                    q.append((row, col, 0))
        # Two edge cases where we will want to return -1.
        if not q or not zeros:
            return -1
        # Our manhattan distance based movements (d, u, r, l)
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
		# Keep record of the largest encountered distance.
        dist = 0
		# while there are 0's left to move to.
        while zeros and q:
            r, c, d = q.popleft()
			# Try to move in all of our possible directions.
            for y, x in directions:
                nr = y + r
                nc = x + c
				# Make sure the new location is in the grid and is a 0.
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:
				    # record the new disr, mark the location as visited and put back into the queue.
                    dist = max(d + 1, dist)
                    zeros -= 1
                    grid[nr][nc] = '#'
                    q.append((nr, nc, d + 1))
                    
        return dist","class Solution {
 public:
  string findReplaceString(string s, vector<int>& indices,
                           vector<string>& sources, vector<string>& targets) {
    vector<pair<int, int>> sortedIndices;

    for (int i = 0; i < indices.size(); ++i)
      sortedIndices.emplace_back(indices[i], i);

    sort(rbegin(sortedIndices), rend(sortedIndices));

    for (const auto& [index, i] : sortedIndices) {
      const string& source = sources[i];
      const string& target = targets[i];
      if (s.substr(index, source.length()) == source)
        s = s.substr(0, index) + target + s.substr(index + source.length());
    }

    return s;
  }
};"
"class Solution:
    def lastSubstring(self, s: str) -> str:
        max_substring = """"
        max_char = """"
        for i in range(len(s)):
            if s[i] >= max_char:
                max_char = s[i]
                max_substring = max(max_substring, s[i : ])
        return max_substring","class Solution {
 public:
  vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {
    vector<int> ans(n);
    vector<int> count(n, 1);
    vector<unordered_set<int>> tree(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].insert(v);
      tree[v].insert(u);
    }

    postorder(tree, 0, -1, count, ans);
    preorder(tree, 0, -1, count, ans);
    return ans;
  }

 private:
  void postorder(const vector<unordered_set<int>>& tree, int node, int parent,
                 vector<int>& count, vector<int>& ans) {
    for (const int child : tree[node]) {
      if (child == parent)
        continue;
      postorder(tree, child, node, count, ans);
      count[node] += count[child];
      ans[node] += ans[child] + count[child];
    }
  }

  void preorder(const vector<unordered_set<int>>& tree, int node, int parent,
                vector<int>& count, vector<int>& ans) {
    for (const int child : tree[node]) {
      if (child == parent)
        continue;
      // count[child] nodes are 1 step closer from child than parent
      // (n - count[child]) nodes are 1 step farther from child than parent
      ans[child] = ans[node] - count[child] + (tree.size() - count[child]);
      preorder(tree, child, node, count, ans);
    }
  }
};"
"class Solution:
    def invalidTransactions(self, ts: List[str]) -> List[str]:
        nts = [t.split(',') for t in ts]
        nts = sorted([[a, int(b), int(c), d] for a, b, c, d in nts])
        res = set()
        for a in nts:
            if a[2] > 1000: res.add(','.join(map(str,a)))
        for i in range(len(nts)):
            for j in range(i + 1, len(nts)):
                a, b = nts[i], nts[j]
                if a[0] != b[0] or abs(a[1] - b[1]) > 60: break
                if a[3] != b[3]: 
                    res.add(','.join(map(str,a)))
                    res.add(','.join(map(str,b)))
        return list(res)","class Solution {
 public:
  int largestOverlap(vector<vector<int>>& A, vector<vector<int>>& B) {
    const int n = A.size();
    const int magic = 100;
    int ans = 0;
    vector<pair<int, int>> onesA;
    vector<pair<int, int>> onesB;
    unordered_map<int, int> map;

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        if (A[i][j] == 1)
          onesA.emplace_back(i, j);
        if (B[i][j] == 1)
          onesB.emplace_back(i, j);
      }

    for (const pair<int, int>& a : onesA)
      for (const pair<int, int>& b : onesB)
        ++map[(a.first - b.first) * magic + (a.second - b.second)];

    for (const auto& [_, value] : map)
      ans = max(ans, value);

    return ans;
  }
};"
"class Solution:
    def numreturn(self , inputlist):
        a = sorted(inputlist)
        res = sum([1 for i in a if i==a[0]])
        return res
    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:
        q = [self.numreturn(iq) for iq in queries]
        w = [self.numreturn(iw) for iw in words]
        res = []
        for i in range(len(q)):
            temp = sum([1 for one in w if one>q[i]])
            res.append(temp)
        return res","class Solution {
 public:
  bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {
    return rec1[0] < rec2[2] && rec2[0] < rec1[2] &&  //
           rec1[1] < rec2[3] && rec2[1] < rec1[3];
  }
};"
"class Solution:
    def removeZeroSumSublists(self, H: ListNode) -> ListNode:
        A, b = ListNode(0), 1; A.next = H
        while b:
            s, b, D, C = 0, 0, {0:A}, A.next
            while C != None:
                s += C.val
                if s in D:
                    D[s].next, b = C.next, 1
                    break
                else: D[s], C = C, C.next
        return A.next
		
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  double new21Game(int n, int k, int maxPts) {
    // When the game ends, the point is in [k..k - 1 + maxPts]
    //   P = 1, if n >= k - 1 + maxPts
    //   P = 0, if n < k (note the constraints already have k <= n)
    if (k == 0 || n >= k - 1 + maxPts)
      return 1.0;

    double ans = 0.0;
    vector<double> dp(n + 1);  // dp[i] := prob to have i points
    dp[0] = 1.0;
    double windowSum = dp[0];  // P(i - 1) + P(i - 2) + ... + P(i - maxPts)

    for (int i = 1; i <= n; ++i) {
      // The prob to get point i is
      // P(i) = [P(i - 1) + P(i - 2) + ... + P(i - maxPts)] / maxPts
      dp[i] = windowSum / maxPts;
      if (i < k)
        windowSum += dp[i];
      else  // The game ends
        ans += dp[i];
      if (i - maxPts >= 0)
        windowSum -= dp[i - maxPts];
    }

    return ans;
  }
};"
"class Solution:
    def numPrimeArrangements(self, n: int) -> int:
        
        def simplesieve(n):
            prime=[]
            mark=[True]*(n+1)
            p=2
            while (p**2 <=n):
                if mark[p]:
                    for i in range(p*p,n+1,p):
                        mark[i]=False
                p+=1
            for i in range(2,n+1):
                if mark[i]:
                    prime.append(i)
            return prime
        
        def segementedsieve(n):
            result=[]
            limit=math.floor(math.sqrt(n))+1
            primes=simplesieve(limit)
            result.extend(primes)
            low=limit
            high=low+limit
            while low<=n:
                if high>=n:
                    high=n
                mark=[True]*(limit+1)
                
                for i in primes:
                    lowlimit=int(math.floor(low/i)*i)
                    if lowlimit<low:
                        lowlimit+=i
                    for j in range(lowlimit,high+1,i):
                        mark[j-low]=False
                for i in range(low,high):
                    if mark[i-low]:
                        result.append(i)
                
                low+=limit
                high+=limit
                
            return result
        
        #print(segementedsieve(n+1))
        number_of_primes_less_than_n=len(segementedsieve(n+1))
        non_prime_number_count=n-number_of_primes_less_than_n
        prime_permutations=math.factorial(number_of_primes_less_than_n)
        non_prime_permutations=math.factorial(non_prime_number_count)
        return (prime_permutations*non_prime_permutations)%(10**9+7)","class Solution {
 public:
  string pushDominoes(string dominoes) {
    int L = -1;
    int R = -1;

    for (int i = 0; i <= dominoes.length(); ++i)
      if (i == dominoes.length() || dominoes[i] == 'R') {
        if (L < R)
          while (R < i)
            dominoes[R++] = 'R';
        R = i;
      } else if (dominoes[i] == 'L') {
        if (R < L || L == -1 && R == -1) {
          if (L == -1 && R == -1)
            ++L;
          while (L < i)
            dominoes[L++] = 'L';
        } else {
          int l = R + 1;
          int r = i - 1;
          while (l < r) {
            dominoes[l++] = 'R';
            dominoes[r--] = 'L';
          }
        }
        L = i;
      }

    return dominoes;
  }
};"
"class Solution:
    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        runningCount = [[0]*26]
        countSnapshot = [0]*26
        a = ord(""a"")
        for c in s:
            countSnapshot[ord(c)-a] += 1
            runningCount.append([*countSnapshot]) # the * is necessary to deep copy the list
        
        for left,right,k in queries:
            if k>=13:
                yield True
                continue
            odds = 0
            for i in range(26):
                odds += (runningCount[right+1][i] - runningCount[left][i])%2
            yield k>=odds//2","class Solution {
 public:
  int numSimilarGroups(vector<string>& A) {
    int ans = 0;
    vector<bool> seen(A.size());

    for (int i = 0; i < A.size(); ++i)
      if (!seen[i]) {
        dfs(A, i, seen);
        ++ans;
      }

    return ans;
  }

 private:
  // Dfs on string A[i]
  void dfs(const vector<string>& A, int i, vector<bool>& seen) {
    seen[i] = true;
    for (int j = 0; j < A.size(); ++j)
      if (!seen[j] && isSimilar(A[i], A[j]))
        dfs(A, j, seen);
  }

  bool isSimilar(const string& X, const string& Y) {
    int diff = 0;
    for (int i = 0; i < X.length(); ++i)
      if (X[i] != Y[i] && ++diff > 2)
        return false;
    return true;
  }
};"
"class Solution:
    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:
        freq = defaultdict(int)
        for word in words: 
            mask = 0
            for c in word: mask |= 1 << (ord(c) - 97)
            freq[mask] += 1
            
        ans = []
        for puzzle in puzzles: 
            mask = val = 0 
            for c in puzzle: mask |= 1 << (ord(c) - 97)
            mask0 = mask # loop through sub-masks
            while mask: 
                if mask &amp; (1 << ord(puzzle[0])-97): val += freq[mask]
                mask = mask0 &amp; (mask - 1)
            ans.append(val)
        return ans","class Solution {
 public:
  int numMagicSquaresInside(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i + 2 < grid.size(); ++i)
      for (int j = 0; j + 2 < grid[0].size(); ++j)
        if (grid[i][j] % 2 == 0 && grid[i + 1][j + 1] == 5)
          ans += isMagic(grid, i, j);

    return ans;
  }

 private:
  int isMagic(const vector<vector<int>>& grid, int i, int j) {
    string s;

    for (const int num : {0, 1, 2, 5, 8, 7, 6, 3})
      s += to_string(grid[i + num / 3][j + num % 3]);

    return string(""4381672943816729"").find(s) != string::npos ||
           string(""9276183492761834"").find(s) != string::npos;
  }
};"
"class Solution:
    def distanceBetweenBusStops(self, D: List[int], s: int, d: int) -> int:
    	return min(sum(D[min(s,d):max(s,d)]), sum(D)-sum(D[min(s,d):max(s,d)]))
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  bool canVisitAllRooms(vector<vector<int>>& rooms) {
    vector<bool> seen(rooms.size());
    dfs(rooms, 0, seen);
    return all_of(begin(seen), end(seen), [](int s) { return s == true; });
  }

 private:
  void dfs(const vector<vector<int>>& rooms, int node, vector<bool>& seen) {
    seen[node] = true;
    for (const int child : rooms[node])
      if (!seen[child])
        dfs(rooms, child, seen);
  }
};"
"class Solution:
    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
        months = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        # The first day of 1971 was Thursday
        week_day = [ ""Thursday"", ""Friday"", ""Saturday"",""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday""]
        no_of_days = 0
        for i in range(1971, year):
            if (i % 400 == 0) or (i % 4 == 0 and i % 100 != 0):
                no_of_days += 366
            else:
                no_of_days += 365

        # If current year is leap year and month is more than February then extra 1 day needs to be added
        if ((year % 400 == 0) or (year % 4 == 0 and year % 100 != 0)):
            if (month > 2):
                no_of_days += 1

        for i in range(1, month):
            no_of_days += months[i]

        no_of_days += day

        return (week_day[(no_of_days % 7)])","class Solution {
 public:
  vector<int> splitIntoFibonacci(string num) {
    vector<int> ans;
    dfs(num, 0, ans);
    return ans;
  }

 private:
  bool dfs(const string& num, int s, vector<int>& ans) {
    if (s == num.length() && ans.size() >= 3)
      return true;

    for (int i = s; i < num.length(); ++i) {
      if (num[s] == '0' && i > s)
        break;
      const long val = stol(num.substr(s, i + 1 - s));
      if (val > INT_MAX)
        break;
      if (ans.size() >= 2 &&
          val > ans[ans.size() - 2] + static_cast<long>(ans.back()))
        break;
      if (ans.size() <= 1 ||
          val == ans[ans.size() - 2] + static_cast<long>(ans.back())) {
        ans.push_back(val);
        if (dfs(num, i + 1, ans))
          return true;
        ans.pop_back();
      }
    }

    return false;
  }
};"
"class Solution:
    def maximumSum(self, arr: List[int]) -> int:
	    # noDeletions, oneDeletion, max
        nodel = onedel = mx = arr[0]
        
        for i in range(1, len(arr)):
            nodel2 = nodel
            nodel = max(arr[i], arr[i] + nodel)
            onedel = max(arr[i], arr[i] + onedel, max(0, arr[i]) + nodel2)
            mx = max(mx, nodel, onedel)
            
        return mx","/**
 * // This is the Master's API interface.
 * // You should not implement it, or speculate about its implementation
 * class Master {
 *  public:
 *   int guess(string word);
 * };
 */
class Solution {
 public:
  void findSecretWord(vector<string>& wordlist, Master& master) {
    srand(time(nullptr));  // Required

    for (int i = 0; i < 10; ++i) {
      const string& guessedWord = wordlist[rand() % wordlist.size()];
      const int matches = master.guess(guessedWord);
      if (matches == 6)
        break;
      vector<string> updated;
      for (const string& word : wordlist)
        if (getMatches(guessedWord, word) == matches)
          updated.push_back(word);
      wordlist = move(updated);
    }
  }

 private:
  int getMatches(const string& s1, const string& s2) {
    int matches = 0;
    for (int i = 0; i < s1.length(); ++i)
      if (s1[i] == s2[i])
        ++matches;
    return matches;
  }
};"
"class Solution:
    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
        n1 , n2, dp = len(arr1) , len(arr2) , {}
        arr2.sort()
        
        def solve(i , j , prev):
            
            if i == n1:return 0
            
            if (i,j,prev) in dp: return dp[(i,j,prev)]
            
            k = bisect.bisect_right(arr2[j:],prev) + j
        
            ans = float('inf') if k == n2 else solve(i+1,k+1,arr2[k]) + 1
            
            if arr1[i] > prev:ans = min(ans,solve(i+1 , j ,arr1[i]))
            
            dp[(i,j,prev)] = ans
            
            return ans
        
        
        ans = solve(0,0,-float('inf'))
        
        return ans if ans != float('inf') else -1","class Solution {
 public:
  bool backspaceCompare(string s, string t) {
    return backspace(s) == backspace(t);
  }

 private:
  string backspace(const string& s) {
    string stack;
    for (const char c : s)
      if (c != '#')
        stack.push_back(c);
      else if (!stack.empty())
        stack.pop_back();
    return stack;
  }
};"
"class Solution:
    def maxNumberOfBalloons(self, t: str) -> int:
        	return (lambda x: min(x[i]//(1 + (i in 'lo')) for i in 'balon'))(collections.Counter(t))
			
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int longestMountain(vector<int>& arr) {
    int ans = 0;

    for (int i = 0; i + 1 < arr.size();) {
      while (i + 1 < arr.size() && arr[i] == arr[i + 1])
        ++i;

      int increasing = 0;
      int decreasing = 0;

      while (i + 1 < arr.size() && arr[i] < arr[i + 1]) {
        ++increasing;
        ++i;
      }

      while (i + 1 < arr.size() && arr[i] > arr[i + 1]) {
        ++decreasing;
        ++i;
      }

      if (increasing > 0 && decreasing > 0)
        ans = max(ans, increasing + decreasing + 1);
    }

    return ans;
  }
};"
"class Solution:
    def reverseParentheses(self, s: str) -> str:
        stack = []
        i = 0
        while i < len(s):
            while i < len(s) and s[i] != "")"":
                stack.append(s[i])
                i += 1
            temp = """"
            if i < len(s) and s[i] == "")"":
                while stack[-1] != ""("":
                    temp += stack.pop()
                i += 1
                stack.pop()
            if temp != """":
                for letter in temp:
                    stack.append(letter)
        return """".join(stack)","class Solution {
 public:
  bool isNStraightHand(vector<int>& hand, int groupSize) {
    map<int, int> count;

    for (const int card : hand)
      ++count[card];

    for (const auto& [start, _] : count) {
      const int value = count[start];
      if (value > 0)
        for (int i = start; i < start + groupSize; ++i) {
          count[i] -= value;
          if (count[i] < 0)
            return false;
        }
    }

    return true;
  }
};"
"class Solution:
    def kConcatenationMaxSum(self, a: List[int], k: int) -> int:
    	L, M, j, m = len(a), 10**9 + 7, 0, 0
    	if min(a) >= 0: return sum(a)*k % M
    	if max(a) <= 0: return 0
    	while j < 2*L:
    		n, i = 0, j
    		for j in range(i,2*L):
    			n, j = n + a[j%L], j + 1
    			if n < 0: break
    			if n > m: m = n
    	return max(m,sum(a)*(k-2)+m) % M
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int shortestPathLength(vector<vector<int>>& graph) {
    const int n = graph.size();
    const int goal = (1 << n) - 1;

    int ans = 0;
    queue<pair<int, int>> q;  // (u, state)
    vector<vector<bool>> seen(n, vector<bool>(1 << n));

    for (int i = 0; i < n; ++i)
      q.emplace(i, 1 << i);

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [u, state] = q.front();
        q.pop();
        if (state == goal)
          return ans;
        if (seen[u][state])
          continue;
        seen[u][state] = true;
        for (const int v : graph[u])
          q.emplace(v, state | (1 << v));
      }
      ++ans;
    }

    return -1;
  }
};"
"class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        graph = [[] for _ in range(n)]
        group = [None] * n

        for n1, n2 in connections:
            graph[n1].append(n2)
            graph[n2].append(n1)

        def dfs(node, parent):
            group[node] = node
            for neighbor in graph[node]:
                if neighbor == parent:
                    continue
                elif group[neighbor] is None:
                    dfs(neighbor, node)
                    if group[neighbor] != neighbor:
                        group[node] = group[neighbor]
                else:
                    if group[neighbor] < group[node]:
                        group[group[node]] = group[neighbor]
                    else:
                        group[group[neighbor]] = group[node]

        def get_root_parent(node):
            if group[node] == node:
                return node
            group[node] = get_root_parent(group[node])
            return group[node]

        dfs(0, 0)

        for i in range(n):
            group[i] = get_root_parent(i)

        return [conn for conn in connections if group[conn[0]] != group[conn[1]]]","class Solution {
 public:
  string shiftingLetters(string s, vector<int>& shifts) {
    string ans;

    for (int i = shifts.size() - 2; i >= 0; --i)
      shifts[i] = (shifts[i] + shifts[i + 1]) % 26;

    for (int i = 0; i < s.length(); ++i)
      ans += (s[i] - 'a' + shifts[i]) % 26 + 'a';

    return ans;
  }
};"
"class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        
        arr.sort()
        temp = arr[1] - arr[0]
        for i in range(len(arr) - 1):
            temp = min(temp ,arr[i+1] - arr[i] )
        
        res = [[arr[i] , arr[i+1]] for i in range(len(arr)-1) if arr[i+1] - arr[i] == temp]

        return res","class Solution {
 public:
  int maxDistToClosest(vector<int>& seats) {
    const int n = seats.size();
    int ans = 0;
    int j = -1;

    for (int i = 0; i < n; ++i)
      if (seats[i] == 1) {
        ans = j == -1 ? i : max(ans, (i - j) / 2);
        j = i;
      }

    return max(ans, n - j - 1);
  }
};"
"class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        [a,b,c] = sorted([a,b,c])
        if a == 1: return n
        def lcm(x,y): return x*y//math.gcd(x,y)
        AB, BC, AC, ABC, r, s = lcm(a,b), lcm(b,c), lcm(a,c), lcm(lcm(a,b),c), n*a//3, n*a+1
        def unc(x): return x//a + x//b + x//c - x//AB - x//BC - x//AC + x//ABC
        while unc(s-1) - n > 0:
            m = (r+s)//2
            if unc(m) - n > 0: s = m
            else: r = m
        return max(i*((s-1)//i) for i in [a,b,c])
				
				
- Junaid Mansuri
(LeetCode ID)@hotmail.com","struct Event {
  int x;
  int y1;
  int y2;
  char type;
  Event(int x, int y1, int y2, char type) : x(x), y1(y1), y2(y2), type(type) {}
};

class Solution {
 public:
  int rectangleArea(vector<vector<int>>& rectangles) {
    constexpr int kMod = 1'000'000'007;

    vector<Event> events;

    for (const vector<int>& r : rectangles) {
      events.emplace_back(r[0], r[1], r[3], 's');
      events.emplace_back(r[2], r[1], r[3], 'e');
    }

    sort(begin(events), end(events),
         [](const auto& a, const auto& b) { return a.x < b.x; });

    long ans = 0;
    int prevX = 0;
    vector<pair<int, int>> yPairs;

    for (const auto& [currX, y1, y2, type] : events) {
      if (currX > prevX) {
        const int width = currX - prevX;
        ans = (ans + width * getHeight(yPairs)) % kMod;
        prevX = currX;
      }
      if (type == 's') {
        yPairs.emplace_back(y1, y2);
        sort(begin(yPairs), end(yPairs));
      } else {  // Type == 'e'
        const auto it =
            find(begin(yPairs), end(yPairs), pair<int, int>(y1, y2));
        yPairs.erase(it);
      }
    }

    return ans % kMod;
  }

 private:
  long getHeight(const vector<pair<int, int>>& yPairs) {
    int height = 0;
    int prevY = 0;

    for (const auto& [y1, y2] : yPairs) {
      prevY = max(prevY, y1);
      if (y2 > prevY) {
        height += y2 - prevY;
        prevY = y2;
      }
    }

    return height;
  }
};"
"class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        class UF:
            def __init__(self, n): self.p = list(range(n))
            def union(self, x, y): self.p[self.find(x)] = self.find(y)
            def find(self, x):
                if x != self.p[x]: self.p[x] = self.find(self.p[x])
                return self.p[x]
        uf, res, m = UF(len(s)), [], defaultdict(list)
        for x,y in pairs: 
            uf.union(x,y)
        for i in range(len(s)): 
            m[uf.find(i)].append(s[i])
        for comp_id in m.keys(): 
            m[comp_id].sort(reverse=True)
        for i in range(len(s)): 
            res.append(m[uf.find(i)].pop())
        return ''.join(res)","class Solution {
 public:
  vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
    const int n = quiet.size();
    vector<int> ans(n, -1);
    vector<vector<int>> graph(n);

    for (const vector<int>& r : richer) {
      const int u = r[1];
      const int v = r[0];
      graph[u].push_back(v);
    }

    for (int i = 0; i < n; ++i)
      dfs(graph, i, quiet, ans);

    return ans;
  }

 private:
  int dfs(const vector<vector<int>>& graph, int u, const vector<int>& quiet,
          vector<int>& ans) {
    if (ans[u] != -1)
      return ans[u];

    ans[u] = u;

    for (const int v : graph[u]) {
      const int res = dfs(graph, v, quiet, ans);
      if (quiet[res] < quiet[ans[u]])
        ans[u] = res;
    }

    return ans[u];
  }
};"
"class Solution:
    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:
        for i in range(n): 
            if group[i] == -1: group[i] = i + m # re-group 
        
        graph0 = {} # digraph of groups 
        indeg0 = [0]*(m+n) # indegree of groups 
        
        graph1 = {} # digrpah of items 
        indeg1 = [0]*n # indegree of items
        
        for i, x in enumerate(beforeItems): 
            for xx in x: 
                if group[xx] != group[i]: 
                    graph0.setdefault(group[xx], []).append(group[i])
                    indeg0[group[i]] += 1
                graph1.setdefault(xx, []).append(i)
                indeg1[i] += 1
        
        def fn(graph, indeg): 
            """"""Return topological sort of graph using Kahn's algo.""""""
            ans = []
            stack = [k for k in range(len(indeg)) if indeg[k] == 0]
            while stack: 
                n = stack.pop()
                ans.append(n)
                for nn in graph.get(n, []):
                    indeg[nn] -= 1
                    if indeg[nn] == 0: stack.append(nn)
            return ans 
        
        tp0 = fn(graph0, indeg0) 
        if len(tp0) != len(indeg0): return [] 
        
        tp1 = fn(graph1, indeg1)
        if len(tp1) != len(indeg1): return []
        
        mp0 = {x: i for i, x in enumerate(tp0)}
        mp1 = {x: i for i, x in enumerate(tp1)}
        
        return sorted(range(n), key=lambda x: (mp0[group[x]], mp1[x]))","class Solution {
 public:
  int peakIndexInMountainArray(vector<int>& arr) {
    int l = 0;
    int r = arr.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (arr[m] >= arr[m + 1])
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};"
"class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        freq = {}
        for x in arr: 
            freq[x] = 1 + freq.get(x, 0)
        return len(freq) == len(set(freq.values()))","struct Car {
  int pos;
  double time;  // Time to reach the target
};

class Solution {
 public:
  int carFleet(int target, vector<int>& position, vector<int>& speed) {
    int ans = 0;
    vector<Car> cars(position.size());

    for (int i = 0; i < position.size(); ++i)
      cars[i] = {position[i], (double)(target - position[i]) / speed[i]};

    sort(begin(cars), end(cars),
         [](const auto& a, const auto& b) { return a.pos > b.pos; });

    double maxTime = 0;  // The time of the slowest car to reach the target

    for (const Car& car : cars)
      // A car needs more time to reach the target, so it becomes slowest
      if (car.time > maxTime) {
        maxTime = car.time;
        ++ans;
      }

    return ans;
  }
};"
"class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        
        window = collections.deque([])
        best = 0
        i = 0
        
        while i < len(s):
            
            cost = abs(ord(s[i]) - ord(t[i]))
            
            if maxCost - cost >= 0:
                window.append(cost)
                maxCost -= cost
                best = max(best, len(window))
                i += 1
                continue
            
            if len(window) > 0:
                maxCost += window.popleft()
                continue
                
            i += 1
                
        return best","class Solution {
 public:
  int kSimilarity(string s1, string s2) {
    int ans = 0;
    queue<string> q{{s1}};
    unordered_set<string> seen{{s1}};

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        string curr = q.front();
        q.pop();
        if (curr == s2)
          return ans;
        for (const string& child : getChildren(curr, s2)) {
          if (seen.count(child))
            continue;
          q.push(child);
          seen.insert(child);
        }
      }
      ++ans;
    }

    return -1;
  }

 private:
  vector<string> getChildren(string& curr, const string& target) {
    vector<string> children;
    int i = 0;  // First index s.t. curr[i] != target[i]
    while (curr[i] == target[i])
      ++i;

    for (int j = i + 1; j < curr.length(); ++j)
      if (curr[j] == target[i]) {
        swap(curr[i], curr[j]);
        children.push_back(curr);
        swap(curr[i], curr[j]);
      }

    return children;
  }
};"
"class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:
        stack = []
        for c in s: 
            if stack and stack[-1][0] == c: 
                stack[-1][1] += 1
            else: stack.append([c, 1])
            if stack[-1][1] == k: stack.pop()
        return """".join(x*c for x, c in stack)","class Solution {
 public:
  int scoreOfParentheses(string s) {
    int ans = 0;
    int layer = 0;

    for (int i = 0; i + 1 < s.length(); ++i) {
      const char a = s[i];
      const char b = s[i + 1];
      if (a == '(' && b == ')')
        ans += 1 << layer;
      layer += a == '(' ? 1 : -1;
    }

    return ans;
  }
};"
"class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        n = len(grid)
        
        def findNeighbors(head, state):
            actual = []
            x, y = head
            if state == 'H':
                # go right when horizontal
                if y + 1 <= n - 1 and grid[x][y + 1] == 0:
                    actual.append((x, y + 1, 'H'))
                    
                # go down when horizontal
                if x + 1 <= n - 1 and grid[x + 1][y] == 0 and grid[x + 1][y - 1] == 0:
                    actual.append((x + 1, y, 'H'))
                    
                    # can rotate clkwise here
                    actual.append((x + 1, y - 1, 'V'))
                    
            else:
                # go down when vertical
                if x + 1 <= n - 1 and grid[x + 1][y] == 0:
                    actual.append((x + 1, y, 'V'))
                    
                # go right when vertical
                if y + 1 <= n - 1 and grid[x][y + 1] == 0 and grid[x - 1][y + 1] == 0:
                    actual.append((x, y + 1, 'V'))
                    
                    # can rotate anti clkwise here
                    actual.append((x - 1, y + 1, 'H'))
                    
            return actual
        
        visited = set()
        q = deque()
        q.append((0, 1, 'H', 0))
        
        while q:
            x, y, state, dist = q.popleft()
            if (x, y, state) == (n - 1, n - 1, 'H'):
                return dist
            
            if (x, y, state) in visited:
                continue
                
            visited.add((x, y, state))
            
            for nx, ny, ndir in findNeighbors((x, y), state):
                q.append((nx, ny, ndir, dist + 1))
                
        return -1","class Solution {
 public:
  double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int k) {
    double ans = DBL_MAX;
    int qualitySum = 0;
    // (wagePerQuality, quality) sorted by wagePerQuality
    vector<pair<double, int>> workers;
    priority_queue<int> maxHeap;

    for (int i = 0; i < quality.size(); ++i)
      workers.emplace_back((double)wage[i] / quality[i], quality[i]);

    sort(begin(workers), end(workers));

    for (const auto& [wagePerQuality, q] : workers) {
      maxHeap.push(q);
      qualitySum += q;
      if (maxHeap.size() > k)
        qualitySum -= maxHeap.top(), maxHeap.pop();
      if (maxHeap.size() == k)
        ans = min(ans, qualitySum * wagePerQuality);
    }

    return ans;
  }
};"
"class Solution:
    def minCostToMoveChips(self, C: List[int]) -> int:
        return min(sum(c % 2 for c in C), len(C) - sum(c % 2 for c in C))
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int mirrorReflection(int p, int q) {
    while (p % 2 == 0 && q % 2 == 0) {
      p /= 2;
      q /= 2;
    }

    if (p % 2 == 0)
      return 2;
    if (q % 2 == 0)
      return 0;
    return 1;
  }
};"
"class Solution:
    def longestSubsequence(self, A: List[int], k: int) -> int:
        D, C = {}, {}
        for a in A:
            if a not in D: D[a], C[a+k] = 1, a
            if a in C: C[a+k], D[C.pop(a)] = C[a], D[C[a]] + 1
        return max(D.values())
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  bool buddyStrings(string A, string B) {
    if (A.length() != B.length())
      return false;
    if (A == B && set<char>(begin(A), end(A)).size() < A.length())
      return true;

    vector<int> diff;

    for (int i = 0; i < A.length(); ++i)
      if (A[i] != B[i])
        diff.push_back(i);

    return diff.size() == 2 && A[diff[0]] == B[diff[1]] &&
           A[diff[1]] == B[diff[0]];
  }
};"
"class Solution:
    def getMaximumGold(self, G: List[List[int]]) -> int:
        M, N, V, m = len(G), len(G[0]), set(), [0]
        def dfs(i, j, t):
            V.add((i,j))
            for k,l in (i-1,j),(i,j+1),(i+1,j),(i,j-1):
                if 0 <= k < M and 0 <= l < N and G[k][l] and (k,l) not in V: dfs(k, l, t + G[k][l])
            m[0], _ = max(m[0], t), V.remove((i,j))
        for i,j in itertools.product(range(M),range(N)):
            if G[i][j]: dfs(i, j, G[i][j])
        return m[0]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com","class Solution {
 public:
  int matrixScore(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;

    // Flip rows with leading 0
    for (auto& row : grid)
      if (row[0] == 0)
        flip(row);

    // Flip cols with 1s < 0s
    for (int j = 0; j < n; ++j)
      if (onesColCount(grid, j) * 2 < m)
        flipCol(grid, j);

    // Add binary number for each row
    for (const vector<int>& row : grid)
      ans += binary(row);

    return ans;
  }

 private:
  void flip(vector<int>& row) {
    for (int i = 0; i < row.size(); ++i)
      row[i] ^= 1;
  }

  int onesColCount(const vector<vector<int>>& grid, int j) {
    int ones = 0;
    for (int i = 0; i < grid.size(); ++i)
      ones += grid[i][j];
    return ones;
  }

  void flipCol(vector<vector<int>>& grid, int j) {
    for (int i = 0; i < grid.size(); ++i)
      grid[i][j] ^= 1;
  }

  int binary(const vector<int>& row) {
    int res = row[0];
    for (int j = 1; j < row.size(); ++j)
      res = res * 2 + row[j];
    return res;
  }
};"
"class Solution:
    def countVowelPermutation(self, n: int) -> int:
        a, e, i, o, u, MOD = 1, 1, 1, 1, 1, 10**9+7
        for _ in range(n-1):
            a, e, i, o, u = e, (a+i)%MOD, (a+e+o+u)%MOD, (i+u)%MOD, a
        return sum([a, e, i, o, u])%MOD","class Solution {
 public:
  int shortestSubarray(vector<int>& nums, int k) {
    const int n = nums.size();
    int ans = n + 1;
    deque<int> q;
    vector<long> prefix{0};

    for (int i = 0; i < n; ++i)
      prefix.push_back(prefix.back() + nums[i]);

    for (int i = 0; i < n + 1; ++i) {
      while (!q.empty() && prefix[i] - prefix[q.front()] >= k)
        ans = min(ans, i - q.front()), q.pop_front();
      while (!q.empty() && prefix[i] <= prefix[q.back()])
        q.pop_back();
      q.push_back(i);
    }

    return ans <= n ? ans : -1;
  }
};"
"class Solution:
    def balancedStringSplit(self, s: str) -> int:
        stk = []
        ret = 0

        for ch in s:
            if not stk:             # begin
                ret += 1            # in balance
                stk.append(ch)
            elif ch == stk[-1]:     # continue
                stk.append(ch)
            else:                   # change direction
                stk.pop()
        return ret","class Solution {
 public:
  vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
    vector<int> ans;
    unordered_map<TreeNode*, int> nodeToDist;  // {node: distance to target}

    getDists(root, target, nodeToDist);
    dfs(root, k, 0, nodeToDist, ans);
    return ans;
  }

 private:
  void getDists(TreeNode* root, TreeNode* target,
                unordered_map<TreeNode*, int>& nodeToDist) {
    if (root == nullptr)
      return;
    if (root == target) {
      nodeToDist[root] = 0;
      return;
    }

    getDists(root->left, target, nodeToDist);
    if (const auto it = nodeToDist.find(root->left); it != cend(nodeToDist)) {
      // The target is in the left subtree
      nodeToDist[root] = it->second + 1;
      return;
    }

    getDists(root->right, target, nodeToDist);
    if (const auto it = nodeToDist.find(root->right); it != cend(nodeToDist))
      // The target is in the right subtree
      nodeToDist[root] = it->second + 1;
  }

  void dfs(TreeNode* root, int k, int dist,
           unordered_map<TreeNode*, int>& nodeToDist, vector<int>& ans) {
    if (root == nullptr)
      return;
    if (const auto it = nodeToDist.find(root); it != cend(nodeToDist))
      dist = it->second;
    if (dist == k)
      ans.push_back(root->val);

    dfs(root->left, k, dist + 1, nodeToDist, ans);
    dfs(root->right, k, dist + 1, nodeToDist, ans);
  }
};"
"class Solution:
    def dieSimulator(self, n: int, R: List[int]) -> int:
        D, R, S, m = [[0]*7 for _ in range(n)], [0]+R, set(range(1,7)), 10**9 + 7
        def dfs(L, d):
            if L >= n: return 1 if L == n else 0
            c = 0
            if D[L][d]: return D[L][d]
            for i in S-{d}:
                for j in range(1,R[i]+1): c += dfs(L+j,i)
            D[L][d] = c
            return c
        return dfs(0,0) % m
		
		
- Junaid Mansuri","struct T {
  int i;
  int j;
  int keys;  // Keys in bitmask
  T(int i, int j, int keys) : i(i), j(j), keys(keys) {}
};

class Solution {
 public:
  int shortestPathAllKeys(vector<string>& grid) {
    const int m = grid.size();
    const int n = grid[0].length();
    const int keysCount = getKeysCount(grid);
    const int kKeys = (1 << keysCount) - 1;
    const vector<int> dirs{0, 1, 0, -1, 0};
    const vector<int> start = getStart(grid);
    int ans = 0;
    queue<T> q{{{start[0], start[1], 0}}};
    vector<vector<vector<bool>>> seen(
        m, vector<vector<bool>>(n, vector<bool>(kKeys)));
    seen[start[0]][start[1]][0] = true;

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j, keys] = q.front();
        q.pop();
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          const char c = grid[x][y];
          if (c == '#')
            continue;
          const int newKeys = 'a' <= c && c <= 'f' ? keys | 1 << c - 'a' : keys;
          if (newKeys == kKeys)
            return ans;
          if (seen[x][y][newKeys])
            continue;
          if ('A' <= c && c <= 'F' && ((newKeys >> c - 'A') & 1) == 0)
            continue;
          q.emplace(x, y, newKeys);
          seen[x][y][newKeys] = true;
        }
      }
    }

    return -1;
  }

 private:
  int getKeysCount(const vector<string>& grid) {
    int count = 0;
    for (const string& s : grid)
      count += std::count_if(begin(s), end(s),
                             [](char c) { return 'a' <= c && c <= 'f'; });
    return count;
  }

  vector<int> getStart(const vector<string>& grid) {
    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].length(); ++j)
        if (grid[i][j] == '@')
          return {i, j};
    throw;
  }
};"
"class Solution:
    def maxEqualFreq(self, N: List[int]) -> int:
        L, C = len(N), collections.Counter(N)
        for i in range(L-1,-1,-1):
            S = set(C.values())
            if len(C.values()) == 1 or S == {1}: return i + 1
            elif len(S) == 2:
                if 1 in S and list(C.values()).count(1) == 1: return i + 1
                if list(C.values()).count(max(S)) == 1 and max(S) - min(S) == 1: return i + 1
            if C[N[i]] == 1: del C[N[i]]
            else: C[N[i]] -= 1
        return 0
		
		
- Junaid Mansuri","struct T {
  TreeNode* lca;
  int depth;
};

class Solution {
 public:
  TreeNode* subtreeWithAllDeepest(TreeNode* root) {
    return dfs(root).lca;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {nullptr, 0};

    const T left = dfs(root->left);
    const T right = dfs(root->right);
    if (left.depth > right.depth)
      return {left.lca, left.depth + 1};
    if (left.depth < right.depth)
      return {right.lca, right.depth + 1};
    return {root, left.depth + 1};
  }
};"
"class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        return 1 if n == 1 else 1/2","class Solution {
 public:
  int primePalindrome(int n) {
    if (n <= 2)
      return 2;
    if (n == 3)
      return 3;
    if (n <= 5)
      return 5;
    if (n <= 7)
      return 7;
    if (n <= 11)
      return 11;

    int nLength = to_string(n).length();

    while (true) {
      for (const int num : getPalindromes(nLength))
        if (num >= n && isPrime(num))
          return num;
      ++nLength;
    }

    throw;
  }

 private:
  vector<int> getPalindromes(int n) {
    vector<int> palindromes;
    const int length = n / 2;

    for (int i = pow(10, length - 1); i < pow(10, length); ++i) {
      const string s = to_string(i);
      string reversedS = s;
      reverse(begin(reversedS), end(reversedS));
      for (int j = 0; j < 10; ++j)
        palindromes.push_back(stoi(s + to_string(j) + reversedS));
    }

    return palindromes;
  }

  bool isPrime(int num) {
    for (int i = 2; i < sqrt(num) + 1; ++i)
      if (num % i == 0)
        return false;

    return true;
  }
};"
"class Solution:
    def checkStraightLine(self, C: List[List[int]]) -> bool:
        if len(set(i[0] for i in C)) == 1: return True
        if len(set(i[0] for i in C)) < len(C): return False
        m, [x1, y1] = (C[1][1]-C[0][1])//(C[1][0]-C[0][0]), C.pop(0)
        for x,y in C:
            if (y-y1)/(x-x1) != m: return False
        return True
		
		
- Junaid Mansuri","class Solution {
 public:
  vector<vector<int>> transpose(vector<vector<int>>& A) {
    vector<vector<int>> ans(A[0].size(), vector<int>(A.size()));

    for (int i = 0; i < A.size(); ++i)
      for (int j = 0; j < A[0].size(); ++j)
        ans[j][i] = A[i][j];

    return ans;
  }
};"
"class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        folder.sort(key=len, reverse=False)         # shorter ones in the front
        result = []
        
        while folder != []:
            curr = folder.pop(0)
            result.append(curr)
            tmp = copy.deepcopy(folder)
            for i in tmp:
                if (curr+""/"") in i:
                    folder.remove(i)
            # print(result)
        
        return result","class Solution {
 public:
  int binaryGap(int n) {
    int ans = 0;

    // D := distance between any two 1's
    // Initialized to a reasonable small value
    for (int d = -32; n; n /= 2, ++d)
      if (n & 1) {
        ans = max(ans, d);
        d = 0;
      }

    return ans;
  }
};"
"class Solution:
    def balancedString(self, S: str) -> int:
        L, m, D, c, i, j = len(S), len(S), {k:v-len(S)//4 for k,v in collections.Counter(S).items() if v>len(S)//4}, {k:0 for k in 'QWER'}, -1, 0
        if not D: return 0
        for j, s in enumerate(S):
            while i < L - 1 and any(c[k] < D[k] for k in D): i += 1; c[S[i]] += 1
            if i == L - 1 and any(c[k] < D[k] for k in D): break
            m = min(m, i - j + 1); c[s] -= 1
        return m
		
		
- Junaid Mansuri","class Solution {
 public:
  bool reorderedPowerOf2(int n) {
    int count = counter(n);

    for (int i = 0; i < 30; ++i)
      if (counter(1 << i) == count)
        return true;

    return false;
  }

 private:
  int counter(int n) {
    int count = 0;

    for (; n > 0; n /= 10)
      count += pow(10, n % 10);

    return count;
  }
};"
"class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        start = min(startTime)
        end = max(endTime)
        n = len(startTime)
        newList = [[startTime[i]-start+1, endTime[i]-start+1, profit[i]] for i in range(n)]
        newList.sort(key = lambda x : x[1])
        n = len(newList)
        dp = [0]*(n + 1)
        for i in range(n):
            [starti, endi, costi] = newList[i]
            j = i-1
            while j >= 0 and newList[j][1] > starti:
                j-=1
            dp[i+1] = max(dp[j+1]+costi,dp[i+1], dp[i])

        return dp[-1]","class Solution {
 public:
  vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
    multiset<int> set{begin(nums1), end(nums1)};

    for (int i = 0; i < nums2.size(); ++i) {
      const auto p =
          *rbegin(set) <= nums2[i] ? begin(set) : set.upper_bound(nums2[i]);
      nums1[i] = *p;
      set.erase(p);
    }

    return nums1;
  }
};"
"class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        result =[]
        for x in range(1,z+1):
            l,h=1,z
            while(l<=h):
                m=(l+h)//2
                if (customfunction.f(x,m)==z):
                    result.append([x,m])
                    break;
                elif (customfunction.f(x,m)<z):
                    l=m+1
                elif (customfunction.f(x,m)>z):
                    h=m-1
        return result","class Solution {
 public:
  int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
    // dp[i] := farthest position we can reach w/ i refuels
    vector<long> dp(stations.size() + 1);
    dp[0] = startFuel;

    for (int i = 0; i < stations.size(); ++i)
      for (int j = i + 1; j > 0; --j)
        if (dp[j - 1] >=
            stations[i][0])  // With j - 1 refuels, we can reach stations[i][0]
          dp[j] = max(dp[j], dp[j - 1] + stations[i][1]);

    for (int i = 0; i < dp.size(); ++i)
      if (dp[i] >= target)
        return i;

    return -1;
  }
};"
"class Solution:
    def circularPermutation(self, n: int, start: int) -> List[int]:
        # gray code generation! for every new ""bit"":
        # 1) preface reversed list with 1 == same as adding 2^(N-1)
        # 2) squish onto existing list

        # (N)  1   2    3   gray
        #      0  00  000   0
        #      1  01  001   1
        #         11  011   2
        #         10  010   3
        #             110   4
        #             111   5
        #             101   6
        #             100   7

        # then find start position (ambiguously NOT gray representation)
        # slice and dice the created list with ""start"" at index 0

        # O(2^N) time, O(2^N) space

        gc, bit = [0, 1], 1
        while bit < n:
            bit += 1

            next_vals = []
            for val in reversed(gc):
                next_vals.append( val + 2**(bit-1) )
            gc.extend(next_vals)

        ind = gc.index(start)
        return gc[ind:] + gc[:ind]","class Solution {
 public:
  bool leafSimilar(TreeNode* root1, TreeNode* root2) {
    vector<int> leaves1;
    vector<int> leaves2;
    dfs(root1, leaves1);
    dfs(root2, leaves2);
    return leaves1 == leaves2;
  }

  void dfs(TreeNode* root, vector<int>& leaves) {
    if (root == nullptr)
      return;
    if (root->left == nullptr && root->right == nullptr) {
      leaves.push_back(root->val);
      return;
    }

    dfs(root->left, leaves);
    dfs(root->right, leaves);
  }
};"
"class Solution:
    def maxLength(self, arr: List[str]) -> int:
        ans = 0
        freq = [0]*26 
        
        def fn(i): 
            """"""Return max length of arr[i:] given freq.""""""
            if i == len(arr): return 0 
            ans = fn(i+1) # skipping arr[i]
            if len(set(arr[i])) == len(arr[i]): 
                if all(freq[ord(c)-97] == 0 for c in arr[i]): 
                    for c in arr[i]: freq[ord(c)-97] += 1
                    ans = max(ans, len(arr[i]) + fn(i+1))
                    for c in arr[i]: freq[ord(c)-97] -= 1 # backtracking 
            return ans 
        
        return fn(0)","class Solution {
 public:
  int lenLongestFibSubseq(vector<int>& arr) {
    const int n = arr.size();
    int ans = 0;
    vector<vector<int>> dp(n, vector<int>(n, 2));
    unordered_map<int, int> numToIndex;

    for (int i = 0; i < n; ++i)
      numToIndex[arr[i]] = i;

    for (int j = 0; j < n; ++j)
      for (int k = j + 1; k < n; ++k) {
        const int ai = arr[k] - arr[j];
        if (ai < arr[j] && numToIndex.count(ai)) {
          const int i = numToIndex[ai];
          dp[j][k] = dp[i][j] + 1;
          ans = max(ans, dp[j][k]);
        }
      }

    return ans;
  }
};"
"class Solution:
    def tilingRectangle(self, n: int, m: int) -> int:
        # edge case 1 allowing early quit processing. 
        if n == m : 
            return 1 
        # edge case 2, occurs according to tiling problem. Only one for which implementation breaks. 
        elif (n==11 and m == 13) or (n==13 and m==11) : 
            return 6 
        else : 
            # memo usage of results. Build from result 1 go to end result. Bottom up progression. 
            memo = [[0 for _ in range(m+1)] for _ in range(n+1)]
            # loop from 1 to n inclusive 
            for n_measure in range(1, n+1) : 
                # loop 1 to m inclusive 
                for m_measure in range(1, m+1) : 
                    # if we are at equal measures, this is a square 
                    if (n_measure == m_measure) : 
                        # mark it as 1 as these are our measures so this can be covered by equal square 
                        memo[n_measure][m_measure] = 1
                        continue
                    # only do half the array 
                    else : 
                        if m_measure < n and n_measure < m and memo[m_measure][n_measure] != 0 : 
                            memo[n_measure][m_measure] = memo[m_measure][n_measure]
                            continue
                    # otherwise, set sub rectangles 1 and 2 and minimal rectangle to infinity to start 
                    sub_rectangle1, sub_rectangle2, min_rectangle = inf, inf, inf
                    offset = 1 
                    # starting with offset of 1 go to min of n and m 
                    while offset <= min(n_measure, m_measure) : 
                        # if we have run off the smaller, break at this point 
                        if (m_measure - offset < 0) or (n_measure - offset < 0) : 
                            break
                        # get sub rectangles 1 and 2 based off of which slicing you're doing 
                        sub_rectangle1 = memo[n_measure][m_measure-offset] + memo[n_measure-offset][offset]
                        sub_rectangle2 = memo[n_measure-offset][m_measure] + memo[offset][m_measure-offset]
                        # set min to minimum of the results now built 
                        min_rectangle = min(min_rectangle, sub_rectangle1, sub_rectangle2)
                        # increment offset as if you are doing two different measures simultaneously 
                        offset += 1 
                    # memoize current result minmal plus 1 more for work done for this square itself. 
                    memo[n_measure][m_measure] = min_rectangle + 1
            return memo[n][m]","class Solution {
 public:
  int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = 0;
    int d = 0;  // 0 := north, 1 := east, 2 := south, 3 := west
    int x = 0;  // Start x
    int y = 0;  // Start y
    unordered_set<pair<int, int>, pairHash> obstaclesSet;

    for (const vector<int>& o : obstacles)
      obstaclesSet.insert({o[0], o[1]});

    for (const int c : commands) {
      if (c == -1) {
        d = (d + 1) % 4;
      } else if (c == -2) {
        d = (d + 3) % 4;
      } else {
        for (int step = 0; step < c; ++step) {
          if (obstaclesSet.count({x + dirs[d], y + dirs[d + 1]}))
            break;
          x += dirs[d];
          y += dirs[d + 1];
        }
      }
      ans = max(ans, x * x + y * y);
    }

    return ans;
  }

 private:
  struct pairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};"
"class Solution:
    def minimumSwap(self, S: str, T: str) -> int:
        L, D = len(S), {'x': 1, 'y': 1}
        for i in range(L): D[S[i]] += S[i] != T[i]
        return -1 if (D['x']+D['y']) % 2 else D['x']//2 + D['y']//2
		
		
- Junaid Mansuri","class Solution {
 public:
  int minEatingSpeed(vector<int>& piles, int h) {
    int l = 1;
    int r = *max_element(begin(piles), end(piles));

    while (l < r) {
      const int m = (l + r) / 2;
      if (eatHours(piles, m) <= h)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  // Returns hours to eat all piles with speed m.
  int eatHours(const vector<int>& piles, int m) {
    return accumulate(begin(piles), end(piles), 0, [&](int subtotal, int pile) {
      return subtotal + (pile - 1) / m + 1;  // ceil(pile / m)
    });
  }
};"
"class Solution:
def numberOfSubarrays(self, nums: List[int], k: int) -> int:
    
    res,left,end=0,0,0
    n=len(nums)
    dic = defaultdict(int)
    while (end<n):
        dic[nums[end]%2]+=1
        if dic[1]==k:
            re = 0              # count of even numbers right side of limit (k no. of odds)
            while end+1<n and nums[end+1]%2==0:
                re+=1
                end+=1
                dic[0]+=1
            
            le = 0
            while dic[1]==k:
                le+=1
                dic[nums[left]%2]-=1
                left+=1
            
            if re:
                res += le*(re+1)
            else:
                res += le
                
        end+=1
        
    return res","class Solution {
 public:
  ListNode* middleNode(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
    }

    return slow;
  }
};"
"class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        s,temp = list(s), []
        for i in range(len(s)):
            if s[i] in [""("","")""]:
                if not temp: temp.append((i,s[i]))
                elif temp[-1][-1]==""("" and s[i] == "")"": temp.pop()
                else: temp.append((i,s[i]))
        for item in temp: s[item[0]] = None
        res = """"
        for char in s:
            if char is not None: res += char
        return res","class Solution {
 public:
  bool stoneGame(vector<int>& piles) {
    const int n = piles.size();
    // dp[i][j] := max stones you can get more than your opponent in piles[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = piles[i];

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);
      }

    return dp[0][n - 1] > 0;
  }
};"
"class Solution:
    def isGoodArray(self, nums: List[int]) -> bool:
        
        from functools import reduce
        def gcd (a,b):
            while b:
                a, b = b, a%b
            return a
        
        from math import gcd
        
        if reduce(gcd, nums) == 1:
            return True
        else:
            return False","class Solution {
 public:
  int nthMagicalNumber(long n, long a, long b) {
    constexpr int kMod = 1'000'000'007;
    const long lcm = a * b / __gcd(a, b);
    long l = min(a, b);
    long r = min(a, b) * n;

    while (l < r) {
      const long m = (l + r) / 2;
      if (m / a + m / b - m / lcm >= n)
        r = m;
      else
        l = m + 1;
    }

    return l % kMod;
  }
};"
"class Solution:
    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:
        row = set()
        col = set()
        ans = 0
        for i, j in indices:
            diff = m - 2 * len(col)
            ans += diff * (-1) ** (i in row) 
            row ^= {i}
            diff = n - 2 * len(row)
            ans += diff * (-1) ** (j in col) 
            col ^= {j}
        return ans","class Solution {
 public:
  int profitableSchemes(int n, int minProfit, vector<int>& group,
                        vector<int>& profit) {
    constexpr int kMod = 1'000'000'007;
    // dp[k][i][j] := # of schemes w/ first k crimes, AT MOST i members, and at
    // Least j profits
    vector<vector<vector<int>>> dp(
        group.size() + 1,
        vector<vector<int>>(n + 1, vector<int>(minProfit + 1)));

    // No crimes, no profits, and any # of members
    for (int i = 0; i <= n; ++i)
      dp[0][i][0] = 1;

    for (int k = 1; k <= group.size(); ++k) {
      const int g = group[k - 1];
      const int p = profit[k - 1];
      for (int i = 0; i <= n; ++i)
        for (int j = 0; j <= minProfit; ++j)
          if (i < g) {
            dp[k][i][j] = dp[k - 1][i][j];
          } else {
            dp[k][i][j] = dp[k - 1][i][j] + dp[k - 1][i - g][max(0, j - p)];
            dp[k][i][j] %= kMod;
          }
    }

    return dp[group.size()][n][minProfit];
  }
};"
"class Solution:
    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
        cnt = sum(x==2 for x in colsum)
        if upper + lower != sum(colsum) or cnt > upper or cnt > lower : return [] #sanity check 
        
        ans = [[0]*len(colsum) for _ in range(2)]
        for i, c in enumerate(colsum): 
            if c == 2: ans[0][i] = ans[1][i] = 1
            elif c == 1:
                if cnt < upper: #there is capacity in upper
                    ans[0][i] = 1 
                    cnt += 1
                else: ans[1][i] = 1
        return ans","class Solution {
 public:
  string decodeAtIndex(string s, int k) {
    long size = 0;  // Length of decoded `s`

    for (const char c : s)
      if (isdigit(c))
        size *= c - '0';
      else
        ++size;

    for (int i = s.length() - 1; i >= 0; --i) {
      k %= size;
      if (k == 0 && isalpha(s[i]))
        return string(1, s[i]);
      if (isdigit(s[i]))
        size /= s[i] - '0';
      else
        --size;
    }

    throw;
  }
};"
"class Solution:
    def closedIsland(self, grid: List[List[int]]) -> int:
        m=len(grid)
        n=len(grid[0])
        ans=0
		#replacing all 0's to -1
        for i in range(m):
            for j in range(n):
                if grid[i][j]==0:
                    grid[i][j]=-1
		#reconverting -1's at boundaries and -1's connected with -1's at boundary to 0
        for i in range(m):
            for j in range(n):
                if (i==0 or i==m-1 or j==0 or j==n-1) and grid[i][j]==-1:
                    self.dfs(i,j,grid,m,n)
		#checking for number of closed island.
        for i in range(m):
            for j in range(n):
                if grid[i][j]==-1:
                    ans+=1
                    self.dfs(i,j,grid,m,n)
        return ans
    def dfs(self,row,col,grid,m,n):
        grid[row][col]=0
        if row-1>=0 and grid[row-1][col]==-1:
            self.dfs(row-1,col,grid,m,n)
        if row+1<m and grid[row+1][col]==-1:
            self.dfs(row+1,col,grid,m,n)
        if col-1>=0 and grid[row][col-1]==-1:
            self.dfs(row,col-1,grid,m,n)
        if col+1<n and grid[row][col+1]==-1:
            self.dfs(row,col+1,grid,m,n)
        return","class Solution {
 public:
  int numRescueBoats(vector<int>& people, int limit) {
    int ans = 0;

    sort(begin(people), end(people));

    for (int i = 0, j = people.size() - 1; i <= j; ++ans) {
      int remain = limit - people[j--];
      if (people[i] <= remain)
        ++i;
    }

    return ans;
  }
};"
"class Solution:
    def maxScoreWords(self, W: List[str], T: List[str], S: List[int]) -> int:
        L, CT, D, SL, X, M = len(W), collections.Counter(T), {a:S[i] for i,a in enumerate(string.ascii_lowercase)}, set(''.join(W)), set(), 0
        for n in range(1,L+1):
            for wc in itertools.combinations(range(L),n):
                if any(wc[:i] in X for i in range(1,len(wc)+1)): continue
                CC = collections.Counter(''.join([W[i] for i in wc]))
                if any(CT[c] < CC[c] for c in SL): X.add(wc)
                else: M = max(M,sum(D[i]*CC[i] for i in CC))
        return M
		
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {
    vector<vector<pair<int, int>>> graph(n);
    vector<int> dist(graph.size(), maxMoves + 1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int cnt = edge[2];
      graph[u].emplace_back(v, cnt);
      graph[v].emplace_back(u, cnt);
    }

    const int reachableNodes = dijkstra(graph, 0, maxMoves, dist);
    int reachableSubnodes = 0;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int cnt = edge[2];
      // Reachable nodes of `edge` from `u`.
      const int a = dist[u] > maxMoves ? 0 : min(maxMoves - dist[u], cnt);
      // Reachable nodes of `edge` from `v`.
      const int b = dist[v] > maxMoves ? 0 : min(maxMoves - dist[v], cnt);
      reachableSubnodes += min(a + b, cnt);
    }

    return reachableNodes + reachableSubnodes;
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src,
               int maxMoves, vector<int>& dist) {
    using P = pair<int, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[src] = 0;
    minHeap.emplace(dist[src], src);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      // Already take `maxMoves` to reach `u`, can't explore anymore.
      for (const auto& [v, w] : graph[u])
        if (d + w + 1 < dist[v]) {
          dist[v] = d + w + 1;
          minHeap.emplace(dist[v], v);
        }
    }

    return count_if(begin(dist), end(dist),
                    [&](int d) { return d <= maxMoves; });
  }
};"
"class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        dp = []
        for i in range(3):
            z = []
            for j in range(len(nums)):
                z.append(0)
            dp.append(z)
        dp[nums[0]%3][0] = nums[0]
        for i in range(1,len(nums)):
            for j in range(3):
                x = dp[j][i-1] + nums[i]
                dp[x%3][i] = max([dp[x%3][i], x, dp[x%3][i-1]])
                dp[j][i] = max(dp[j][i-1],dp[j][i])
        return dp[0][-1]","class Solution {
 public:
  int projectionArea(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i) {
      int maxOfRow = 0;
      int maxOfCol = 0;
      for (int j = 0; j < grid.size(); ++j) {
        maxOfRow = max(maxOfRow, grid[i][j]);
        maxOfCol = max(maxOfCol, grid[j][i]);
        if (grid[i][j])
          ++ans;
      }
      ans += maxOfRow + maxOfCol;
    }

    return ans;
  }
};"
"class Solution:
    def minPushBox(self, grid: List[List[str]]) -> int:
        # dfs to move person
        # bfs to move box
        m = len(grid)
        n = len(grid[0])
        dirc = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        
        si, sj, bi, bj, tari, tarj = -1, -1, -1, -1, -1, -1
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == ""S"":
                    si, sj = i, j
                if grid[i][j] == ""B"":
                    bi, bj = i, j
                if grid[i][j] == ""T"":
                    tari, tarj = i, j
        
        def ok(i, j, bi=-1, bj=-1):
            if i < 0 or j < 0 or i >= m or j >= n:
                return False
            if grid[i][j] == ""#"" or (i == bi and j == bj):
                return False
            return True
        
        def p_reachable(si, sj, ti, tj, bi, bj):
            if not ok(ti, tj, bi, bj):
                return False
            vis = set()
            def dfs(i, j):
                vis.add((i, j))
                if i == ti and j == tj:
                    return True
                flag = False
                for d in dirc:
                    newi, newj = i + d[0], j + d[1]
                    if ok(newi, newj, bi, bj) and (newi, newj) not in vis:
                        flag = flag or dfs(newi, newj)
                return flag
            return dfs(si, sj)
        
        queue = deque()
        queue.append(((bi, bj), (si, sj)))
        bvis = set()
        cnt = 0
        while queue:
            l = len(queue)
            for i in range(l):
                cur = queue.popleft()
                if cur[0][0] == tari and cur[0][1] == tarj:
                    return cnt
                for d in dirc:
                    newbi = cur[0][0] + d[0]
                    newsi = cur[0][0] - d[0]
                    newbj = cur[0][1] + d[1]
                    newsj = cur[0][1] - d[1]
                    if ok(newbi, newbj) and ((newbi, newbj), (cur[0][0], cur[0][1])) not in bvis and p_reachable(cur[1][0], cur[1][1], newsi, newsj, cur[0][0], cur[0][1]):
                        queue.append(((newbi, newbj), (cur[0][0], cur[0][1])))
                        bvis.add(((newbi, newbj), (cur[0][0], cur[0][1])))
            cnt += 1
        return -1","class Solution {
 public:
  vector<string> uncommonFromSentences(string A, string B) {
    vector<string> ans;
    unordered_map<string, int> count;
    istringstream iss(A + ' ' + B);

    while (iss >> A)
      ++count[A];

    for (const auto& [word, freq] : count)
      if (freq == 1)
        ans.push_back(word);

    return ans;
  }
};"
"class Solution:
    def minTimeToVisitAllPoints(self, P: List[List[int]]) -> int:
        L, t = len(P), 0
        for i in range(L-1):
            (a,b), (c,d) = P[i], P[i+1]
            t += max(abs(a-c),abs(b-d))
        return t
		
		
- Junaid Mansuri","class Solution {
 public:
  vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart,
                                      int cStart) {
    const vector<int> dx{1, 0, -1, 0};
    const vector<int> dy{0, 1, 0, -1};
    vector<vector<int>> ans{{rStart, cStart}};

    for (int i = 0; ans.size() < rows * cols; ++i)
      for (int step = 0; step < i / 2 + 1; ++step) {
        rStart += dy[i % 4];
        cStart += dx[i % 4];
        if (0 <= rStart && rStart < rows && 0 <= cStart && cStart < cols)
          ans.push_back({rStart, cStart});
      }

    return ans;
  }
};"
"class Solution:
    def countServers(self, grid: List[List[int]]) -> int:
        R = len(grid)
        C = len(grid[0])        
        visited = set()
        
        def neighbours(r, c, grid):
            nei = set()
            for i in range(C):
                nei.add((r,i))
            for j in range(R):
                nei.add((j,c))
            nei.discard((r,c))
            return nei
                    
        def dfs(grid,i,j, visited):
            for nei in neighbours(i,j, grid):
                x, y = nei
                if nei not in visited and grid[x][y] == 1:
                    visited.add(nei)
        
        for i, row in enumerate(grid):
            for j, val in enumerate(row):
                if val == 1:
                    dfs(grid, i, j, visited)
        
        return len(visited)","enum Color { kWhite, kRed, kGreen };

class Solution {
 public:
  bool possibleBipartition(int n, vector<vector<int>>& dislikes) {
    vector<vector<int>> graph(n + 1);
    vector<Color> colors(n + 1, Color::kWhite);

    for (const vector<int>& d : dislikes) {
      const int u = d[0];
      const int v = d[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    // Reduce to 785. Is Graph Bipartite?
    for (int i = 1; i <= n; ++i)
      if (colors[i] == Color::kWhite &&
          !isValidColor(graph, i, colors, Color::kRed))
        return false;

    return true;
  }

 private:
  bool isValidColor(const vector<vector<int>>& graph, int u,
                    vector<Color>& colors, Color color) {
    // The painted color should be same as the `color`
    if (colors[u] != Color::kWhite)
      return colors[u] == color;

    colors[u] = color;  // Always paint w/ `color`

    // All children should have valid colors
    for (const int v : graph[u])
      if (!isValidColor(graph, v, colors,
                        color == Color::kRed ? Color::kGreen : Color::kRed))
        return false;

    return true;
  }
};"
"class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        ans = []
        n = len(products)
        now = products
        
        #iterate through length of searchWord
        for i in range(len(searchWord)):
            temp = []
            
            #iterate through length of current list
            for j in range(len(now)):
                
                #check if there are enough characters 
                if len(now[j])>= i and searchWord[:i+1] == now[j][:i+1]:
                    temp.append(now[j])
            
            #top 3 words hence sort
            temp.sort()
            
            if len(temp)>3:
                ans.append(temp[:3])
            else:
                ans.append(temp)
            now = temp
            
        return ans","class Solution {
 public:
  int superEggDrop(int k, int n) {
    // dp[k][n] := min # of moves to know f with k eggs and n floors
    dp.resize(k + 1, vector<int>(n + 1, -1));
    return drop(k, n);
  }

 private:
  vector<vector<int>> dp;

  int drop(int k, int n) {
    if (k == 0)  // No eggs -> done
      return 0;
    if (k == 1)  // One egg -> drop from 1-th floor to n-th floor
      return n;
    if (n == 0)  // No floor -> done
      return 0;
    if (n == 1)  // One floor -> drop from that floor
      return 1;
    if (dp[k][n] != -1)
      return dp[k][n];

    dp[k][n] = INT_MAX;

    for (int i = 1; i <= n; ++i) {
      const int broken = drop(k - 1, i - 1);
      const int unbroken = drop(k, n - i);
      dp[k][n] = min(dp[k][n], 1 + max(broken, unbroken));
    }

    return dp[k][n];
  }
};"
"class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        n = min(arrLen, steps//2+1) #reachable right end
        ways = [1] + [0]*(n-1)
        for step in range(steps): 
            ways = [sum(ways[max(0,i-1):i+2]) % (10**9+7) for i in range(min(step+2,steps-step,n))]
        return ways[0]","class Solution {
 public:
  vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {
    const int diff = (accumulate(begin(aliceSizes), end(aliceSizes), 0) -
                      accumulate(begin(bobSizes), end(bobSizes), 0)) /
                     2;
    const unordered_set<int> bobSizesSet{begin(bobSizes), end(bobSizes)};

    for (const int aliceSize : aliceSizes) {
      const int target = aliceSize - diff;
      if (bobSizesSet.count(target))
        return {aliceSize, target};
    }

    throw;
  }
};"
"class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        class Score:
            def __init__(self):
                self.rows = [0 for i in range(3)]
                self.cols = [0 for i in range(3)]
                self.diag = 0
                self.adiag = 0
        A = Score()
        B = Score()
        for i, (x,y) in enumerate(moves):
            player = B if (i % 2) else A
            player.rows[x] += 1
            player.cols[y] += 1
            if (x == y):
                player.diag += 1
            if (x + y == 2):
                player.adiag += 1
                
            if 3 in A.rows or 3 in A.cols or A.diag == 3 or A.adiag == 3:
                return ""A""
            if 3 in B.rows or 3 in B.cols or B.diag == 3 or B.adiag == 3:
                return ""B""
            
        if len(moves) == 9:
            return ""Draw""
        else:
            return ""Pending""","class Solution {
 public:
  TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {
    unordered_map<int, int> postToIndex;

    for (int i = 0; i < post.size(); ++i)
      postToIndex[post[i]] = i;

    return build(pre, 0, pre.size() - 1, post, 0, post.size() - 1, postToIndex);
  }

 private:
  TreeNode* build(const vector<int>& pre, int preStart, int preEnd,
                  const vector<int>& post, int postStart, int postEnd,
                  const unordered_map<int, int>& postToIndex) {
    if (preStart > preEnd)
      return nullptr;
    if (preStart == preEnd)
      return new TreeNode(pre[preStart]);

    const int rootVal = pre[preStart];
    const int leftRootVal = pre[preStart + 1];
    const int leftRootPostIndex = postToIndex.at(leftRootVal);
    const int leftSize = leftRootPostIndex - postStart + 1;

    TreeNode* root = new TreeNode(rootVal);
    root->left = build(pre, preStart + 1, preStart + leftSize, post, postStart,
                       leftRootPostIndex, postToIndex);
    root->right = build(pre, preStart + leftSize + 1, preEnd, post,
                        leftRootPostIndex + 1, postEnd - 1, postToIndex);
    return root;
  }
};"
"class Solution:
    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:
        if tomatoSlices &amp; 1 or not (2*cheeseSlices <= tomatoSlices <= 4*cheeseSlices): return []
        return [(tomatoSlices - 2*cheeseSlices)//2, (4*cheeseSlices - tomatoSlices)//2]","class Solution {
 public:
  vector<string> findAndReplacePattern(vector<string>& words, string pattern) {
    vector<string> ans;

    for (const string& word : words)
      if (isIsomorphic(word, pattern))
        ans.push_back(word);

    return ans;
  }

 private:
  bool isIsomorphic(const string& w, const string& p) {
    vector<int> map_w(128);
    vector<int> map_p(128);

    for (int i = 0; i < w.length(); ++i) {
      if (map_w[w[i]] != map_p[p[i]])
        return false;
      map_w[w[i]] = i + 1;
      map_p[p[i]] = i + 1;
    }

    return true;
  }
};"
"class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        total = 0
        dp = [[0] * len(row) for row in matrix]
        for i, row in enumerate(matrix):
            for j, num in enumerate(row):
                if not num:
                    continue
                upper = 0
                if i-1 >= 0:
                    upper = dp[i-1][j]
                left = 0
                if j-1 >= 0:
                    left = dp[i][j-1]
                diag = 0
                if i-1 >= 0 and j-1 >= 0:  # Can this be made less redundant?
                    diag = dp[i-1][j-1]
                dp[i][j] = min(upper, left, diag) + 1
                total += dp[i][j]
        return total","class Solution {
 public:
  int sumSubseqWidths(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    long ans = 0;
    long exp = 1;

    sort(begin(nums), end(nums));

    for (int i = 0; i < n; ++i, exp = exp * 2 % kMod) {
      ans += (nums[i] - nums[n - i - 1]) * exp;
      ans %= kMod;
    }

    return ans;
  }
};"
"class Solution:
    def palindromePartition(self, s: str, k: int) -> int:
        
        n = len(s)
        
        def getChanges(i, j):
            ret = 0
            while i < j:
                if s[i] != s[j]:
                    ret += 1
                i += 1
                j -= 1
            return ret
        
        cost = [[getChanges(i, j) for j in range(n)] for i in range(n)]

        @cache
        def res(l = 0, r = 0, k = k):
            if l == len(s) and r == len(s) and k == 0:
                return 0
            elif r == len(s) or k <= 0:
                return math.inf
            else:
                return min(cost[l][r] + res(r + 1, r + 1, k - 1), res(l, r +1, k))
        
        return res()","class Solution {
 public:
  int surfaceArea(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid.size(); ++j) {
        if (grid[i][j])
          ans += grid[i][j] * 4 + 2;
        if (i > 0)
          ans -= min(grid[i][j], grid[i - 1][j]) * 2;
        if (j > 0)
          ans -= min(grid[i][j], grid[i][j - 1]) * 2;
      }

    return ans;
  }
};"
"class Solution:
    def subtractProductAndSum(self, n: int) -> int:
        digit_prod = 1
        digit_sum = 0
        for i in range(len(str(n))):
            digit_prod *= int(str(n)[i]) 
            digit_sum += int(str(n)[i])
        return digit_prod - digit_sum","class Solution {
 public:
  int numSpecialEquivGroups(vector<string>& A) {
    unordered_set<string> set;

    for (const string& s : A) {
      string even;
      string odd;
      for (int i = 0; i < s.length(); ++i)
        if (i % 2 == 0)
          even += s[i];
        else
          odd += s[i];
      sort(begin(even), end(even));
      sort(begin(odd), end(odd));
      set.insert(even + odd);
    }

    return set.size();
  }
};"
"class Solution:
    def groupThePeople(self, G: List[int]) -> List[List[int]]:
        S, D = set(G), collections.defaultdict(list)
        for i, g in enumerate(G): D[g].append(i)
        return [D[i][i*j:i*(j+1)] for i in S for j in range(G.count(i)//i)]
		
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  vector<TreeNode*> allPossibleFBT(int n) {
    if (n % 2 == 0)
      return {};
    if (n == 1)
      return {new TreeNode(0)};
    if (const auto it = memo.find(n); it != cend(memo))
      return it->second;

    vector<TreeNode*> ans;

    for (int leftCount = 0; leftCount < n; ++leftCount) {
      const int rightCount = n - 1 - leftCount;
      for (TreeNode* left : allPossibleFBT(leftCount))
        for (TreeNode* right : allPossibleFBT(rightCount)) {
          ans.push_back(new TreeNode(0));
          ans.back()->left = left;
          ans.back()->right = right;
        }
    }

    return memo[n] = ans;
  }

 private:
  unordered_map<int, vector<TreeNode*>> memo;
};"
"class Solution:
    def smallestDivisor(self, N: List[int], t: int) -> int:
        N.sort(); a, b, ceil = 1, N[-1], math.ceil
        while a < b:
            m = (a+b)//2
            if sum(ceil(n/m) for n in N) > t: a = m + 1
            else: b = m
        return a","class Solution {
 public:
  bool isMonotonic(vector<int>& nums) {
    bool increasing = true;
    bool decreasing = true;

    for (int i = 1; i < nums.size(); ++i) {
      increasing &= nums[i] >= nums[i - 1];
      decreasing &= nums[i] <= nums[i - 1];
    }

    return increasing || decreasing;
  }
};"
"class Solution:
    def minFlips(self, G: List[List[int]]) -> int:
        M, N = len(G), len(G[0])
        P = [(i,j) for i,j in itertools.product(range(M),range(N))]
        for n in range(M*N+1):
            for p in itertools.permutations(P,n):
                H = list(map(list,G))
                for (x,y) in p:
                    for (i,j) in (x,y-1),(x,y),(x,y+1),(x-1,y),(x+1,y):
                        if 0 <= i < M and 0 <= j < N: H[i][j] = 1 - H[i][j]
                if max(max(H)) == 0: return n
        return -1
		
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  TreeNode* increasingBST(TreeNode* root, TreeNode* tail = nullptr) {
    if (root == nullptr)
      return tail;

    TreeNode* ans = increasingBST(root->left, root);
    root->left = nullptr;
    root->right = increasingBST(root->right, tail);
    return ans;
  }
};"
"class Solution:
    def findSpecialInteger(self, arr: List[int]) -> int:
        larr = len(arr)
        
        if larr == 0:
            return None
        
        v = len(arr)*.25
        
        prev = None
        ct = 0
        for e in arr:
            if e == prev:
                ct += 1
            else:
                ct = 1
            prev = e
            if ct > v:
                return e
        return None","class Solution {
 public:
  int subarrayBitwiseORs(vector<int>& arr) {
    vector<int> s;
    int l = 0;

    for (const int a : arr) {
      const int r = s.size();
      s.push_back(a);
      // s[l..r) are values generated in previous iteration
      for (int i = l; i < r; ++i)
        if (s.back() != (s[i] | a))
          s.push_back(s[i] | a);
      l = r;
    }

    return unordered_set<int>(begin(s), end(s)).size();
  }
};"
"class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        ans, prev = 0, -inf
        for _, y in sorted(intervals, key=lambda x: (x[0], -x[1])): 
            if y > prev: ans, prev = ans+1, y
        return ans","class Solution {
 public:
  string orderlyQueue(string s, int k) {
    if (k > 1) {
      sort(begin(s), end(s));
      return s;
    }

    string ans = s;

    for (int i = 1; i < s.length(); ++i)
      ans = min(ans, s.substr(i) + s.substr(0, i));

    return ans;
  }
};"
"class Solution:
    def minFallingPathSum(self, arr: List[List[int]]) -> int:
        if not arr or not arr[0]:
            return 0
        m, n = len(arr), len(arr[0])
        if n == 1:
            return arr[0][0] if m == 1 else 0
        dp = [[-1, 0], [-1, 0]]
        for i in range(m):
            min1, min2 = [[-1, float(""inf"")], [-1, float(""inf"")]]
            for j in range(n):
                min_idx = 0 if dp[0][0] != j else 1
                cur_val = dp[min_idx][1] + arr[i][j]
                if cur_val < min1[1]:
                    min1, min2 = [j, cur_val], min1
                elif cur_val < min2[1]:
                    min2 = [j, cur_val]
            dp = [min1, min2]
        return dp[0][1]","class StockSpanner {
 public:
  int next(int price) {
    int span = 1;
    while (!stack.empty() && stack.top().first <= price)
      span += stack.top().second, stack.pop();
    stack.emplace(price, span);
    return span;
  }

 private:
  stack<pair<int, int>> stack;  // (price, span)
};"
"class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        decn = 0
        while head:
            decn = decn*2 + head.val
            head = head.next
        
        return decn","class Solution {
 public:
  int atMostNGivenDigitSet(vector<string>& digits, int n) {
    int ans = 0;
    const string num = to_string(n);

    for (int i = 1; i < num.length(); ++i)
      ans += pow(digits.size(), i);

    for (int i = 0; i < num.length(); ++i) {
      bool dHasSameNum = false;
      for (const string& digit : digits) {
        if (digit[0] < num[i])
          ans += pow(digits.size(), num.length() - i - 1);
        else if (digit[0] == num[i])
          dHasSameNum = true;
      }
      if (!dHasSameNum)
        return ans;
    }

    return ans + 1;
  }
};"
"class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:
        def recur(number, ans):
            intNum = int(number)
            if intNum >= low and intNum <= high:  ans.append(intNum)
            if number[-1] != '9':                 recur( number + str( int(number[-1])+1 ), ans)
        ans =  []
        for i in range(1, 9): recur(str(i), ans)
        ans.sort()
        return ans","class Solution {
 public:
  int numPermsDISequence(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    // dp[i][j] := # of valid permutations w/ i + 1 digits, where s[i] is j-th
    // Digit of remaining digits
    vector<vector<int>> dp(n + 1, vector<int>(n + 1));

    // When there's only one digit, the # of perms is 1
    for (int j = 0; j <= n; ++j)
      dp[0][j] = 1;

    for (int i = 1; i <= n; ++i)
      if (s[i - 1] == 'I') {  // s[i - 1] == 'I'
        // Calculate postfix sum to prevent duplicate calculation
        int postfixsum = 0;
        for (int j = n - i; j >= 0; --j) {
          postfixsum = (postfixsum + dp[i - 1][j + 1]) % kMod;
          dp[i][j] = postfixsum;
        }
      } else {  // s[i - 1] == 'D'
        // Calculate prefix sum to prevent duplicate calculation
        int prefix = 0;
        for (int j = 0; j <= n - i; ++j) {
          prefix = (prefix + dp[i - 1][j]) % kMod;
          dp[i][j] = prefix;
        }
      }

    return dp[n][0];
  }
};"
"class Solution:
    def maxSideLength(self, G: List[List[int]], t: int) -> int:
        M, N, m = len(G), len(G[0]), 0; S = [[0]*(N+1) for _ in range(M+1)]
        S[1] = list(itertools.accumulate([0]+G[0]))
        for i in range(1,M):
            s = list(itertools.accumulate(G[i]))
            for j in range(N): S[i+1][j+1] = s[j] + S[i][j+1]
        for i,j in itertools.product(range(M),range(N)):
            for L in range(m+1, min(M-i+1,N-j+1)):
                if S[i+L][j+L]-S[i][j+L]-S[i+L][j]+S[i][j] <= t: m = max(m,L)
                else: break
        return m
		
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  int totalFruit(vector<int>& fruits) {
    int ans = 0;
    unordered_map<int, int> count;

    for (int l = 0, r = 0; r < fruits.size(); ++r) {
      ++count[fruits[r]];
      while (count.size() > 2) {
        if (--count[fruits[l]] == 0)
          count.erase(fruits[l]);
        ++l;
      }
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};"
"class Solution:
    def shortestPath(self, G: List[List[int]], k: int) -> int:
        M, N, P, Q, D, L = len(G)-1, len(G[0])-1, [(0,0,0)], [], {}, 0
        if k >= M+N: return M+N
        while P:
            for (x,y,s) in P:
                if (x,y) == (M,N): return L
                for i,j in (x-1,y),(x,y+1),(x+1,y),(x,y-1):
                    if 0<=i<=M and 0<=j<=N:
                        t = s + G[i][j]
                        if t <= k and D.get((i,j),math.inf) > t: D[(i,j)], _ = t, Q.append((i,j,t))
            P, Q, L = Q, [], L + 1
        return -1
		
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  vector<int> sortArrayByParity(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      if (nums[l] % 2 == 1 && nums[r] % 2 == 0)
        swap(nums[l], nums[r]);
      if (nums[l] % 2 == 0)
        ++l;
      if (nums[r] % 2 == 1)
        --r;
    }

    return nums;
  }
};"
"class Solution(object):
    def findNumbers(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        #iniializing the counter
        counter = 0
        for i in nums:
            #counting the digits in the number
            count = 0
            while (i > 0):
                i = i//10
                count = count + 1
            #checking wether the count is even or odd
            if count % 2 == 0:
                counter +=1
        return counter","class Solution {
 public:
  int superpalindromesInRange(string left, string right) {
    int ans = 0;
    long long l = stoll(left);
    long long r = stoll(right);

    for (long long i = sqrt(l); i * i <= r;) {
      long long palindrome = nextPalindrome(i);
      long long squared = palindrome * palindrome;
      if (squared <= r && isPalindrome(squared))
        ++ans;
      i = palindrome + 1;
    }

    return ans;
  }

 private:
  long long nextPalindrome(int num) {
    const string s = to_string(num);
    const int n = s.length();
    string half = s.substr(0, (n + 1) / 2);
    string reversedHalf = reversed(half.substr(0, n / 2));
    const long long candidate = stoll(half + reversedHalf);
    if (candidate >= num)
      return candidate;

    half = to_string(stoll(half) + 1);
    reversedHalf = reversed(half.substr(0, n / 2));
    return stoll(half + reversedHalf);
  }

  string reversed(const string& s) {
    return {rbegin(s), rend(s)};
  }

  bool isPalindrome(long long num) {
    const string s = to_string(num);
    int l = 0;
    int r = s.length() - 1;

    while (l < r)
      if (s[l++] != s[r--])
        return false;

    return true;
  }
};"
"class Solution:
    def isPossibleDivide(self, N: List[int], k: int) -> bool:
        L, C = len(N), collections.Counter(N)
        for i in range(L//k):
            m = min(C.keys())
            for j in range(m,m+k):
                if C[j] > 1: C[j] -= 1
                else: del C[j]
        return not (C or L % k)
		
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  int sumSubarrayMins(vector<int>& arr) {
    constexpr int kMod = 1'000'000'007;
    const int n = arr.size();
    long ans = 0;
    // prevMin[i] := index k s.t. arr[k] is the prev min in arr[:i]
    vector<int> prevMin(n, -1);
    // nextMin[i] := index k s.t. arr[k] is the next min in arr[i + 1:]
    vector<int> nextMin(n, n);
    stack<int> stack;

    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && arr[stack.top()] > arr[i]) {
        const int index = stack.top();
        stack.pop();
        nextMin[index] = i;
      }
      if (!stack.empty())
        prevMin[i] = stack.top();
      stack.push(i);
    }

    for (int i = 0; i < n; ++i) {
      ans += static_cast<long>(arr[i]) * (i - prevMin[i]) * (nextMin[i] - i);
      ans %= kMod;
    }

    return ans;
  }
};"
"class Solution:
    def maxFreq(self, s: str, M: int, m: int, _: int) -> int:
        L, D = len(s), collections.defaultdict(int)
        for j in range(L+1-m): D[s[j:j+m]] += (len(set(s[j:j+m])) <= M)
        return max(D.values())
		
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  int smallestRangeI(vector<int>& nums, int k) {
    const int max = *max_element(begin(nums), end(nums));
    const int min = *min_element(begin(nums), end(nums));
    return std::max(0, max - min - 2 * k);
  }
};"
"class Solution:
    def maxCandies(self, S: List[int], C: List[int], K: List[List[int]], CB: List[List[int]], I: List[int]) -> int:
        t, I, S, B = 0, set(I), set([i for i,v in enumerate(S) if v]), 1
        while B:
            B = 0
            for b in I &amp; S: t, I, S, B = t + C[b], I.union(set(CB[b]))-{b}, S.union(set(K[b])), 1
        return t
            
            
            
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  int snakesAndLadders(vector<vector<int>>& board) {
    const int n = board.size();
    int ans = 0;
    queue<int> q{{1}};
    vector<bool> seen(1 + n * n);
    vector<int> A(1 + n * n);  // 2D -> 1D

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        A[(n - 1 - i) * n + (n - i & 1 ? j + 1 : n - j)] = board[i][j];

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const int curr = q.front();
        q.pop();
        for (int next = curr + 1; next <= min(curr + 6, n * n); ++next) {
          const int dest = A[next] > 0 ? A[next] : next;
          if (dest == n * n)
            return ans;
          if (seen[dest])
            continue;
          q.push(dest);
          seen[dest] = true;
        }
      }
    }

    return -1;
  }
};"
"class Solution:
    def replaceElements(self, arr: List[int]) -> List[int]:
        res = [-1]
        for i in range(len(arr)-1, 0, -1):
            res.append(max(res[-1], arr[i]))
        return res[::-1]","class Solution {
 public:
  int smallestRangeII(vector<int>& nums, int k) {
    sort(begin(nums), end(nums));

    int ans = nums.back() - nums.front();
    const int left = nums.front() + k;
    const int right = nums.back() - k;

    for (int i = 0; i + 1 < nums.size(); ++i) {
      const int mini = min(left, nums[i + 1] - k);
      const int maxi = max(right, nums[i] + k);
      ans = min(ans, maxi - mini);
    }

    return ans;
  }
};"
"class Solution:
    def solve(self,arr,k):    # returns the sum of arr , when replaced with k by fallowing 
                                # the given conditions  
        i=0
        while i<len(arr):
            if arr[i]>k:
                break
            i=i+1
            
        d=len(arr)-i
        d=d*k
        d=d+sum(arr[:i])
        return d
    
    def findBestValue(self, arr: List[int], target: int) -> int:
        end=max(arr)
        start=1
        x=0
        res=0
        rx=0
        arr.sort()
        while start<=end:
            mid=start+(end-start)//2
            a=list(arr)
            x=self.solve(a,mid) 
            
            if x<target:
                start=mid+1
            else:
                end=mid-1
                
            if abs(rx-target)>abs(target-x):
                rx=x                             
                res=mid
            elif abs(rx-target)==abs(target-x):
                res=min(res,mid)
                rx=min(rx,x)
                
        return res
    
    #rx is the sum of previous minimum number replaced in the array
    # mid is the number we are storing in the res  which is the number we are replacing in the array
    # every time we store sum of arr and mid  (mid is the number we are replacing in the arr  to get that sum)  considering the minimum","class Solution {
 public:
  vector<int> sortArray(vector<int>& nums) {
    mergeSort(nums, 0, nums.size() - 1);
    return nums;
  }

 private:
  void mergeSort(vector<int>& A, int l, int r) {
    if (l >= r)
      return;

    const int m = (l + r) / 2;
    mergeSort(A, l, m);
    mergeSort(A, m + 1, r);
    merge(A, l, m, r);
  }

  void merge(vector<int>& A, int l, int m, int r) {
    vector<int> sorted(r - l + 1);
    int k = 0;      // sorted's index
    int i = l;      // left's index
    int j = m + 1;  // right's index

    while (i <= m && j <= r)
      if (A[i] < A[j])
        sorted[k++] = A[i++];
      else
        sorted[k++] = A[j++];

    // Put possible remaining left part to the sorted array
    while (i <= m)
      sorted[k++] = A[i++];

    // Put possible remaining right part to the sorted array
    while (j <= r)
      sorted[k++] = A[j++];

    copy(begin(sorted), end(sorted), begin(A) + l);
  }
};"
"class Solution:
    def pathsWithMaxScore(self, B: List[str]) -> List[int]:
        L, D, B[-1], m = len(B), {(0,0):(0,1)}, B[-1][:-1]+'0', 10**9 + 7
        def dfs(i,j):
            if (i,j) in D: return D[(i,j)]
            if i < 0 or j < 0 or B[i][j] == ""X"": return (0,0)
            SP = [dfs(x,y) for x,y in [(i-1,j),(i,j-1),(i-1,j-1)]]
            S = max(SP[i][0] for i in range(3))
            D[(i,j)] = (int(B[i][j]) + S, sum(y for x,y in SP if x == S))
            return D[(i,j)]
        (MS,MP) = dfs(L-1,L-1)
        return [[MS,0][MP == 0], MP % m]
		
		
- Junaid Mansuri
- Chicago, IL","enum class State { kDraw, kMouseWin, kCatWin };

class Solution {
 public:
  int catMouseGame(vector<vector<int>>& graph) {
    const int n = graph.size();
    // Result of (cat, mouse, move)
    // Move := 0 (mouse) / 1 (cat)
    vector<vector<vector<State>>> states(
        n, vector<vector<State>>(n, vector<State>(2)));
    vector<vector<vector<int>>> outDegree(
        n, vector<vector<int>>(n, vector<int>(2)));
    queue<tuple<int, int, int, State>> q;  // (cat, mouse, move, state)

    for (int cat = 0; cat < n; ++cat)
      for (int mouse = 0; mouse < n; ++mouse) {
        outDegree[cat][mouse][0] = graph[mouse].size();
        outDegree[cat][mouse][1] =
            graph[cat].size() - count(begin(graph[cat]), end(graph[cat]), 0);
      }

    // Start from states that winner can be determined
    for (int cat = 1; cat < n; ++cat)
      for (int move = 0; move < 2; ++move) {
        // Mouse is in the hole -> State::kMouseWin
        states[cat][0][move] = State::kMouseWin;
        q.emplace(cat, 0, move, State::kMouseWin);
        // Cat catches mouse -> State::kCatWin
        states[cat][cat][move] = State::kCatWin;
        q.emplace(cat, cat, move, State::kCatWin);
      }

    while (!q.empty()) {
      const auto [cat, mouse, move, state] = q.front();
      q.pop();
      if (cat == 2 && mouse == 1 && move == 0)
        return static_cast<int>(state);
      const int prevMove = move ^ 1;
      for (const int prev : graph[prevMove ? cat : mouse]) {
        const int prevCat = prevMove ? prev : cat;
        if (prevCat == 0)  // Invalid
          continue;
        const int prevMouse = prevMove ? mouse : prev;
        // The state is already determined
        if (states[prevCat][prevMouse][prevMove] != State::kDraw)
          continue;
        if (prevMove == 0 && state == State::kMouseWin ||
            prevMove == 1 && state == State::kCatWin ||
            --outDegree[prevCat][prevMouse][prevMove] == 0) {
          states[prevCat][prevMouse][prevMove] = state;
          q.emplace(prevCat, prevMouse, prevMove, state);
        }
      }
    }

    return static_cast<int>(states[2][1][0]);
  }
};"
"class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        
        queue = deque()
        queue.append(root)
        
        res = []
        while queue:
            temp = []
            for _ in range(len(queue)):
                node = queue.popleft()
                temp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(temp)
    
        return sum(res[-1])","class Solution {
 public:
  bool hasGroupsSizeX(vector<int>& deck) {
    unordered_map<int, int> count;
    int gcd = 0;

    for (const int d : deck)
      ++count[d];

    for (const auto& [_, value] : count)
      gcd = __gcd(gcd, value);

    return gcd >= 2;
  }
};"
"class Solution:
    def sumZero(self, n: int) -> List[int]:
        l = []
        if n % 2 == 0:
            for i in range(1, n//2 + 1):
                l.append(i * 2)
                l.append(-i * 2)
        else:
            for i in range(-n//2 + 1, n//2 + 1):
                l.append(i)
        return l","class Solution {
 public:
  int partitionDisjoint(vector<int>& nums) {
    const int n = nums.size();
    vector<int> min(n);
    min[n - 1] = nums[n - 1];
    int max = INT_MIN;

    for (int i = n - 2; i >= 0; --i)
      min[i] = std::min(min[i + 1], nums[i]);

    for (int i = 0; i < n; ++i) {
      max = std::max(max, nums[i]);
      if (max <= min[i + 1])
        return i + 1;
    }

    throw;
  }
};"
"class Solution:
    
    def __init__(self):
        self.l1 = []
        self.l2 = []
    
    def inOrder(self,root, s):
        if root == None:
            return
        self.inOrder(root.left, s)
        s.append(root.val)
        self.inOrder(root.right, s)
    
    
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        self.inOrder(root1, self.l1)
        self.inOrder(root2, self.l2)
        l = self.l1 + self.l2 
        l.sort()
        return l","class Solution {
 public:
  vector<string> wordSubsets(vector<string>& A, vector<string>& B) {
    vector<string> ans;
    vector<int> countB(26);

    for (const string& b : B) {
      vector<int> temp = counter(b);
      for (int i = 0; i < 26; ++i)
        countB[i] = max(countB[i], temp[i]);
    }

    for (const string& a : A)
      if (isUniversal(counter(a), countB))
        ans.push_back(a);

    return ans;
  }

 private:
  vector<int> counter(const string& s) {
    vector<int> count(26);
    for (char c : s)
      ++count[c - 'a'];
    return count;
  }

  bool isUniversal(vector<int> countA, vector<int>& countB) {
    for (int i = 0; i < 26; ++i)
      if (countA[i] < countB[i])
        return false;
    return true;
  }
};"
"class Solution:
    def canReach(self, A: List[int], S: int) -> bool:
        L, V, C = len(A), set(), collections.deque([S])
        while C:
            _, i = V.update(C), C.popleft()
            if A[i] == 0: return True
            if i-A[i] >=0 and i-A[i] not in V: C.append(i-A[i])
            if i+A[i] < L and i+A[i] not in V: C.append(i+A[i])
        return False
        

- Junaid MAnsuri
- Chicago, IL","class Solution {
 public:
  string reverseOnlyLetters(string s) {
    for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {
      while (i < j && !isalpha(s[i]))
        ++i;
      while (i < j && !isalpha(s[j]))
        --j;
      swap(s[i], s[j]);
    }
    return s;
  }
};"
"class Solution:
    def isSolvable(self, W: List[str], R: str) -> bool:
        LW, LR, F, ML, AW, V, LMap = len(W), len(R), set([w[0] for w in W+[R]]), max(map(len, W+[R])), W+[R], set(), {}
        if LR < ML: return False
        def dfs(d,i,c):
            if d == ML: return c == 0
            if i == len(W) + 1:
                s = sum(LMap[w[-d-1]] if d < len(w) else 0 for w in W) + c
                return dfs(d+1,0,s//10) if s % 10 == LMap[R[-d-1]] else False
            if i < LW and d >= len(W[i]): return dfs(d,i+1,c)
            ch = AW[i][-d-1]
            if ch in LMap: return dfs(d,i+1,c)
            for x in range((ch in F), 10):
                if x not in V:
                    LMap[ch], _ = x, V.add(x)
                    if dfs(d,i+1,c): return True
                    V.remove(LMap.pop(ch))
        return dfs(0,0,0)
		
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  int maxSubarraySumCircular(vector<int>& nums) {
    int totalSum = 0;
    int currMaxSum = 0;
    int currMinSum = 0;
    int maxSum = INT_MIN;
    int minSum = INT_MAX;

    for (const int num : nums) {
      totalSum += num;
      currMaxSum = max(currMaxSum + num, num);
      currMinSum = min(currMinSum + num, num);
      maxSum = max(maxSum, currMaxSum);
      minSum = min(minSum, currMinSum);
    }

    return maxSum < 0 ? maxSum : max(maxSum, totalSum - minSum);
  }
};"
"class Solution:
    def freqAlphabets(self, s: str) -> str:
        x = ''
        i = len(s)-1
        while i > -1:
            if s[i] == '#':
                if int(s[i-2:i])%26 == 0:
                    x = chr(96+26) + x
                else:
                    x = chr(96 + int(s[i-2:i])%26) + x
                i -= 3
            else:
                x = chr(96 + int(s[i])%26) + x
                i -= 1
        return x","class Solution {
 public:
  int numMusicPlaylists(int n, int goal, int k) {
    this->n = n;
    this->k = k;
    // dp[i][j] := # of playlists with i songs and j different songs
    dp.resize(goal + 1, vector<long>(n + 1, -1));
    return playlists(goal, n);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  int n;
  int k;
  vector<vector<long>> dp;

  long playlists(int i, int j) {
    if (i == 0)
      return j == 0;
    if (j == 0)
      return 0;
    if (dp[i][j] >= 0)
      return dp[i][j];

    dp[i][j] = playlists(i - 1, j - 1) * (n - (j - 1));  // Last song is new
    dp[i][j] += playlists(i - 1, j) * max(0, j - k);     // Last song is old
    return dp[i][j] %= kMod;
  }
};"
"class Solution:
    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:
        graph = collections.defaultdict(list)
        for u, v in enumerate(friends):
            for i in v:
                graph[u].append(i)
        queue = collections.deque()
        queue.append((id, 0))
        visited = set()
        visited.add(id)
        res = collections.defaultdict(int)
        while queue:
            id, l = queue.popleft()
            if l == level:
                for j in watchedVideos[id]:
                    res[j] += 1
            for v in graph[id]:
                if l+1 <= level and v not in visited:
                    visited.add(v)
                    queue.append((v, l+1))
        from functools import cmp_to_key
        def func(x, y):
            if res[x] > res[y]:
                return -1
            elif res[y] > res[x]:
                return 1
            else:
                if x > y:
                    return -1
                elif y > x:
                    return 1
                else:
                    return 0
        return (sorted(res.keys(), key=cmp_to_key(func)))[::-1]","class Solution {
 public:
  int minAddToMakeValid(string s) {
    int l = 0;
    int r = 0;

    for (const char c : s)
      if (c == '(') {
        ++l;
      } else {
        if (l == 0)
          ++r;
        else
          --l;
      }

    return l + r;
  }
};"
"class Solution:
    def minInsertions(self, s: str) -> int:
        n = len(s)
        dp = [[0 for i in range(n)] for j in range(n)]
        
        r=0
        c=1
        
        while c<n:
            ci = c
            r = 0
            
            while ci<n and r<n:
                if s[ci] == s[r]:
                    dp[r][ci] = dp[r+1][ci-1]
                else:
                    dp[r][ci] = 1+min(dp[r+1][ci],dp[r][ci-1])
                ci+=1
                r+=1
            c+=1
        return dp[0][n-1]","class Solution {
 public:
  vector<int> sortArrayByParityII(vector<int>& nums) {
    const int n = nums.size();

    for (int i = 0, j = 1; i < n; i += 2, j += 2) {
      while (i < n && nums[i] % 2 == 0)
        i += 2;
      while (j < n && nums[j] % 2 == 1)
        j += 2;
      if (i < n)
        swap(nums[i], nums[j]);
    }

    return nums;
  }
};"
"class Solution:
    def decompressRLElist(self, nums: List[int]) -> List[int]:
        k = 0
        arr = []
        while k < len(nums):
            freq = nums[k]
            val = nums[k+1]
            for i in range(freq):
                arr.append(val)
            k += 2
            
        return arr","class Solution {
 public:
  int threeSumMulti(vector<int>& arr, int target) {
    constexpr int kMod = 1'000'000'007;
    int ans = 0;
    unordered_map<int, int> count;

    for (const int a : arr)
      ++count[a];

    for (const auto& [i, x] : count)
      for (const auto& [j, y] : count) {
        const int k = target - i - j;
        const auto it = count.find(k);
        if (it == cend(count))
          continue;
        if (i == j && j == k)
          ans = (ans + static_cast<long>(x) * (x - 1) * (x - 2) / 6) % kMod;
        else if (i == j && j != k)
          ans = (ans + static_cast<long>(x) * (x - 1) / 2 * it->second) % kMod;
        else if (i < j && j < k)
          ans = (ans + static_cast<long>(x) * y * it->second) % kMod;
      }

    return ans;
  }
};"
"class Solution:
    def sumEvenGrandparent(self, root: TreeNode) -> int:
        if not root: return 0 #edge case 
        ans = 0
        #preorder dfs
        stack = [(root, None, None)] #node-parent-grandparent
        while stack: 
            node, parent, grand = stack.pop()
            if grand and grand &amp; 1 == 0: ans += node.val #even-valued grandparent 
            if node.left: stack.append((node.left, node.val, parent))
            if node.right: stack.append((node.right, node.val, parent))
        return ans","class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    const int n = graph.size();
    UnionFind uf(n);
    vector<int> ufSize(n);
    vector<int> malwareCount(n);

    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j)
        if (graph[i][j] == 1)
          uf.unionByRank(i, j);

    for (int i = 0; i < n; ++i)
      ++ufSize[uf.find(i)];

    for (const int i : initial)
      ++malwareCount[uf.find(i)];

    sort(begin(initial), end(initial));

    int ans = initial[0];
    int maxUfSize = 0;

    // Find the max union's malware if it only contains 1 malware
    for (const int i : initial) {
      const int id = uf.find(i);
      if (ufSize[id] > maxUfSize && malwareCount[id] == 1) {
        maxUfSize = ufSize[id];
        ans = i;
      }
    }

    return ans;
  }
};"
"class Solution:
    def distinctEchoSubstrings(self, text: str) -> int:
        ans = set()
        
        for i in range(len(text)-1): 
            for j in range(i+1, (i+len(text))//2+1): 
                if text[i:j] == text[j:2*j-i]: ans.add(text[i:j])
        
        return len(ans)","class Solution {
 public:
  bool isLongPressedName(string name, string typed) {
    int i = 0;

    for (int j = 0; j < typed.length(); ++j)
      if (i < name.length() && name[i] == typed[j])
        ++i;
      else if (j == 0 || typed[j] != typed[j - 1])
        return false;

    return i == name.length();
  }
};"
"class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        if n<10:
            return [1,n-1]
        a = int(str(n)[1:])+1
        a = int(''.join(['1' if i == '0' else i for i in str(a)]))
        return [a,n-a]","class Solution {
 public:
  int minFlipsMonoIncr(string s) {
    vector<int> dp(2);

    for (const char c : s) {
      const int temp = dp[0] + (c == '1');
      dp[1] = min(dp[0], dp[1]) + (c == '0');
      dp[0] = temp;
    }

    return min(dp[0], dp[1]);
  }
};"
"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        a = bin(a)[2:]
        b = bin(b)[2:]
        c = bin(c)[2:]
        x = max([len(a),len(b),len(c)])
        a = a.zfill(x)
        b = b.zfill(x)
        c = c.zfill(x)
        count = 0
        for i in range(x-1,-1,-1):
            if int(c[i]) != (int(a[i]) or int(b[i])):
                if c[i] == '0':
                    if a[i] == '1':
                        count += 1
                    if b[i] == '1':
                        count += 1
                else:
                    count += 1
        return count","class Solution {
 public:
  vector<int> threeEqualParts(vector<int>& arr) {
    const int ones =
        count_if(begin(arr), end(arr), [](int a) { return a == 1; });

    if (ones == 0)
      return {0, static_cast<int>(arr.size()) - 1};
    if (ones % 3 != 0)
      return {-1, -1};

    int k = ones / 3;
    int i;
    int j;
    int first;
    int second;
    int third;

    for (i = 0; i < arr.size(); ++i)
      if (arr[i] == 1) {
        first = i;
        break;
      }

    int gapOnes = k;

    for (j = i + 1; j < arr.size(); ++j)
      if (arr[j] == 1 && --gapOnes == 0) {
        second = j;
        break;
      }

    gapOnes = k;

    for (i = j + 1; i < arr.size(); ++i)
      if (arr[i] == 1 && --gapOnes == 0) {
        third = i;
        break;
      }

    while (third < arr.size() && arr[first] == arr[second] &&
           arr[second] == arr[third]) {
      ++first;
      ++second;
      ++third;
    }

    if (third == arr.size())
      return {first - 1, second};
    return {-1, -1};
  }
};"
"class Solution:
    def minimumDistance(self, word: str) -> int:
        word = [ord(x)-65 for x in word]
        dist = lambda x, y: 0 if -1 in (x, y) else abs(x//6 - y//6) + abs(x%6 - y%6) # l1 distance
        
        @cache
        def fn(i, f1=-1, f2=-1):
            """"""Return minimum distance of typing word[i:] with 2 fingers.""""""
            if i == len(word): return 0 
            return min(dist(word[i], f1) + fn(i+1, word[i], f2), dist(word[i], f2) + fn(i+1, f1, word[i]))
        
        return fn(0)","class Solution {
 public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int ans = 0;
    int minCount = graph.size();

    sort(begin(initial), end(initial));

    for (const int i : initial) {
      const int count = bfs(graph, i, initial);
      if (count < minCount) {
        minCount = count;
        ans = i;
      }
    }

    return ans;
  }

 private:
  int bfs(const vector<vector<int>>& graph, int removed, vector<int>& initial) {
    queue<int> q;
    vector<bool> seen(graph.size());
    seen[removed] = true;

    int count = 0;

    for (const int i : initial)
      if (i != removed) {
        q.push(i);
        seen[i] = true;
      }

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      ++count;
      for (int i = 0; i < graph.size(); ++i) {
        if (seen[i])
          continue;
        if (i != u && graph[i][u]) {
          q.push(i);
          seen[i] = true;
        }
      }
    }

    return count;
  }
};"
"class Solution:
    def maximum69Number (self, num: int) -> int:

        lst_num = list(str(num))

        for i in range(len(lst_num)):
            if lst_num[i] == '6':
                lst_num[i] = '9'
                break
        return int(''.join(lst_num))","class Solution {
 public:
  int numUniqueEmails(vector<string>& emails) {
    unordered_set<string> normalized;

    for (const string& email : emails) {
      string local;
      for (const char c : email) {
        if (c == '+' || c == '@')
          break;
        if (c == '.')
          continue;
        local += c;
      }
      string atDomain = email.substr(email.find('@'));
      normalized.insert(local + atDomain);
    }

    return normalized.size();
  }
};"
"class Solution:
    def printVertically(self, s: str) -> List[str]:
        M = max(map(len,s.split()))
        return [''.join(v).rstrip() for v in map(''.join,zip(*[s+' '*(M-len(s)) for s in s.split()]))]
		
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  int numSubarraysWithSum(vector<int>& nums, int goal) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> count{{0, 1}};

    for (int num : nums) {
      prefix += num;
      if (const auto it = count.find(prefix - goal); it != cend(count))
        ans += it->second;
      ++count[prefix];
    }

    return ans;
  }
};"
"class Solution:
    def removeLeafNodes(self, root: TreeNode, target: int) -> TreeNode:
    
        def helper(node):
            if node:    
                node.left = helper(node.left)
                node.right = helper(node.right)

                if not node.left and not node.right and node.val == target:
                    return None
                else:
                    return node
        
        return helper(root)","class Solution {
 public:
  int minFallingPathSum(vector<vector<int>>& A) {
    const int n = A.size();

    for (int i = 1; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        int mini = INT_MAX;
        for (int k = max(0, j - 1); k < min(n, j + 2); ++k)
          mini = min(mini, A[i - 1][k]);
        A[i][j] += mini;
      }

    return *min_element(begin(A[n - 1]), end(A[n - 1]));
  }
};"
"class Solution:
    def minTaps(self, n: int, ranges: List[int]) -> int:
        intervals = [(0, ranges[0])]
        for i in range(1, n + 1):
            l, r = max(i - ranges[i], 0), i + ranges[i]
            if intervals[-1][1] < r:
                while intervals and intervals[-1][0] >= l:
                    intervals.pop()
                if not intervals:
                    intervals.append((l, r))
                elif intervals[-1][1] < n and l <= intervals[-1][1]:
                    intervals.append((intervals[-1][1], r))
		return len(intervals) if intervals[-1][1] >= n else -1","class Solution {
 public:
  vector<int> beautifulArray(int n) {
    vector<int> A(n);
    iota(begin(A), end(A), 1);
    divide(A, 0, n - 1, 1);
    return A;
  }

 private:
  void divide(vector<int>& A, int l, int r, int mask) {
    if (l >= r)
      return;
    const int m = partition(A, l, r, mask);
    divide(A, l, m, mask << 1);
    divide(A, m + 1, r, mask << 1);
  }

  int partition(vector<int>& A, int l, int r, int mask) {
    int nextSwapped = l;
    for (int i = l; i <= r; ++i)
      if (A[i] & mask)
        swap(A[i], A[nextSwapped++]);
    return nextSwapped - 1;
  }
};"
"class Solution:
    def breakPalindrome(self, palindrome: str) -> str:
        n = len(palindrome)
        # there is no way to replace a single character to make ""a"" not a palindrome
        # because no matter what we change, it is still a palindrome
        if n == 1:
            return ''
        # let's think about n = 2 case, e.g. ""bb""
        # in this case, to acheive the lexicographically smallest one
        # we should replace from the left and the best character to use is ""a""
        # for ""bb"", we replace the first ""b"" to ""a"" to become ""ab""
        
        # let's think about another n = 2 case, e.g. ""aa""
        # in this case, to acheive the lexicographically smallest one
        # we should replace from the left and the best character to use is ""a""
        # however, for ""aa"", we cannot use ""a"" here and the best character to use is ""b"" now
        # for ""aa"", we replace the second ""a"" to ""b"" to become ""ab""
        # why not replace the first ""a""? because ""ba"" is not smallest.
        for i in range(n // 2):
            #  here we know that as long as palindrome[i] is not ""a"", we skip it
            if palindrome[i] != 'a':
                # otherwise, we replace the first character that is not ""a""
                return palindrome[:i] + 'a' + palindrome[i + 1:]
        # by the time it reaches here, the only possible case is all the characters in palindrome is ""a""
        # e.g. ""aaaaaa"" so that we haven't changed anything in above logic
        # in this case, as mentioned above, the best character to use is ""b""
        # and we should replace the last character to achieve the smallest one possible
        return palindrome[:-1] + 'b'","class Solution {
 public:
  int shortestBridge(vector<vector<int>>& grid) {
    markGridTwo(grid);

    for (int color = 2;; ++color)
      for (int i = 0; i < grid.size(); ++i)
        for (int j = 0; j < grid[0].size(); ++j)
          if (grid[i][j] == color)
            if (expand(grid, i + 1, j, color) ||  //
                expand(grid, i - 1, j, color) ||  //
                expand(grid, i, j + 1, color) ||  //
                expand(grid, i, j - 1, color))
              return color - 2;
  }

 private:
  // Mark one group to 2s by DFS
  void markGridTwo(vector<vector<int>>& grid) {
    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] == 1) {
          markGridTwo(grid, i, j);
          return;
        }
  }

  void markGridTwo(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] != 1)
      return;

    grid[i][j] = 2;
    markGridTwo(grid, i + 1, j);
    markGridTwo(grid, i - 1, j);
    markGridTwo(grid, i, j + 1);
    markGridTwo(grid, i, j - 1);
  }

  // Expand from colors' group to 1s' group
  bool expand(vector<vector<int>>& grid, int i, int j, int color) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return false;
    if (grid[i][j] == 0)
      grid[i][j] = color + 1;
    return grid[i][j] == 1;  // We touch the 1s' group!
  }
};"
"class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        
        diag = {}
        m = len(mat)
        n = len(mat[0])
        
        for row in range(m):
            for col in range(n):
                diag.setdefault(col-row, [])
                diag[col-row].append(mat[row][col])
        
        for key, val in diag.items():
            diag[key] = sorted(val)
        
        for row in range(m):
            for col in range(n):
                mat[row][col] = diag[col-row].pop(0)
        
        return mat","class Solution {
 public:
  int knightDialer(int n) {
    constexpr int kMod = 1'000'000'007;
    const vector<pair<int, int>> dirs = {{-2, 1}, {-1, 2}, {1, 2},   {2, 1},
                                         {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};

    // dp[i][j] := # of ways to stand on (i, j)
    vector<vector<int>> dp(4, vector<int>(3, 1));
    dp[3][0] = dp[3][2] = 0;

    for (int k = 0; k < n - 1; ++k) {
      vector<vector<int>> newDp(4, vector<int>(3));
      for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 3; ++j) {
          if (isNotNumericCell(i, j))
            continue;
          for (const auto& [dx, dy] : dirs) {
            const int x = i + dx;
            const int y = j + dy;
            if (x < 0 || x >= 4 || y < 0 || y >= 3)
              continue;
            if (isNotNumericCell(x, y))
              continue;
            newDp[i][j] = (newDp[i][j] + dp[x][y]) % kMod;
          }
        }
      dp = move(newDp);
    }

    int ans = 0;

    for (const vector<int>& row : dp)
      for (const int a : row)
        ans = (ans + a) % kMod;

    return ans;
  }

 private:
  bool isNotNumericCell(int i, int j) {
    return i == 3 && (j == 0 || j == 2);
  }
};"
"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        maxi, mini = -math.inf, math.inf
        
        for a, b in zip(nums, nums[1:]):
            maxi = max(min(a, b), maxi)
            mini = min(max(a, b), mini)
        change = max(0, (maxi - mini) * 2)
        
        # solving the boundary situation
        for a, b in zip(nums, nums[1:]):
            tmp1 = - abs(a - b) + abs(nums[0] - b)
            tmp2 = - abs(a - b) + abs(nums[-1] - a)
            change = max([tmp1, tmp2, change])
			
        original_value = sum(abs(a - b) for a, b in zip(nums, nums[1:]))
        return  original_value + change","class Solution {
 public:
  vector<int> movesToStamp(string stamp, string target) {
    vector<int> ans;
    // stamped[i] := true if we already stamped target by stamp on index i
    vector<bool> stamped(target.length());
    int stampedCount = 0;  // Out goal is to make stampedCount = target.length()

    while (stampedCount < target.length()) {
      bool isStamped = false;
      // Try to stamp target[i..i + stamp.length()) for each index
      for (int i = 0; i <= target.length() - stamp.length(); ++i) {
        if (stamped[i])
          continue;
        const int stampified = stampify(stamp, target, i);
        if (stampified == 0)
          continue;
        stampedCount += stampified;
        isStamped = true;
        stamped[i] = true;
        ans.push_back(i);
      }
      // After trying stamp each index, we can't find a valid stamp
      if (!isStamped)
        return {};
    }

    reverse(begin(ans), end(ans));
    return ans;
  }

 private:
  // Stamp target[i..i + stamp.length()) and return # of newly stamped chars
  // E.g. stampify(""abc"", ""ababc"", 2) returns 3 because target becomes ""ab***""
  int stampify(const string& stamp, string& target, int s) {
    int stampified = stamp.length();

    for (int i = 0; i < stamp.length(); ++i)
      if (target[s + i] == '*')  // Already stamped
        --stampified;
      else if (target[s + i] != stamp[i])
        return 0;  // We can't stamp on index i

    if (stampified > 0)
      fill(begin(target) + s, begin(target) + s + stamp.length(), '*');

    return stampified;
  }
};"
"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        rank = {x:len(arr)-i for i, x in enumerate(sorted(arr, reverse=True))}
        return map(rank.get, arr)","class Solution {
 public:
  vector<string> reorderLogFiles(vector<string>& logs) {
    vector<string> ans;
    vector<string> digitLogs;
    vector<pair<string, string>> letterLogs;

    for (const string& log : logs) {
      const int i = log.find_first_of(' ');
      if (isdigit(log[i + 1]))
        digitLogs.push_back(log);
      else
        letterLogs.emplace_back(log.substr(0, i), log.substr(i + 1));
    }

    sort(begin(letterLogs), end(letterLogs), [](const auto& a, const auto& b) {
      return a.second == b.second ? a.first < b.first : a.second < b.second;
    });

    for (const auto& [identifier, letters] : letterLogs)
      ans.push_back(identifier + ' ' + letters);

    for (const string& digitLog : digitLogs)
      ans.push_back(digitLog);

    return ans;
  }
};"
"class Solution:
    def removePalindromeSub(self, s: str) -> int:
        
        n=len(s)
        if not n:
            return 0
        if s[::-1]==s:
            return 1
        else:
            return 2","class Solution {
 public:
  int rangeSumBST(TreeNode* root, int L, int R) {
    if (root == nullptr)
      return 0;
    if (root->val < L)
      return rangeSumBST(root->right, L, R);
    if (root->val > R)
      return rangeSumBST(root->left, L, R);
    return root->val + rangeSumBST(root->left, L, R) +
           rangeSumBST(root->right, L, R);
  }
};"
"class Solution:
    def filterRestaurants(self, R: List[List[int]], V: int, P: int, D: int) -> List[int]:
        R = [[r[1],r[0]] for r in R if r[2] >= V and r[3] <= P and r[4] <= D]
        return list(zip(*sorted(R, reverse = True)))[1] if R else []
		
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  int minAreaRect(vector<vector<int>>& points) {
    int ans = INT_MAX;
    unordered_map<int, unordered_set<int>> xToYs;

    for (const vector<int>& p : points)
      xToYs[p[0]].insert(p[1]);

    for (int i = 1; i < points.size(); ++i)
      for (int j = 0; j < i; ++j) {
        const vector<int>& p = points[i];
        const vector<int>& q = points[j];
        if (p[0] == q[0] || p[1] == q[1])
          continue;
        if (xToYs[p[0]].count(q[1]) && xToYs[q[0]].count(p[1]))
          ans = min(ans, abs(p[0] - q[0]) * abs(p[1] - q[1]));
      }

    return ans == INT_MAX ? 0 : ans;
  }
};"
"class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        
        dis=[]
        for i in range(n):
            x=[]
            for j in range(n):
                x.append(float(""inf""))
            dis.append(x)
            
        
        for i in range(len(edges)):
            x=edges[i]
            dis[x[0]][x[1]]=x[2]
            dis[x[1]][x[0]]=x[2]
            
        
        for k in range(n):
            for j in range(n):
                for i in range(n):
                    if dis[i][j]>dis[i][k]+dis[k][j]:
                        dis[i][j]=dis[i][k]+dis[k][j]
        
        d={}
        print(dis)
        for i in range(n):
            d[i]=0
        for i in range(n):
            for j in range(n):
                if dis[i][j]<=distanceThreshold:
                    if i==j:
                        continue
                    d[i]+=1
                    
        l=list(d.keys())
        min=float(""inf"")
        
        for i in range(len(l)):
            if d[l[i]]<min:
                min=d[l[i]]
                
        ans=[]
        for i in range(len(l)):
            if d[l[i]]==min:
                ans.append(l[i])
                
        
        
        return max(ans)","class Solution {
 public:
  int distinctSubseqII(string s) {
    constexpr int kMod = 1'000'000'007;
    // endsWith[i] := # of subseqs ends with 'a' + i
    vector<long> endsWith(26);

    for (const char c : s)
      endsWith[c - 'a'] = accumulate(begin(endsWith), end(endsWith), 1L) % kMod;

    return accumulate(begin(endsWith), end(endsWith), 0L) % kMod;
  }
};"
"class Solution:
    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
        n = len(jobDifficulty)
        if d > n:
            return -1

        # Memoize maximum for every cut
        max_dp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n):
            for j in range(i, n):
                if i == j:
                    max_dp[i][j] = jobDifficulty[i]
                else:
                    max_dp[i][j] = max(max_dp[i][j - 1], jobDifficulty[j])
        
        # Calculate minimum difficulty
        dp = [[0 for _ in range(n)] for _ in range(d)]
        for i in range(d):
            for j in range(i, min(n, n - d + i + 1)):
                if i == 0:
                    dp[i][j] = max_dp[i][j]
                else:
                    dp[i][j] = min(
                        dp[i - 1][k - 1] + max_dp[k][j]
                        for k in range(i, j + 1)
                    )
        return dp[d - 1][n - 1]","class Solution {
 public:
  bool validMountainArray(vector<int>& arr) {
    if (arr.size() < 3)
      return false;

    int l = 0;
    int r = arr.size() - 1;

    while (l + 1 < arr.size() && arr[l] < arr[l + 1])
      ++l;
    while (r > 0 && arr[r] < arr[r - 1])
      --r;

    return l > 0 && r < arr.size() - 1 && l == r;
  }
};"
"class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:

        row = []
        for i in range(len(mat)):
            row.append((sum(mat[i]), i))
        heapq.heapify(row)

        ans = []
        while k>0:
            (val, idx) = heapq.heappop(row)
            ans.append(idx)
            k -= 1

        return ans","class Solution {
 public:
  vector<int> diStringMatch(string s) {
    vector<int> ans;
    int min = 0;
    int max = s.length();

    for (const char c : s)
      ans.push_back(c == 'I' ? min++ : max--);
    ans.push_back(min);

    return ans;
  }
};"
"class Solution:
    def minSetSize(self, arr: List[int]) -> int:
        h = [-c for c in Counter(arr).values()]
        heapq.heapify(h)
        
        size = len(arr)
        half = (size + 1) // 2        
        result = 0
        while size > half:
            size += heapq.heappop(h)
            result += 1
            
        return result","class Solution {
 public:
  string shortestSuperstring(vector<string>& A) {
    const int n = A.size();
    // cost[i][j] := cost to append A[j] after A[i]
    vector<vector<int>> cost(n, vector<int>(n));

    // GetCost(a, b) := cost to append b after a
    auto getCost = [](const string& a, const string& b) {
      int cost = b.length();
      const int minLength = min(a.length(), b.length());
      for (int k = 1; k <= minLength; ++k)
        if (a.substr(a.length() - k) == b.substr(0, k))
          cost = b.length() - k;
      return cost;
    };

    // Pre-calculate cost array to save time
    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j) {
        cost[i][j] = getCost(A[i], A[j]);
        cost[j][i] = getCost(A[j], A[i]);
      }

    vector<int> bestPath;
    int minLength = n * 20;  // Given by problem

    dfs(A, cost, {}, bestPath, 0, 0, 0, minLength);

    string ans = A[bestPath[0]];

    for (int k = 1; k < n; ++k) {
      const int i = bestPath[k - 1];
      const int j = bestPath[k];
      ans += A[j].substr(A[j].length() - cost[i][j]);
    }

    return ans;
  }

 private:
  // Used: i-th bit means A[i] is used or not
  void dfs(const vector<string>& A, const vector<vector<int>>& cost,
           vector<int>&& path, vector<int>& bestPath, int used, int depth,
           int currLength, int& minLength) {
    if (currLength >= minLength)
      return;
    if (depth == A.size()) {
      minLength = currLength;
      bestPath = path;
      return;
    }

    for (int i = 0; i < A.size(); ++i) {
      if (1 << i & used)
        continue;
      path.push_back(i);
      const int newLength =
          depth == 0 ? A[i].length() : currLength + cost[path[depth - 1]][i];
      dfs(A, cost, move(path), bestPath, used | 1 << i, depth + 1, newLength,
          minLength);
      path.pop_back();
    }
  }
};"
"class Solution:
    def maxProduct(self, root: TreeNode) -> int:
        subtreeSums = set()
        
        def getSum(node):
            if not node:
                return 0
            elif not node.left and not node.right:
                subtreeSums.add(node.val)
                return node.val
            else:
                result = getSum(node.left) + getSum(node.right) + node.val
                subtreeSums.add(result)
                return result
            
        rootSum = getSum(root)
        idealSplit = rootSum/2
        closestToIdeal = 0
        
        for possibleSum in subtreeSums:
            if math.fabs(possibleSum - idealSplit) < math.fabs(closestToIdeal - idealSplit):
                closestToIdeal = possibleSum        
        
        return (((rootSum - closestToIdeal) % (10**9 + 7)) * (closestToIdeal % (10**9 + 7)))  % (10**9 + 7)","class Solution {
 public:
  int minDeletionSize(vector<string>& A) {
    const int n = A[0].length();
    int ans = 0;

    for (int j = 0; j < n; ++j)
      for (int i = 0; i + 1 < A.size(); ++i)
        if (A[i][j] > A[i + 1][j]) {
          ++ans;
          break;
        }

    return ans;
  }
};"
"class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        n=len(arr)
        ans=-float('inf')
        dp=[-1 for i in range(n)]
        def dfs(ind):
            if dp[ind]!=-1:
                return dp[ind]
            v1,v2=0,0
            for left in range(ind-1,max(-1,ind-d-1),-1):
                if arr[left]<arr[ind]:
                    lv=1+dfs(left)
                else:
                    break
                v1=max(v1,lv)
            for right in range(ind+1,min(n,ind+d+1),1):
                if arr[right]<arr[ind]:
                    rv=1+dfs(right)
                else:
                    break
                v2=max(v2,rv)
            dp[ind]=max(v1,v2,1)
            return dp[ind]
        for i in range(n):
            ans=max(ans,dfs(i))
        return ans","class Solution {
 public:
  int minIncrementForUnique(vector<int>& nums) {
    int ans = 0;
    int minAvailable = 0;

    sort(begin(nums), end(nums));

    for (const int num : nums) {
      ans += max(minAvailable - num, 0);
      minAvailable = max(minAvailable, num) + 1;
    }

    return ans;
  }
};"
"class Solution:
    def numberOfSteps(self, num: int) -> int:
        count = 0 # taking a couter to count  number of steps to reduce it to zero

        while num>0: # nums should not be less then 0
            if num % 2 == 0: # if num is completely divide by zero 
                num = num//2 # to have the quotient
                count+=1 # as number got reduced we will increase the counter
            else:
                num-=1 # and if num is not even then we subtract one out of it.
                count+=1 # as number got reduced we will increase the counter
        return count # returning the step occurred o reduce the number.","class Solution {
 public:
  bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
    stack<int> stack;
    int i = 0;  // popped's index

    for (const int x : pushed) {
      stack.push(x);
      while (!stack.empty() && stack.top() == popped[i]) {
        stack.pop();
        ++i;
      }
    }

    return stack.empty();
  }
};"
"class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        window_start, total, res = 0, 0, 0
        
        for i in range(k - 1):
            total += arr[i]
            
        for window_end in range(k - 1, len(arr)):
            total += arr[window_end]
            if window_end - window_start + 1 > k:
                total -= arr[window_start]
                window_start += 1
                
            if total / k >= threshold:
                res += 1
            
        return res","class Solution {
 public:
  int removeStones(vector<vector<int>>& stones) {
    int numOfIslands = 0;
    vector<vector<int>> graph(stones.size());
    unordered_set<int> seen;

    for (int i = 0; i < stones.size(); ++i)
      for (int j = i + 1; j < stones.size(); ++j)
        if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
          graph[i].push_back(j);
          graph[j].push_back(i);
        }

    for (int i = 0; i < stones.size(); ++i)
      if (seen.insert(i).second) {
        dfs(graph, i, seen);
        ++numOfIslands;
      }

    return stones.size() - numOfIslands;
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, unordered_set<int>& seen) {
    for (const int v : graph[u])
      if (seen.insert(v).second)
        dfs(graph, v, seen);
  }
};"
"class Solution:
    def angleClock(self, H: int, M: int) -> float:
        return min(abs(30*H-11*M/2),360-abs(30*H-11*M/2))
		
		
- Junaid Mansuri
- Chicago, IL","class Solution {
 public:
  int bagOfTokensScore(vector<int>& tokens, int power) {
    int ans = 0;
    int score = 0;
    int i = 0;                  // Index of smallest token
    int j = tokens.size() - 1;  // Index of largest token

    sort(begin(tokens), end(tokens));

    while (i <= j && (power >= tokens[i] || score)) {
      while (i <= j && power >= tokens[i]) {
        // Play the smallest face up
        power -= tokens[i++];
        ++score;
      }
      ans = max(ans, score);
      if (i <= j && score) {
        // Play the largest face down
        power += tokens[j--];
        --score;
      }
    }

    return ans;
  }
};"
"class Solution:
    def minJumps(self, arr: List[int]) -> int:
        N, grps = len(arr), defaultdict(list)

        for i, el in enumerate(arr): 
            grps[el].append(i)

        vis, vis_grps = set(), set()
        
        def bfs(lvl, dist):
            nextLvl = set()
            
            for i in lvl:
                if i in vis: continue
                if i == N-1: return dist
                
                vis.add(i)
                
                if i: nextLvl.add(i-1)
                if i+1 < N: nextLvl.add(i+1)
                
                if not arr[i] in vis_grps:
                    vis_grps.add(arr[i])
                    nextLvl.update(grps[arr[i]])
            
            return bfs(nextLvl, dist + 1)
            
        return bfs(set([0]), 0)","class Solution {
 public:
  string largestTimeFromDigits(vector<int>& arr) {
    string ans;

    for (int i = 0; i < 4; ++i)
      for (int j = 0; j < 4; ++j)
        for (int k = 0; k < 4; ++k) {
          if (i == j || i == k || j == k)
            continue;
          const string hours = to_string(arr[i]) + to_string(arr[j]);
          const string minutes =
              to_string(arr[k]) + to_string(arr[6 - i - j - k]);
          if (hours < ""24"" && minutes < ""60"")
            ans = max(ans, hours + ':' + minutes);
        }

    return ans;
  }
};"
"class Solution:
    def checkIfExist(self, arr: List[int]) -> bool:
        s = set([x*1.0 for x in arr])

        from collections import Counter
        if Counter(arr)[0] >= 2:
            return True
        
        for i in arr:
            t = i/2
            
            if t in s and t != 0:
                return True
        
        return False","class Solution {
 public:
  vector<int> deckRevealedIncreasing(vector<int>& deck) {
    sort(begin(deck), end(deck), greater<int>());

    deque<int> q{deck[0]};

    for (int i = 1; i < deck.size(); ++i) {
      q.push_front(q.back());
      q.pop_back();
      q.push_front(deck[i]);
    }

    return {begin(q), end(q)};
  }
};"
"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        x=list((Counter(s) &amp; Counter(t)).elements())
        return len(s)-len(x)","class Solution {
 public:
  bool flipEquiv(TreeNode* root1, TreeNode* root2) {
    if (root1 == nullptr)
      return root2 == nullptr;
    if (root2 == nullptr)
      return root1 == nullptr;
    if (root1->val != root2->val)
      return false;
    return flipEquiv(root1->left, root2->left) &&
               flipEquiv(root1->right, root2->right) ||
           flipEquiv(root1->left, root2->right) &&
               flipEquiv(root1->right, root2->left);
  }
};"
"class Solution:
    def maxStudents(self, seats: List[List[str]]) -> int:
        m, n = len(seats), len(seats[0]) # dimensions 
        
        valid = []
        for i in range(m): 
            val = 0
            for j in range(n): 
                if seats[i][j] == ""."": val |= 1 << j 
            valid.append(val)
        
        @cache
        def fn(i, mask): 
            """"""Return max students taking seats[i:] given previous row as mask.""""""
            if i == len(seats): return 0 
            ans = fn(i+1, 0)
            for x in range(1 << n): 
                if x &amp; valid[i] == x and (x >> 1) &amp; x == 0 and (mask >> 1) &amp; x == 0 and (mask << 1) &amp; x == 0: 
                    ans = max(ans, bin(x).count(""1"") + fn(i+1, x))
            return ans 
        
        return fn(0, 0)","class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int largestComponentSize(vector<int>& nums) {
    const int n = *max_element(begin(nums), end(nums));
    int ans = 0;
    UnionFind uf(n + 1);
    unordered_map<int, int> count;

    for (const int num : nums)
      for (int x = 2; x <= sqrt(num); ++x)
        if (num % x == 0) {
          uf.unionByRank(num, x);
          uf.unionByRank(num, num / x);
        }

    for (const int num : nums)
      ans = max(ans, ++count[uf.find(num)]);

    return ans;
  }
};"
"class Solution:
    
    def negativeCounter(self, lst: List[int]) -> int:
        l = 0
        r = len(lst) - 1
        count = 0
        
        while l <= r:
            mid = l + (r - l)//2
            if lst[mid] >= 0:
                l = mid + 1
            else:
                count += r - mid + 1
                r = mid - 1
        return count
    
    def countNegatives(self, grid: List[List[int]]) -> int:
        
        count = 0       
        for item in grid:
            count += self.negativeCounter(item)
        return count","class Solution {
 public:
  bool isAlienSorted(vector<string>& words, const string& order) {
    vector<char> map(26);  // Order = ""bca"" -> map = ['c', 'a', 'b']

    for (int i = 0; i < 26; ++i)
      map[order[i] - 'a'] = i + 'a';

    for (string& word : words)
      for (char& c : word)
        c = map[c - 'a'];

    return is_sorted(begin(words), end(words));
  }
};"
"class Solution:
    def maxEvents(self, events: List[List[int]]) -> int:
        events.sort(key=lambda x: (x[1], x[0]))
        attend = set()
        
        for start, end in events:
            for day in range(start, end+1):
                if day not in attend: 
                    attend.add(day)
                    break
                    
        return len(attend)","class Solution {
 public:
  bool canReorderDoubled(vector<int>& arr) {
    unordered_map<int, int> count;

    for (const int a : arr)
      ++count[a];

    sort(arr.begin(), arr.end(),
         [](const int a, const int b) { return abs(a) < abs(b); });

    for (const int a : arr) {
      if (count[a] == 0)
        continue;
      if (count[2 * a] == 0)
        return false;
      --count[a];
      --count[2 * a];
    }

    return true;
  }
};"
"class Solution:
    def isPossible(self, target: List[int]) -> bool:
        n = len(target)
        sumk = 0
        for x in sorted(target):
            if x == 1:
                continue
            if (x-1) % (n-1) != 0:
                return False
            k = (x-1)//(n-1)
            if not k > sumk:
                return False
            sumk += k
        return True","class Solution {
 public:
  int minDeletionSize(vector<string>& A) {
    const int n = A[0].length();
    int ans = 0;
    // sorted[i] := true if A[i] < A[i + 1]
    vector<bool> sorted(A.size() - 1);

    for (int j = 0; j < n; ++j) {
      int i;
      for (i = 0; i + 1 < A.size(); ++i)
        if (!sorted[i] && A[i][j] > A[i + 1][j]) {
          ++ans;
          break;
        }
      // Already compared each pair, update the sorted array if needed
      if (i + 1 == A.size())
        for (i = 0; i + 1 < A.size(); ++i)
          sorted[i] = sorted[i] || A[i][j] < A[i + 1][j];
    }

    return ans;
  }
};"
"class Solution:
    def count1s(self, num):
        count = 0
        while num >= 1:
            if num%2: count += 1
            num = num//2
        return count
    def cmp(self, vals):
        l,r = vals
        return r * 10000 + l
        
    def sortByBits(self, arr: List[int]) -> List[int]:
        new_arr = [[arr[i], self.count1s(arr[i])] for i,_ in enumerate(arr)]
        sorted_new_arr = sorted(new_arr, key = self.cmp)
        result = [sorted_new_arr[i][0] for i,_ in enumerate(sorted_new_arr)]
        return result","class Solution {
 public:
  int tallestBillboard(vector<int>& rods) {
    const int n = rods.size();
    const int sum = accumulate(begin(rods), end(rods), 0);
    // dp[i][j] := max min-height of using rods[0..i) to pile two piles that
    // Have height difference j
    vector<vector<int>> dp(n + 1, vector<int>(sum + 1, -1));
    dp[0][0] = 0;

    for (int i = 1; i <= n; ++i) {
      const int h = rods[i - 1];
      for (int j = 0; j <= sum - h; ++j) {
        if (dp[i - 1][j] < 0)
          continue;
        // don't use rods[i - 1]
        dp[i][j] = max(dp[i][j], dp[i - 1][j]);
        // Put on the taller pile
        dp[i][j + h] = max(dp[i][j + h], dp[i - 1][j]);
        // Put on the shorter pile
        dp[i][abs(j - h)] = max(dp[i][abs(j - h)], dp[i - 1][j] + min(j, h));
      }
    }

    return dp[n][0];
  }
};"
"class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        return reduce(lambda y,x:[y[0]+1+min(y[1].values()), dict(y[1],**{x[1]:x[0]})],
		              enumerate(s+'a'),[0,defaultdict(lambda:-1)])[0]","class Solution {
 public:
  vector<int> prisonAfterNDays(vector<int>& cells, int n) {
    vector<int> firstDayCells;
    vector<int> nextDayCells(cells.size());

    for (int day = 0; n-- > 0; cells = nextDayCells, ++day) {
      for (int i = 1; i + 1 < cells.size(); ++i)
        nextDayCells[i] = cells[i - 1] == cells[i + 1];
      if (day == 0)
        firstDayCells = nextDayCells;
      else if (nextDayCells == firstDayCells)
        n %= day;
    }

    return cells;
  }
};"
"class Solution:
    def countOrders(self, n: int) -> int:
        ans = 1
        for x in range(2, n+1): 
            ans = (ans*x*(2*x-1)) % 1_000_000_007
        return ans","class Solution {
 public:
  bool isCompleteTree(TreeNode* root) {
    if (root == nullptr)
      return true;

    queue<TreeNode*> q{{root}};

    while (q.front() != nullptr) {
      TreeNode* node = q.front();
      q.pop();
      q.push(node->left);
      q.push(node->right);
    }

    while (!q.empty() && q.front() == nullptr)
      q.pop();

    return q.empty();
  }
};"
"class Solution:
    def daysBetweenDates(self, date1: str, date2: str) -> int:
        if date1 > date2: date1, date2 = date2, date1
        y1, m1, d1 = [int(x) for x in date1.split(""-"")]
        y2, m2, d2 = [int(x) for x in date2.split(""-"")]
        
        leap = lambda y: (y%4 == 0 and y%100 != 0) or (y%400 == 0)
        dates = 365*(y2-y1) + sum(leap(y) for y in range(y1, y2))
        
        days = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
        dates -= days[m1-1] + (m1 > 2 and leap(y1)) + d1
        dates += days[m2-1] + (m2 > 2 and leap(y2)) + d2
        
        return dates","class Solution {
 public:
  int regionsBySlashes(vector<string>& grid) {
    const int n = grid.size();
    // G := upscaled grid
    vector<vector<int>> g(n * 3, vector<int>(n * 3));

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == '/') {
          g[i * 3][j * 3 + 2] = 1;
          g[i * 3 + 1][j * 3 + 1] = 1;
          g[i * 3 + 2][j * 3] = 1;
        } else if (grid[i][j] == '\\') {
          g[i * 3][j * 3] = 1;
          g[i * 3 + 1][j * 3 + 1] = 1;
          g[i * 3 + 2][j * 3 + 2] = 1;
        }

    int ans = 0;

    for (int i = 0; i < n * 3; ++i)
      for (int j = 0; j < n * 3; ++j)
        if (g[i][j] == 0) {
          dfs(g, i, j);
          ++ans;
        }

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& g, int i, int j) {
    if (i < 0 || i == g.size() || j < 0 || j == g[0].size())
      return;
    if (g[i][j] != 0)
      return;

    g[i][j] = 2;  // Mark 2 as visited
    dfs(g, i + 1, j);
    dfs(g, i - 1, j);
    dfs(g, i, j + 1);
    dfs(g, i, j - 1);
  }
};"
"class Solution:
    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:
        children = 0
        for i in range(n):
            if i > leftChild[i] > -1 or i > rightChild[i] > -1: return False
            children += (leftChild[i] > -1) + (rightChild[i] > -1)
        return children == n - 1","class Solution {
 public:
  int minDeletionSize(vector<string>& A) {
    const int n = A[0].length();
    // dp[i] := LIS ending at A[*][i]
    vector<int> dp(n, 1);

    for (int i = 1; i < n; ++i)
      for (int j = 0; j < i; ++j)
        if (all_of(begin(A), end(A),
                   [&](const string& a) { return a[j] <= a[i]; }))
          dp[i] = max(dp[i], dp[j] + 1);

    return n - *max_element(begin(dp), end(dp));
  }
};"
"class Solution:
    def smallerNumbersThanCurrent(self, nums):
        count = [0 for i in range(102)]
        for num in nums: count[num+1] += 1
        for i in range(1, len(count)): count[i] += count[i-1]
        return [count[num] for num in nums]","class Solution {
 public:
  int repeatedNTimes(vector<int>& nums) {
    for (int i = 0; i + 2 < nums.size(); ++i)
      if (nums[i] == nums[i + 1] || nums[i] == nums[i + 2])
        return nums[i];
    return nums.back();
  }
};"
"class Solution:
    def rankTeams(self, votes: List[str]) -> str:
        d = {}
        for z in range(len(votes[0])):
            for i in votes:
                d[i[z]] = d.get(i[z],'') + chr(97 + z)
        d = dict((i,j) for i,j in sorted(d.items(),key=lambda x:x[0]))
        return ''.join([i for i,j in sorted(d.items(),key=lambda x:x[1])])","class Solution {
 public:
  int maxWidthRamp(vector<int>& nums) {
    int ans = 0;
    stack<int> stack;

    for (int i = 0; i < nums.size(); ++i)
      if (stack.empty() || nums[i] < nums[stack.top()])
        stack.push(i);

    for (int i = nums.size() - 1; i > ans; --i)
      while (!stack.empty() && nums[i] >= nums[stack.top()])
        ans = max(ans, i - stack.top()), stack.pop();

    return ans;
  }
};"
"class Solution:
    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:
        if root is None:
            return False
        if self.helper(head, root):
            return True
        if self.isSubPath(head, root.left):
            return True
        return self.isSubPath(head, root.right)

    def helper(self, list_node: ListNode, tree_node: TreeNode) -> bool:
        if list_node is None:
            return True
        if tree_node is None:
            return False
        if tree_node.val != list_node.val:
            return False
        else:
            return self.helper(list_node.next, tree_node.left) or self.helper(list_node.next, tree_node.right)","class Solution {
 public:
  double minAreaFreeRect(vector<vector<int>>& points) {
    long long ans = LLONG_MAX;
    // For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}
    unordered_map<int, vector<tuple<int, int, int, int>>> centerToPoints;

    for (const vector<int>& A : points)
      for (const vector<int>& B : points) {
        const int center = hash(A, B);
        centerToPoints[center].emplace_back(A[0], A[1], B[0], B[1]);
      }

    // For all pair points ""that share the same center""
    for (const auto& [_, points] : centerToPoints)
      for (const auto& [ax, ay, bx, by] : points)
        for (const auto& [cx, cy, dx, dy] : points)
          // AC is perpendicular to AD
          // AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0
          if ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0) {
            const long long squaredArea =
                dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy);
            if (squaredArea > 0)
              ans = min(ans, squaredArea);
          }

    return ans == LLONG_MAX ? 0 : sqrt(ans);
  }

 private:
  int hash(const vector<int>& p, const vector<int>& q) {
    return ((long long)(p[0] + q[0]) << 16) + (p[1] + q[1]);
  }

  long long dist(int px, int py, int qx, int qy) {
    return (px - qx) * (px - qx) + (py - qy) * (py - qy);
  }
};"
"class Solution:
    def dfs(self, grid: List[List[int]]) -> int:
        # timeout
        
        size_y = len(grid)
        size_x = len(grid[0])
        src = (0, 0)
        des = (size_y - 1, size_x - 1)
        stack = [(src, 0)]
        costs = {
            src: 0
        }
        
        while stack:
            cur, cost = stack.pop()
            sign = grid[cur[0]][cur[1]]
            
            # print(cur, cost, sign)
            
            for neighbor, neighbor_sign in self.iter_neighbors(cur, size_y, size_x):
                neighbor_cost = cost
                if sign != neighbor_sign:
                    neighbor_cost += 1
                known_neighbor_cost = costs.get(neighbor)
                
                if known_neighbor_cost is None or known_neighbor_cost > neighbor_cost:
                    costs[neighbor] = neighbor_cost

                    stack.append((neighbor, neighbor_cost))
    
        return costs[des]
    
    def bfs(self, grid: List[List[int]]) -> int:
        # 7500 ms, 14.2 MB
        size_y = len(grid)
        size_x = len(grid[0])
        src = (0, 0)
        des = (size_y - 1, size_x - 1)
        queue = [(src, 0)]
        costs = {
            src: 0
        }
        
        while queue:
            cur, cost = queue.pop(0)
            sign = grid[cur[0]][cur[1]]
            
            for neighbor, neighbor_sign in self.iter_neighbors(cur, size_y, size_x):
                neighbor_cost = cost
                if sign != neighbor_sign:
                    neighbor_cost += 1
                known_neighbor_cost = costs.get(neighbor)
                
                if known_neighbor_cost is None or known_neighbor_cost > neighbor_cost:
                    costs[neighbor] = neighbor_cost

                    queue.append((neighbor, neighbor_cost))
    
        return costs[des]
    
    def dijkstra(self, grid: List[List[int]]) -> int:
        # 1000 ms, 16.7 MB
        import heapq

        class Node:
            def __init__(self, y, x, sign, distance=0, via=None):
                self.coord = (y, x)
                self.distance = distance
                self.via = via
                self.sign = sign

            def __lt__(self, other):
                return self.distance < other.distance
        
        size_y = len(grid)
        size_x = len(grid[0])
        start = Node(0, 0, grid[0][0])
        
        node_map = {
            (0, 0): start
        }
        visited_coords = {(0,0)}
        heap = [start]
        
        des_coord = (size_y - 1, size_x - 1)
        
        while heap:
            cur = heapq.heappop(heap)
            visited_coords.add(cur.coord)
            y, x = cur.coord
            
            for neighbor_coord, neighbor_sign in self.iter_neighbors(cur.coord, size_y, size_x):
                if neighbor_coord != cur.coord and neighbor_coord not in visited_coords:

                    if cur.sign == neighbor_sign:
                        # no penalty when it's the node the arrow is pointing at
                        nd = cur.distance
                    else:
                        nd = cur.distance + 1

                    node = node_map.get(neighbor_coord)
                    if node:
                        if node.distance > nd:
                            node.distance = nd
                            node.via = cur
                            heapq.heapify(heap)
                    else:
                        node = Node(*neighbor_coord, grid[neighbor_coord[0]][neighbor_coord[1]], distance=nd, via=cur)
                        node_map[neighbor_coord] = node
                    
                        heapq.heappush(heap, node)

        des_node = node_map[des_coord]

        return des_node.distance
    
    def iter_neighbors(self, coord: tuple, size_y: int, size_x: int):
        y, x = coord
        for sign in range(1, 5):
            if sign == 1:  # right
                if x < size_x - 1:
                    yield (y, x + 1), sign
            elif sign == 2: # left
                if x > 0:
                    yield (y, x - 1), sign
            elif sign == 3: # down
                if y < size_y - 1:
                    yield (y + 1, x), sign
            else:           # up
                if y > 0:
                    yield (y - 1, x), sign

    def minCost(self, grid: List[List[int]]) -> int:
        return self.dijkstra(grid)","class Solution {
 public:
  int leastOpsExpressTarget(int x, int target) {
    return dfs(x, target, {});
  }

 private:
  int dfs(int x, int target, unordered_map<int, int>&& memo) {
    if (const auto it = memo.find(target); it != cend(memo))
      return it->second;
    if (x > target)
      return min(2 * target - 1, 2 * (x - target));
    if (x == target)
      return 0;

    long prod = x;
    int n = 0;
    while (prod < target) {
      prod *= x;
      ++n;
    }
    if (prod == target)
      return memo[target] = n;

    int ans = dfs(x, target - prod / x, move(memo)) + n;
    if (prod < 2 * target)
      ans = min(ans, dfs(x, prod - target, move(memo)) + n + 1);
    return memo[target] = ans;
  }
};"
"class Solution:
    def sortString(self, s: str) -> str:
        
        count, res, flag = collections.Counter(sorted(s)), [], True

        while count:
            temp = list(count)
            res += temp if flag else reversed(temp)
            count -= collections.Counter(temp)
            flag ^= True        
        
        return """".join(res)","class Solution {
 public:
  vector<string> spellchecker(vector<string>& wordlist,
                              vector<string>& queries) {
    vector<string> ans;
    unordered_map<string, string> dict;

    for (const string& word : wordlist) {
      dict.insert({word, word});
      dict.insert({lowerKey(word), word});
      dict.insert({vowelKey(word), word});
    }

    for (const string& query : queries)
      if (const auto it = dict.find(query); it != cend(dict))
        ans.push_back(it->second);
      else if (const auto it = dict.find(lowerKey(query)); it != cend(dict))
        ans.push_back(it->second);
      else if (const auto it = dict.find(vowelKey(query)); it != cend(dict))
        ans.push_back(it->second);
      else
        ans.push_back("""");

    return ans;
  }

 private:
  string lowerKey(const string& word) {
    string s{""$""};
    for (char c : word)
      s += tolower(c);
    return s;
  }

  string vowelKey(const string& word) {
    string s;
    for (char c : word)
      s += string(""aeiou"").find(tolower(c)) != string::npos ? '*' : tolower(c);
    return s;
  }
};"
"class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        # one (int) variable to store vowel-related information
        # e.g., 00000 (0)
        # if a occurs, 00000 ^ 00001 = 00001 (1)
        # if i occurs, 00001 ^ 00100 = 00101 (5)
        # if a occurs, 00101 ^ 00001 = 00100 (4)
        # ---------------------------------------------------------
        # if at index 1, we have state 00101 (5)
        # and at index 11, we have state 00101 (5) again, 
        # then we can claim this sub-array (from index 1 to 11) has even vowels 
        # with the evidence that 00101 ^ 00101 = 00000 
        # ---------------------------------------------------------
        # Rationale
        # 1. We one-pass the array &amp; record the state at each element 
        # 2. If the current state has been recorded before, we compare to the leftmost index
        #    with the same state 
        
        vowels = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}
        d = {0: -1} # d: dictoray to record the leftmost indices of states 
        state, ans = 0, 0 
        for i, c in enumerate(s): # c: char 
            if c in vowels:
                state ^= vowels[c]
            
            # record the leftmost index with state v 
            if not (state in d): 
                d[state] = i 
                
            ans = max(ans, i-d[state])
        
        return ans","class Solution {
 public:
  vector<int> numsSameConsecDiff(int n, int k) {
    if (n == 1)
      return {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    vector<int> ans;

    if (k == 0) {
      for (char c = '1'; c <= '9'; ++c)
        ans.push_back(stoi(string(n, c)));
      return ans;
    }

    for (int num = 1; num <= 9; ++num)
      dfs(n - 1, k, num, ans);

    return ans;
  }

 private:
  void dfs(int n, int k, int num, vector<int>& ans) {
    if (n == 0) {
      ans.push_back(num);
      return;
    }

    const int lastDigit = num % 10;

    for (const int nextDigit : {lastDigit - k, lastDigit + k})
      if (0 <= nextDigit && nextDigit <= 9)
        dfs(n - 1, k, num * 10 + nextDigit, ans);
  }
};"
"class Solution:
    def longestZigZag(self, root: TreeNode) -> int:
        
        def fn(node): 
            """"""Return #nodes on longest ZigZag path starting at given node""""""
            nonlocal ans 
            if node is None: return (0, 0)
            (_, r1), (l2, _) = fn(node.left), fn(node.right)
            ans = max(ans, r1+1, l2+1)
            return (r1+1, l2+1)
        
        ans = 0
        fn(root)
        return ans-1","class Solution {
 public:
  int minCameraCover(TreeNode* root) {
    vector<int> ans = dfs(root);
    return min(ans[1], ans[2]);
  }

 private:
  // 0 := all nodes below root are covered except root
  // 1 := all nodes below and including root are covered w/o camera here
  // 2 := all nodes below and including root are covered w/ camera here
  vector<int> dfs(TreeNode* root) {
    if (root == nullptr)
      return {0, 0, 1000};

    vector<int> l = dfs(root->left);
    vector<int> r = dfs(root->right);

    const int s0 = l[1] + r[1];
    const int s1 = min(l[2] + min(r[1], r[2]),  //
                       r[2] + min(l[1], l[2]));
    const int s2 = min({l[0], l[1], l[2]}) +  //
                   min({r[0], r[1], r[2]}) + 1;
    return {s0, s1, s2};
  }
};"
"class Solution:
    def maxSumBST(self, root: TreeNode):
        self.max = 0
		
        def dfs(root):
            if not root :  return (""N"" , 0)
            
            l_v , l_acc  =  dfs(root.left)            
            r_v , r_acc = dfs(root.right)
            
            if (l_v == ""N"" and r_v == ""N"") or (l_v == ""N"" and isinstance(r_v, int) and  r_v > root.val ) or (isinstance(l_v, int) and  l_v < root.val and r_v == ""N"" )  or isinstance(l_v, int) and isinstance(r_v, int) and l_v < root.val < r_v:
                now_acc = l_acc + r_acc + root.val
                self.max = max(self.max , now_acc)
                return (root.val ,now_acc )
            else: 
                return (root.val , -sys.maxsize )
            
        dfs(root)
        return self.max","class Solution {
 public:
  vector<int> pancakeSort(vector<int>& arr) {
    vector<int> ans;

    for (int target = arr.size(); target >= 1; --target) {
      int index = find(arr, target);
      reverse(begin(arr), begin(arr) + index + 1);
      reverse(begin(arr), begin(arr) + target);
      ans.push_back(index + 1);
      ans.push_back(target);
    }

    return ans;
  }

 private:
  int find(vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i)
      if (arr[i] == target)
        return i;
    throw;
  }
};"
"class Solution:
    def generateTheString(self, n: int) -> str:
        return ""a""*n if n &amp; 1 else ""a""*(n-1) + ""b""","class Solution {
 public:
  vector<int> powerfulIntegers(int x, int y, int bound) {
    unordered_set<int> ans;

    for (int i = 1; i < bound; i *= x) {
      for (int j = 1; i + j <= bound; j *= y) {
        ans.insert(i + j);
        if (y == 1)
          break;
      }
      if (x == 1)
        break;
    }

    return {begin(ans), end(ans)};
  }
};"
"class Solution:
    def numTimesAllBlue(self, flips: List[int]) -> int:
        ans = 0
        largest = 0
        for i,n in enumerate(flips):
            largest = max(largest, n)
            if largest == i+1:
                ans+=1
        return ans","class Solution {
 public:
  vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {
    vector<int> ans;
    dfs(root, 0, voyage, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int&& i, const vector<int>& voyage,
           vector<int>& ans) {
    if (root == nullptr)
      return;
    if (root->val != voyage[i++]) {
      ans.clear();
      ans.push_back(-1);
      return;
    }

    if (i < voyage.size() && root->left && root->left->val != voyage[i]) {
      // Flip root
      ans.push_back(root->val);
      dfs(root->right, move(i), voyage, ans);
      dfs(root->left, move(i), voyage, ans);
    } else {
      dfs(root->left, move(i), voyage, ans);
      dfs(root->right, move(i), voyage, ans);
    }
  }
};"
"class Solution:
    def __init__(self):
        self.result = [0]
    def dfs(self,count,head,informTime,time): 
        self.result[0] = max(self.result[0],time)
        for emp in count[head]:
            self.dfs(count,emp,informTime,time+informTime[head])
            
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
        count = collections.defaultdict(list)
        for i in range(len(manager)):
            count[manager[i]].append(i)
        
        self.dfs(count,headID,informTime,0)
        return self.result[0]","class Solution {
 public:
  bool isRationalEqual(string s, string t) {
    return abs(valueOf(s) - valueOf(t)) < 1e-9;
  }

 private:
  const static vector<double> ratios{1.0, 1.0 / 9, 1.0 / 99, 1.0 / 999,
                                     1.0 / 9999};

  double valueOf(const string& s) {
    if (s.find('(') == string::npos)
      return stod(s);

    // Get indices.
    const int leftParenIndex = s.find_first_of('(');
    const int rightParenIndex = s.find_first_of(')');
    const int dotIndex = s.find_first_of('.');

    // integerAndNonRepeating := <IntegerPart><.><NonRepeatingPart>
    const double integerAndNonRepeating = stod(s.substr(0, leftParenIndex));
    const int nonRepeatingLength = leftParenIndex - dotIndex - 1;

    // repeating := <RepeatingPart>
    const int repeating = stoi(s.substr(leftParenIndex + 1, rightParenIndex));
    const int repeatingLength = rightParenIndex - leftParenIndex - 1;
    return integerAndNonRepeating +
           repeating * pow(0.1, nonRepeatingLength) * ratios[repeatingLength];
  }
};"
"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if target==1:
            return 1.0 if len(edges)==0 else 0.0
        # note it's a undirected graph
        graph=[{} for _ in range(n+1)]
        for src,dst in edges:
            graph[src][dst]=1
            graph[dst][src]=1
        # do a bfs
        queue=[(1,1.0)]
        next=[]
        for time in range(t):
            for node,p in queue:
                for child in graph[node]:
                    del graph[child][node]
                    if child==target:
                        if time==t-1 or len(graph[child])<1:
                            return p/len(graph[node])
                        else:
                            return 0.0
                    next.append((child,p/len(graph[node])))
            queue=next
            next=[]
        return 0.0","class Solution {
 public:
  vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
    vector<vector<int>> ans;
    auto compare = [&](const vector<int>& a, const vector<int>& b) {
      return squareDist(a) < squareDist(b);
    };
    priority_queue<vector<int>, vector<vector<int>>, decltype(compare)> maxHeap(
        compare);

    for (const vector<int>& point : points) {
      maxHeap.push(point);
      if (maxHeap.size() > k)
        maxHeap.pop();
    }

    while (!maxHeap.empty())
      ans.push_back(maxHeap.top()), maxHeap.pop();

    return ans;
  };

 private:
  int squareDist(const vector<int>& p) {
    return p[0] * p[0] + p[1] * p[1];
  }
};"
"class Solution:  
    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:  
          
        queue = [([], original)]  
        while queue:  
            actions, node = queue.pop(0)  
            if id(node) == id(target):  
                cloned_target = cloned  
                for a in actions:  
                    if a == 1:  
                        cloned_target = cloned_target.right  
                    else:  
                        cloned_target = cloned_target.left  
                  
                return cloned_target  
                  
            if node.left:  
                actions_copy = []  
                actions_copy.extend(actions)  
                actions_copy.append(0) # Move left  
                queue.append((actions_copy, node.left))  
                  
            if node.right:  
                actions_copy = []  
                actions_copy.extend(actions)  
                actions_copy.append(1) # Move right  
                queue.append((actions_copy, node.right))  
                  
        return None","class Solution {
 public:
  int subarraysDivByK(vector<int>& nums, int k) {
    int ans = 0;
    int prefix = 0;
    vector<int> count(k);
    count[0] = 1;

    for (const int num : nums) {
      prefix = (prefix + num % k + k) % k;
      ans += count[prefix];
      ++count[prefix];
    }

    return ans;
  }
};"
"class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        row_count = len(matrix)
        column_count = len(matrix[0])
        
        result = []
        for row in matrix:
            # Identify min value in row and get it's column index
            min_value = min(row)
            min_index = row.index(min_value)
            column_index = 0
            column_max = 0
            # Using the column check for max of that column
            while column_index < row_count:
                if matrix[column_index][min_index] > column_max:
                    column_max = matrix[column_index][min_index]
                column_index += 1
            # If row min equals column max then add it to our results list   
            if column_max == min_value:
                result.append(min_value)
                
        return result","class Solution {
 public:
  int oddEvenJumps(vector<int>& arr) {
    const int n = arr.size();
    map<int, int> map;    // {num: min index}
    vector<bool> inc(n);  // inc[i] := can reach arr[n - 1] from i w/ inc jump
    vector<bool> dec(n);  // dec[i] := can reach arr[n - 1] from i w/ dec jump

    map[arr[n - 1]] = n - 1;
    inc.back() = true;
    dec.back() = true;

    for (int i = n - 2; i >= 0; --i) {
      const auto lo = map.lower_bound(arr[i]);  // Min val >= arr[i]
      const auto hi = map.upper_bound(arr[i]);  // Min val > arr[i]
      if (lo != cend(map))
        inc[i] = dec[lo->second];
      if (hi != cbegin(map))
        dec[i] = inc[prev(hi)->second];
      map[arr[i]] = i;
    }

    return count(begin(inc), end(inc), true);
  }
};"
"class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        
        def inorder_gen(n: TreeNode):
            if not n:
                return
            yield from inorder_gen(n.left)
            yield n
            yield from inorder_gen(n.right)
            n.left, n.right = None, None
            
        seq = tuple(inorder_gen(root))
        
        def restore(r, l) -> TreeNode:
            if r > l:
                return
            mid = l + (r - l) // 2
            n = seq[mid]
            n.left, n.right = restore(r, mid - 1), restore(mid + 1, l)
            return n
        
        return restore(0, len(seq)-1)","class Solution {
 public:
  int largestPerimeter(vector<int>& nums) {
    sort(begin(nums), end(nums));

    for (int i = nums.size() - 1; i > 1; --i)
      if (nums[i - 2] + nums[i - 1] > nums[i])
        return nums[i - 2] + nums[i - 1] + nums[i];

    return 0;
  }
};"
"class Solution:
def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
    MOD = 10**9+7
	
	#  Converting both list into one list
    candidates = zip(efficiency,speed)
	
	#  sort the candidates in terms of decreasing speed
    candidates = sorted(candidates,key=lambda x:x[0],reverse=True)
    speed_sum=res=0
	
	# defining heap to store ""K"" efficient candidates
    heap=[]
	
	# Checking with every candidates
    for ce,cs in candidates:
        if len(heap)>=k:
            speed_sum-=heap[0]
            heapq.heappop(heap)
        
        heapq.heappush(heap,cs)
        speed_sum+=cs
        res=max(res,speed_sum*ce)
    
	return res%MOD","class Solution {
 public:
  vector<int> sortedSquares(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n);
    int i = n - 1;

    for (int l = 0, r = n - 1; l <= r;)
      if (abs(nums[l]) > abs(nums[r]))
        ans[i--] = nums[l] * nums[l++];
      else
        ans[i--] = nums[r] * nums[r--];

    return ans;
  }
};"
"class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        count, total = 0, len(arr1)
        
        for out in arr1:
            for inner in arr2:
                if abs(out - inner) <= d:
                    count += 1
                    brea
        return total - count","class Solution {
 public:
  int maxTurbulenceSize(vector<int>& arr) {
    int ans = 1;
    int increasing = 1;
    int decreasing = 1;

    for (int i = 1; i < arr.size(); ++i) {
      if (arr[i] > arr[i - 1]) {
        increasing = decreasing + 1;
        decreasing = 1;
      } else if (arr[i] < arr[i - 1]) {
        decreasing = increasing + 1;
        increasing = 1;
      } else {
        increasing = 1;
        decreasing = 1;
      }
      ans = max({ans, increasing, decreasing});
    }

    return ans;
  }
};"
"class Solution:
    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
        count, reservedSeats, available_rows = 0, sorted(reservedSeats), n

        row = reservedSeats[0][0]
        available_rows -= 1
        row_result =  [0] * 10
        
        for seats in reservedSeats:
            sit = seats[1]
            if row == seats[0]:
                row_result[sit-1] = 1
            else:
                # Calculate
                spaces = 0
                for idx, chair in enumerate(row_result):
                    if chair == 0:
                        spaces += 1
                    else:
                        spaces = 0
                    
                    if spaces >= 4 and idx in (4,6,8):
                        count += 1
                        spaces = 0
                    
                row = seats[0] 
                row_result =  [0] * 10
                row_result[sit-1] = 1
                available_rows -= 1
                
        spaces = 0
        for idx, chair in enumerate(row_result):
            if chair == 0:
                spaces += 1
            else:
                spaces = 0
            if spaces >= 4  and idx in (4,6,8):
                count += 1
                spaces = 0
        
        count = count + (available_rows * 2)
                        
        return count","class Solution {
 public:
  int distributeCoins(TreeNode* root) {
    int ans = 0;
    dfs(root, ans);
    return ans;
  }

  // Returns how many coins I can give (positive) / take (negative)
 private:
  int dfs(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = dfs(root->left, ans);
    const int r = dfs(root->right, ans);
    ans += abs(l) + abs(r);
    return (root->val - 1) + l + r;
  }
};"
"class Solution:
    def getKth(self, lo: int, hi: int, k: int) -> int:
        
		# to store the power value of n, and avoid repeated computation
        loop_up_table = {}
        
        def power_val( n ):
            
            step, origin_input = 0, n
            while n != 1:

                
                if n in loop_up_table:
                    # speed up by look-up table
                    loop_up_table[origin_input] = loop_up_table[n] + step
                    return loop_up_table[n]+step
                
                
                if n &amp; 1 == 1:
                    n = 3*n + 1
                else:
                    n = n // 2
            
                step += 1
            
            loop_up_table[origin_input] = step
            return step
        
        # ------------------------------------------
        
        ranked_value = sorted( range(lo, hi+1), key = lambda n:  (power_val(n), n) )

        return ranked_value[k-1]","class Solution {
 public:
  int uniquePathsIII(vector<vector<int>>& grid) {
    int ans = 0;
    int empty = 1;
    int sx;
    int sy;
    int ex;
    int ey;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] == 0) {
          ++empty;
        } else if (grid[i][j] == 1) {
          sx = i;
          sy = j;
        } else if (grid[i][j] == 2) {
          ex = i;
          ey = j;
        }

    dfs(grid, empty, sx, sy, ex, ey, ans);

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& grid, int empty, int i, int j, int ex, int ey,
           int& ans) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] < 0)
      return;
    if (i == ex && j == ey) {
      if (empty == 0)
        ++ans;
      return;
    }

    grid[i][j] = -2;
    dfs(grid, empty - 1, i + 1, j, ex, ey, ans);
    dfs(grid, empty - 1, i - 1, j, ex, ey, ans);
    dfs(grid, empty - 1, i, j + 1, ex, ey, ans);
    dfs(grid, empty - 1, i, j - 1, ex, ey, ans);
    grid[i][j] = 0;
  }
};"
"class Solution:
    def maxSizeSlices(self, slices: List[int]) -> int:
        
        def solve(index,end,slices,n,dic):
            key=(index,n)
            if key in dic:
                return dic[key]
            else:
                if n==0 or index>end:
                    return 0
                include=slices[index]+solve(index+2,end,slices,n-1,dic)
                exclude=solve(index+1,end,slices,n,dic)
                dic[key]=max(include,exclude)
                return dic[key]
        l=len(slices)
        dic1={}
        dic2={}
        c1=solve(0,l-2,slices,l//3,dic1)
        c2=solve(1,l-1,slices,l//3,dic2)
        return max(c1,c2)","class Solution {
 public:
  int countTriplets(vector<int>& nums) {
    constexpr int kMax = 1 << 16;
    int ans = 0;
    vector<int> count(kMax);  // {nums[i] & nums[j]: times}

    for (const int a : nums)
      for (const int b : nums)
        ++count[a & b];

    for (const int num : nums)
      for (int i = 0; i < kMax; ++i)
        if ((num & i) == 0)
          ans += count[i];

    return ans;
  }
};"
"class Solution:
    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:
        result = []
        for i in range(0, len(index)):
            # insertion is guaranteed to be valid
            result.insert(index[i], nums[i]) # shift then insert value
        return result","class Solution {
 public:
  int mincostTickets(vector<int>& days, vector<int>& costs) {
    int ans = 0;
    queue<pair<int, int>> last7;
    queue<pair<int, int>> last30;

    for (int day : days) {
      while (!last7.empty() && last7.front().first + 7 <= day)
        last7.pop();
      while (!last30.empty() && last30.front().first + 30 <= day)
        last30.pop();
      last7.emplace(day, ans + costs[1]);
      last30.emplace(day, ans + costs[2]);
      ans = min({ans + costs[0], last7.front().second, last30.front().second});
    }

    return ans;
  }
};"
"class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        
        def fn(x):
            c = s = 0
            for i in range(1, int(x**0.5)+1):
                if x % i == 0: 
                    c += 1 + (0 if x//i == i else 1)
                    s += i + (0 if x//i == i else x//i)
            return s if c == 4 else 0
        
        return sum(fn(x) for x in nums)","class Solution {
 public:
  string strWithout3a3b(int A, int B, char a = 'a', char b = 'b') {
    if (A < B)
      return strWithout3a3b(B, A, b, a);
    if (B == 0)
      return string(min(A, 2), a);

    const int useA = min(A, 2);
    const int useB = (A - useA >= B) ? 1 : 0;
    return string(useA, a) + string(useB, b) +
           strWithout3a3b(A - useA, B - useB, a, b);
  }
};"
"class Solution:
    def hasValidPath(self, grid: List[List[int]]) -> bool:
        if not grid or not grid[0]:
            return False
        
        M, N = len(grid), len(grid[0])
        left, right, up, down = (0,-1), (0,1), (-1,0), (1,0)
        direction = { 1: (left, right), 2: (up, down), 3: (left, down), 4: (right, down), 5: (left, up), 6: (right, up) }
        compatibles = { right: {1, 3, 5}, left: {1, 4, 6}, up: {2, 3, 4}, down: {2, 5, 6} }
        
        q = collections.deque([(0, 0)])
        seen = {(0, 0)}
        while q:
            r, c = q.popleft()
            if (r, c) == (M-1, N-1):
                return True
            di_x, di_y = direction[grid[r][c]]
            accepted_paths = compatibles[di_x] | compatibles[di_y]
            for dr, dc in [di_x, di_y]:
                cr, cc = r+dr, c+dc
                if (cr, cc) not in seen and 0 <= cr < M and 0 <= cc < N and grid[cr][cc] in accepted_paths:
                    seen.add((cr, cc))
                    q.append((cr, cc))
        return False","class Solution {
 public:
  vector<int> sumEvenAfterQueries(vector<int>& nums,
                                  vector<vector<int>>& queries) {
    vector<int> ans;
    int sum = accumulate(begin(nums), end(nums), 0, [](int subtotal, int num) {
      return subtotal + (num % 2 == 0 ? num : 0);
    });

    for (const vector<int>& query : queries) {
      const int val = query[0];
      const int index = query[1];
      if (nums[index] % 2 == 0)
        sum -= nums[index];
      nums[index] += val;
      if (nums[index] % 2 == 0)
        sum += nums[index];
      ans.push_back(sum);
    }

    return ans;
  }
};"
"class Solution:
    def longestPrefix(self, s: str) -> str:
        lps = [0]*len(s)
        curr = 1
        pre = 0
        while curr < len(s):
            if s[curr] == s[pre]:
                lps[curr] = pre + 1
                curr +=1
                pre+=1
            else:
                if pre == 0:
                    lps[curr] = 0
                    curr += 1
                else:
                    pre = lps[pre-1]
        a = ''
        for i in range(lps[-1]):
            a += s[i]
        return a","class Solution {
 public:
  vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList,
                                           vector<vector<int>>& secondList) {
    vector<vector<int>> ans;
    short i = 0;
    short j = 0;

    while (i < firstList.size() && j < secondList.size()) {
      // Lo := the start of the intersection
      // Hi := the end of the intersection
      const int lo = max(firstList[i][0], secondList[j][0]);
      const int hi = min(firstList[i][1], secondList[j][1]);
      if (lo <= hi)
        ans.push_back({lo, hi});
      firstList[i][1] < secondList[j][1] ? ++i : ++j;
    }

    return ans;
  }
};"
"class Solution:
    def findLucky(self, arr: List[int]) -> int:
        ans = [0] * 501
        res = -1
        for i in range(len(arr)):
            ans[arr[i]] += 1
        for i in range(1, 501):
            if ans[i] == i:
                res = max(res, i)
        return res","class Solution {
 public:
  vector<vector<int>> verticalTraversal(TreeNode* root) {
    vector<vector<int>> ans;
    map<int, multiset<pair<int, int>>> xToSortedPairs;  // {x: {(-y, val)}}

    dfs(root, 0, 0, xToSortedPairs);

    for (const auto& [_, pairs] : xToSortedPairs) {
      vector<int> vals;
      for (const pair<int, int>& pair : pairs)
        vals.push_back(pair.second);
      ans.push_back(vals);
    }

    return ans;
  }

 private:
  void dfs(TreeNode* root, int x, int y,
           map<int, multiset<pair<int, int>>>& xToSortedPairs) {
    if (root == nullptr)
      return;

    xToSortedPairs[x].emplace(y, root->val);
    dfs(root->left, x - 1, y + 1, xToSortedPairs);
    dfs(root->right, x + 1, y + 1, xToSortedPairs);
  }
};"
"class Solution:
    def numTeams(self, rating: List[int]) -> int:
        teams = [0]
        
        def up(n1, n2):
            return n2 > n1
        
        def down(n1, n2):
            return n2 < n1
        
        def search_team(team, np=0, op=up):
            for i in range(np, len(rating)):
                nv = rating[i]
                if not team or op(team[-1], nv):
                    team_copy = []
                    team_copy.extend(team)
                    team_copy.append(nv)
                    if len(team_copy) < 3:
                        search_team(team_copy, np=i, op=op)
                    else:
                        teams[0] += 1
        
        # Search team in up rating
        search_team([])
        # Search team in down rating        
        search_team([], op=down)
        
        return teams[0]","class Solution {
 public:
  string smallestFromLeaf(TreeNode* root) {
    string ans;
    dfs(root, """", ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, string&& path, string& ans) {
    if (root == nullptr)
      return;

    path.push_back(root->val + 'a');

    if (root->left == nullptr && root->right == nullptr) {
      reverse(begin(path), end(path));
      if (ans == """" || ans > path)
        ans = path;
      reverse(begin(path), end(path));  // Roll back
    }

    dfs(root->left, move(path), ans);
    dfs(root->right, move(path), ans);
    path.pop_back();
  }
};"
"class Solution:
    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:
        p=10**9+7
        ord_a=ord('a')
        l=len(evil)
        dup=[]
        for i in range(1, l):
            if evil[i:]==evil[:l-i]:
                dup.append(i)
        lend=len(dup)
        def count(s):
            tmp_ct=0
            bd=1
            ind=n
            without_s=[]
            for i in range(n):
                tmp_ct*=26
                if bd:
                    tmp_ct+=ord(s[i])-ord_a
                if i>=l-1 and ind>i-l and evil<s[i-l+1:i+1]:
                    tmp_ct-=1
                if i>=l:
                    tmp_ct-=without_s[i-l]
                if i>=l-1:
                    if s[i-l+1:i+1]==evil:
                        bd=0
                        ind=i
                tmp_ct%=p
                tmp_with_s=0
                for j in range(lend):
                    d=dup[j]
                    if i>=d:
                        tmp_with_s+=without_s[i-d]
                    if i>=d-1 and ind>i-d and evil[:d]<s[i-d+1:i+1]:
                        tmp_with_s+=1
                without_s.append(tmp_ct-tmp_with_s)
            return tmp_ct, bd
        str_ct1, bd1=count(s1)
        str_ct2, bd2=count(s2)
        return (str_ct2-str_ct1+bd2)%p","class Solution {
 public:
  vector<int> addToArrayForm(vector<int>& num, int k) {
    for (int i = num.size() - 1; i >= 0; --i) {
      num[i] += k;
      k = num[i] / 10;
      num[i] %= 10;
    }

    while (k > 0) {
      num.insert(begin(num), k % 10);
      k /= 10;
    }

    return num;
  }
};"
"class Solution:
    def countLargestGroup(self, n: int) -> int:
        freq = {}
        for x in range(1, n+1): 
            key = sum(int(d) for d in str(x))
            freq[key] = 1 + freq.get(key, 0)
        vals = list(freq.values())
        return vals.count(max(vals))","class UnionFind {
 public:
  UnionFind(int n) : id(n) {
    iota(begin(id), end(id), 0);
  }

  void union_(int u, int v) {
    id[find(u)] = find(v);
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
};

class Solution {
 public:
  bool equationsPossible(vector<string>& equations) {
    UnionFind uf(26);

    for (const string& e : equations)
      if (e[1] == '=') {
        const int x = e[0] - 'a';
        const int y = e[3] - 'a';
        uf.union_(x, y);
      }

    for (const string& e : equations)
      if (e[1] == '!') {
        const int x = e[0] - 'a';
        const int y = e[3] - 'a';
        if (uf.find(x) == uf.find(y))
          return false;
      }

    return true;
  }
};"
"class Solution:
    def canConstruct(self, s: str, k: int) -> bool:
        if len(s) < k:
            return False
        
        counter = collections.Counter(s)
        
        odd_count = 0
        for key in counter:
            if counter[key] % 2 != 0:
                odd_count += 1
        
        return odd_count <= k","class Solution {
 public:
  int brokenCalc(int X, int Y) {
    int ops = 0;

    while (X < Y) {
      if (Y % 2 == 0)
        Y /= 2;
      else
        Y += 1;
      ++ops;
    }

    return ops + X - Y;
  }
};"
"class Solution:
    def checkOverlap(self, r: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:
        
        if xc >= x1 and xc <= x2 and yc >= y1 and yc <= y2:
            return True
        
        elif xc > x2:
            if yc > y2:
                return r**2 >= (xc-x2)**2 + (yc-y2)**2
            elif yc >= y1 and yc < y2:
                return r >= xc-x2
            else: # yc < y1
                return r**2 >= (xc-x2)**2 + (yc-y1)**2
        elif xc <= x1:
            if yc > y2:
                return r**2 >= (xc-x1)**2 + (yc-y2)**2
            elif yc >= y1 and yc < y2:
                return r >= x1-xc
            else: # yc < y1
                return r**2 >= (xc-x1)**2 + (yc-y1)**2
        elif xc > x1 and xc < x2 and yc > y2:
            
            return r >= yc -y2
        else: 
            return r >= y1-yc","class Solution {
 public:
  int subarraysWithKDistinct(vector<int>& nums, int k) {
    return subarrayWithAtMostKDistinct(nums, k) -
           subarrayWithAtMostKDistinct(nums, k - 1);
  }

 private:
  int subarrayWithAtMostKDistinct(const vector<int>& nums, int k) {
    int ans = 0;
    vector<int> count(nums.size() + 1);

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (++count[nums[r]] == 1)
        --k;
      while (k == -1)
        if (--count[nums[l++]] == 0)
          ++k;
      ans += r - l + 1;  // nums[l..r], nums[l + 1..r], ..., nums[r]
    }

    return ans;
  }
};"
"class Solution:
    def maxSatisfaction(self, satisfaction: List[int]) -> int:
        satisfaction.sort()
        result , current_sum = 0 , 0
        while satisfaction and satisfaction[-1] + current_sum > 0:
            current_sum += satisfaction.pop()
            result += current_sum
        return result","class Solution {
 public:
  bool isCousins(TreeNode* root, int x, int y) {
    if (root == nullptr)
      return false;

    queue<TreeNode*> queue{{root}};

    while (!queue.empty()) {
      bool isFindX = false;
      bool isFindY = false;
      for (int i = queue.size(); i > 0; --i) {
        root = queue.front(), queue.pop();
        if (root->val == x)
          isFindX = true;
        else if (root->val == y)
          isFindY = true;
        else if (root->left && root->right) {
          if (root->left->val == x && root->right->val == y)
            return false;
          if (root->left->val == y && root->right->val == x)
            return false;
        }
        if (root->left)
          queue.push(root->left);
        if (root->right)
          queue.push(root->right);
      }
      if (isFindX && isFindY)
        return true;
      else if (isFindX || isFindY)
        return false;
    }

    return false;
  }
};"
"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        
        # make nums sorted in descending order
        nums.sort( reverse = True )
        
        summation = sum( nums )
        
        sequence, partial_sum = [], 0
        
        # keep picking number from largest one, until partial sum is larger than (summation / 2)
        for number in nums:
            
            partial_sum += number
            sequence.append( number )
            
            if partial_sum > summation / 2:
                break
                
        return sequence","class Solution {
 public:
  int orangesRotting(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};

    auto isNeighborRotten = [&](int i, int j, const vector<vector<int>>& grid) {
      for (int k = 0; k < 4; ++k) {
        const int r = i + dirs[k];
        const int c = j + dirs[k + 1];
        if (r < 0 || r == m || c < 0 || c == n)
          continue;
        if (grid[r][c] == 2)
          return true;
      }
      return false;
    };

    int ans = 0;

    while (true) {
      vector<vector<int>> nextGrid(m, vector<int>(n));
      // Calculate `nextGrid` based on `grid`
      for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
          if (grid[i][j] == 1) {  // Fresh
            if (isNeighborRotten(
                    i, j, grid))  // Any of 4-directionally oranges is rotten
              nextGrid[i][j] = 2;
            else
              nextGrid[i][j] = 1;
          } else if (grid[i][j] == 2) {  // Rotten
            nextGrid[i][j] = 2;          // Keep rotten
          }
      if (nextGrid == grid)
        break;
      grid = nextGrid;
      ++ans;
    }

    return any_of(
               begin(grid), end(grid),
               [&](vector<int>& row) {
      return any_of(begin(row), end(row),
                    [&](int orange) { return orange == 1; });
               })
        ? -1
        : ans;
  }
};"
"class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        nums = [a, b, c]
        chars = ['a', 'b', 'c']
        indices = [0, 1, 2]
        def keyFunc(i):
            return nums[i]
        indices = sorted(indices, key=keyFunc)
        if nums[indices[2]] > (nums[indices[1]] + nums[indices[0]] + 1) * 2:
            nums[indices[2]] = (nums[indices[1]] + nums[indices[0]] + 1) * 2
        if nums[indices[2]] > nums[indices[1]] + nums[indices[0]] + 1:
            s = """"
            gaps = nums[indices[1]] + nums[indices[0]] + 1
            doubles = nums[indices[2]] % gaps
            if doubles == 0:
                doubles = gaps
            singles = nums[indices[2]] - doubles
            for k in [0, 1]:
                for i in range(nums[indices[k]]):
                    if doubles > 0:
                        s += chars[indices[2]]
                        doubles -= 1
                    s += chars[indices[2]]
                    s += chars[indices[k]]
            if doubles > 0:
                s += chars[indices[2]]
            s += chars[indices[2]]
            return s
        else:
            s = """"
            singles = nums[indices[2]]
            gaps = nums[indices[1]] + nums[indices[0]] + 1
            zeros = gaps - singles
            skip = True
            for k in [0, 1]:
                for i in range(nums[indices[k]]):
                    if zeros > 0 and skip:
                        zeros -= 1
                    else:
                        s += chars[indices[2]]
                    s += chars[indices[k]]    
                    skip = not skip
            if not(zeros > 0 and skip):
                s += chars[indices[2]]
            return s","class Solution {
 public:
  int minKBitFlips(vector<int>& nums, int k) {
    int ans = 0;
    int flippedTime = 0;

    for (int i = 0; i < nums.size(); ++i) {
      if (i >= k && nums[i - k] == 2)
        --flippedTime;
      if (flippedTime % 2 == nums[i]) {
        if (i + k > nums.size())
          return -1;
        ++ans;
        ++flippedTime;
        nums[i] = 2;
      }
    }

    return ans;
  }
};"
"class Solution:
    def stoneGameIII(self, s: List[int]) -> str:
        n = len(s)
        dpi = 0
        dp1 = 0
        dp2 = 0
        i = n-1
        while i >= 0:
            ans = -1<<32
            ans = max(ans,s[i]-dpi)
            if i+1 < n:
                ans = max(ans,(s[i]+s[i+1])-dp1)
            if i+2 < n:
                ans = max(ans,(s[i]+s[i+1]+s[i+2])-dp2)
            dp2 = dp1
            dp1 = dpi
            dpi = ans
            i -= 1
        if dpi > 0:
            return ""Alice""
        if dpi == 0:
            return ""Tie""
        return ""Bob""","class Solution {
 public:
  int numSquarefulPerms(vector<int>& nums) {
    int ans = 0;
    sort(begin(nums), end(nums));
    dfs(nums, vector<bool>(nums.size()), {}, ans);
    return ans;
  }

 private:
  void dfs(vector<int>& nums, vector<bool>&& used, vector<int>&& path,
           int& ans) {
    if (path.size() > 1 && !isSquare(path.back() + path[path.size() - 2]))
      return;
    if (path.size() == nums.size()) {
      ++ans;
      return;
    }

    for (int i = 0; i < nums.size(); ++i) {
      if (used[i])
        continue;
      if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])
        continue;
      used[i] = true;
      path.push_back(nums[i]);
      dfs(nums, move(used), move(path), ans);
      path.pop_back();
      used[i] = false;
    }
  }

  bool isSquare(int num) {
    const int root = sqrt(num);
    return root * root == num;
  }
};"
"class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        words_set = words.sort(key=len)
        ans = []
        for i in range(len(words)):
            for j in range(i+1, len(words)):
                if words[i] in words[j]:
                    ans.append(words[i])
        return set(ans)","class Solution {
 public:
  int findJudge(int n, vector<vector<int>>& trust) {
    vector<int> count(n + 1);

    for (vector<int>& t : trust) {
      --count[t[0]];
      ++count[t[1]];
    }

    for (int i = 1; i < n + 1; ++i)
      if (count[i] == n - 1)
        return i;

    return -1;
  }
};"
"class Solution:
    def processQueries(self, queries: List[int], m: int) -> List[int]:
        
        p=[]
        for i in range(1,m+1):
            p.append(i)
        
        result=[]
        for i in range(len(queries)):
            x=queries[i]
            idx=p.index(x)
            p.pop(idx)
            p.insert(0,x)
            result.append(idx)
        
        return result
        print(result)","class Solution {
 public:
  TreeNode* insertIntoMaxTree(TreeNode* root, int val) {
    if (root == nullptr)
      return new TreeNode(val);
    if (root->val < val)
      return new TreeNode(val, root, nullptr);
    root->right = insertIntoMaxTree(root->right, val);
    return root;
  }
};"
"class Solution:
    def entityParser(self, text: str) -> str:
        mapping = {""&amp;quot;"" : '""', 
                   ""&amp;apos;"" : ""'"", 
                   ""&amp;gt;""   : "">"", 
                   ""&amp;lt;""   : ""<"", 
                   ""&amp;frasl;"": ""/"", 
                   ""&amp;amp;""  : ""&amp;""}
        for key, val in mapping.items():
            text = text.replace(key, val)
        return text","class Solution {
 public:
  int numRookCaptures(vector<vector<char>>& board) {
    int ans = 0;
    int i0 = 0;
    int j0 = 0;

    for (int i = 0; i < 8; ++i)
      for (int j = 0; j < 8; ++j)
        if (board[i][j] == 'R') {
          i0 = i;
          j0 = j;
        }

    for (const vector<int>& d :
         vector<vector<int>>({{1, 0}, {0, 1}, {-1, 0}, {0, -1}}))
      for (int i = i0 + d[0], j = j0 + d[1]; 0 <= i && i < 8 && 0 <= j && j < 8;
           i += d[0], j += d[1]) {
        if (board[i][j] == 'p')
          ++ans;
        if (board[i][j] != '.')
          break;
      }

    return ans;
  }
};"
"class Solution:
    def numOfWays(self, n: int) -> int:
        if n == 0:
            return 0
        atlevel = 12
        five = 6
        four = 6
        depth = 1
        while depth < n:
            depth+=1
            a1four = five*2
            a1five = five*3
            b1five = four*2
            b1four = four*2
            atlevel = a1four+a1five+b1four+b1five
            five = a1five+b1five
            four = a1four+b1four
        return atlevel%(10**9+7)","class Solution {
 public:
  int mergeStones(vector<int>& stones, int K) {
    const int n = stones.size();
    this->K = K;

    // dp[i][j][k] := min cost to merge stones[i..j] into k piles
    dp.resize(n, vector<vector<int>>(n, vector<int>(K + 1, kMax)));
    prefix.resize(n + 1);

    partial_sum(begin(stones), end(stones), begin(prefix) + 1);

    const int cost = mergeStones(stones, 0, n - 1, 1);
    return cost == kMax ? -1 : cost;
  }

 private:
  static constexpr int kMax = 1'000'000'000;
  int K;
  vector<vector<vector<int>>> dp;
  vector<int> prefix;

  int mergeStones(const vector<int>& stones, int i, int j, int k) {
    if ((j - i + 1 - k) % (K - 1))
      return kMax;
    if (i == j)
      return k == 1 ? 0 : kMax;
    if (dp[i][j][k] != kMax)
      return dp[i][j][k];
    if (k == 1)
      return mergeStones(stones, i, j, K) + prefix[j + 1] - prefix[i];

    for (int m = i; m < j; m += K - 1)
      dp[i][j][k] = min(dp[i][j][k], mergeStones(stones, i, m, 1) +
                                         mergeStones(stones, m + 1, j, k - 1));

    return dp[i][j][k];
  }
};"
"class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        
        prefix_sum = 0
        negative_most_offset = float('inf')
        
        # linear scan, and update nagative most offset by prefix sum
        for i in range(0, len(nums)):
            
            prefix_sum += nums[i]
            negative_most_offset = min( prefix_sum, negative_most_offset)
        
        # compute the minimum value to get positive
        threshold = min( negative_most_offset,  0 )
        
        # abs to flip the sign, +1 to make it larger than zero
        return abs(threshold)+1","class Solution {
 public:
  vector<int> gridIllumination(int n, vector<vector<int>>& lamps,
                               vector<vector<int>>& queries) {
    vector<int> ans;
    unordered_map<int, int> rows;
    unordered_map<int, int> cols;
    unordered_map<int, int> diag1;
    unordered_map<int, int> diag2;
    unordered_set<pair<int, int>, pairHash> lampsSet;

    for (vector<int>& lamp : lamps) {
      int i = lamp[0];
      int j = lamp[1];
      if (lampsSet.insert({i, j}).second) {
        ++rows[i];
        ++cols[j];
        ++diag1[i + j];
        ++diag2[i - j];
      }
    }

    for (const vector<int>& query : queries) {
      int i = query[0];
      int j = query[1];
      if (rows[i] || cols[j] || diag1[i + j] || diag2[i - j]) {
        ans.push_back(1);
        for (int y = max(0, i - 1); y < min(n, i + 2); ++y)
          for (int x = max(0, j - 1); x < min(n, j + 2); ++x)
            if (lampsSet.erase({y, x})) {
              --rows[y];
              --cols[x];
              --diag1[y + x];
              --diag2[y - x];
            }
      } else {
        ans.push_back(0);
      }
    }

    return ans;
  }

 private:
  struct pairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};"
"class Solution:
    
   
    
    def findMinFibonacciNumbers(self, k: int) -> int:
        m= [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733 
]
        m.sort()
        m=m[::-1]
        x=0
        count=0
        print(m)
        i=0
        y=k

        
        
        for i in range(len(m)):
            if m[i]>k:
                continue
            count+=1
            x+=m[i]
            if x>k:
                x-=m[i]
                count-=1
            if x==k:
                break
        return count","class Solution {
 public:
  vector<string> commonChars(vector<string>& A) {
    vector<string> ans;
    vector<int> commonCount(26, INT_MAX);

    for (const string& a : A) {
      vector<int> count(26);
      for (char c : a)
        ++count[c - 'a'];
      for (int i = 0; i < 26; ++i)
        commonCount[i] = min(commonCount[i], count[i]);
    }

    for (char c = 'a'; c <= 'z'; ++c)
      for (int i = 0; i < commonCount[c - 'a']; ++i)
        ans.push_back(string(1, c));

    return ans;
  }
};"
"class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        def get_hs(n):
            ''' get happy string for length=`n`'''
            def _gen_of_hs(hs, n=n):
                ''' generator of happy string'''
                if len(hs) == n:
                    yield hs
                else:
                    for c in ['a', 'b', 'c']:
                        if hs and hs[-1] == c:
                            continue
                            
                        yield from _gen_of_hs(hs+c)
                        
            return _gen_of_hs('', n)
        
        num_of_hs = 0
        ''' number of happy string generated'''
        
        # Algorithm: Keep generating happy string util the kth one generated.
        for hs in get_hs(n):
            num_of_hs += 1
            if num_of_hs == k:
                return hs
            
        # Unable to retrieve the kth happy string
        return """"
            `","class Solution {
 public:
  bool isValid(string s) {
    stack<char> stack;

    for (const char c : s)
      if (c == 'c') {
        if (stack.size() < 2)
          return false;
        if (stack.top() != 'b')
          return false;
        stack.pop();
        if (stack.top() != 'a')
          return false;
        stack.pop();
      } else {
        stack.push(c);
      }

    return stack.empty();
  }
};"
"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        dp = [0]*(len(s)+1)
        dp[-1] = sm = 1 
        
        ii = len(s)
        for i in reversed(range(len(s))): 
            if s[i] != ""0"": 
                while ii - i - 1 > log10(k) or int(s[i:ii]) > k: 
                    sm = (sm - dp[ii]) % 1_000_000_007
                    ii -= 1
                dp[i] = sm
                sm = (sm + dp[i]) % 1_000_000_007
        return dp[0]","class Solution {
 public:
  int longestOnes(vector<int>& nums, int k) {
    int ans = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (nums[r] == 0)
        --k;
      while (k < 0)
        if (nums[l++] == 0)
          ++k;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};"
"class Solution:
    def reformat(self, s: str) -> str:
        nextDigit, nextStr, res = 0, 0, """"
		
        def helper(curr,fn):
            #return first occurance str with function passed (digit, alpha)
            while curr<len(s):
                if fn(s[curr]):
                    break;
                curr+=1
            return curr
			
        #append to res digit and str in that order
        while nextDigit<len(s) and nextStr<len(s):
            nextDigit = helper(nextDigit, str.isdigit)
            nextStr = helper(nextStr, str.isalpha)
            if nextDigit >= len(s):
                break
            res += s[nextDigit] 
            if nextStr >= len(s):
                break
            res += s[nextStr] 
            nextDigit += 1
            nextStr += 1
            
        #if there are digits remaining 
        if helper(nextDigit + 1, str.isdigit) < len(s):
            return """"
        # if the current string is not accounted for, prepend it to the result
        if nextStr < len(s) and s[nextStr].isalpha():
            res = s[nextStr] + res
        # if we can find more strings
        if helper(nextStr + 1, str.isalpha) < len(s):
            return """"
        return res","class Solution {
 public:
  int largestSumAfterKNegations(vector<int>& nums, int k) {
    sort(begin(nums), end(nums));

    for (int i = 0; i < nums.size(); ++i) {
      if (nums[i] > 0 || k == 0)
        break;
      nums[i] = -nums[i];
      --k;
    }

    return accumulate(begin(nums), end(nums), 0) -
           (k % 2) * *min_element(begin(nums), end(nums)) * 2;
  }
};"
"class Solution:
    def displayTable(self, orders) :
        #definitely needs improvement.
        tables = {}
        food = {}
        for order in orders: #go thru orders to list all table and food items.
            tables[order[1]] = None
            food[order[2]] = None
        food_kinds = len(food)
        tables_num = len(tables)
        display_table = [[""0"" for i in range(food_kinds+1)] for j in range(tables_num+1)]
        display_table[0][0] = ""Table""
        row_table = 1
        tables = dict(sorted(tables.items(),key = lambda x:int(x[0]))) #sort table in numeric order
        for table in tables:
            display_table[row_table][0]= table
            tables[table] = row_table #record which row is for this table.
            row_table+=1
        column_table = 1
        food = dict(sorted(food.items(),key = lambda x:x[0])) #sort food item in alphabetical order
        for food_item in food:
            display_table[0][column_table]= food_item
            food[food_item]= column_table #record which column is for this food item
            column_table +=1
            
        for order in orders:
            if display_table[tables[order[1]]][food[order[2]]] == ""0"":
                display_table[tables[order[1]]][food[order[2]]]=""1""
            else: 
                display_table[tables[order[1]]][food[order[2]]]=str(int(display_table[tables[order[1]]][food[order[2]]])+1)
        return display_table","class Solution {
 public:
  int clumsy(int n) {
    if (n == 1)
      return 1;
    if (n == 2)
      return 2;
    if (n == 3)
      return 6;
    if (n == 4)
      return 7;
    if (n % 4 == 1)
      return n + 2;
    if (n % 4 == 2)
      return n + 2;
    if (n % 4 == 3)
      return n - 1;
    return n + 1;
  }
};"
"class Solution:
    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:
        vals = {'c': 0, 'r': 1, 'o': 2, 'a': 3, 'k': 4}
        croaks = [0] * 4
        frogs = 0

        for c in croakOfFrogs:
            val = vals[c]
            if val:
                if not croaks[val - 1]:
                    return -1
                croaks[val - 1] -= 1
                
            if val != 4:
                croaks[val] += 1
            
            frogs = max(frogs, sum(croaks))
        
        return frogs if not sum(croaks) else -1","class Solution {
 public:
  int minDominoRotations(vector<int>& tops, vector<int>& bottoms) {
    const int n = tops.size();
    vector<int> countTops(7);
    vector<int> countBottoms(7);
    vector<int> countBoth(7);

    for (int i = 0; i < n; ++i) {
      ++countTops[tops[i]];
      ++countBottoms[bottoms[i]];
      if (tops[i] == bottoms[i])
        ++countBoth[tops[i]];
    }

    for (int i = 1; i <= 6; ++i)
      if (countTops[i] + countBottoms[i] - countBoth[i] == n)
        return n - max(countTops[i], countBottoms[i]);

    return -1;
  }
};"
"class Solution:
    def numOfArrays(self, n: int, m: int, k: int) -> int:
        
        @cache
        def fn(i, x, k): 
            """"""Return number of ways to build arr[i:] with current max at x and remaining cost at k.""""""
            if n - i < k: return 0 # impossible 
            if m - x < k: return 0 # impossible 
            if k == 0: return x**(n-i)
            return x*fn(i+1, x, k) + fn(i+1, x+1, k-1) + fn(i, x+1, k) - (x+1)*fn(i+1, x+1, k)
        
        return fn(0, 0, k) % 1_000_000_007","class Solution {
 public:
  TreeNode* bstFromPreorder(vector<int>& preorder) {
    TreeNode* root = new TreeNode(preorder[0]);
    stack<TreeNode*> stack{{root}};

    for (int i = 1; i < preorder.size(); ++i) {
      TreeNode* parent = stack.top();
      TreeNode* child = new TreeNode(preorder[i]);
      // Adjust parent
      while (!stack.empty() && stack.top()->val < child->val)
        parent = stack.top(), stack.pop();
      // Create parent-child link according to BST property
      if (parent->val > child->val)
        parent->left = child;
      else
        parent->right = child;
      stack.push(child);
    }

    return root;
  }
};"
"class Solution:
    def maxScore(self, s: str) -> int:
        s_len = len(s)  
        ''' Length of `s`'''  
        max_score = -1  
        ''' Keep max score during searching'''  
        for i in range(s_len-2, -1, -1):  
            if s[i] != '0':  
                # Skip split on 1  
                continue  
  
            split_left = s[:i+1]  
            ''' Left part after split'''  
            if split_left.count('0') >= split_left.count('1'):  
                # print(""{}: {} {}"".format(s, split_left, s[i+1:]))  
                cur_score =  split_left.count('0') + s[i+1:].count('1')  
                if cur_score > max_score:  
                    max_score = cur_score  
  
        # If mas_score = -1, it means no split at all  
        # So we have to split at least once by minimum cost:  
        # s[:1] + s[1:]  
        # which will lose one '1' and obtain score = s.count('1') - 1   
        return max_score if max_score > 0 else s.count('1') - 1  


sol = Solution()
for s, ans in [
                (""01101"", 4),
                (""110000"", 3),
                (""1011011"", 5),
                (""01001"", 4),
                (""011101"", 5),
                (""00111"", 5),
                (""1111"", 3),
                (""11100"", 2),
                (""0000"", 3),
                (""0100001"", 6)
              ]:
    rel = sol.maxScore(s)
    print(""{}: {}"".format(s, rel))
    assert ans == rel","class Solution {
 public:
  int bitwiseComplement(int n) {
    int mask = 1;
    while (mask < n)
      mask = (mask << 1) + 1;
    return mask ^ n;
  }
};"
"class Solution:
    def maxScore(self, cardPoints: List[int], k: int) -> int:
        M = sum(cardPoints[:k])
        temp = M
        for i in range(1, k+1):
            temp += cardPoints[-i]
            temp -= cardPoints[k-i]
            if temp > M:
                M = temp
        
        return M","class Solution {
 public:
  int numPairsDivisibleBy60(vector<int>& time) {
    int ans = 0;
    vector<int> count(60);

    for (int t : time) {
      t %= 60;
      ans += count[(60 - t) % 60];
      ++count[t];
    }

    return ans;
  }
};"
"class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        idx, val = [], []
        for i, row in enumerate(nums):
            for j, num in enumerate(row): 
                idx.append((i+j, -i))
                val.append(num)
        _, ans = zip(*sorted(zip(idx, val)))
        return ans","class Solution {
 public:
  int shipWithinDays(vector<int>& weights, int days) {
    int l = *max_element(begin(weights), end(weights));
    int r = accumulate(begin(weights), end(weights), 0);

    while (l < r) {
      const int m = (l + r) / 2;
      if (shipDays(weights, m) <= days)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int shipDays(const vector<int>& weights, int shipCapacity) {
    int days = 1;
    int capacity = 0;
    for (const int weight : weights)
      if (capacity + weight > shipCapacity) {
        ++days;
        capacity = weight;
      } else {
        capacity += weight;
      }
    return days;
  };
};"
"class Solution:
    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:
        stk = []
        subsum = 0
        best = float('-inf')
        for idx in range(len(nums)):
            while stk and nums[stk[-1]] < 0  and (len(stk) == 1 or idx - stk[-2] <= k) and nums[stk[-1]] < nums[idx]:
                subsum -= nums[stk.pop()]  # kick out more expensive negative bridge elements
            if nums[idx] > 0 and subsum < 0:
                stk = [idx]
                subsum = nums[idx]  # don't have a negative start
            else:
                stk.append(idx)
                subsum += nums[idx]
            best = max(best, subsum)
            
        return best","class Solution {
 public:
  int numDupDigitsAtMostN(int n) {
    return n - countSpecialNumbers(n);
  }

 private:
  // Same as 2376. Count Special Integers
  int countSpecialNumbers(int n) {
    const int digitSize = log10(n) + 1;
    // dp[i][j][k] := # of special integers that belong to the interval
    // [0, 10^i] with `usedMask` j, where k is 0/1 tight constraint
    dp.resize(digitSize + 1, vector<vector<int>>(1 << 10, vector<int>(2, -1)));
    return count(to_string(n), digitSize, 0, true) - 1;  // - 0;
  }

  vector<vector<vector<int>>> dp;

  int count(const string& s, int digitSize, int usedMask, bool isTight) {
    if (digitSize == 0)
      return 1;
    if (dp[digitSize][usedMask][isTight] != -1)
      return dp[digitSize][usedMask][isTight];

    int ans = 0;
    const int maxDigit = isTight ? s[s.length() - digitSize] - '0' : 9;

    for (int digit = 0; digit <= maxDigit; ++digit) {
      // `digit` is used
      if (usedMask >> digit & 1)
        continue;
      // Use `digit` now
      const bool nextIsTight = isTight && (digit == maxDigit);
      if (usedMask == 0 && digit == 0)  // don't count leading 0s as used
        ans += count(s, digitSize - 1, usedMask, nextIsTight);
      else
        ans += count(s, digitSize - 1, usedMask | 1 << digit, nextIsTight);
    }

    return dp[digitSize][usedMask][isTight] = ans;
  }
};"
"class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        maxCandy = max(candies)
        boolResult = []
        
        for candy in candies:
            if candy + extraCandies >= maxCandy:
                boolResult.append(True)
            else:
                boolResult.append(False)
        
        return boolResult","class Solution {
 public:
  bool canThreePartsEqualSum(vector<int>& arr) {
    const int sum = accumulate(begin(arr), end(arr), 0);
    if (sum % 3 != 0)
      return false;

    const int average = sum / 3;
    int partCount = 0;
    int partSum = 0;

    for (const int a : arr) {
      partSum += a;
      if (partSum == average) {
        ++partCount;
        partSum = 0;
      }
    }

    // Edge case: arr = [0, 0, 0, 0] -> partCount = 4.
    return partCount >= 3;
  }
};"
"class Solution:
    def maxDiff(self, num: int) -> int:
        
        num_string = str(num)
        
        def apply_transform( src_char: str, dest_char: str, s: str):
        
            return int( s.replace( src_char, dest_char ) )
        
        # -----------------------------------------------------------
        
        # digit replacement for maximum number
        
        max_num = num
        
        for char in num_string:
            if char < '9':
                max_num = apply_transform( char, '9', num_string ) 
                break
        
        # -----------------------------------------------------------
        
        # digit replacement for minimum number
        
        min_num = num
        
        if num_string[0] > '1':
            # leading digit cannot be zero
            min_num = apply_transform( num_string[0], '1', num_string )
        
        else:
            for char in num_string[1:]:
                if char > '1':
                    min_num = apply_transform( char, '0', num_string )
                    break
        
        return max_num - min_num","class Solution {
 public:
  int maxScoreSightseeingPair(vector<int>& values) {
    int ans = 0;
    int bestPrev = 0;

    for (const int value : values) {
      ans = max(ans, value + bestPrev);
      bestPrev = max(bestPrev, value) - 1;
    }

    return ans;
  }
};"
"class Solution:
    def checkIfCanBreak(self, s1: str, s2: str) -> bool:
        s1, s2 = sorted([char for char in s1]), sorted([char for char in s2])

        return all([s1[i] >= s2[i] for i in range(len(s1))]) or all([s1[i] <= s2[i] for i in range(len(s1))])","class Solution {
 public:
  int smallestRepunitDivByK(int k) {
    if (k % 10 != 1 && k % 10 != 3 && k % 10 != 7 && k % 10 != 9)
      return -1;

    unordered_set<int> seen;
    int n = 0;

    for (int length = 1; length <= k; ++length) {
      n = (n * 10 + 1) % k;
      if (n == 0)
        return length;
      if (seen.count(n))
        return -1;
      seen.insert(n);
    }

    return -1;
  }
};"
"class Solution:
    def numberWays(self, hats: List[List[int]]) -> int:
        N = len(hats) # number of people
        h2p = collections.defaultdict(list) # hat -> people
        for person in range(N):
            for hat in hats[person]:
                h2p[hat].append(person)
                
        if len(h2p) < N: # when the number of hats < the number of people
            return 0
        
		# For each hat, dp stores the status of the people has been matched by a hat.
        # e.g. 0b0000000000 means no one wears a hat
        # 0b0010000000 means only person No.2 wears a hat
        # There are totally 2 ^ N different possible status.
        MASK = [1 << p for p in range(N)]
        dp = [[0] * (2 ** N) for _ in range(len(h2p) + 1)]
        dp[0][0] = 1
        
        i, MOD = 1, 1000000007
        while h2p: # O(H)
            _, people = h2p.popitem()
            for j, n in enumerate(dp[i - 1]): #O(2^P)
                if not n:
                    continue
                
                dp[i][j] += n # when mask = 0
                for p in people: #O(P)
                    if not (MASK[p] &amp; j):
                        dp[i][MASK[p] + j] += n
            i += 1
        
        return dp[-1][-1] % MOD","class Solution {
 public:
  bool queryString(string s, int n) {
    if (n > 1511)
      return false;

    for (int i = n; i > n / 2; --i) {
      string binary = bitset<32>(i).to_string();
      binary = binary.substr(binary.find(""1""));
      if (s.find(binary) == string::npos)
        return false;
    }

    return true;
  }
};"
"class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        source = set([path[1] for path in paths])
        destination = set([path[0] for path in paths])
        destination_city = source.difference(destination)
        return destination_city.pop()","class Solution {
 public:
  string baseNeg2(int n) {
    string ans;

    while (n != 0) {
      ans += to_string(n & 1);
      n = -(n >> 1);
    }

    return ans.empty() ? ""0"" : string{rbegin(ans), rend(ans)};
  }
};"
"class Solution:
    def kLengthApart(self, nums, k: int) -> bool:
        prev = -k - 1
        for i in range(len(nums)):
            if nums[i] == 1:
                if i - prev - 1 < k:
                    return False
                prev = i

        return True","class Solution {
 public:
  vector<bool> prefixesDivBy5(vector<int>& nums) {
    vector<bool> ans;
    int curr = 0;

    for (const int num : nums) {
      curr = (curr * 2 + num) % 5;
      ans.push_back(curr % 5 == 0);
    }

    return ans;
  }
};"
"class Solution:
    # no need of binary search, described below....
	def solve(self, nums, k):

        def valid(n):
            # slide a window length N
            minq = deque()  # stores (val, index)
            maxq = deque()  # descending

            for r, v in enumerate(nums):
                while maxq and maxq[-1][0] < v:
                    # i replace him as a maximum
                    # candidate in the current window
                    maxq.pop()
                while minq and minq[-1][0] > v:
                    # i replace him as a minimum
                    # candidate in the current window
                    minq.pop()
                # now adding self will maintain property
                maxq.append((v, r))
                minq.append((v, r))

                # lazy pop max/min whom no longer in window
                while maxq and maxq[0][1] <= (r - n):
                    maxq.popleft()
                while minq and minq[0][1] <= (r - n):
                    minq.popleft()

                # check if valid ;)
                # print(' ',maxq,minq)
                if r >= (n - 1) and maxq[0][0] - minq[0][0] <= k:
                    return True

            return False

        l, r = 1, len(nums) + 1
        while l < r:
            n = (l + r) // 2
            print(l, r, n)
            if valid(n):
                l = n + 1
            else:
                r = n
        return l - 1","class Solution {
 public:
  vector<int> nextLargerNodes(ListNode* head) {
    vector<int> ans;
    stack<int> stack;

    for (; head; head = head->next) {
      while (!stack.empty() && head->val > ans[stack.top()]) {
        int index = stack.top();
        stack.pop();
        ans[index] = head->val;
      }
      stack.push(ans.size());
      ans.push_back(head->val);
    }

    for (; !stack.empty(); stack.pop())
      ans[stack.top()] = 0;

    return ans;
  }
};"
"class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        row=len(mat)
        col=len(mat[0])
        temp=[i for i in mat[0]]
        for i in range(1,row):
            currSum=[]
            for j in range(col):
                for it in range(len(temp)):
                    currSum.append(temp[it]+mat[i][j])
            currSum.sort()
            temp.clear()
            maxSize=min(k,len(currSum))
            for size in range(maxSize):
                temp.append(currSum[size])
        return temp[k-1]","class Solution {
 public:
  int numEnclaves(vector<vector<int>>& A) {
    const int m = A.size();
    const int n = A[0].size();

    // Remove lands connected to edge
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i * j == 0 || i == m - 1 || j == n - 1)
          if (A[i][j] == 1)
            dfs(A, i, j);

    return accumulate(begin(A), end(A), 0, [](int s, vector<int>& row) {
      return s + accumulate(begin(row), end(row), 0);
    });
  }

 private:
  void dfs(vector<vector<int>>& A, int i, int j) {
    if (i < 0 || i == A.size() || j < 0 || j == A[0].size())
      return;
    if (A[i][j] == 0)
      return;

    A[i][j] = 0;
    dfs(A, i + 1, j);
    dfs(A, i - 1, j);
    dfs(A, i, j + 1);
    dfs(A, i, j - 1);
  };
};"
"class Solution:
    def buildArray(self, t: List[int], n: int) -> List[str]:
        l=[]
        for i in range(1,t[-1]+1):
            l.append(""Push"")
            if i not in t:
                l.append(""Pop"")
            
        return l","class Solution {
 public:
  vector<bool> camelMatch(vector<string>& queries, string pattern) {
    vector<bool> ans;
    for (const string& query : queries)
      ans.push_back(isMatch(query, pattern));
    return ans;
  }

 private:
  bool isMatch(const string& query, const string& pattern) {
    int j = 0;
    for (const char c : query)
      if (j < pattern.length() && c == pattern[j])
        ++j;
      else if (isupper(c))
        return false;
    return j == pattern.length();
  }
};"
"class Solution:
    def countTriplets(self, arr: List[int]) -> int:
        count = 0
        for i in range(len(arr)):
            x = arr[i]
            for k in range(i+1,len(arr)):
                x = x ^ arr[k]
                if x == 0:
                    count = count + (k-i)
        return count","class Solution {
 public:
  int videoStitching(vector<vector<int>>& clips, int time) {
    int ans = 0;
    int end = 0;
    int farthest = 0;

    sort(std::begin(clips), std::end(clips));

    int i = 0;
    while (farthest < time) {
      while (i < clips.size() && clips[i][0] <= end)
        farthest = max(farthest, clips[i++][1]);
      if (end == farthest)
        return -1;
      ++ans;
      end = farthest;
    }

    return ans;
  }
};"
"class Solution:
    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:
        tree = dict()
        for fm, to in edges: tree.setdefault(fm, []).append(to)
            
        def fn(i):
            """"""Returns distance and found flag""""""
            dist, found = 0, hasApple[i]
            for j in tree.get(i, []):
                d, f = fn(j)
                dist += 2+d if f else 0
                found |= f
            return dist, found
        
        return fn(0)[0]","class Solution {
 public:
  bool divisorGame(int n) {
    return n % 2 == 0;
  }
};"
"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        m, n = len(pizza), len(pizza[0])
        
        prefix = [[0]*(n+1) for _ in range(m+1)] # prefix array 
        for i in range(m):
            for j in range(n): 
                prefix[i+1][j+1] = prefix[i][j+1] + prefix[i+1][j] - prefix[i][j]
                if pizza[i][j] == ""A"": prefix[i+1][j+1] += 1
                
        @cache
        def fn(i, j, k):
            """"""Return number of ways of cutting pizza[i:][j:] for k people.""""""
            if i == m or j == n: return 0 # out of pizza 
            apples = prefix[-1][-1] - prefix[-1][j] - prefix[i][-1] + prefix[i][j]
            if apples < k+1: return 0 # not enough apple 
            if k == 0: return 1
            
            ans = 0 
            for ii in range(i, m): 
                if prefix[ii+1][-1] - prefix[ii+1][j] - prefix[i][-1] + prefix[i][j]: 
                    ans += fn(ii+1, j, k-1)
            for jj in range(j, n): 
                if prefix[-1][jj+1] - prefix[-1][j] - prefix[i][jj+1] + prefix[i][j]: 
                    ans += fn(i, jj+1, k-1)
            return ans % 1_000_000_007
        
        return fn(0, 0, k-1)","class Solution {
 public:
  int maxAncestorDiff(TreeNode* root) {
    return maxAncestorDiff(root, root->val, root->val);
  }

 private:
  // Returns |max - min| of the tree w/ root
  int maxAncestorDiff(TreeNode* root, int mini, int maxi) {
    if (root == nullptr)
      return 0;

    mini = min(mini, root->val);
    maxi = max(maxi, root->val);
    const int l = maxAncestorDiff(root->left, mini, maxi);
    const int r = maxAncestorDiff(root->right, mini, maxi);
    return max({maxi - mini, l, r});
  }
};"
"class Solution:
    def maxPower(self, s: str) -> int:
        curr = power = 1
        for i in range(1, len(s)):
            power = max(power, (curr := curr+1 if s[i] == s[i-1] else 1))
        return power","class Solution {
 public:
  int longestArithSeqLength(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    // dp[i][k] := length of the longest arithmetic subseq ofnums
    // nums[0..i] with k = diff + 500
    vector<vector<int>> dp(n, vector<int>(1001));

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < i; ++j) {
        const int k = nums[i] - nums[j] + 500;
        dp[i][k] = max(2, dp[j][k] + 1);
        ans = max(ans, dp[i][k]);
      }

    return ans;
  }
};"
"class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
                
        result, seen = [], set()
                
        for num in range(1, n+1):
            for denom in range(num+1, n+1):                
                if (num/denom) not in seen:
                    seen.add(num/denom)
                    result += [f""{num}/{denom}""]
                    
        return result","class Solution {
 public:
  TreeNode* recoverFromPreorder(string traversal) {
    int i = 0;
    return recoverFromPreorder(traversal, 0, i);
  }

 private:
  TreeNode* recoverFromPreorder(const string& traversal, int depth, int& i) {
    int nDashes = 0;
    while (i + nDashes < traversal.length() && traversal[i + nDashes] == '-')
      ++nDashes;
    if (nDashes != depth)
      return nullptr;

    i += depth;
    const int start = i;
    while (i < traversal.length() && isdigit(traversal[i]))
      ++i;

    return new TreeNode(stoi(traversal.substr(start, i - start)),
                        recoverFromPreorder(traversal, depth + 1, i),
                        recoverFromPreorder(traversal, depth + 1, i));
  }
};"
"class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        
        def dfs(node,maxval):
            if not node:
                return 0
            
            
            res = 1 if node.val>=maxval else 0
            maxval = max(node.val, maxval)
            res+= dfs(node.left,maxval)
            res+=dfs(node.right, maxval)
            return res
        return dfs(root, root.val)","class Solution {
 public:
  int twoCitySchedCost(vector<vector<int>>& costs) {
    const int n = costs.size() / 2;
    int ans = 0;

    // How much money can we save if we fly a person to A instead of B?
    // To save money, we should
    //   1) fly the person with the max saving to A
    //   2) fly the person with the min saving to B
    sort(begin(costs), end(costs), [](const auto& a, const auto& b) {
      // Sort in descending order by the money saved
      // If we fly a person to A instead of B
      return a[1] - a[0] > b[1] - b[0];
    });

    for (int i = 0; i < n; ++i)
      ans += costs[i][0] + costs[i + n][1];

    return ans;
  }
};"
"class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        
        @cache
        def fn(x): 
            """"""Return max integer given target x.""""""
            if x == 0: return 0
            if x < 0: return -inf 
            return max(fn(x - c) * 10 + i + 1 for i, c in enumerate(cost))
        
        return str(max(0, fn(target)))","class Solution {
 public:
  int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {
    return max(helper(nums, firstLen, secondLen),
               helper(nums, secondLen, firstLen));
  }

 private:
  int helper(vector<int>& A, int l, int r) {
    const int n = A.size();
    vector<int> left(n);
    int sum = 0;

    for (int i = 0; i < n; ++i) {
      sum += A[i];
      if (i >= l)
        sum -= A[i - l];
      if (i >= l - 1)
        left[i] = i > 0 ? max(left[i - 1], sum) : sum;
    }

    vector<int> right(n);
    sum = 0;

    for (int i = n - 1; i >= 0; --i) {
      sum += A[i];
      if (i <= n - r - 1)
        sum -= A[i + r];
      if (i <= n - r)
        right[i] = i < n - 1 ? max(right[i + 1], sum) : sum;
    }

    int ans = 0;

    for (int i = 0; i < n - 1; ++i)
      ans = max(ans, left[i] + right[i + 1]);

    return ans;
  }
};"
"class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        
		# make a pair with start-time and end-time
        homework_interval = zip(startTime, endTime)
        
		# compute the number of busy students by condition judgement
        return sum( ( start <= queryTime <= end ) for start, end in homework_interval )","class Solution {
 public:
  vector<int> numMovesStones(int a, int b, int c) {
    vector<int> nums = {a, b, c};

    sort(begin(nums), end(nums));

    if (nums[2] - nums[0] == 2)
      return {0, 0};
    return {min(nums[1] - nums[0], nums[2] - nums[1]) <= 2 ? 1 : 2,
            nums[2] - nums[0] - 2};
  }
};"
"class Solution:
    def arrangeWords(self, text: str) -> str:
        return "" "".join(sorted(str(text[0].lower()+text[1:]).split(),key=len)).capitalize()","class Solution {
 public:
  vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0,
                                  int color) {
    dfs(grid, r0, c0, grid[r0][c0]);

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] < 0)
          grid[i][j] = color;

    return grid;
  }

 private:
  void dfs(vector<vector<int>>& grid, int i, int j, int startColor) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] != startColor)
      return;

    grid[i][j] = -startColor;  // Mark
    dfs(grid, i + 1, j, startColor);
    dfs(grid, i - 1, j, startColor);
    dfs(grid, i, j + 1, startColor);
    dfs(grid, i, j - 1, startColor);

    // If this cell already on the boarder, it must be painted later
    if (i == 0 || i == grid.size() - 1 || j == 0 || j == grid[0].size() - 1)
      return;

    if (abs(grid[i + 1][j]) == startColor &&  //
        abs(grid[i - 1][j]) == startColor &&  //
        abs(grid[i][j + 1]) == startColor &&  //
        abs(grid[i][j - 1]) == startColor)
      grid[i][j] = startColor;
  }
};"
"class Solution:
    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:
        
        # convert to list of sets
        favoriteCompanies = [set(ele) for idx, ele in enumerate(favoriteCompanies)]
        
        # go through all subsets
        result = []
        for index, companies in enumerate(favoriteCompanies):
            
            # a bool whether we will add this set
            add_to_list = True
            
            for other_index, other_companies in enumerate(favoriteCompanies):
                
                # check whether we look at the same set
                if index == other_index:
                    continue
                
                # if we are subset we set add_to_list to false and break
                if companies.issubset(other_companies):
                    add_to_list = False
                    break
                
            # add if we want to
            if add_to_list:
                result.append(index)
                
        return result","class Solution {
 public:
  int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
    const int m = nums1.size();
    const int n = nums2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        dp[i][j] = nums1[i - 1] == nums2[j - 1]
                       ? dp[i - 1][j - 1] + 1
                       : max(dp[i - 1][j], dp[i][j - 1]);

    return dp[m][n];
  }
};"
"class Solution:
    def numPoints(self, points: List[List[int]], r: int) -> int:
        
        def getPointsInside(i, r, n):
            # This vector stores alpha and beta and flag
            # is marked true for alpha and false for beta
            angles = []

            for j in range(n):
                
                if i != j and distance[i][j] <= 2 * r:
                    # acos returns the arc cosine of the complex
                    # used for cosine inverse
                    B = math.acos(distance[i][j] / (2 * r))

                    # arg returns the phase angle of the complex
                    x1, y1 = points[i]
                    x2, y2 = points[j]
                    
                    A = math.atan2(y1 - y2, x1 - x2)
                    
                    alpha = A - B
                    
                    beta = A + B
                    
                    angles.append((alpha, False))
                    
                    angles.append((beta, True))

            # angles vector is sorted and traversed
            angles.sort()
            # count maintains the number of points inside
            # the circle at certain value of theta
            # res maintains the maximum of all count
            cnt, res = 1, 1
            for angle in angles:
                # entry angle
                if angle[1] == False: 
                    cnt += 1
                # exit angle
                else: 
                    cnt -= 1

                res = max(cnt, res)

            return res

        # Returns count of maximum points that can lie
        # in a circle of radius r.
        #a dis array stores the distance between every
        # pair of points
        n = len(points)
        max_pts = n
        distance = [[0 for _ in range(max_pts)] for _ in range(max_pts)]
        for i in range(n - 1):
            for j in range(i + 1, n):
                # abs gives the magnitude of the complex
                # number and hence the distance between
                # i and j
                x1, y1 = points[i]
                x2, y2 = points[j]
                distance[i][j] = distance[j][i] = sqrt((x1 - x2)**2 + (y1 - y2)**2)

        # This loop picks a point p
        ans = 0
        # maximum number of points for point arr[i]
        for i in range(n):
            ans = max(ans, getPointsInside(i, r, n))

        return ans","class Solution {
 public:
  bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source,
                        vector<int>& target) {
    unordered_set<long> blockedSet;
    for (const vector<int>& b : blocked)
      blockedSet.insert(hash(b[0], b[1]));

    return dfs(blockedSet, source[0], source[1], hash(target[0], target[1]),
               {}) &&
           dfs(blockedSet, target[0], target[1], hash(source[0], source[1]),
               {});
  }

 private:
  bool dfs(unordered_set<long>& blockedSet, int i, int j, long target,
           unordered_set<long>&& visited) {
    if (i < 0 || i >= 1e6 || j < 0 || j >= 1e6 ||
        blockedSet.count(hash(i, j)) || visited.count(hash(i, j)))
      return false;

    visited.insert(hash(i, j));
    if (visited.size() > (1 + 199) * 199 / 2 || hash(i, j) == target)
      return true;
    return dfs(blockedSet, i + 1, j, target, move(visited)) ||
           dfs(blockedSet, i - 1, j, target, move(visited)) ||
           dfs(blockedSet, i, j + 1, target, move(visited)) ||
           dfs(blockedSet, i, j - 1, target, move(visited));
  }

  long hash(int i, int j) {
    return (static_cast<long>(i) << 16) + j;
  }
};"
"class Solution:
    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
        for i, word in enumerate(sentence.split()):
            if word.startswith(searchWord): return i+1
        return -1","class Solution {
 public:
  bool isBoomerang(vector<vector<int>>& points) {
    return (points[1][0] - points[0][0]) * (points[2][1] - points[1][1]) !=
           (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]);
  }
};"
"class Solution:
    def maxVowels1(self, s: str, k: int) -> int:
        vowel = {'a','e','i','o','u'}
        maxVowels = 0
        for all_windows in range(len(s) - k+1):
            currentVowels = 0
            for letter in s[all_windows:all_windows + k]:
                if vowel.intersection({letter}):
                    currentVowels+=1
            if currentVowels > maxVowels:
                maxVowels= currentVowels
        return maxVowels","class Solution {
 public:
  TreeNode* bstToGst(TreeNode* root) {
    int prefix = 0;

    function<void(TreeNode*)> reversedInorder = [&](TreeNode* root) {
      if (root == nullptr)
        return;

      reversedInorder(root->right);

      root->val += prefix;
      prefix = root->val;

      reversedInorder(root->left);
    };

    reversedInorder(root);
    return root;
  }
};"
"class Solution:
    def pseudoPalindromicPaths (self, root: TreeNode) -> int:
        def dfs(root: TreeNode, bitmap: int) -> int:
            if not root:
                return 0
            bitmap ^= 1 << root.val
            if not root.left and not root.right:
                return int(bitmap &amp; (bitmap - 1) == 0)
            return dfs(root.left, bitmap) + dfs(root.right, bitmap)
        return dfs(root, 0)","class Solution {
 public:
  int minScoreTriangulation(vector<int>& values) {
    const int n = values.size();
    vector<vector<int>> dp(n, vector<int>(n));

    for (int j = 2; j < n; ++j)
      for (int i = j - 2; i >= 0; --i) {
        dp[i][j] = INT_MAX;
        for (int k = i + 1; k < j; ++k)
          dp[i][j] =
              min(dp[i][j],
                  dp[i][k] + values[i] * values[k] * values[j] + dp[k][j]);
      }

    return dp[0][n - 1];
  }
};"
"class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        
        @cache
        def fn(i, j): 
            """"""Return max dot product of nums1[i:] and nums2[j:].""""""
            if i == len(nums1) or j == len(nums2): return -inf
            return max(nums1[i]*nums2[j] + fn(i+1, j+1), nums1[i]*nums2[j], fn(i+1, j), fn(i, j+1))
        
        return fn(0, 0)","class Solution {
 public:
  vector<int> numMovesStonesII(vector<int>& stones) {
    const int n = stones.size();
    int minMoves = n;

    sort(begin(stones), end(stones));

    for (int l = 0, r = 0; r < n; ++r) {
      while (stones[r] - stones[l] + 1 > n)
        ++l;
      int alreadyStored = r - l + 1;
      if (alreadyStored == n - 1 && stones[r] - stones[l] + 1 == n - 1)
        minMoves = min(minMoves, 2);
      else
        minMoves = min(minMoves, n - alreadyStored);
    }

    return {minMoves, max(stones[n - 1] - stones[1] - n + 2,
                          stones[n - 2] - stones[0] - n + 2)};
  }
};"
"class Solution:
    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:
        return Counter(target)==Counter(arr)","class Solution {
 public:
  bool isRobotBounded(string instructions) {
    int x = 0;
    int y = 0;
    int d = 0;
    vector<vector<int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    for (char instruction : instructions) {
      if (instruction == 'G') {
        x += directions[d][0];
        y += directions[d][1];
      } else if (instruction == 'L')
        d = (d + 3) % 4;
      else
        d = (d + 1) % 4;
    }

    return x == 0 && y == 0 || d > 0;
  }
};"
"class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        return all(bin(i)[2:].zfill(k) in s for i in range(2**k))","class Solution {
 public:
  vector<int> gardenNoAdj(int n, vector<vector<int>>& paths) {
    vector<int> ans(n);  // ans[i] := 1, 2, 3, or 4
    vector<vector<int>> graph(n);

    for (const vector<int>& p : paths) {
      const int u = p[0] - 1;
      const int v = p[1] - 1;
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    for (int i = 0; i < n; ++i) {
      vector<bool> used(5);
      for (const int v : graph[i])
        used[ans[v]] = true;
      for (int type = 1; type < 5; ++type)
        if (!used[type]) {
          ans[i] = type;
          break;
        }
    }

    return ans;
  }
};"
"class Solution:
    def checkIfPrerequisite(self, n: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        
        def bfs(root, dest):
            
            stack = deque([root])
            seen = set()
            
            while stack:
                
                item = stack.popleft()
                if item == dest:
                    return True
                for child in graph[item]:
                    
                    if child not in seen:
                        seen.add(child)
                        stack.append(child)
            return False
        
        graph = {i: [] for i in range(n)}
        for a, b in prerequisites:
            graph[a].append(b)
         
        res = []
        for a, b in queries:
            
            res.append(bfs(a, b))
        return res","class Solution {
 public:
  int maxSumAfterPartitioning(vector<int>& arr, int k) {
    const int n = arr.size();
    vector<int> dp(n + 1);

    for (int i = 1; i <= n; ++i) {
      int mini = INT_MIN;
      for (int j = 1; j <= min(i, k); ++j) {
        min = max(min, arr[i - j]);
        dp[i] = max(dp[i], dp[i - j] + mini * j);
      }
    }

    return dp[n];
  }
};"
"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        n = len(grid)
        m = len(grid[0])
        
        
        @cache
        def dfs(row1, col1, row2, col2, n, m):
			
            if (col1 >= m or col1 < 0) or (col2 >= m or col2 < 0) or row1 >= n or row2 >= n: return -math.inf
            
            temp = grid[row1][col1] if row1 == row2 and col1 == col2 else grid[row1][col1] + grid[row2][col2]
            
			# if reached the bottom of the grid then return the temp value
            if row1 == n-1 and row2 == n-1: return temp

            return temp + max(dfs(row1+1, a, row2+1, b, n, m)
                             for a in [col1-1, col1, col1+1]
                             for b in [col2-1, col2, col2+1])

        # one starting point is (0,0) and other is (0,m-1)
        return dfs(0, 0, 0, m-1, n, m)","class Solution {
 public:
  string longestDupSubstring(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    vector<int> pows(n, 1);
    int bestStart = -1;
    int l = 1;
    int r = n;

    for (int i = 1; i < n; ++i)
      pows[i] = (pows[i - 1] * 26L) % kMod;

    while (l < r) {
      const int m = (l + r) / 2;
      const int start = getStart(s, m, pows, kMod);
      if (start == -1) {
        r = m;
      } else {
        bestStart = start;
        l = m + 1;
      }
    }

    if (bestStart == -1)
      return """";
    if (getStart(s, l, pows, kMod) == -1)
      return s.substr(bestStart, l - 1);
    return s.substr(bestStart, l);
  }

 private:
  // k := length of hashed substring
  int getStart(const string& s, int k, const vector<int>& pows,
               const int& kMod) {
    unordered_map<int, vector<int>> hashedToStarts;
    long long h = 0;

    // Compute hash value of s[:k].
    for (int i = 0; i < k; ++i)
      h = ((h * 26) % kMod + val(s[i])) % kMod;
    hashedToStarts[h].push_back(0);

    // Compute rolling hash by Rabin Karp.
    for (int i = k; i < s.length(); ++i) {
      const int startIndex = i - k + 1;
      h = ((h - static_cast<long long>(pows[k - 1]) * val(s[i - k])) % kMod +
           kMod) %
          kMod;
      h = (h * 26 + val(s[i])) % kMod;
      if (const auto it = hashedToStarts.find(h); it != cend(hashedToStarts)) {
        const string currSub = s.substr(startIndex, k);
        for (const int start : it->second)
          if (s.substr(start, k) == currSub)
            return startIndex;
      }
      hashedToStarts[h].push_back(startIndex);
    }

    return -1;
  }

  constexpr int val(char c) {
    return c - 'a';
  }
};"
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        nums.sort()
        return (nums[len(nums)-1] - 1)*(nums[len(nums)-2] - 1)","class Solution {
 public:
  string removeDuplicates(const string& S) {
    string ans;

    for (const char c : S)
      if (!ans.empty() && ans.back() == c)
        ans.pop_back();
      else
        ans.push_back(c);

    return ans;
  }
};"
"class Solution:
    def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:
        horizontalCuts.sort()
        verticalCuts.sort()
        
        maxHorizontalArea = max(horizontalCuts[0], h - horizontalCuts[-1])
        maxVerticalArea = max(verticalCuts[0], w - verticalCuts[-1])
        
        for i in range(0, len(horizontalCuts) - 1):
            maxHorizontalArea = max(maxHorizontalArea, horizontalCuts[i + 1] - horizontalCuts[i])
            
        for i in range(0, len(verticalCuts) - 1):
            maxVerticalArea = max(maxVerticalArea, verticalCuts[i + 1] - verticalCuts[i])
        
        return (maxHorizontalArea * maxVerticalArea) % int(1e9 + 7)","class Solution {
 public:
  int longestStrChain(vector<string>& words) {
    const unordered_set<string> wordsSet{begin(words), end(words)};
    int ans = 0;

    for (const string& word : words)
      ans = max(ans, longestStrChain(word, wordsSet));

    return ans;
  }

 private:
  // dp[s] := longest string chain where s is the last word
  unordered_map<string, int> dp;

  int longestStrChain(const string& s, const unordered_set<string>& wordsSet) {
    if (const auto it = dp.find(s); it != cend(dp))
      return it->second;

    int ans = 1;

    for (int i = 0; i < s.length(); ++i) {
      const string pred = s.substr(0, i) + s.substr(i + 1);
      if (wordsSet.count(pred))
        ans = max(ans, longestStrChain(pred, wordsSet) + 1);
    }

    return dp[s] = ans;
  }
};"
"class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        visited = set()
        inDegree = collections.defaultdict(list)
        outDegree = collections.defaultdict(set)
        for con in connections:
            outDegree[con[0]].add(con[1])
            inDegree[con[1]].append(con[0])
        cnt = 0
        stack = [0]
        while stack:
            city = stack.pop()
            if city in visited:
                continue
            visited.add(city)
            stack.extend(inDegree[city])
            for c in outDegree[city]:
                if c not in visited:
                    cnt += 1
                    stack.append(c)
        return cnt","class Solution {
 public:
  int lastStoneWeightII(vector<int>& stones) {
    const int sum = accumulate(begin(stones), end(stones), 0);
    vector<bool> dp(sum + 1);
    dp[0] = true;
    int s = 0;

    for (int stone : stones)
      for (int w = sum / 2; w > 0; --w) {
        if (w >= stone)
          dp[w] = dp[w] || dp[w - stone];
        if (dp[w])
          s = max(s, w);
      }

    return sum - 2 * s;
  }
};"
"class Solution:
    def getProbability(self, balls: List[int]) -> float:
        n = sum(balls)//2
        
        @cache 
        def fn(i, s0, s1, c0, c1):
            """"""Return number of ways to distribute boxes successfully (w/o considering relative order).""""""
            if s0 > n or s1 > n: return 0 # impossible 
            if i == len(balls): return int(c0 == c1)
            ans = 0 
            for x in range(balls[i]+1): 
                ans += fn(i+1, s0+x, s1+balls[i]-x, c0+(x > 0), c1+(x < balls[i])) * comb(balls[i], x)
            return ans
        
        return fn(0, 0, 0, 0, 0) / comb(2*n, n)","class Solution {
 public:
  int heightChecker(vector<int>& heights) {
    int ans = 0;
    int currentHeight = 1;
    vector<int> count(101);

    for (int height : heights)
      ++count[height];

    for (int height : heights) {
      while (count[currentHeight] == 0)
        ++currentHeight;
      if (height != currentHeight)
        ++ans;
      --count[currentHeight];
    }

    return ans;
  }
};"
"class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        '''Time complexity: Olog(n as specified in the arg), Space complexity: O(1)'''
        
        # To manage space, we can work on the same variable (i.e. modifying in place)
        # We can iterate n times, while popping the last element and inserting in its right position in the same list
        
        for i in range(n, 0, -1):
            nums.insert(i, nums.pop())
            
        return nums","class Solution {
 public:
  int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {
    int satisfied = 0;
    int madeSatisfied = 0;
    int windowSatisfied = 0;

    for (int i = 0; i < customers.size(); ++i) {
      if (grumpy[i] == 0)
        satisfied += customers[i];
      else
        windowSatisfied += customers[i];
      if (i >= X && grumpy[i - X] == 1)
        windowSatisfied -= customers[i - X];
      madeSatisfied = max(madeSatisfied, windowSatisfied);
    }

    return satisfied + madeSatisfied;
  }
};"
"class Solution:
    def getStrongest(self, arr: List[int], k: int) -> List[int]:
        n = len(arr)
        
        if n == 1:
            return arr[:k]
        elif n == k:
            return arr
        
        arr.sort()
        m = arr[(n-1)//2]
        
        res = []
        i, j = 0, n-1
        while i < j:
            if abs(arr[i]-m) > abs(arr[j]-m):
                res.append(arr[i])
                i += 1
            elif abs(arr[i]-m) < abs(arr[j]-m):
                res.append(arr[j])
                j -= 1
            else: # abs(arr[i]-m) == abs(arr[j]-m)
                if arr[i] > arr[j]:
                    res.append(arr[i])
                    i += 1
                elif arr[i] < arr[j]:
                    res.append(arr[j])
                    j -= 1
                else:
                    res.append(arr[i])
                    i += 1
            if len(res) == k:
                return res","class Solution {
 public:
  vector<int> prevPermOpt1(vector<int>& arr) {
    const int n = arr.size();
    int l = n - 2;
    int r = n - 1;

    while (l >= 0 && arr[l] <= arr[l + 1])
      l--;
    if (l < 0)
      return arr;
    while (arr[r] >= arr[l] || arr[r] == arr[r - 1])
      r--;
    swap(arr[l], arr[r]);

    return arr;
  }
};"
"class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
    
        # check how many neighbors in initial state
        neighbor = 0
        prev = 0
        for house in houses:
            if house and house != prev:
                prev = house
                neighbor += 1
            
        if neighbor > target: return -1
        
        
        # dp[# index][# color][# neighbor]
        dp = [[[inf] * (target+1) for _ in range(n)] for _ in range(m)]
        if not houses[0]:
            for color in range(n):
                dp[0][color][1] = cost[0][color]
        else:
            dp[0][houses[0]-1][1] = 0
        
        for i in range(1, m):
            for color in range(n):
                for neighbor in range(1, target+1):
                    # i-th house is not painted yet
                    if not houses[i]:
                        # same color with i-1
                        dp[i][color][neighbor] = dp[i-1][color][neighbor] + cost[i][color]
                        # different color with i-1
                        for diff_color in range(n):
                            if color != diff_color:
                                dp[i][color][neighbor] = min(dp[i][color][neighbor], dp[i-1][diff_color][neighbor-1] + cost[i][color])
                    # i-th house is already painted
                    else:
                        if color+1 == houses[i]:
                            dp[i][color][neighbor] = dp[i-1][color][neighbor]
                            for diff_color in range(n):
                                if color != diff_color:
                                    dp[i][color][neighbor] = min(dp[i][color][neighbor], dp[i-1][diff_color][neighbor-1])
                        else:
                            dp[i][color][neighbor] = inf
                                          
        minCost = inf
        for j in range(n):
            minCost = min(minCost, dp[-1][j][target])
        return minCost if minCost != inf else -1","class Solution {
 public:
  vector<int> rearrangeBarcodes(vector<int>& barcodes) {
    vector<int> ans(barcodes.size());
    vector<int> count(10001);
    int i = 0;  // ans' index

    for (const int b : barcodes)
      ++count[b];

    const auto maxIt = max_element(begin(count), end(count));
    const int maxNum = maxIt - begin(count);

    auto fillAns = [&](int num) {
      while (count[num]-- > 0) {
        ans[i] = num;
        i = i + 2 < barcodes.size() ? i + 2 : 1;
      }
    };

    fillAns(maxNum);
    for (int num = 1; num < 10001; ++num)
      fillAns(num);

    return ans;
  }
};"
"class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
#         each number in the array is a price
#         there is a discount where you will get that i term discounted by the next item in the array that is less than or equal to the current item's price

# you ONLY need to look ahead of i, never before. AND you stop when you've reached that discount amount

        finalSale = []
        
        for i in range(0, len(prices)):
            currentPrice = prices[i]
            discountAmount = 0
            for j in range(i + 1, len(prices)):
                possibleDiscount = prices[j]
                if possibleDiscount <= currentPrice:
                    currentPrice = currentPrice - possibleDiscount
                    break
            finalSale.append(currentPrice)
                    
        return finalSale","class Solution {
 public:
  int shortestWay(string source, string target) {
    int ans = 0;

    for (int i = 0; i < target.length();) {
      const int prevIndex = i;
      for (int j = 0; j < source.length(); ++j)
        if (i < target.length() && source[j] == target[i])
          ++i;
      // All chars in source didn't match target[i]
      if (i == prevIndex)
        return -1;
      ++ans;
    }

    return ans;
  }
};"
"class Solution:
    def minSumOfLengths(self, arr: List[int], target: int) -> int:
        complements = {0: -1}
        cum_sum = 0
        intervals = []
        for i, el in enumerate(arr):
            cum_sum += el
            if cum_sum - target in complements:
                intervals.append((complements[cum_sum - target] + 1, i))
            complements[cum_sum] = i 

        if len(intervals) < 2:
            return -1

        intervals.sort(key=lambda x: x[1] - x[0])
        non_overlap_intervals = filter_non_overlap(intervals)

        if not non_overlap_intervals:
            return -1

        return sum(interval[1] - interval[0] + 1 for interval in non_overlap_intervals)


def filter_non_overlap(intervals):
    for i in range(len(intervals)):
        for j in range(i + 1, len(intervals)):
            if not (intervals[i][0] <= intervals[j][1] and intervals[j][0] <= intervals[i][1]):
                return intervals[i], intervals[j]","class Solution {
 public:
  vector<int> assignBikes(vector<vector<int>>& workers,
                          vector<vector<int>>& bikes) {
    const int n = workers.size();
    const int m = bikes.size();
    vector<int> ans(n, -1);
    vector<bool> usedBikes(m);
    // buckets[k] := (i, j), where k = dist(workers[i], bikes[j])
    vector<vector<pair<int, int>>> buckets(2001);

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < m; ++j)
        buckets[dist(workers[i], bikes[j])].emplace_back(i, j);

    for (int k = 0; k < 2001; ++k)
      for (const auto& [i, j] : buckets[k])
        if (ans[i] == -1 && !usedBikes[j]) {
          ans[i] = j;
          usedBikes[j] = true;
        }

    return ans;
  }

 private:
  int dist(const vector<int>& p1, const vector<int>& p2) {
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]);
  }
};"
"class Solution:
    def minDistance(self, houses: List[int], k: int) -> int:
        houses.sort()
        len_houses = len(houses)
        if k == len_houses:
            return 0
        cost = {**{(i,i): 0 for i in range(len_houses)},
                **{(i,i+1):houses[i+1] - houses[i]  for i in range(len_houses - 1)}}
        for i in range(len_houses):
            for r in range(1,min(i+1,len_houses-i)):
                cost[i-r,i+r] = cost[i-r+1,i+r-1] + houses[i+r] - houses[i-r]
                if i+r + 1 < len_houses:
                    cost[i-r,i+r+1] = cost[i-r+1,i+r] + houses[i+r+1] - houses[i-r]
        dp = {(j,1):cost[0,j] for j in range(len_houses)} # dp(i,k) is total cost of using k mail boxes for first i houses
        for box in range(2, k + 1):
            for j in range(box - 1, len_houses):
                dp[j,box] = min(dp[i,box-1] + cost[i+1,j] for i in range(box - 2, j))
        return dp[len_houses - 1, k]","class Solution {
 public:
  string minimizeError(vector<string>& prices, int target) {
    // A[i] := (costCeil - costFloor, costCeil, costFloor)
    // The lower the costCeil - costFloor, the cheaper to ceil it
    vector<tuple<double, double, double>> A;
    int sumFloored = 0;
    int sumCeiled = 0;

    for (const string& p : prices) {
      const double price = stod(p);
      const int floored = floor(price);
      const int ceiled = ceil(price);
      sumFloored += floored;
      sumCeiled += ceiled;
      const double costFloor = price - static_cast<double>(floored);
      const double costCeil = static_cast<double>(ceiled) - price;
      A.emplace_back(costCeil - costFloor, costCeil, costFloor);
    }

    if (sumFloored > target || sumCeiled < target)
      return ""-1"";

    sort(begin(A), end(A));

    double sumError = 0.0;
    const int nCeiled = target - sumFloored;
    for (int i = 0; i < nCeiled; ++i)
      sumError += get<1>(A[i]);
    for (int i = nCeiled; i < A.size(); ++i)
      sumError += get<2>(A[i]);

    stringstream ss;
    ss << std::fixed << std::setprecision(3) << sumError;
    return ss.str();
  }
};"
"class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        runningSum = [nums[0]]
        for i in range(1, len(nums)):
            currentSum = 0
            for j in range(i+1):
                currentSum += nums[j]
            runningSum.append(currentSum)
        return runningSum","enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  bool leadsToDestination(int n, vector<vector<int>>& edges, int source,
                          int destination) {
    vector<vector<int>> graph(n);
    vector<State> state(n);

    for (const vector<int>& edge : edges)
      graph[e[0]].push_back(e[1]);

    return acyclic(graph, source, destination, state);
  }

 private:
  bool acyclic(const vector<vector<int>>& graph, int u, int dest,
               vector<State>& state) {
    if (graph[u].empty())
      return u == dest;
    if (state[u] == State::kVisiting)
      return false;
    if (state[u] == State::kVisited)
      return true;

    state[u] = State::kVisiting;
    for (const int v : graph[u])
      if (!acyclic(graph, v, dest, state))
        return false;
    state[u] = State::kVisited;

    return true;
  }
};"
"class Solution:
    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:
        most_common = Counter(arr).most_common()
        for i in range(len(most_common) - 1, -1, -1):
            if k >= most_common[i][1]:
                k -= most_common[i][1]
            else:
                return i + 1
            
        return 0","class Solution {
 public:
  int missingElement(vector<int>& nums, int k) {
    int l = 0;
    int r = nums.size();

    // # of missing numbers in [nums[0], nums[i]]
    auto nMissing = [&](int i) { return nums[i] - nums[0] - i; };

    // Find the first index l s.t. nMissing(l) >= k
    while (l < r) {
      const int m = (l + r) / 2;
      if (nMissing(m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return nums[l - 1] + (k - nMissing(l - 1));
  }
};"
"class Solution:
    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
        if len(bloomDay) < m*k:
            return -1
        
        l = 1
        r = max(bloomDay)
        
        while l < r:
            mid = l + (r-l) // 2
            if self.condition(mid,bloomDay,k,m):
                r = mid
            else:
                l = mid+1
        return l
        
        
        
    def condition(self,n,nums,k,m):
        bouquets = 0
        flowers = 0
        for flower in nums:
            if flower <= n:
                bouquets += (flowers + 1) // k
                flowers = (flowers + 1) % k    
            else:
                flowers = 0
                
        return bouquets >= m","class UnionFind {
 public:
  UnionFind(int n) : id(n) {
    iota(begin(id), end(id), 0);
  }

  void union_(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i > j)
      id[i] = j;
    else
      id[j] = i;
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
};

class Solution {
 public:
  string smallestEquivalentString(string s1, string s2, string baseStr) {
    string ans;
    UnionFind uf(26);

    for (int i = 0; i < s1.length(); ++i)
      uf.union_(s1[i] - 'a', s2[i] - 'a');

    for (const char c : baseStr)
      ans += 'a' + uf.find(c - 'a');

    return ans;
  }
};"
"class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        k = 0
        for x in range(start, start+(2*n),2):
            k ^= x
        
        return k","class Solution {
 public:
  int longestRepeatingSubstring(string s) {
    const int n = s.length();
    int ans = 0;
    // dp[i][j] := # of repeating chars of s[0..i) and s[0..j)
    vector<vector<int>> dp(n + 1, vector<int>(n + 1));

    for (int i = 1; i <= n; ++i)
      for (int j = i + 1; j <= n; ++j)
        if (s[i - 1] == s[j - 1]) {
          dp[i][j] = 1 + dp[i - 1][j - 1];
          ans = max(ans, dp[i][j]);
        }

    return ans;
  }
};"
"class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        d, res = {}, []
        for name in names:
            if name in d:
                orig_name = name
                # get the smallest positive key
                key = d[name]
                while(name in d):
                    name = orig_name + ""({})"".format(key)
                    key += 1
                d[name] = 1
				# memoization done so as to get the latest version of this next time
                d[orig_name] = key
            else:
                d[name] = 1
            res.append(name)
        return res","class Solution {
 public:
  int validSubarrays(vector<int>& nums) {
    // For each num in nums, each element x in the stack can be the leftmost
    // element s.t. [x, num] forms a valid subarray, so the stack.size() is
    // the # of valid subarrays ending at curr num.
    //
    // E.g. nums = [1, 3, 2]
    // num = 1, stack = [1] -> valid subarray is [1]
    // num = 3, stack = [1, 3] -> valid subarrays are [1, 3], [3]
    // num = 2, stack = [1, 2] -> valid subarrays are [1, 3, 2], [2]
    int ans = 0;
    stack<int> stack;

    for (const int num : nums) {
      while (!stack.empty() && stack.top() > num)
        stack.pop();
      stack.push(num);
      ans += stack.size();
    }

    return ans;
  }
};"
"class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        days = dict() #days of raining for a given lake 
        for d, lake in enumerate(rains): 
            if lake: days.setdefault(lake, deque()).append(d)
            
        ans, hp = [], [] #min-heap 
        full = set() #full lakes
        for d, lake in enumerate(rains): 
            if lake: 
                if lake in full: return []
                full.add(lake)
                days[lake].popleft()
                if days[lake]: heappush(hp, (days[lake][0], lake))
                ans.append(-1)
            else: 
                if hp: 
                    _, lake = heappop(hp)
                    full.remove(lake)
                    ans.append(lake)
                else: 
                    ans.append(1)
        return ans","class Solution {
 public:
  int assignBikes(vector<vector<int>>& workers, vector<vector<int>>& bikes) {
    // dp[i] := min dist to assign bikes j (bitmask)
    dp.resize(1 << bikes.size());
    return assignBikes(workers, bikes, 0, 0);
  }

 private:
  vector<int> dp;

  int assignBikes(const vector<vector<int>>& workers,
                  const vector<vector<int>>& bikes, int s, int bikeUsed) {
    if (s == workers.size())
      return 0;
    if (dp[bikeUsed])
      return dp[bikeUsed];

    int ans = INT_MAX;

    for (int i = 0; i < bikes.size(); ++i) {
      if (bikeUsed >> i & 1)
        continue;
      ans = min(ans, dist(workers[s], bikes[i]) +
                         assignBikes(workers, bikes, s + 1, bikeUsed | 1 << i));
    }

    return dp[bikeUsed] = ans;
  }

  int dist(const vector<int>& p1, const vector<int>& p2) {
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]);
  }
};"
"class Solution:
    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        graph = dict()
        for u, v, w in edges: 
            graph.setdefault(u, []).append((v, w))
            graph.setdefault(v, []).append((u, w))
            
        ref = self.mst(n, graph)
        critical, pseudo = [], []
        for i in range(len(edges)):
            if self.mst(n, graph, exclude=edges[i][:2]) > ref: critical.append(i)
            elif self.mst(n, graph, init=edges[i]) == ref: pseudo.append(i)
        return [critical, pseudo]
            
        
    def mst(self, n, graph, init=None, exclude=None):
        """"""Return weight of MST of given graph using Prim's algo""""""

        def visit(u): 
            """"""Mark node and put its edges to priority queue""""""
            marked[u] = True
            for v, w in graph.get(u, []):
                if exclude and u in exclude and v in exclude: continue
                if not marked[v]: heappush(pq, (w, u, v))
                    
        ans = 0
        marked = [False]*n
        pq = [] #min prioirty queue
        
        if init: 
            u, v, w = init
            ans += w
            marked[u] = marked[v] = True
            visit(u) or visit(v)
        else:
            visit(0)

        while pq: 
            w, u, v = heappop(pq)
            if marked[u] and marked[v]: continue
            ans += w
            if not marked[u]: visit(u)
            if not marked[v]: visit(v)
                
        return ans if all(marked) else inf","class Solution {
 public:
  int digitsCount(int d, int low, int high) {
    return countDigit(high, d) - countDigit(low - 1, d);
  }

 private:
  int countDigit(int n, int d) {
    int count = 0;

    for (int pow10 = 1; pow10 <= n; pow10 *= 10) {
      const int divisor = pow10 * 10;
      const int quotient = n / divisor;
      const int remainder = n % divisor;
      if (quotient > 0)
        count += quotient * pow10;
      if (d == 0)
        count -= pow10;
      if (remainder >= d * pow10)
        count += min(remainder - d * pow10 + 1, pow10);
    }

    return count;
  }
};"
"class Solution:
    def average(self, salary: List[int]) -> float:
        salary.remove(min(salary))
        salary.remove(max(salary))
        avg = 0
        for i in range(0,len(salary)):
            avg += salary[i] 
        
        return float(avg / len(salary))","class Solution {
 public:
  string gcdOfStrings(string str1, string str2) {
    if (str1.length() < str2.length())
      return gcdOfStrings(str2, str1);
    if (str1.find(str2) == string::npos)
      return """";
    if (str2.empty())
      return str1;
    return gcdOfStrings(str2, mod(str1, str2));
  }

 private:
  string mod(string& s1, const string& s2) {
    while (s1.find(s2) == 0)
      s1 = s1.substr(s2.length());
    return s1;
  }
};"
"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        try:
            return list(filter(lambda x:n%x==0,range(1,n+1)))[k-1]
        except:
            return -1","class Solution {
 public:
  int maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    int ans = 0;
    vector<int> flip(n);
    unordered_set<int> seen;

    for (int i = 0; i < m; ++i) {
      if (seen.count(i))
        continue;
      int count = 0;
      for (int j = 0; j < n; ++j)
        flip[j] = 1 ^ matrix[i][j];
      for (int k = 0; k < m; ++k)
        if (matrix[k] == matrix[i] || matrix[k] == flip) {
          seen.insert(k);
          ++count;
        }
      ans = max(ans, count);
    }

    return ans;
  }
};"
"class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        sums=0 #Summaries of our streaks before making two mistakes
        sumlist=list() #list of that summaries. So we can find our biggest streak later with max()
         
        if sum(nums)==len(nums): #First of all lets test the case there might be no penalties at all
            return sum(nums)-1
        
        s=0 #Penalty counter. Be careful, 2 penalties and streak is over!
        i=0 #lets start our journey from beginning of our list.
        while i< len(nums):
            if nums[i]==0 and s==0: #First Penalty!(0) You can continue, for now...
                s+=1 #Saving that you already done your first penalty
                p=i #Saving your first penalty's location.
                i+=1 #Go next one!
            elif nums[i]==0 and s!=0: #Second Penalty(0) stop now!!! And tell everything you count by far to 'SUMLIST'
                sumlist.append(sums) #saving your streak...
                s=0  #new beginning no penalties...
                sums=0 #but ofcourse youre starting from bottom
				i=p  #start from your first penalty's location!
                i+=1 #actually next of it. Since its a penalty, its not fair to start with a penalty already
            else:
                sums+=1 #No penalties? Add 1 more to your pocket
                i+=1 #Go next one
        sumlist.append(sums) #There might be only one zero so lets append sums just in case, we will return max of that sumlist so, no problem.
        return max(sumlist) #Returning maximum of our streaks with only one penalty!","class Solution {
 public:
  vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) {
    deque<int> ans;
    int carry = 0;
    int i = arr1.size() - 1;
    int j = arr2.size() - 1;

    while (carry || i >= 0 || j >= 0) {
      if (i >= 0)
        carry += arr1[i--];
      if (j >= 0)
        carry += arr2[j--];
      ans.push_front(carry & 1);
      carry = -(carry >> 1);
    }

    while (ans.size() > 1 && ans.front() == 0)
      ans.pop_front();

    return {begin(ans), end(ans)};
  }
};"
"class Solution:
    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:
        graph = collections.defaultdict(int)
        for x, y in dependencies:
            graph[y] |= 1 << (x - 1) # dependency mask of course y
        last_mask = (1 << n) - 1 # all course
        queue = collections.deque([(0, 0)]) # start with zero course taken
        visited = {0}
        while queue:
            mask, num_semesters = queue.popleft()
			# mask &amp; (1 << (x - 1)) == 0 course have not been taken
			# mask &amp; graph[x] == graph[x] but all its dependency course have been taken
            free_courses = [x for x in range(1, n + 1) if (mask &amp; (1 << (x - 1)) == 0) and mask &amp; graph[x] == graph[x]]
            for courses in itertools.combinations(free_courses, min(k, len(free_courses))):
                new_mask = mask
                for x in courses:
                    new_mask |= 1 << (x - 1)
                if new_mask == last_mask:
                    return num_semesters + 1
                if new_mask not in visited:
                    visited.add(new_mask)
                    queue.append((new_mask, num_semesters + 1))","class Solution {
 public:
  int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    int ans = 0;

    // Transfer each row of matrix to prefix sum
    for (auto& row : matrix)
      for (int i = 1; i < n; ++i)
        row[i] += row[i - 1];

    for (int baseCol = 0; baseCol < n; ++baseCol)
      for (int j = baseCol; j < n; ++j) {
        unordered_map<int, int> prefixCount{{0, 1}};
        int sum = 0;
        for (int i = 0; i < m; ++i) {
          if (baseCol > 0)
            sum -= matrix[i][baseCol - 1];
          sum += matrix[i][j];
          if (const auto it = prefixCount.find(sum - target);
              it != cend(prefixCount))
            ans += it->second;
          ++prefixCount[sum];
        }
      }

    return ans;
  }
};"
"class Solution:
    def isPathCrossing(self, path: str) -> bool:
        directions = {
            'N': (0,1),
            'E': (1,0),
            'W': (-1,0),
            'S': (0,-1)
        }
        
        s = (0, 0)
        storage = [(0,0)]
        for d in path:
            x,y = s
            i,j = directions[d]
            x, y = x+i, y+j
            s = x,y
            if s in storage:
                return True
            else:
                storage.append(s)
        
        return False","class Solution {
 public:
  vector<string> findOcurrences(string text, string first, string second) {
    vector<string> ans;
    stringstream ss(text);

    for (string prev2, prev, word; ss >> word;) {
      if (prev2 == first && prev == second)
        ans.push_back(word);
      prev2 = prev;
      prev = word;
    }

    return ans;
  }
};"
"class Solution:
    def canArrange(self, a: List[int], k: int) -> bool:
        d=[0]*k 
        for i in a: 
            d[i%k]+=1 
        for i in range(k):
            if i==0:
                if d[i]%2!=0:
                    return 0
            elif(d[i]!=d[k-i]):
                return 0
        return 1","class Solution {
 public:
  int numTilePossibilities(string tiles) {
    vector<int> count(26);

    for (const char t : tiles)
      ++count[t - 'A'];

    return dfs(count);
  }

 private:
  int dfs(vector<int>& count) {
    int possibleSequences = 0;

    for (int& c : count) {
      if (c == 0)
        continue;
      // Put c in the current position. We only care about the # of possible
      // sequences of letters but don't care about the actual combination.
      --c;
      possibleSequences += 1 + dfs(count);
      ++c;
    }

    return possibleSequences;
  }
};"
"class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:
        nums.sort()
        
        ans = 0
        lo, hi = 0, len(nums)-1
        while lo <= hi: 
            if nums[lo] + nums[hi] > target: hi -= 1
            else: 
                ans += pow(2, hi - lo, 1_000_000_007)
                lo += 1
        
        return ans % 1_000_000_007","class Solution {
 public:
  TreeNode* sufficientSubset(TreeNode* root, int limit) {
    if (root == nullptr)
      return nullptr;
    if (root->left == nullptr && root->right == nullptr)
      return root->val < limit ? nullptr : root;

    root->left = sufficientSubset(root->left, limit - root->val);
    root->right = sufficientSubset(root->right, limit - root->val);

    // Both children are nullptr
    return root->left == root->right ? nullptr : root;
  }
};"
"class Solution:
    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
        deque = collections.deque()
        res = -math.inf

        for point in points:
            x, y = point[0], point[1]
            
            while deque and x - deque[0][0] > k:
                deque.popleft()
            
            if deque:
                res = max(res, (y + deque[0][1]) + (x - deque[0][0]))
            
            # while deque AND any equation including (x, y) will always yield a greater
			# (or ==) result than any equation including (deque[-1][0], deque[-1][1])
            while deque and (deque[-1][0] - x) + (y - deque[-1][1]) >= 0:
                deque.pop()
            
            deque.append(point)
        
        return res","class Solution {
 public:
  string smallestSubsequence(string text) {
    string ans;
    vector<int> count(128);
    vector<bool> used(128);

    for (const char c : text)
      ++count[c];

    for (const char c : text) {
      --count[c];
      if (used[c])
        continue;
      while (!ans.empty() && ans.back() > c && count[ans.back()] > 0) {
        used[ans.back()] = false;
        ans.pop_back();
      }
      used[c] = true;
      ans.push_back(c);
    }

    return ans;
  }
};"
"class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr.sort()
        diff=arr[0]-arr[1]
        for i in range(1,len(arr)-1):
            if arr[i]-arr[i+1]!=diff:
                return False
        else:
            return True","class Solution {
 public:
  vector<string> expand(string s) {
    vector<string> ans;
    string path;
    dfs(s, 0, path, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int i, string& path, vector<string>& ans) {
    if (i == s.length()) {
      ans.push_back(path);
      return;
    }
    if (s[i] == '{') {
      const int nextRightBraceIndex = s.find_first_of('}', i);
      for (const char c :
           split(s.substr(i + 1, nextRightBraceIndex - i - 1), ',')) {
        path.push_back(c);
        dfs(s, nextRightBraceIndex + 1, path, ans);
        path.pop_back();
      }
    } else {  // s[i] != '{'
      path.push_back(s[i]);
      dfs(s, i + 1, path, ans);
      path.pop_back();
    }
  }

  vector<char> split(const string& s, char delimiter) {
    vector<char> splitted;
    for (const char c : s)
      if (c != delimiter)
        splitted.push_back(c);
    return splitted;
  }
};"
"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        left_max = max(left) if left else 0
        right_max = n - min(right) if right else 0
        return max(left_max, right_max)","class Solution {
 public:
  int confusingNumberII(int n) {
    return dfs(n, 0, 0, 1);
  }

 private:
  vector<pair<int, int>> digitToRotated{{0, 0}, {1, 1}, {6, 9}, {8, 8}, {9, 6}};

  int dfs(int n, long num, long rotatedNum, long unit) {
    int ans = num != rotatedNum;
    // Add one more digit
    for (const auto& [digit, rotated] : digitToRotated) {
      if (digit == 0 && num == 0)
        continue;
      const long nextNum = num * 10 + digit;
      if (nextNum > n)
        break;
      ans += dfs(n, nextNum, rotated * unit + rotatedNum, unit * 10);
    }
    return ans;
  }
};"
"class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        n,m = len(mat), len(mat[0])
        nums = []
        for i in range(n):
            num = []
            for j in range(m-1,-1,-1):
                if mat[i][j] == 0:
                    num = [0] + num
                elif mat[i][j] == 1 and j == m-1:
                    num = [1] + num
                elif mat[i][j] == 1 and j != m-1:
                    num = [1 + num[0]] + num
            nums.append(num)
        ans = 0
        for i in range(n):
            for j in range(m):
                x = m + 1
                for k in range(i,n):
                    x = min(x,nums[k][j])
                    ans += x
        return ans","class Solution {
 public:
  void duplicateZeros(vector<int>& arr) {
    int zeros = count_if(begin(arr), end(arr), [](int a) { return a == 0; });

    for (int i = arr.size() - 1, j = arr.size() + zeros - 1; i < j; --i, --j) {
      if (j < arr.size())
        arr[j] = arr[i];
      if (arr[i] == 0)
        if (--j < arr.size())
          arr[j] = arr[i];
    }
  }
};"
"class Solution:
    def minInteger(self, num: str, k: int) -> str:
        n = len(num)
        if k >= n*(n-1)//2: return """".join(sorted(num)) #special case
        
        #find smallest elements within k swaps 
        #and swap it to current position 
        num = list(num)
        for i in range(n):
            if not k: break 
            #find minimum within k swaps
            ii = i
            for j in range(i+1, min(n, i+k+1)): 
                if num[ii] > num[j]: ii = j 
            #swap the min to current position 
            if ii != i: 
                k -= ii-i
                for j in range(ii, i, -1):
                    num[j-1], num[j] = num[j], num[j-1]
        return """".join(num)","class Solution {
 public:
  int largestValsFromLabels(vector<int>& values, vector<int>& labels,
                            int num_wanted, int use_limit) {
    const int n = values.size();
    int ans = 0;
    vector<pair<int, int>> items(n);
    unordered_map<int, int> labelsUsed;

    for (int i = 0; i < n; ++i)
      items[i] = make_pair(values[i], labels[i]);

    sort(begin(items), end(items),
         [](const auto& a, const auto& b) { return a.first > b.first; });

    for (auto&& [value, label] : items) {
      if (labelsUsed[label] < use_limit) {
        ans += value;
        ++labelsUsed[label];
        if (--num_wanted == 0)
          break;
      }
    }

    return ans;
  }
};"
"class Solution:
    def reformatDate(self, date: str) -> str:
        month, date = {""Jan"":""01"", ""Feb"":""02"", ""Mar"":""03"", ""Apr"":""04"", ""May"":""05"", ""Jun"":""06"", ""Jul"":""07"", ""Aug"":""08"", ""Sep"":""09"", ""Oct"":""10"", ""Nov"":""11"", ""Dec"":""12""}, date.split()
        return date[2] + '-' + month[date[1]] + '-' + ''.join(['0']+[d for d in date[0] if d.isdigit()])[-2:]","class Solution {
 public:
  int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
    const int n = grid.size();
    if (grid[0][0] == 0 && n == 1)
      return 1;
    if (grid[0][0] == 1 || grid.back().back() == 1)
      return -1;

    const vector<pair<int, int>> dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};

    int ans = 0;
    queue<pair<int, int>> q{{{0, 0}}};
    vector<vector<bool>> seen(n, vector<bool>(n));
    seen[0][0] = true;

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == n || y < 0 || y == n)
            continue;
          if (grid[x][y] != 0 || seen[x][y])
            continue;
          if (x == n - 1 && y == n - 1)
            return ans + 1;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
    }

    return -1;
  }
};"
"class Solution:
    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:
        ans = [nums[0]]
        for i in range(1, n):
            ans.append(nums[i])    
            nums[i] += nums[i-1]
            ans.append(nums[i])    
            for j in range(i-1): ans.append(nums[i] - nums[j])
        ans.sort()                
        return sum(ans[left-1:right]) % 1000000007","class Solution {
 public:
  string shortestCommonSupersequence(string str1, string str2) {
    string ans;
    int i = 0;  // str1's index
    int j = 0;  // str2's index

    for (const char c : lcs(str1, str2)) {
      // Append chars that are not part of the LCS
      while (str1[i] != c)
        ans += str1[i++];
      while (str2[j] != c)
        ans += str2[j++];
      // Append the char of the LCS and match str1 and str2
      ans += c;
      ++i;
      ++j;
    }

    // Append remaining chars
    return ans + str1.substr(i) + str2.substr(j);
  }

 private:
  string lcs(const string& A, const string& B) {
    const int m = A.length();
    const int n = B.length();
    // dp[i][j] := LCS of A[0..i) and B[0..j)
    vector<vector<string>> dp(m + 1, vector<string>(n + 1));

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (A[i - 1] == B[j - 1])
          dp[i][j] = dp[i - 1][j - 1] + A[i - 1];
        else
          dp[i][j] = dp[i - 1][j].length() > dp[i][j - 1].length()
                         ? dp[i - 1][j]
                         : dp[i][j - 1];

    return dp[m][n];
  }
};"
"class Solution:
    def minDifference(self, nums: List[int]) -> int:
        heapq.heapify(nums)
        return min(map(lambda x, y: x-y, heapq.nlargest(4,nums), heapq.nsmallest(4,nums)[::-1]))","class Solution {
 public:
  vector<double> sampleStats(vector<int>& count) {
    const int n = accumulate(begin(count), end(count), 0);
    const double mode = max_element(begin(count), end(count)) - begin(count);
    return {
        getMinimum(count),
        getMaximum(count),
        getMean(count, n),
        (getLeftMedian(count, n) + getRightMedian(count, n)) / 2.0,
        mode,
    };
  }

 private:
  double getMinimum(const vector<int>& count) {
    for (int i = 0; i < count.size(); ++i)
      if (count[i])
        return i;
    return -1;
  }

  double getMaximum(const vector<int>& count) {
    for (int i = count.size() - 1; i >= 0; --i)
      if (count[i])
        return i;
    return -1;
  }

  double getMean(const vector<int>& count, double n) {
    double mean = 0;
    for (long i = 0; i < count.size(); ++i)
      mean += (i * count[i]) / n;
    return mean;
  }

  double getLeftMedian(const vector<int>& count, double n) {
    int numCount = 0;
    for (int i = 0; i < count.size(); ++i) {
      numCount += count[i];
      if (numCount >= n / 2)
        return i;
    }
    return -1;
  }

  double getRightMedian(const vector<int>& count, double n) {
    int numCount = 0;
    for (int i = count.size() - 1; i >= 0; --i) {
      numCount += count[i];
      if (numCount >= n / 2)
        return i;
    }
    return -1;
  }
};"
"class Solution:
    def __init__(self):
        self.cache = {}
    
    def winnerSquareGame(self, n: int) -> bool:
        if not n: return False
        if n in self.cache:
            return self.cache[n]
        i = int(math.sqrt(n))
        while i >= 1:
            if not self.winnerSquareGame(n - i*i):
                self.cache[n] = True
                return self.cache[n]
            i -= 1
        self.cache[n] = False
        return self.cache[n]","class Solution {
 public:
  bool carPooling(vector<vector<int>>& trips, int capacity) {
    int currentPassengers = 0;
    map<int, int> timeline;

    for (const vector<int>& trip : trips) {
      const int nPassengers = trip[0];
      const int start = trip[1];
      const int end = trip[2];
      timeline[start] += nPassengers;
      timeline[end] -= nPassengers;
    }

    for (const auto [_, passengerChange] : timeline) {
      currentPassengers += passengerChange;
      if (currentPassengers > capacity)
        return false;
    }

    return true;
  }
};"
"class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        repetitions = {}

        for value in nums:
            repetitions[value] = repetitions.get(value, -1) + 1
        
        return sum((v*(v+1))//2 for v in repetitions.values())","/**
 * // This is the MountainArray's API interface.
 * // You should not implement it, or speculate about its implementation
 * class MountainArray {
 *  public:
 *   int get(int index);
 *   int length();
 * };
 */

class Solution {
 public:
  int findInMountainArray(int target, MountainArray& mountainArr) {
    const int n = mountainArr.length();
    const int peakIndex = peakIndexInMountainArray(mountainArr, 0, n - 1);

    const int leftIndex = searchLeft(mountainArr, target, 0, peakIndex);
    if (mountainArr.get(leftIndex) == target)
      return leftIndex;

    const int rightIndex =
        searchRight(mountainArr, target, peakIndex + 1, n - 1);
    if (mountainArr.get(rightIndex) == target)
      return rightIndex;

    return -1;
  }

 private:
  // 852. Peak Index in a Mountain Array
  int peakIndexInMountainArray(MountainArray& A, int l, int r) {
    while (l < r) {
      const int m = (l + r) / 2;
      if (A.get(m) < A.get(m + 1))
        l = m + 1;
      else
        r = m;
    }
    return l;
  }

  int searchLeft(MountainArray& A, int target, int l, int r) {
    while (l < r) {
      const int m = (l + r) / 2;
      if (A.get(m) < target)
        l = m + 1;
      else
        r = m;
    }
    return l;
  }

  int searchRight(MountainArray& A, int target, int l, int r) {
    while (l < r) {
      const int m = (l + r) / 2;
      if (A.get(m) > target)
        l = m + 1;
      else
        r = m;
    }
    return l;
  }
};"
"class Solution:
    def numSub(self, s: str) -> int:
        return sum(map(lambda x: ((1+len(x))*len(x)//2)%(10**9+7), s.split('0')))","class Solution {
 public:
  vector<string> braceExpansionII(string expression) {
    return dfs(expression, 0, expression.length() - 1);
  }

 private:
  vector<string> dfs(const string& expression, int s, int e) {
    set<string> ans;
    vector<vector<string>> groups{{}};
    int layer = 0;
    int left = 0;

    for (int i = s; i <= e; ++i)
      if (expression[i] == '{' && ++layer == 1)
        left = i + 1;
      else if (expression[i] == '}' && --layer == 0)
        merge(groups, dfs(expression, left, i - 1));
      else if (expression[i] == ',' && layer == 0)
        groups.push_back({});
      else if (layer == 0)
        merge(groups, {string(1, expression[i])});

    for (const vector<string>& group : groups)
      for (const string& word : group)
        ans.insert(word);

    return {begin(ans), end(ans)};
  }

  void merge(vector<vector<string>>& groups, const vector<string> group) {
    if (groups.back().empty()) {
      groups[groups.size() - 1] = group;
      return;
    }

    vector<string> mergedGroup;

    for (auto& word1 : groups.back())
      for (auto& word2 : group)
        mergedGroup.push_back(word1 + word2);

    groups[groups.size() - 1] = mergedGroup;
  }
};"
"class Solution:
	def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
        edge_prob=[]
        for i in range(n):
            edge_prob.append([])
        for i in range(len(edges)):
            edge_prob[edges[i][0]].append([edges[i][1],succProb[i]])
            edge_prob[edges[i][1]].append([edges[i][0],succProb[i]])
        
        prob=[0]*n
        pq=[]
        pq.append((-1,start))
        while pq:
            current=heapq.heappop(pq)
            if prob[current[1]]==0:
                prob[current[1]]=-current[0]
                for neighbor in edge_prob[current[1]]:
                    heapq.heappush(pq,(-neighbor[1]*prob[current[1]],neighbor[0]))
                if current[1]==end:
                    break
        return prob[end]","class Solution {
 public:
  int twoSumLessThanK(vector<int>& nums, int k) {
    if (nums.size() < 2)
      return -1;

    int ans = -1;  // Note the constraint that nums[i] > 0.
    int l = 0;
    int r = nums.size() - 1;

    sort(begin(nums), end(nums));

    while (l < r)
      if (nums[l] + nums[r] < k) {
        ans = max(ans, nums[l] + nums[r]);
        ++l;
      } else {
        --r;
      }

    return ans;
  }
};"
"class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        #euclidean distance 
        fn = lambda x, y: sum(sqrt((x-xx)**2 + (y-yy)**2) for xx, yy in positions)
        #centroid as starting point
        x = sum(x for x, _ in positions)/len(positions)
        y = sum(y for _, y in positions)/len(positions)
        
        ans = fn(x, y)
        chg = 100 #change since 0 <= positions[i][0], positions[i][1] <= 100
        while chg > 1e-6: #accuracy within 1e-5
            zoom = True
            for dx, dy in (-1, 0), (0, -1), (0, 1), (1, 0):
                xx = x + chg * dx
                yy = y + chg * dy
                dd = fn(xx, yy)
                if dd < ans: 
                    ans = dd 
                    x, y = xx, yy
                    zoom = False 
                    break 
            if zoom: chg /= 2
        return ans","class Solution {
 public:
  int numKLenSubstrNoRepeats(string s, int k) {
    int ans = 0;
    int unique = 0;
    vector<int> count(26);

    for (int i = 0; i < s.length(); ++i) {
      if (++count[s[i] - 'a'] == 1)
        ++unique;
      if (i >= k && --count[s[i - k] - 'a'] == 0)
        --unique;
      if (unique == k)
        ++ans;
    }

    return ans;
  }
};"
"class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        total = numBottles
        p = numBottles
        
        while p >= numExchange:
            p_int = p // numExchange
            p_rem = p % numExchange
            p = p_int + p_rem
            total += p_int
        
        return total","class UnionFind {
 public:
  UnionFind(int n) : count(n), id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
    --count;
  }

  int getCount() const {
    return count;
  }

 private:
  int count;
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  int earliestAcq(vector<vector<int>>& logs, int n) {
    UnionFind uf(n);

    // Sort `logs` by timestamp.
    sort(
        begin(logs), end(logs),
        [](const vector<int>& a, const vector<int>& b) { return a[0] < b[0]; });

    for (const vector<int>& log : logs) {
      const int timestamp = log[0];
      const int x = log[1];
      const int y = log[2];
      uf.unionByRank(x, y);
      if (uf.getCount() == 1)
        return timestamp;
    }

    return -1;
  }
};"
"class Solution:
    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:
        graph = self.build_graph(edges)
        res = [0] * n
        visited = set()
		
        def add(seen1, seen2):
            seen = [0] * 26
            for i in range(26):
                seen[i] = seen1[i] + seen2[i]
            return seen
        
        def index(char):
            return ord(char) - ord('a')
        
        def dfs(node):
		    # Maintain a visited since the edge is represented in both directions in the graph
            visited.add(node)
            seen = [0] * 26
            for neigh in graph.get(node, []):
                if not neigh in visited:
                    seen = add(seen, dfs(neigh))
                
            seen[index(labels[node])] += 1
            res[node] = seen[index(labels[node])]
            return seen
        
        dfs(0)
        return res
        
    def build_graph(self, edges):
        graph = {}
        for edge in edges:
		     # Include edges in both directions since ordering of edges is not guaranteed
			 # e.g. case [[0, 2], [0, 3], [1, 2]]
			 # In above example we should traverse from 2 to 1.
            graph.setdefault(edge[0], []).append(edge[1])
            graph.setdefault(edge[1], []).append(edge[0])
        return graph","struct T {
  int i;
  int j;
  int val;
  T(int i, int j, int val) : i(i), j(j), val(val) {}
};

class Solution {
 public:
  int maximumMinimumPath(vector<vector<int>>& A) {
    const int m = A.size();
    const int n = A[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = A[0][0];
    vector<vector<bool>> seen(m, vector<bool>(n));
    auto compare = [](const T& a, const T& b) { return a.val < b.val; };
    priority_queue<T, vector<T>, decltype(compare)> maxHeap(compare);

    maxHeap.emplace(0, 0, A[0][0]);

    while (!maxHeap.empty()) {
      const auto [i, j, val] = maxHeap.top();
      maxHeap.pop();
      ans = min(ans, val);
      if (i == m - 1 && j == n - 1)
        return ans;
      seen[i][j] = true;
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        maxHeap.emplace(x, y, A[x][y]);
      }
    }

    throw;
  }
};"
"class Solution:
    def maxNumOfSubstrings(self, s: str) -> List[str]:
        
        # record last index(+1) and interval relations
        last, interval = {}, {}
        for i, c in enumerate(s):
            last[c] = i + 1
            if c not in interval:
                interval[c] = set(''.join(s.split(c)[1:-1]))
        
        # union-find
        parent = {c: c for c in s}
        
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            parent[find(x)] = find(y)
            return
        
        for c in interval:
            for n in interval[c]:
                if c in interval[n]:
                    union(c, n)
        
        # cut and remove redundant character
        splits, max_splits = [(s, 0)], []
        
        while splits:
            
            # cut
            splits_cut = []
            for string, start in splits:
                left = right = 0 
                for i, c in enumerate(string):
                    right = max(right, last[c] - start)
                    if i == right - 1:
                        splits_cut.append((string[left:right], start + left))
                        left = right
            
            # remove redundant
            splits_rem = []
            for string, start in splits_cut:
                len_splits_rem = len(splits_rem)
                redundant = find(string[0])
                
                left = 0
                while left < len(string):
                    if find(string[left]) == redundant:
                        left += 1
                    else:
                        right = left
                        while right < len(string) and find(string[right]) != redundant:
                            right += 1
                        splits_rem.append((string[left:right], start + left))
                        left = right

                if len_splits_rem == len(splits_rem):
                    max_splits.append(string)

            splits = splits_rem
        
        return max_splits","class Solution {
 public:
  vector<int> distributeCandies(int candies, long n) {
    vector<int> ans(n);
    int rows = (-n + sqrt(n * n + 8 * n * n * candies)) / (2 * n * n);
    int accumN = rows * (rows - 1) * n / 2;

    for (int i = 0; i < n; ++i)
      ans[i] = accumN + rows * (i + 1);

    int givenCandies = (n * n * rows * rows + n * rows) / 2;
    candies -= givenCandies;

    for (int i = 0, lastGiven = rows * n + 1; candies > 0; ++i, ++lastGiven) {
      int actualGiven = min(lastGiven, candies);
      candies -= actualGiven;
      ans[i] += actualGiven;
    }

    return ans;
  }
};"
"class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        while n > m: 
            n &amp;= n-1 #unset last set bit
        return n","class Solution {
 public:
  vector<int> pathInZigZagTree(int label) {
    deque<int> ans;
    int level;

    for (int l = 0; l < 21; ++l)
      if (pow(2, l) > label) {
        level = l - 1;
        break;
      }

    if (level & 1)
      label = boundarySum(level) - label;

    for (int l = level; l >= 0; --l) {
      ans.push_front(l & 1 ? boundarySum(l) - label : label);
      label /= 2;
    }

    return {begin(ans), end(ans)};
  }

 private:
  int boundarySum(int level) {
    return pow(2, level) + pow(2, level + 1) - 1;
  }
};"
"class Solution:
    def countOdds(self, low: int, high: int) -> int:
        if low % 2 == 0:
            low += 1
        return (((high - low)//2) + 1)","class Solution {
 public:
  int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {
    // dp[i] := min height to place the first i books
    vector<int> dp(books.size() + 1, INT_MAX);
    dp[0] = 0;

    for (int i = 0; i < books.size(); ++i) {
      int sumThickness = 0;
      int maxHeight = 0;
      // Place books[j..i] on a new shelf.
      for (int j = i; j >= 0; --j) {
        const int thickness = books[j][0];
        const int height = books[j][1];
        sumThickness += thickness;
        if (sumThickness > shelfWidth)
          break;
        maxHeight = max(maxHeight, height);
        dp[i + 1] = min(dp[i + 1], dp[j] + maxHeight);
      }
    }

    return dp.back();
  }
};"
"class Solution:
    def numOfSubarrays(self, arr: List[int]) -> int:
        freq = [1, 0]
        ans = prefix = 0
        for x in arr: 
            prefix += x 
            ans += freq[1 ^ prefix&amp;1]
            freq[prefix&amp;1] += 1
        return ans % 1_000_000_007","class Solution {
 public:
  bool parseBoolExpr(string expression) {
    int i = 0;
    return parse(expression, i);
  }

 private:
  bool parse(const string& exp, int& i) {
    if (exp[i] == 't') {
      ++i;
      return true;
    }
    if (exp[i] == 'f') {
      ++i;
      return false;
    }
    if (exp[i] == '!') {
      i += 2;
      bool ans = !parse(exp, i);
      ++i;
      return ans;
    }

    bool isAnd = exp[i] == '&';
    bool ans = isAnd;
    i += 2;
    while (exp[i] != ')') {
      bool parsed = parse(exp, i);
      if (isAnd)
        ans &= parsed;
      else
        ans |= parsed;
      if (exp[i] == ',')
        ++i;
    }
    ++i;
    return ans;
  }
};"
"class Solution:
    def numSplits(self, s: str) -> int:
        tail_d, head_d, ans = {}, {}, 0
        
        def add_c(d, c):
            if c not in d:
                d[c] = 1
            else:
                d[c] += 1
                
        def remove_c(d, c):
            n = d[c]
            n -= 1
            if n == 0:
                del d[c]
            else:
                d[c] = n
                                
        def is_same(d1, d2):
            return len(d1) == len(d2)
        
        # 0) Initialize tail_d
        for c in s:
            add_c(tail_d, c)
            
            
        # 1) Start searching number of good ways of split        
        for c in s:
            remove_c(tail_d, c)
            add_c(head_d, c)
            if is_same(tail_d, head_d):
                ans += 1
        
            if len(tail_d) < len(head_d):
                break
                
        # 3) Return the answer
        return ans","class Solution {
 public:
  string defangIPaddr(string address) {
    return regex_replace(address, regex(""[.]""), ""[.]"");
  }
};"
"class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        ans = 0 
        stack = [] # increasing stack
        for x in target: 
            while stack and stack[-1] >= x: 
                ans += stack.pop() - max(x, (stack or [0])[-1])
            stack.append(x)
        prev = 0
        for x in stack: 
            ans += x - prev 
            prev = x
        return ans","class Solution {
 public:
  vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
    vector<int> ans(n);

    for (vector<int>& booking : bookings) {
      ans[booking[0] - 1] += booking[2];
      if (booking[1] < n)
        ans[booking[1]] -= booking[2];
    }

    for (int i = 1; i < n; ++i)
      ans[i] += ans[i - 1];

    return ans;
  }
};"
"class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        fs = ''
        num = 0
        for i in range(len(indices)):
            ind = indices.index(num)
            fs += s[ind]
            num += 1
        return fs","class Solution {
 public:
  vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {
    vector<TreeNode*> ans;
    dfs(root, {begin(to_delete), end(to_delete)}, true, ans);
    return ans;
  }

 private:
  TreeNode* dfs(TreeNode*& root, const unordered_set<int>&& toDeleteSet,
                bool isRoot, vector<TreeNode*>& ans) {
    if (root == nullptr)
      return nullptr;

    const bool deleted = toDeleteSet.count(root->val);
    if (isRoot && !deleted)
      ans.push_back(root);

    // If root is deleted, both children have the possibility to be a new root
    root->left = dfs(root->left, move(toDeleteSet), deleted, ans);
    root->right = dfs(root->right, move(toDeleteSet), deleted, ans);
    return deleted ? nullptr : root;
  }
};"
"class Solution:
    def minFlips(self, target: str) -> int:

        count = 0
        checkfor = 1

        for i in range(len(target)):
            if int(target[i]) == checkfor:
                count += 1
                checkfor ^= 1

        return count","class Solution {
 public:
  vector<int> maxDepthAfterSplit(string seq) {
    vector<int> ans;
    int depth = 1;

    // Put all odd-depth parentheses in one group and even-depth parentheses in
    // the other group.
    for (const char c : seq)
      if (c == '(')
        ans.push_back(++depth % 2);
      else
        ans.push_back(depth-- % 2);

    return ans;
  }
};"
"class Solution:
    def __init__(self):
        self.res = 0
        
    def traversal(self, node, dist):
        if not node:
            return []
        
        if not node.left and not node.right:
            return [1]
        
        dists_from_left = self.traversal(node.left, dist)
        dists_from_right = self.traversal(node.right, dist)
        
        for ld in dists_from_left:
            for rd in dists_from_right:
                if ld + rd <= dist:
                    self.res += 1
        
        return [d + 1 for d in dists_from_left + dists_from_right if d < dist]
        
        
    def countPairs(self, root: TreeNode, distance: int) -> int:
        self.traversal(root, distance)
        
        return self.res","class Foo {
 public:
  Foo() {
    firstDone.lock();
    secondDone.lock();
  }

  void first(function<void()> printFirst) {
    printFirst();
    firstDone.unlock();
  }

  void second(function<void()> printSecond) {
    firstDone.lock();
    printSecond();
    secondDone.unlock();
  }

  void third(function<void()> printThird) {
    secondDone.lock();
    printThird();
  }

 private:
  mutex firstDone;
  mutex secondDone;
};"
"class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        # Find min lenth of the code starting from group ind, if there are res_k characters to delete and 
		#       group ind needs to be increased by carry_over additional characters
        def FindMinLen(ind, res_k, carry_over=0): 
            
            # If we already found the min length - just retrieve it (-1 means we did not calculate it)
            if carry_over == 0 and dynamic[ind][res_k] != -1:
                return dynamic[ind][res_k]
            
            # Number of character occurences that we need to code. Includes carry-over.
            cur_count = carry_over + frequency[ind]

            # Min code length if the group ind stays intact. The code accounts for single-character ""s0"" vs. ""s""  situation.
            min_len = 1 + min(len(str(cur_count)), cur_count - 1) + FindMinLen(ind+1,res_k)

            # Min length if we keep only 0, 1, 9, or 99 characters in the group - delete the rest, if feasible
            for leave_count, code_count in [(0,0), (1, 1), (9, 2), (99, 3)]:
                if cur_count > leave_count and res_k >= cur_count - leave_count:
                    min_len = min(min_len, code_count + FindMinLen(ind + 1,res_k - (cur_count - leave_count)))

            # If we drop characters between this character group and next group, like drop ""a"" in ""bbbabb""
            next_ind = chars.find(chars[ind], ind + 1)
            delete_count = sum(frequency[ind+1:next_ind])
            if next_ind > 0 and res_k >= delete_count:
                min_len = min(min_len, FindMinLen(next_ind, res_k - delete_count, carry_over = cur_count))

            # If there was no carry-over, store the result
            if carry_over == 0: dynamic[ind][res_k] = min_len
            return min_len
        
        # Two auxiliary lists - character groups (drop repeated) and number of characters in the group
        frequency, chars = [], """"
        for char in s:
            if len(frequency)==0 or char != chars[-1]:
                frequency.append(0)
                chars = chars + char
            frequency[-1] += 1
        
        # Table with the results. Number of character groups by number of available deletions.  
        dynamic = [[-1] * (k + 1) for i in range(len(frequency))] + [[0]*(k + 1)]
        
        return FindMinLen(0, k)","// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class FooBar {
 public:
  FooBar(int n) : n(n) {
    sem_init(&fooSemaphore, /*pshared=*/0, /*value=*/1);
    sem_init(&barSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~FooBar() {
    sem_destroy(&fooSemaphore);
    sem_destroy(&barSemaphore);
  }

  void foo(function<void()> printFoo) {
    for (int i = 0; i < n; ++i) {
      sem_wait(&fooSemaphore);
      printFoo();
      sem_post(&barSemaphore);
    }
  }

  void bar(function<void()> printBar) {
    for (int i = 0; i < n; ++i) {
      sem_wait(&barSemaphore);
      printBar();
      sem_post(&fooSemaphore);
    }
  }

 private:
  const int n;
  sem_t fooSemaphore;
  sem_t barSemaphore;
};"
"class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        length=len(arr)
        count=0
        for i in range(length):
            for j in range(i+1,length):
                for k in range(j+1,length):
                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:
                        count+=1
                    else:
                        continue
                            
        return count","// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class ZeroEvenOdd {
 public:
  ZeroEvenOdd(int n) : n(n) {
    sem_init(&zeroSemaphore, /*pshared=*/0, /*value=*/1);
    sem_init(&evenSemaphore, /*pshared=*/0, /*value=*/0);
    sem_init(&oddSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~ZeroEvenOdd() {
    sem_destroy(&zeroSemaphore);
    sem_destroy(&evenSemaphore);
    sem_destroy(&oddSemaphore);
  }

  // printNumber(x) outputs ""x"", where x is an integer.
  void zero(function<void(int)> printNumber) {
    for (int i = 0; i < n; ++i) {
      sem_wait(&zeroSemaphore);
      printNumber(0);
      sem_post(&(i % 2 == 0 ? oddSemaphore : evenSemaphore));
    }
  }

  void even(function<void(int)> printNumber) {
    for (int i = 2; i <= n; i += 2) {
      sem_wait(&evenSemaphore);
      printNumber(i);
      sem_post(&zeroSemaphore);
    }
  }

  void odd(function<void(int)> printNumber) {
    for (int i = 1; i <= n; i += 2) {
      sem_wait(&oddSemaphore);
      printNumber(i);
      sem_post(&zeroSemaphore);
    }
  }

 private:
  const int n;
  sem_t zeroSemaphore;
  sem_t evenSemaphore;
  sem_t oddSemaphore;
};"
"class Solution:
    def getWinner(self, arr: List[int], k: int) -> int:
        n = len(arr)
        winningInteger = arr[0]
        winCount = 0
        for i in range(1, n):
            if winningInteger > arr[i]:
                winCount += 1
            else:
                winningInteger = arr[i]
                winCount = 1
            if winCount == k:
                return winningInteger
        return winningInteger","// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class H2O {
 public:
  H2O() {
    sem_init(&hSemaphore, /*pshared=*/0, /*value=*/1);
    sem_init(&oSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~H2O() {
    sem_destroy(&hSemaphore);
    sem_destroy(&oSemaphore);
  }

  void hydrogen(function<void()> releaseHydrogen) {
    sem_wait(&hSemaphore);
    ++h;
    // releaseHydrogen() outputs ""H"". Do not change or remove this line.
    releaseHydrogen();
    if (h % 2 == 0)
      sem_post(&oSemaphore);
    else
      sem_post(&hSemaphore);
  }

  void oxygen(function<void()> releaseOxygen) {
    sem_wait(&oSemaphore);
    // releaseOxygen() outputs ""O"". Do not change or remove this line.
    releaseOxygen();
    sem_post(&hSemaphore);
  }

 private:
  sem_t hSemaphore;
  sem_t oSemaphore;
  int h = 0;
};"
"class Solution:
    def minSwaps(self, grid: List[List[int]]) -> int:
        A = [sum(int(x == 0) for x in accumulate(row[::-1])) for row in grid]
        n = len(grid)

        res = 0
        for i in range(n):
            for j in range(i, n):
                if A[j] >= n - 1 - i:
                    A = A[:i] + A[j:j+1] + A[i:j] + A[j+1:]
                    res += j - i
                    break
            else:
                return -1
        
        return res","struct T {
  int sum;
  int count;
  double maxAverage;
};

class Solution {
 public:
  double maximumAverageSubtree(TreeNode* root) {
    return maximumAverage(root).maxAverage;
  }

 private:
  T maximumAverage(TreeNode* root) {
    if (root == nullptr)
      return {0, 0, 0.0};

    const T left = maximumAverage(root->left);
    const T right = maximumAverage(root->right);

    const int sum = root->val + left.sum + right.sum;
    const int count = 1 + left.count + right.count;
    const double maxAverage =
        max({sum / (double)count, left.maxAverage, right.maxAverage});
    return {sum, count, maxAverage};
  }
};"
"class Solution:
    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:
        i = j = score1 = score2 = maxScore = 0
        m, n = len(nums1), len(nums2)
        MOD = 10 ** 9 + 7
        
        while i < m and j < n:
            if nums1[i] < nums2[j]:
                score1 += nums1[i]
                i += 1
            elif nums1[i] > nums2[j]:
                score2 += nums2[j]
                j += 1
            else:
                maxScore += nums1[i] + max(score1, score2)
                maxScore %= MOD
                score1 = score2 = 0
                i += 1
                j += 1
        
        while i < m:
            score1 += nums1[i]
            i += 1
        while j < n:
            score2 += nums2[j]
            j += 1
        
        maxScore += max(score1, score2)
        return maxScore % MOD","class Solution {
 public:
  bool canDivideIntoSubsequences(vector<int>& nums, int k) {
    // Find the number with the maxFreq, we need at least maxFreq * k elements
    // E.g. nums = [1, 2, 2, 3, 4], we have maxFreq = 2 (two 2s), so we have to
    // Split nums into two subseqs say k = 3, the minimum length of nums is 2 x
    // 3 = 6, which is impossible if nums.size() = 5
    const int n = nums.size();
    int freq = 1;
    int maxFreq = 1;

    for (int i = 1; i < n; ++i) {
      freq = nums[i - 1] < nums[i] ? 1 : ++freq;
      maxFreq = max(maxFreq, freq);
    }

    return n >= maxFreq * k;
  }
};"
"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        check = [True]*2001
        for e in arr:
            check[e] = False
        ind = 1
        for i in range(k):
            while check[ind]==False:
                ind+=1
            ind+=1
        return ind-1","class Solution {
 public:
  vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
    vector<int> ans;
    vector<int> count(1001);

    for (int a : arr1)
      ++count[a];

    for (int a : arr2)
      while (count[a]-- > 0)
        ans.push_back(a);

    for (int num = 0; num < 1001; ++num)
      while (count[num]-- > 0)
        ans.push_back(num);

    return ans;
  }
};"
"class Solution:
    def canConvertString(self, s: str, t: str, k: int) -> bool:
        if len(s)!=len(t):return False
        
        lookup=collections.defaultdict(int)
        for i in range(len(s)):
            if s[i]!=t[i]:
                char = ord(t[i])-ord(s[i])
                if char<0:char+=26
                lookup[char] += 1        
        
        keys = sorted(lookup.keys())
        for key in keys:
            temp=key
            if key<k:
                lookup[key]-=1
                while lookup[key]:
                    temp+=26
                    if temp>k:break
                    if temp<=k:
                        lookup[key]-=1
            if temp>k or key>k:return False
        return True","struct T {
  TreeNode* lca;
  int depth;
};

class Solution {
 public:
  TreeNode* lcaDeepestLeaves(TreeNode* root) {
    return dfs(root).lca;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {nullptr, 0};
    const T left = dfs(root->left);
    const T right = dfs(root->right);
    if (left.depth > right.depth)
      return {left.lca, left.depth + 1};
    if (left.depth < right.depth)
      return {right.lca, right.depth + 1};
    return {root, left.depth + 1};
  }
};"
"class Solution:
    def minInsertions(self, s: str) -> int:
        stack = []
        ret = 0
        for c in s:
            if c == '(':
                if stack and not stack[- 1]:
                    ret += 1
                    stack.pop()
                stack.append(1)
            else:
                if not stack:
                    ret += 1
                    stack.append(1)
                if stack[- 1]:
                    stack[- 1] -= 1
                else:
                    stack.pop()
        while stack:
            ret += 1 + stack.pop()
        return ret","class Solution {
 public:
  int longestWPI(vector<int>& hours) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> map;

    for (int i = 0; i < hours.size(); ++i) {
      prefix += hours[i] > 8 ? 1 : -1;
      if (prefix > 0) {
        ans = i + 1;
      } else {
        if (!map.count(prefix))
          map[prefix] = i;
        if (const auto it = map.find(prefix - 1); it != cend(map))
          ans = max(ans, i - it->second);
      }
    }

    return ans;
  }
};"
"class Solution:
    def longestAwesome(self, s: str) -> int:
        ans = prefix = 0
        seen = {0: -1}
        for i, c in enumerate(s):
            prefix ^= 1 << int(c) #toggle bit 
            ans = max(ans, i - seen.get(prefix, inf))
            for k in range(10): 
                x = prefix ^ (1 << k) #toggle kth bit 
                ans = max(ans, i - seen.get(x, inf))
            seen.setdefault(prefix, i)
        return ans","class Solution {
 public:
  vector<int> smallestSufficientTeam(vector<string>& req_skills,
                                     vector<vector<string>>& people) {
    const int n = req_skills.size();
    const int nSkills = 1 << n;
    unordered_map<string, int> skillToId;
    // dp[i] := min people's indices to cover skillset of mask i
    unordered_map<int, vector<int>> dp;
    dp.reserve(nSkills);  // Avoid rehash
    dp[0] = {};

    for (int i = 0; i < n; ++i)
      skillToId[req_skills[i]] = i;

    auto getSkill = [&](const vector<string>& person) {
      int mask = 0;
      for (const string& skill : person)
        if (const auto it = skillToId.find(skill); it != cend(skillToId))
          mask |= 1 << it->second;
      return mask;
    };

    for (int i = 0; i < people.size(); ++i) {
      const int currSkill = getSkill(people[i]);
      for (const auto& [mask, indices] : dp) {
        const int newSkillSet = mask | currSkill;
        if (newSkillSet == mask)  // Adding people[i] doesn't increase skill set
          continue;
        if (!dp.count(newSkillSet) ||
            dp[newSkillSet].size() > indices.size() + 1) {
          dp[newSkillSet] = indices;
          dp[newSkillSet].push_back(i);
        }
      }
    }

    return dp[nSkills - 1];
  }
};"
"class Solution:
    def findKthBit(self, n: int, k: int) -> str:
        '''
        length pattern:
            1-1
            2-2*1+1=3=2**2-1
            3-2*3+1=7=2**3-1
            4-2*7+1=15=16-1=2**4-1
            n-2**n-1
        k-th bit:
            k<2**(n-1)
        '''
        def helper(n,k):
            if n==1:
                return 0
            elif k==2**(n-1):
                return 1
            elif k<2**(n-1):
                return helper(n-1,k)
            else:
                return 1-helper(n-1,2**(n-1)-(k-2**(n-1)))
        return str(helper(n,k))","class Solution {
 public:
  int numEquivDominoPairs(vector<vector<int>>& dominoes) {
    int ans = 0;
    unordered_map<int, int> count;

    for (vector<int>& domino : dominoes) {
      int key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1]);
      ans += count[key];
      ++count[key];
    }

    return ans;
  }
};"
"class Solution:
    def maxNonOverlapping(self, nums: List[int], target: int) -> int:
        
        moddict = {}
        moddict[0] = 0
        
        res = 0  # value to be returned
        
        cnt = 1
        s = 0 
        
        for num in nums:
            s += num
            if s-target in moddict:
                res += 1
                moddict = {}
            moddict[s] = cnt
            
            cnt += 1
        return res","enum class Color { kInit, kRed, kBlue };

class Solution {
 public:
  vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges,
                                       vector<vector<int>>& blueEdges) {
    vector<int> ans(n, -1);
    vector<vector<pair<int, Color>>> graph(n);  // graph[u] := [(v, edgeColor)]
    queue<pair<int, Color>> q{{{0, Color::kInit}}};  // [(u, prevColor)]

    for (const vector<int>& edge : redEdges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].emplace_back(v, Color::kRed);
    }

    for (const vector<int>& edge : blueEdges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].emplace_back(v, Color::kBlue);
    }

    for (int step = 0; !q.empty(); ++step)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [u, prevColor] = q.front();
        q.pop();
        ans[u] = ans[u] == -1 ? step : ans[u];
        for (auto& [v, edgeColor] : graph[u]) {
          if (v == -1 || edgeColor == prevColor)
            continue;
          q.emplace(v, edgeColor);
          v = -1;  // Mark (u, v) as used.
        }
      }

    return ans;
  }
};"
"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        # Function to make cut
        def makeCut(start, end, t=dict()):
            
            # Make key
            key = (start, end)
            
            # If key doesn't exist
            if key not in t:
            
                # Init
                currMin = float(""inf"")

                # For all cuts
                for cut in cuts:

                    # If cuts exist between the start and end, it's a valid cut.
                    if start < cut < end:

                        # Get the current cost of the cut 
                        cost = end - start

                        # Update currMin
                        currMin = min(currMin, cost + makeCut(start, cut, t) + makeCut(cut, end, t))

                # Update the currenty key, if nothing is processed, the value is 0
                t[key] = currMin if currMin != float(""inf"") else 0
            
            # return the current key
            return t[key]
        
        return makeCut(0,n)","class Solution {
 public:
  int mctFromLeafValues(vector<int>& arr) {
    const int n = arr.size();
    // dp[i][j] := min cost of arr[i..j]
    vector<vector<int>> dp(n, vector<int>(n));
    // maxVal[i][j] := max value of arr[i..j]
    vector<vector<int>> maxVal(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      maxVal[i][i] = arr[i];

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        maxVal[i][j] = max(maxVal[i][j - 1], maxVal[i + 1][j]);
      }

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        dp[i][j] = INT_MAX;
        for (int k = i; k < j; ++k)
          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] +
                                       maxVal[i][k] * maxVal[k + 1][j]);
      }

    return dp[0].back();
  }
};"
"class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        return any(a % 2 == b % 2 == c % 2 == 1 for a, b, c in zip(arr, arr[1:], arr[2:]))","class Solution {
 public:
  int maxAbsValExpr(vector<int>& arr1, vector<int>& arr2) {
    const int n = arr1.size();
    vector<int> a(n);
    vector<int> b(n);
    vector<int> c(n);
    vector<int> d(n);

    for (int i = 0; i < n; ++i) {
      a[i] = arr1[i] + arr2[i] + i;
      b[i] = arr1[i] + arr2[i] - i;
      c[i] = arr1[i] - arr2[i] + i;
      d[i] = arr1[i] - arr2[i] - i;
    }

    return max(max(diff(a), diff(b)), max(diff(c), diff(d)));
  }

 private:
  int diff(vector<int>& nums) {
    const int min = *min_element(begin(nums), end(nums));
    const int max = *max_element(begin(nums), end(nums));
    return max - min;
  }
};"
"class Solution:
    def minOperations(self, n: int) -> int:
        k=[]
        val = [j for j in range(n)]
        arr = list(map(lambda i:((2*i)+1),val))
        avg = int((sum(arr))/n)
        for s in arr:
            if s<avg:                
                k.append(avg-s) 
        return(sum(k))","class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int minimumCost(int n, vector<vector<int>>& connections) {
    int ans = 0;
    UnionFind uf(n + 1);

    // Sort by cost.
    sort(
        begin(connections), end(connections),
        [](const vector<int>& a, const vector<int>& b) { return a[2] < b[2]; });

    for (const vector<int>& c : connections) {
      const int u = c[0];
      const int v = c[1];
      const int cost = c[2];
      if (uf.find(u) == uf.find(v))
        continue;
      uf.unionByRank(u, v);
      ans += cost;
    }

    const int root = uf.find(1);
    for (int i = 1; i <= n; ++i)
      if (uf.find(i) != root)
        return -1;

    return ans;
  }
};"
"class Solution:
    def maxDistance(self, A, n):
        A.sort()
        L    = len(A)
        lo   = 1
        hi   = (A[-1]-A[0])//(n-1)
        best = 1
        n   -= 1
        def valid(mid):
            prev = A[0]
            i    = 0
            for j in range(n):
                d = prev + mid
                while i<L and A[i]<d:
                    i += 1
                if i==L:
                    return False
                prev = A[i]
            return True
        
        while lo<=hi:
            mid = (lo+hi) >> 1
            if valid(mid):
                best = mid
                lo   = mid + 1
            else:
                hi = mid - 1
        
        return best","enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  int minimumSemesters(int n, vector<vector<int>>& relations) {
    vector<vector<int>> graph(n);
    vector<State> state(n);
    vector<int> depth(n, 1);

    for (const vector<int>& relation : relations) {
      const int u = relation[0] - 1;
      const int v = relation[1] - 1;
      graph[u].push_back(v);
    }

    for (int i = 0; i < n; ++i)
      if (hasCycle(graph, i, state, depth))
        return -1;

    return *max_element(begin(depth), end(depth));
  }

 private:
  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& state,
                vector<int>& depth) {
    if (state[u] == State::kVisiting)
      return true;
    if (state[u] == State::kVisited)
      return false;

    state[u] = State::kVisiting;
    for (const int v : graph[u]) {
      if (hasCycle(graph, v, state, depth))
        return true;
      depth[u] = max(depth[u], 1 + depth[v]);
    }
    state[u] = State::kVisited;

    return false;
  }
};"
"class Solution:
    def minDays(self, n: int) -> int:
        memo = dict()
        def minimumDays(n):
            if n in memo:
                return memo[n]
            
            if n == 1:
                return 1
            if n== 2 or n == 3:
                return 2
            
            memo[n] = min(n%2+minimumDays(n//2)+1, n%3+minimumDays(n//3)+1)
            
            return memo[n]
        
        return minimumDays(n)","class Solution {
 public:
  string alphabetBoardPath(string target) {
    string ans;
    int x = 0;
    int y = 0;

    for (char c : target) {
      int newX = (c - 'a') % 5;
      int newY = (c - 'a') / 5;
      ans += string(max(0, y - newY), 'U') + string(max(0, newX - x), 'R') +
             string(max(0, x - newX), 'L') + string(max(0, newY - y), 'D') +
             '!';
      x = newX;
      y = newY;
    }

    return ans;
  }
};"
"class Solution:
    def thousandSeparator(self, n: int) -> str:
        n=str(n)
        res=""""
        if len(str(n)) <4:
            return str(n)
        count=0
        for i in range(len(n)-1,-1,-1):

            if count<3:
                res+=str(n[i])
                count+=1
            if count==3 and i!=0:
                res+="".""
                
                count=0
        return str(res[::-1])","class Solution {
 public:
  int largest1BorderedSquare(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();

    // leftOnes[i][j] := consecutive 1s in the left of grid[i][j]
    vector<vector<int>> leftOnes(m, vector<int>(n));
    // topOnes[i][j] := consecutive 1s in the top of grid[i][j]
    vector<vector<int>> topOnes(m, vector<int>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1) {
          leftOnes[i][j] = j == 0 ? 1 : 1 + leftOnes[i][j - 1];
          topOnes[i][j] = i == 0 ? 1 : 1 + topOnes[i - 1][j];
        }

    for (int sz = min(m, n); sz > 0; --sz)
      for (int i = 0; i + sz - 1 < m; ++i)
        for (int j = 0; j + sz - 1 < n; ++j) {
          const int x = i + sz - 1;
          const int y = j + sz - 1;
          // If grid[i..x][j..y] has all 1s on its border.
          if (min(leftOnes[i][y], leftOnes[x][y]) >= sz &&
              min(topOnes[x][j], topOnes[x][y]) >= sz)
            return sz * sz;
        }

    return 0;
  }
};"
"class Solution:
    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:
        d = {}
        ans = []
        for x,y in edges:
            if y not in d:
                d[y] = [x]
            else:
                d[y].append(x)
        
        for x in range(n):
            if x not in d:
                ans.append(x)
        
        return ans","class Solution {
 public:
  int stoneGameII(vector<int>& piles) {
    const int n = piles.size();
    // dp[i][j] := max # of stones Alice can get w/ piles[i:] and M = j
    dp.resize(n, vector<int>(n));
    // suffixSum[i] := sum of piles[i:]
    suffixSum = piles;

    for (int i = n - 2; i >= 0; --i)
      suffixSum[i] += suffixSum[i + 1];

    return stoneGameII(0, 1);
  }

 private:
  vector<vector<int>> dp;
  vector<int> suffixSum;

  int stoneGameII(int i, int M) {
    if (i + 2 * M >= dp.size())
      return suffixSum[i];
    if (dp[i][M])
      return dp[i][M];

    int opponent = suffixSum[i];

    for (int X = 1; X <= 2 * M; ++X)
      opponent = min(opponent, stoneGameII(i + X, max(M, X)));

    return dp[i][M] = suffixSum[i] - opponent;
  }
};"
"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        return sum(bin(x).count(""1"") for x in nums) + len(bin(max(nums))) - 3","class Solution {
 public:
  int longestCommonSubsequence(string text1, string text2) {
    const int m = text1.length();
    const int n = text2.length();
    // dp[i][j] := LCS's length of text1[0..i) and text2[0..j)
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        dp[i + 1][j + 1] = text1[i] == text2[j]
                               ? 1 + dp[i][j]
                               : max(dp[i][j + 1], dp[i + 1][j]);

    return dp[m][n];
  }
};"
"class Solution:
    def containsCycle(self, grid: List[List[str]]) -> bool:
        sets_vals = defaultdict(set)
        for r, row in enumerate(grid):
            for c, v in enumerate(row):
                sets_vals[v].add((r, c))
        for _, set_val in sets_vals.items():
            while set_val:
                chain_len = 0
                start = set_val.pop()
                neighbours = {start}
                chain = {start: (chain_len, tuple())}
                while neighbours:
                    chain_len += 1
                    new_neighbours = set()
                    for r, c in neighbours:
                        for new_cell in [(r + 1, c), (r - 1, c), (r, c + 1),
                                         (r, c - 1)]:

                            if (new_cell in chain and
                                    new_cell != chain[(r, c)][1] and
                                    chain[new_cell][0] + chain_len > 3):
                                return True

                            if new_cell in set_val:
                                chain[new_cell] = (chain_len, (r, c))
                                new_neighbours.add(new_cell)
                                set_val.remove(new_cell)

                    neighbours = new_neighbours
        return False","class Solution {
 public:
  int movesToMakeZigzag(vector<int>& nums) {
    vector<int> decreasing(2);

    for (int i = 0; i < nums.size(); ++i) {
      int l = i > 0 ? nums[i - 1] : 1001;
      int r = i + 1 < nums.size() ? nums[i + 1] : 1001;
      decreasing[i % 2] += max(0, nums[i] - min(l, r) + 1);
    }

    return min(decreasing[0], decreasing[1]);
  }
};"
"class Solution:
    def mostVisited(self, n: int, rounds: List[int]) -> List[int]:
        for i in range(len(rounds)-1):
            a, b = rounds[i],rounds[i+1]
            if a < b:
                for j in range(a+1,b):
                    rounds.append(j)
            else:
                for j in range(a+1,n+1):
                    rounds.append(j)
                for j in range(1,b):
                    rounds.append(j)
        m = 0
        v = []
        d = Counter(rounds)
        for i in d:
            if d[i] > m-1:
                v.append(i)
                m = d[i]
        return sorted(v)","class Solution {
 public:
  bool btreeGameWinningMove(TreeNode* root, int n, int x) {
    count(root, x);
    return max({leftCount, rightCount, n - leftCount - rightCount - 1}) > n / 2;
  }

 private:
  int leftCount;   // # of nodes of n's left
  int rightCount;  // # of nodes of n's right

  int count(TreeNode* root, int x) {
    if (root == nullptr)
      return 0;

    const int l = count(root->left, x);
    const int r = count(root->right, x);

    if (root->val == x) {
      leftCount = l;
      rightCount = r;
    }

    return 1 + l + r;
  }
};"
"class Solution:
    def maxCoins(self, piles: List[int]) -> int:
        if len(piles) == 0:
            return 0

        piles.sort()
        
        len_piles = len(piles)
        cnt = 0
        for i in range(len_piles - 2, len_piles //3 -1, -2):
            cnt += piles[i]
        return cnt","class Solution {
 public:
  int longestDecomposition(string text) {
    int count = 0;
    int l = 0;

    for (int r = 1; 2 * r <= text.length(); ++r)
      if (equal(begin(text) + l, begin(text) + r, end(text) - r)) {
        count += 2;
        l = r;
      }

    return count + (2 * l < text.length());
  }
};"
"class Solution:
    def findLatestStep(self, arr: List[int], m: int) -> int:
        span = [0]*(len(arr)+2)
        freq = [0]*(len(arr)+1)
        ans = -1
        for i, x in enumerate(arr, 1): 
            freq[span[x-1]] -= 1
            freq[span[x+1]] -= 1
            span[x] = span[x-span[x-1]] = span[x+span[x+1]] = 1 + span[x-1] + span[x+1]
            freq[span[x]] += 1
            
            if freq[m]: ans = i
        return ans","class Solution {
 public:
  int minSwaps(vector<int>& data) {
    const int k = count(begin(data), end(data), 1);
    int ones = 0;     // Ones in window
    int maxOnes = 0;  // Max ones in window

    for (int i = 0; i < data.size(); ++i) {
      if (i >= k && data[i - k])
        --ones;
      if (data[i])
        ++ones;
      maxOnes = max(maxOnes, ones);
    }

    return k - maxOnes;
  }
};"
"class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        # prefix sum 
        prefix = [0]
        for x in stoneValue: prefix.append(prefix[-1] + x)
        
        @lru_cache(None)
        def fn(lo, hi):
            """"""Return the score of arranging values from lo (inclusive) to hi (exclusive). """"""
            if lo+1 == hi: return 0 
            val = 0
            for mid in range(lo+1, hi): 
                lower = prefix[mid] - prefix[lo]
                upper = prefix[hi] - prefix[mid]
                if lower < upper: val = max(val, lower + fn(lo, mid))
                elif lower > upper: val = max(val, upper + fn(mid, hi))
                else: val = max(val, lower + max(fn(lo, mid), fn(mid, hi)))
            return val 
                
        return fn(0, len(stoneValue))","class Solution {
 public:
  bool canConvert(string str1, string str2) {
    if (str1 == str2)
      return true;

    vector<int> mappings(128);

    // No char in str1 can be mapped to > 1 char in str2
    for (int i = 0; i < str1.length(); ++i) {
      const int a = str1[i];
      const int b = str2[i];
      if (mappings[a] != 0 && mappings[a] != b)
        return false;
      mappings[a] = b;
    }

    // No char in str1 maps to > 1 char in str2 and
    // There is at lest one temp char can break any loops
    return unordered_set<char>(begin(str2), end(str2)).size() < 26;
  }
};"
"class Solution:
    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:
        i=0
        d=m
        if m >len(arr) or k >len(arr):
            return(False)
        while d < len(arr):    
            p=arr[i:d]
            count=1
            j,l=i+m,d+m
            while l<len(arr)+1:
                if arr[j:l]==p:
                    count+=1
                else:
                    break
                if count>=k:
                    return(True)
                    break
                j+=m
                l+=m
            i+=1
            d+=1
        return(False)","class Solution {
 public:
  int dayOfYear(string date) {
    int year = stoi(date.substr(0, 4));
    int month = stoi(date.substr(5, 2));
    int day = stoi(date.substr(8));
    vector<int> days = {
        31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    return accumulate(begin(days), begin(days) + month - 1, 0) + day;
  }

 private:
  bool isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
  }
};"
"class Solution:
    
    @staticmethod
    def process(st, end, cnt_neg, arr):
        if st >= 0 and st <= end and end >= 0:
            if not (cnt_neg % 2):
                return end - st + 1
            first_neg_ind = st 
            last_neg_ind = end
            while(first_neg_ind <= end and arr[first_neg_ind] >= 0):
                first_neg_ind += 1
            while(last_neg_ind >= st and arr[last_neg_ind] >= 0):
                last_neg_ind -= 1
            print((st, end, first_neg_ind, last_neg_ind))
            return max(last_neg_ind - st, end - first_neg_ind)
            
        return 0
    
    def getMaxLen(self, nums: List[int]) -> int:
        prev = 0
        ans = 0
        cnt_neg = 0
        for i in range(len(nums)):
            if not nums[i]:
                ans = max(ans, Solution.process(prev, i-1, cnt_neg, nums))
                prev = i + 1
                cnt_neg = 0
            if nums[i] < 0:
                cnt_neg += 1
        ans = max(ans, Solution.process(prev, len(nums)-1, cnt_neg, nums))
        return ans","class Solution {
 public:
  int numRollsToTarget(int n, int k, int target) {
    constexpr int kMod = 1'000'000'007;
    vector<int> dp(target + 1);
    dp[0] = 1;

    while (n--) {  // N dices
      vector<int> newDp(target + 1);
      for (int i = 1; i <= k; ++i)           // Number 1, 2, ..., f
        for (int t = i; t <= target; ++t) {  // Possible targets
          newDp[t] += dp[t - i];
          newDp[t] %= kMod;
        }
      dp = move(newDp);
    }

    return dp[target];
  }
};"
"class Solution:
    def minDays(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimension 
        grid = """".join("""".join(map(str, x)) for x in grid)
        
        @lru_cache(None)
        def fn(s): 
            """"""Return True if grid is disconnected.""""""
            row, grid = [], []
            for i, c in enumerate(s, 1):
                row.append(int(c))
                if i%n == 0: 
                    grid.append(row)
                    row = []
                    
            def dfs(i, j): 
                """"""""""""
                grid[i][j] = 0
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: dfs(ii, jj)
                return 1
            return sum(dfs(i, j) for i in range(m) for j in range(n) if grid[i][j])
        
        #bfs 
        queue = [grid]
        level = 0 
        seen = {grid}
        while queue: 
            tmp = []
            for node in queue: 
                if fn(node) == 0 or fn(node) >= 2: return level 
                for i in range(m*n):
                    if node[i] == ""1"": 
                        nn = node[:i] + ""0"" + node[i+1:]
                        if nn not in seen: 
                            seen.add(nn)
                            tmp.append(nn)
            queue = tmp
            level += 1","class Solution {
 public:
  int maxRepOpt1(string text) {
    int ans = 0;
    vector<int> count(26);
    vector<pair<char, int>> groups{{text[0], 1}};

    for (char c : text)
      ++count[c - 'a'];

    for (int i = 1; i < text.length(); ++i)
      if (text[i] == text[i - 1])
        ++groups[groups.size() - 1].second;
      else
        groups.emplace_back(text[i], 1);

    for (const auto& [c, length] : groups)
      ans = max(ans, min(length + 1, count[c - 'a']));

    for (int i = 1; i + 1 < groups.size(); ++i)
      if (groups[i - 1].first == groups[i + 1].first && groups[i].second == 1)
        ans = max(ans, min(groups[i - 1].second + groups[i + 1].second + 1,
                           count[groups[i - 1].first - 'a']));

    return ans;
  }
};"
"class Solution:
      

    def numOfWays(self, nums: List[int]) -> int:
        FACT = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 227020758, 178290591, 674358851, 789741546, 425606191, 660911389, 557316307, 146326063, 72847302, 602640637, 860734560, 657629300, 440732388, 459042011, 394134213, 35757887, 36978716, 109361473, 390205642, 486580460, 57155068, 943272305, 14530444, 523095984, 354551275, 472948359, 444985875, 799434881, 776829897, 626855450, 954784168, 10503098, 472639410, 741412713, 846397273, 627068824, 726372166, 318608048, 249010336, 948537388, 272481214, 713985458, 269199917, 75195247, 286129051, 595484846, 133605669, 16340084, 996745124, 798197261, 286427093, 331333826, 536698543, 422103593, 280940535, 103956247, 172980994, 108669496, 715534167, 518459667, 847555432, 719101534, 932614679, 878715114, 661063309, 562937745, 472081547, 766523501, 88403147, 249058005, 671814275, 432398708, 753889928, 834533360, 604401816, 187359437, 674989781, 749079870, 166267694, 296627743, 586379910, 119711155, 372559648, 765725963, 275417893, 990953332, 104379182, 437918130, 229730822, 432543683, 551999041, 407899865, 829485531, 925465677, 24826746, 681288554, 260451868, 649705284, 117286020, 136034149, 371858732, 391895154, 67942395, 881317771, 114178486, 473061257, 294289191, 314702675, 79023409, 640855835, 825267159, 333127002, 640874963, 750244778, 281086141, 979025803, 294327705, 262601384, 400781066, 903100348, 112345444, 54289391, 329067736, 753211788, 190014235, 221964248, 853030262, 424235847, 817254014, 50069176, 159892119, 24464975, 547421354, 923517131, 757017312, 38561392, 745647373, 847105173, 912880234, 757794602, 942573301, 156287339, 224537377, 27830567, 369398991, 365040172, 41386942, 621910678, 127618458, 674190056, 892978365, 448450838, 994387759, 68366839, 417262036, 100021558, 903643190, 619341229, 907349424, 64099836, 89271551, 533249769, 318708924, 92770232, 420330952, 818908938, 584698880, 245797665, 489377057, 66623751, 192146349, 354927971, 661674180, 71396619, 351167662, 19519994, 689278845, 962979640, 929109959, 389110882, 98399701, 89541861, 460662776, 289903466, 110982403, 974515647, 928612402, 722479105, 218299090, 96415872, 572421883, 774063320, 682979494, 693774784, 611379287, 166890807, 880178425, 837467962, 705738750, 616613957, 338771924, 497191232, 896114138, 560652457, 661582322, 224945188, 262995829, 859081981, 857116478, 279856786, 408062844, 406076419, 367193638, 985761614, 767884817, 77737051, 801784560, 410447512, 813374614, 702909132, 777826615, 11426636, 685259446, 721228129, 931065383, 593559607, 860745086, 578819198, 495425745, 893029457, 6156532, 502193801, 37480384, 220174401, 383076669, 3013247, 750298503, 574624441, 230733683, 144887710, 656590378, 773954850, 358485371, 772254339, 469363737, 95843299, 823414273, 87709482, 892174648, 749756145, 185864756, 68295241, 98238739, 131504392, 111672419, 928208089, 687974198, 753032165, 71715287, 506557931, 290314197, 546089425, 174590825, 187067364, 817659471, 309331349, 303445769, 964814732, 112937795, 848457973, 113604679, 263728612, 162653895, 519013648, 956915940, 591788795, 26960558, 818561771, 201473695, 830318534, 283328761, 298655153, 103269519, 567777414, 629890782, 707451727, 528064896, 419467694, 259775012, 452053078, 972081682, 512829263, 412924123, 354780756, 917691336, 648929514, 519218426, 957710940, 848100261, 607279584, 78508462, 651656900, 271922065, 927371945, 976904514, 655633282, 147015495, 44958071, 431540693, 956102180, 821001984, 4640954, 508310043, 709072863, 866824584, 318461564, 773853828, 371761455, 53040744, 609526889, 972452623, 799173814, 723225821, 3874155, 305590228, 289496343, 139259591, 348260611, 756867525, 848691744, 101266155, 835557082, 267191274, 448180160, 518514435, 443022120, 614718802, 151579195, 204297074, 912569551, 137049249, 515433810, 979001276, 524451820, 229298431, 88837724, 892742699, 387369393, 840349900, 206661672, 18186411, 619853562, 246548548, 236767938, 893832644, 930410696, 321544423, 971435684, 402636244, 780681725, 194281388, 661238608, 964476271, 643075362, 439409780, 96895678, 723461710, 915447882, 785640606, 114709392, 933696835, 539582134, 739120141, 300372431, 244129985, 722433522, 26638091, 388855420, 42468156, 647517040, 474194942, 832805846, 958306874, 489519451, 339220689, 9833277, 923477502, 390998217, 790283925, 694135631, 736657340, 609563281, 873127083, 489593220, 264439147, 891171227, 489029295, 502009550, 325923608, 280525558, 857054649, 820622208, 558213940, 216997416, 487921842, 951328535, 606653379, 794417402, 449723904, 783486165, 414645478, 809681447, 114612567, 824953206, 255016498, 147060381, 88903008, 228293174, 394357308, 362355866, 900088886, 638573794, 779598451, 904922263, 451026166, 549459329, 212643744, 563246709, 391796933, 174243175, 189725986, 238337196, 60051478, 782959006, 982673239, 237607992, 685987666, 694447544, 195840153, 519748540, 446086975, 523485236, 185780714, 716004996, 214280883, 140643728, 555470704, 516522055, 116665689, 899547947, 490696549, 683197147, 686671136, 988747143, 744912554, 619072836, 345158054, 224284246, 637879131, 78947725, 342273666, 237716550, 915360466, 711578771, 423071394, 228124918, 271834959, 480779410, 254894593, 859192972, 990202578, 258044399, 151532640, 644862529, 48049425, 448119239, 130306338, 850105179, 401639970, 606863861, 183881380, 837401090, 513536652, 714177614, 946271680, 243293343, 403377310, 688653593, 15447678, 754734307, 631353768, 202296846, 159906516, 912696536, 737140518, 467380526, 896686075, 309895051, 356369955, 461415686, 706245266, 10064183, 183054210, 455971702, 737368289, 956771035, 564163693, 365118309, 226637659, 304857172, 440299843, 717116122, 485961418, 615704083, 476049473, 354119987, 329471814, 620060202, 251964959, 45357250, 175414082, 671119137, 48735782, 122378970, 717506435, 18459328, 949577729, 771970076, 635808197, 608040366, 165916428, 258536202, 902229110, 617090616, 548564593, 613394864, 753777984, 577888302, 416452176, 881599549, 524547188, 599140122, 522765386, 657552586, 256787840, 287613719, 776067801, 597965522, 458655497, 764387515, 350167935, 494713961, 513386012, 576480762, 864589772, 86987059, 495636228, 512647986, 721997962, 982831380, 162376799, 204281975, 462134806, 189646394, 425968575, 209834628, 494248765, 664281698, 947663843, 540352769, 25662122, 986679150, 207298711, 477043799, 24708053, 528335066, 189351697, 717500453, 42764755, 316734785, 823726196, 293357001, 547414377, 258966410, 602945692, 561521296, 351253952, 752369730, 174204566, 871148004, 302242737, 554611874, 540181425, 349941261, 414343943, 921115587, 959388563, 227019335, 708812719, 793380997, 342547759, 324322556, 458370547, 356254978, 809319893, 159690374, 848340820, 971304725, 180230004, 103061704, 207441144, 443272953, 45593686, 541647240, 612817107, 849140508, 109375794, 906749744, 159084460, 541378020, 692284266, 908221578, 720697998, 363923522, 819281897, 701846632, 479994712, 196613531, 29272489, 792937812, 859009553, 202148261, 385627435, 115321267, 612859231, 132778909, 173511339, 782369566, 322583903, 324703286, 31244274, 433755056, 109559692, 871157455, 350443931, 592104988, 197184362, 141678010, 649163959, 746537855, 954594407, 850681817, 703404350, 467293824, 684978431, 565588709, 378843675, 825260479, 749777538, 850502015, 387852091, 412307507, 307565279, 914127155, 864079609, 845970807, 414173935, 638273833, 664477235, 173471099, 480759791, 839694748, 190898355, 956270620, 957911348, 43002811, 628936576, 966234409, 667971950, 236586166, 954211897, 223051884, 21058295, 656573222, 631532535, 809706350, 984734695, 314281677, 311454037, 640732448, 434907794, 175084834, 434807109, 973816812, 488481268, 844735329, 917344075, 314288693, 459259162, 992521062, 667512257, 603748166, 679935673, 833938466, 933875943, 522922384, 981191471, 457854178, 112860028, 484939649, 611363777, 627371454, 844300972, 962501388, 738504183, 631041465, 29224765, 334078303, 211237785, 626057542, 900175080, 728504100, 450509755, 575177363, 905713570, 416609984, 874776027, 334255451, 683287462, 999293262, 474888472, 317020697, 180417613, 591538360, 879151833, 605566485, 569294094, 970567518, 896200922, 943088633, 145735679, 884701203, 949403596, 749113557, 78958680, 850679027, 665376978, 686499745, 426302291, 842343474, 708066168, 962548572, 349652428, 833757979, 492365420, 136639914, 76093131, 591710464, 208764552, 166233017, 498121245, 545840935, 26721664, 736011124, 880639351, 137410283, 42609708, 235572009, 981737748, 718913567, 909319027, 906112184, 298059463, 274736280, 217450848, 351267027, 149682364, 249066734, 11785215, 333890217, 774940233, 302540697, 519852435, 802535369, 620684620, 306323295, 752310997, 848793393, 883503040, 569433124, 254795373, 855478464, 660158704, 87911700, 944741410, 351053939, 2634663, 134077016, 736459220, 4882454, 969435081, 120150411, 922584286, 828772112, 106810765, 371205161, 17024731, 960279329, 389323593, 23991206, 744762405, 684217429, 479374977, 963728237, 3246420, 688035746, 381629444, 752436308, 274567573, 440219140, 702541058, 919238277, 563955926, 467150839, 5249506, 399086000, 833151662, 847391187, 655983283, 337920422, 866913758, 675206635, 549602585, 963783662, 324756002, 393087771, 731515248, 787956453, 550936813, 398161393, 631665856, 442637251, 454846959, 348994181, 88011024, 513458067, 60476466, 9760396, 403700900, 990173371, 519613195, 945797344, 114696834, 327457551, 905694736, 143025346, 289024806, 451579463, 325709522, 18701196, 326143996, 49850509, 619195074, 414881030, 850660769, 880149960, 651809429, 592293509, 810577782, 929598726, 835669318, 731671946, 529667681, 285562083, 293565850, 686472980, 274474950, 282703792, 889076915, 56602629, 546147347, 255724802, 873696194, 831784350, 110556728, 279941051, 667003092, 302778600, 803516696, 772054724, 165410893, 531446229, 958833885, 703493734, 68812272, 481542542, 722167619, 172528691, 173636402, 356397518, 390931659, 311533827, 53449710, 959934024, 259493848, 215350798, 907381983, 791418522, 896453666, 530274270, 443147787, 468552325, 410897594, 491169384, 314015783, 406644587, 772818684, 721371094, 596483817, 922913559, 78344520, 173781169, 485391881, 326797438, 209197264, 227032260, 183290649, 293208856, 909531571, 778733890, 346053132, 674154326, 75833611, 738595509, 449942130, 545136258, 334305223, 589959631, 51605154, 128106265, 85269691, 347284647, 656835568, 934798619, 602272125, 976691718, 647351010, 456965253, 143605060, 148066754, 588283108, 104912143, 240217288, 49898584, 251930392, 868617755, 690598708, 880742077, 200550782, 935358746, 104053488, 348096605, 394187502, 726999264, 278275958, 153885020, 653433530, 364854920, 922674021, 65882280, 762280792, 84294078, 29666249, 250921311, 659332228, 420236707, 614100318, 959310571, 676769211, 355052615, 567244231, 840761673, 557858783, 627343983, 461946676, 22779421, 756641425, 641419708]

        MMI = [0, 1, 500000004, 333333336, 250000002, 400000003, 166666668, 142857144, 125000001, 111111112, 700000005, 818181824, 83333334, 153846155, 71428572, 466666670, 562500004, 352941179, 55555556, 157894738, 850000006, 47619048, 409090912, 739130440, 41666667, 280000002, 576923081, 370370373, 35714286, 758620695, 233333335, 129032259, 281250002, 939393946, 676470593, 628571433, 27777778, 621621626, 78947369, 717948723, 425000003, 658536590, 23809524, 395348840, 204545456, 822222228, 369565220, 404255322, 520833337, 448979595, 140000001, 784313731, 788461544, 56603774, 685185190, 763636369, 17857143, 385964915, 879310351, 50847458, 616666671, 688524595, 564516133, 15873016, 140625001, 30769231, 469696973, 686567169, 838235300, 579710149, 814285720, 98591550, 13888889, 410958907, 310810813, 93333334, 539473688, 831168837, 858974365, 202531647, 712500005, 123456791, 329268295, 84337350, 11904762, 670588240, 197674420, 252873565, 102272728, 415730340, 411111114, 164835166, 184782610, 43010753, 202127661, 231578949, 760416672, 268041239, 724489801, 646464651, 570000004, 940594066, 892156869, 572815538, 394230772, 209523811, 28301887, 224299067, 342592595, 9174312, 881818188, 873873880, 508928575, 893805316, 692982461, 147826088, 939655179, 239316241, 25423729, 478991600, 808333339, 438016532, 844262301, 886178868, 782258070, 856000006, 7936508, 480314964, 570312504, 798449618, 515384619, 190839696, 734848490, 165413535, 843283588, 274074076, 419117650, 58394161, 789855078, 604316551, 407142860, 134751774, 49295775, 832167838, 506944448, 151724139, 705479457, 149659865, 655405410, 530201346, 46666667, 483443712, 269736844, 594771246, 915584422, 625806456, 929487186, 343949047, 601265827, 685534596, 856250006, 962732926, 561728399, 116564418, 664634151, 587878792, 42168675, 5988024, 5952381, 242603552, 335294120, 795321643, 98837210, 791907520, 626436786, 325714288, 51136364, 683615824, 207865170, 435754193, 205555557, 933701664, 82417583, 562841534, 92391305, 524324328, 521505380, 577540111, 601063834, 338624341, 615789478, 439790579, 380208336, 694300523, 634020623, 343589746, 862244904, 969543154, 823232329, 507537692, 285000002, 228855723, 470297033, 108374385, 946078438, 131707318, 286407769, 526570052, 197115386, 832535891, 604761909, 90047394, 514150947, 32863850, 612149537, 79069768, 671296301, 875576043, 4587156, 470319638, 440909094, 950226251, 436936940, 125560539, 754464291, 364444447, 446902658, 35242291, 846491234, 711790398, 73913044, 277056279, 969827593, 90128756, 619658124, 880851070, 512711868, 67510549, 239495800, 280334730, 904166673, 406639007, 219008266, 707818935, 922131154, 89795919, 443089434, 165991904, 391129035, 28112450, 428000003, 912350604, 3968254, 339920951, 240157482, 556862749, 285156252, 70038911, 399224809, 517374521, 757692313, 417624524, 95419848, 836501907, 367424245, 611320759, 582706771, 138576780, 421641794, 743494429, 137037038, 450184505, 209558825, 388278391, 529197084, 752727278, 394927539, 252707583, 802158279, 681003589, 203571430, 718861215, 67375887, 650176683, 524647891, 77192983, 416083919, 808362375, 253472224, 961937723, 575862073, 756013751, 852739732, 522184304, 574829936, 210169493, 327702705, 215488217, 265100673, 441471575, 523333337, 770764125, 241721856, 646864691, 134868422, 137704919, 297385623, 749185673, 457792211, 857605184, 312903228, 787781356, 464743593, 492012783, 671974527, 403174606, 800632917, 652996850, 342767298, 614420067, 428125003, 741433027, 481366463, 597523224, 780864203, 406153849, 58282209, 3058104, 832317079, 343465048, 293939396, 631419944, 521084341, 624624629, 2994012, 737313438, 502976194, 41543027, 121301776, 631268441, 167647060, 284457480, 897660825, 206997086, 49418605, 715942034, 395953760, 985590785, 313218393, 521489975, 162857144, 413105416, 25568182, 175637395, 341807912, 19718310, 103932585, 826330538, 717877100, 713091927, 602777782, 113573408, 466850832, 812672182, 541208795, 882191787, 281420767, 376021801, 546195656, 295392956, 262162164, 436657685, 260752690, 16085791, 788770059, 618666671, 300531917, 212201593, 669312174, 195250661, 307894739, 160104988, 719895293, 172323761, 190104168, 966233773, 847150265, 932816544, 817010315, 951156819, 171794873, 102301791, 431122452, 63613232, 484771577, 840506335, 911616168, 760705295, 253768846, 55137845, 142500001, 855361602, 614427865, 779156333, 735148520, 424691361, 554187196, 238329240, 473039219, 188264060, 65853659, 352798056, 643203888, 578692498, 263285026, 16867470, 98557693, 534772186, 916267949, 844868741, 802380958, 966745850, 45023697, 44917258, 757075477, 134117648, 16431925, 526932088, 806074772, 610722615, 39534884, 761020887, 835648154, 614318711, 937788025, 50574713, 2293578, 354691078, 235159819, 642369025, 220454547, 716553293, 975113129, 88036118, 218468470, 83146068, 562780273, 176733782, 877232149, 285077953, 682222227, 605321512, 223451329, 161147904, 517621149, 432967036, 423245617, 172866522, 355895199, 198257082, 36956522, 321041217, 638528143, 820734347, 984913800, 208602152, 45064378, 775160605, 309829062, 240938168, 440425535, 447983018, 256355934, 763213536, 533755278, 646315794, 119747900, 228511532, 140167365, 206680586, 952083340, 355509358, 703319507, 654244311, 109504133, 653608252, 853909471, 607802879, 461065577, 38854806, 544897963, 641547866, 221544717, 632860045, 82995952, 529292933, 695564521, 156941651, 14056225, 266533068, 714000005, 1996008, 456175302, 282306165, 1984127, 588118816, 669960479, 747534522, 120078741, 491159139, 778431378, 344422703, 142578126, 598440550, 535019459, 314563109, 699612408, 400386850, 758687264, 597302509, 878846160, 191938581, 208812262, 921606125, 47709924, 441904765, 918250957, 301707782, 683712126, 510396979, 805660383, 561205277, 791353389, 589118203, 69288390, 844859819, 210820897, 811918069, 871747218, 404452693, 68518519, 60998152, 725092256, 311233888, 604779416, 801834868, 694139199, 541133459, 264598542, 854280516, 376363639, 39927405, 697463773, 457504524, 626353795, 174774776, 901079143, 457809698, 840501798, 491949914, 101785715, 525846706, 859430611, 433392543, 533687947, 578761066, 825088345, 446208116, 762323949, 732864680, 538596495, 334500878, 708041963, 813263531, 904181191, 229565219, 126736112, 771230508, 980968865, 898100179, 787931040, 869191056, 878006879, 732418530, 426369866, 447863251, 261092152, 724020448, 287414968, 585738544, 605084750, 656514387, 663851356, 160202362, 607744112, 95798320, 632550340, 835845902, 720735791, 410684477, 761666672, 296173047, 885382066, 76285241, 120860928, 887603312, 823432349, 729818786, 67434211, 36124795, 568852463, 492635028, 648692815, 696574230, 874592840, 377235775, 728896109, 716369535, 428802592, 953150249, 156451614, 842190022, 393890678, 630818624, 732371800, 571200004, 746006395, 944178635, 835987267, 36565978, 201587303, 438985740, 900316462, 30015798, 326498425, 696062997, 171383649, 880690744, 807210037, 677621288, 714062505, 720748835, 870716517, 43545879, 740683235, 359689925, 298761612, 119010820, 890432105, 640986137, 703076928, 291858681, 529141108, 29096478, 1529052, 438167942, 916158543, 823439884, 171732524, 698027319, 146969698, 216338882, 315709972, 983408755, 760542174, 33082707, 812312318, 163418292, 1497006, 41853513, 368656719, 62593145, 251488097, 493313525, 520771517, 454814818, 60650888, 320531760, 815634224, 609720181, 83823530, 345080766, 142228740, 530014645, 948830416, 411678835, 103498543, 237263466, 524709306, 927431066, 357971017, 444283650, 197976880, 92352093, 992795396, 520863313, 656609200, 862266864, 760744991, 696709590, 81428572, 489301002, 206552708, 85348507, 12784091, 626950359, 587818701, 991513444, 170903956, 385049368, 9859155, 355836852, 551966296, 701262277, 413165269, 366433569, 358938550, 93444910, 856545967, 318497916, 301388891, 224687935, 56786704, 802213007, 233425416, 630344832, 406336091, 696011009, 770604401, 235939645, 941095897, 729138172, 640710387, 66848568, 688010904, 29931973, 273097828, 698778838, 147696478, 538565633, 131081082, 721997306, 718328846, 590847918, 130376345, 506040272, 508042899, 676037488, 894385033, 889185587, 809333339, 215712385, 650265962, 304116868, 606100800, 896688748, 334656087, 952443864, 597625334, 779973655, 653947373, 582128782, 80052494, 1310616, 859947650, 518954252, 586161884, 850065195, 95052084, 855656703, 983116890, 690012975, 923575136, 648124196, 466408272, 525161294, 908505161, 839124845, 975578413, 613607193, 585897440, 645326509, 551150899, 805874846, 215561226, 868789815, 31806616, 419313853, 742385792, 278833969, 920253171, 841972193, 455808084, 822194205, 880352651, 537106922, 126884423, 877038902, 527568926, 964956202, 571250004, 46192260, 427680801, 764632633, 807213936, 592546588, 889578170, 581164812, 367574260, 102595798, 712345684, 755856972, 277093598, 816728173, 119164620, 223312885, 736519613, 73439413, 94132030, 462759466, 532926833, 618757617, 176399028, 52247874, 321601944, 917575764, 289346249, 617896014, 131642513, 712907122, 8433735, 84235861, 549278850, 496998803, 267386093, 601197609, 958133978, 560334532, 922434374, 696066751, 401190479, 853745547, 483372925, 239620405, 522511852, 848520716, 22458629, 348288078, 878537742, 216725561, 67058824, 722679206, 508215966, 690504108, 263466044, 359064330, 403037386, 792298722, 805361311, 67520373, 19767442, 269454125, 880510447, 718424107, 417824077, 158381504, 807159359, 987312579, 968894016, 200230151, 525287360, 360505169, 1146789, 918671255, 177345539, 265142859, 617579913, 891676175, 821184516, 840728106, 610227277, 759364364, 858276650, 612684036, 987556568, 736723169, 44018059, 559188279, 109234235, 497187855, 41573034, 738496077, 781390140, 705487127, 88366891, 287150840, 938616078, 813823863, 642538980, 314794218, 841111117, 591564932, 302660756, 256921375, 611725668, 786740337, 80573952, 324145537, 758810578, 882288235, 216483518, 963776077, 711622812, 371303398, 86433261, 712568311, 677947603, 741548533, 99128541, 41349293, 18478261, 916395229, 660520612, 776814740, 819264075, 304864867, 910367177, 952535066, 492456900, 252960174, 104301076, 23630505, 22532189, 595927121, 887580306, 515508025, 154914531, 16008538, 120469084, 164004261, 720212771, 568544106, 223991509, 115588548, 128177967, 467724871, 381606768, 551214365, 266877639, 262381456, 323157897, 884332288, 59873950, 383001052, 114255766, 687958120, 570083686, 204806689, 103340293, 8342023, 476041670, 746097820, 177754679, 580477678, 851659757, 338860106, 827122159, 260599795, 554752070, 199174408, 326804126, 669412981, 926954739, 943473799, 803901443, 468717952, 730532792, 584442174, 19427403, 492339125, 772448985, 1019368, 320773933, 399796544, 610772362, 793908635, 816430026, 447821685, 41497976, 17189080, 764646470, 172552978, 847782264, 877139986, 578470829, 901507544, 507028116, 911735212, 133266534, 874874881, 857000006]
        n = len(nums)
        lis = [0] * n
        def count(subnums):
            nonlocal lis
            if subnums:
                low = [num for num in subnums if num < subnums[0]]
                high = [num for num in subnums if num > subnums[0]]
                lis[subnums[0]-1] = len(subnums)
                count(low)
                count(high)
        
        count(nums)




        M = 10 ** 9 + 7
        denum = 1
        for k in range(1,n+1):
            denum = (denum * MMI[lis[k-1]]) % M
        return (FACT[n] * denum) % M - 1","class Solution {
 public:
  int countCharacters(vector<string>& words, string chars) {
    int ans = 0;
    vector<int> count(26);

    for (const char c : chars)
      ++count[c - 'a'];

    for (const string& word : words) {
      vector<int> tempCount(count);
      for (const char c : word)
        if (--tempCount[c - 'a'] < 0) {
          ans -= word.length();
          break;
        }
      ans += word.length();
    }

    return ans;
  }
};"
"class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        
        n = len(mat)
        
        diagonal_sum = 0
        
        for i in range(n):
            diagonal_sum += mat[i][i]
            
			# Before adding the element for the second diagonal, 
			# make sure we are not in the middle element
            if n - i != i + 1: 
                diagonal_sum += mat[i][-i - 1]
        
        return diagonal_sum","class Solution {
 public:
  int maxLevelSum(TreeNode* root) {
    int ans = 1;
    int maxLevelSum = INT_MIN;
    queue<TreeNode*> q{{root}};

    for (int level = 1; !q.empty(); ++level) {
      int levelSum = 0;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        levelSum += node->val;
        if (node->left != nullptr)
          q.push(node->left);
        if (node->right != nullptr)
          q.push(node->right);
      }
      if (maxLevelSum < levelSum) {
        maxLevelSum = levelSum;
        ans = level;
      }
    }

    return ans;
  }
};"
"class Solution:
    def numWays(self, s: str) -> int:
        n = len(s)
        mod = 10**9+7
        numOnes = [0]*n
        numOnes[0] = 1 if s[0] == '1' else 0
        
        for i, ch in enumerate(s[1:]):
            numOnes[i+1] += numOnes[i]
            if ch == '1':
                numOnes[i+1] += 1
            i += 1

        if numOnes[-1]%3 != 0:
            return 0
        elif numOnes[-1] == 0:
            return ((n - 1)*(n-2)%mod)//2
        else:
			# get the required number of ones in each partition
            val = numOnes[-1]//3
        
        multiples = [val*1, val*2] # values to be counted in 'numOnes' array
        
        res = 1
        for multiple in multiples:
            res = res*numOnes.count(multiple)%mod
        
        return res","class Solution {
 public:
  int maxDistance(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<pair<int, int>> q;
    int water = 0;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 0)
          ++water;
        else
          q.emplace(i, j);

    if (water == 0 || water == m * n)
      return -1;

    int ans = 0;

    for (int d = 0; !q.empty(); ++d)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        ans = d;
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (grid[x][y] > 0)
            continue;
          q.emplace(x, y);
          grid[x][y] = 2;  // Mark as visited.
        }
      }

    return ans;
  }
};"
"class Solution:
    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:
        lo = next((i for i in range(len(arr)-1) if arr[i] > arr[i+1]), None)
        hi = next((i for i in reversed(range(1, len(arr))) if arr[i-1] > arr[i]), None)
        if lo is None: return 0 
        
        ll = bisect_right(arr, arr[hi], 0, lo+1)
        rr = bisect_left(arr, arr[lo], hi, len(arr))
        
        return min(hi - ll, rr - lo - 1)","class Solution {
 public:
  string lastSubstring(string s) {
    int i = 0;
    int j = 1;
    int k = 0;  // Number of same characters of s[i:] and s[j:]

    while (j + k < s.length()) {
      if (s[i + k] == s[j + k]) {
        ++k;
      } else if (s[i + k] > s[j + k]) {
        // Now s[i:i + k] == s[j:j + k] and s[i + k] > s[j + k] means that
        // We should start from s[j + k] to find a possible larger substring
        j += k + 1;
        k = 0;
      } else {
        // Now s[i:i + k] == s[j:j + k] and s[i + k] < s[j + k] means that
        // Either starting from s[i + k + 1] or s[j] has a larger substring
        i = max(i + k + 1, j);
        j = i + 1;
        k = 0;
      }
    }

    return s.substr(i);
  }
};"
"class Solution:
    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:
        # start = initial index
        # end = destination index     

        MOD = (10**9)+7 
        lenLocations = len(locations)

        @cache
        def dfs(index, fuel):
            # If you have no more fuel and you're at destination:
            # You cannot try another other routes, return 1 because you're at destination
            if fuel == 0 and index == finish:
                return 1

            # If no more fuel and not at route:
            # You cannot try another other routes, return 1 because you're not at destination
            if fuel <= 0:
                return 0
            
            # If your current index is destination index, you found an existing route
            countWays = 1 if index == finish else 0

            # Try every location index (dfs), but you cannot stay at your current index
            for nextIndex in range(len(locations)):
                if index != nextIndex:
                    cost = abs(locations[index]-locations[nextIndex])
                    countWays += dfs(nextIndex,fuel-cost)

            return countWays

        return dfs(start,fuel) % MOD","class Solution {
 public:
  int connectSticks(vector<int>& sticks) {
    int ans = 0;
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int stick : sticks)
      minHeap.push(stick);

    while (minHeap.size() > 1) {
      const int x = minHeap.top();
      minHeap.pop();
      const int y = minHeap.top();
      minHeap.pop();
      ans += x + y;
      minHeap.push(x + y);
    }

    return ans;
  }
};"
"class Solution:
    def modifyString(self, s: str) -> str:
        if len(s) == 1 and s[0] != '?':
            return s[0]
        elif len(s) == 1 and s[0] == '?':
            return 'a'
        else:
            x = {'a','b','c'}
            res = ''
            for i in range(len(s)):
                if s[i] == '?':
                    if i == 0:
                        res += list(x.difference(set(s[i+1])))[0]
                    elif i == len(s)-1:
                        res += list(x.difference(set([s[i-1],res[i-1]])))[0]
                    else:
                        res += list(x.difference(set([s[i-1],s[i+1],res[i-1]])))[0]
                else:
                    res += s[i]
            return res","class Solution {
 public:
  int minCostToSupplyWater(int n, vector<int>& wells,
                           vector<vector<int>>& pipes) {
    int ans = 0;
    using P = pair<int, int>;
    vector<vector<P>> graph(n + 1);
    priority_queue<P, vector<P>, greater<>> minHeap;  // (d, u)

    for (const vector<int>& pipe : pipes) {
      const int u = pipe[0];
      const int v = pipe[1];
      const int w = pipe[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    // Connect virtual 0 with node 1 to n.
    for (int i = 0; i < n; ++i) {
      graph[0].emplace_back(i + 1, wells[i]);
      minHeap.emplace(wells[i], i + 1);
    }

    unordered_set<int> mst{{0}};

    while (mst.size() < n + 1) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      if (mst.count(u))
        continue;
      // Add the new vertex.
      mst.insert(u);
      ans += d;
      // Expand if possible.
      for (const auto [v, w] : graph[u])
        if (!mst.count(v))
          minHeap.emplace(w, v);
    }

    return ans;
  }
};"
"class Solution:
    # two-sum. search for nums1[i]^2/nums2[k]
    # O(mn) time : O(m + n) space
    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        def count(arr1, arr2):
            res = 0
            for n1 in arr1:
                n2_freq = defaultdict(int)
                for n2 in arr2:
                    if n1*n1 / n2 in n2_freq:
                        res += n2_freq[n1*n1 / n2]
                    n2_freq[n2] += 1
            return res
        return count(nums1, nums2) + count(nums2, nums1)","struct Trans {
  string name;
  int time;
  int amount;
  string city;
};

class Solution {
 public:
  vector<string> invalidTransactions(vector<string>& transactions) {
    vector<string> ans;
    unordered_map<string, vector<Trans>> nameToTranses;

    for (const string& t : transactions) {
      const Trans trans = getTrans(t);
      nameToTranses[trans.name].push_back(trans);
    }

    for (const string& t : transactions) {
      const Trans currTrans = getTrans(t);
      if (currTrans.amount > 1000) {
        ans.push_back(t);
      } else if (const auto it = nameToTranses.find(currTrans.name);
                 it != cend(nameToTranses)) {
        // Iterate through all transactions w/ the same name,
        // Check if within 60 minutes in a different city
        for (Trans trans : it->second)
          if (abs(trans.time - currTrans.time) <= 60 &&
              trans.city != currTrans.city) {
            ans.push_back(t);
            break;
          }
      }
    }

    return ans;
  }

 private:
  Trans getTrans(const string& t) {
    istringstream iss(t);
    vector<string> s(4, """");
    for (int i = 0; getline(iss, s[i++], ',');)
      ;
    return {s[0], stoi(s[1]), stoi(s[2]), s[3]};
  }
};"
"class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        
        consecutives = dict()
        
        i = 1
        prev = colors[0]
        count = 0
        while i < len(colors):
            if colors[i] == prev:
                if count not in consecutives:
                    consecutives[count] = [neededTime[i-1]]
                consecutives[count].append(neededTime[i])
            else:
                prev = colors[i]
                count +=1
            i+=1

        sum_ = 0
        for list_ in consecutives.values():
            if len(list_) == 1:
                sum_ += list_[0]
            else:
                max_ = 0
                for i in list_:
                    sum_+=i
                    max_ = max(max_, i)
                sum_ -= max_
        return sum_","class Solution {
 public:
  vector<int> numSmallerByFrequency(vector<string>& queries,
                                    vector<string>& words) {
    vector<int> ans;
    vector<int> wordsFreq;

    for (const string& word : words)
      wordsFreq.push_back(f(word));
    sort(begin(wordsFreq), end(wordsFreq));

    for (const string& query : queries) {
      const int freq = f(query);
      ans.push_back(end(wordsFreq) -
                    upper_bound(begin(wordsFreq), end(wordsFreq), freq));
    }

    return ans;
  }

 private:
  int f(const string& word) {
    int count = 0;
    char currentChar = 'z' + 1;

    for (const char c : word)
      if (c < currentChar) {
        currentChar = c;
        count = 1;
      } else if (c == currentChar) {
        ++count;
      }

    return count;
  }
};"
"class Solution:
    def numSpecial(self, mat: List[List[int]]) -> int:
        ans, m, n = 0, len(mat), len(mat[0])
        row, col = [0] * m, [0] * n
        for i in range(m):
            for j in range(n):
                row[i] += mat[i][j]
                col[j] += mat[i][j]
        for i in range(m):
            for j in range(n):
                if mat[i][j] and row[i] == 1 and col[j] == 1: ans += 1; break
        return ans","class Solution {
 public:
  ListNode* removeZeroSumSublists(ListNode* head) {
    ListNode dummy(0, head);
    int prefix = 0;
    unordered_map<int, ListNode*> prefixToNode;
    prefixToNode[0] = &dummy;

    for (; head; head = head->next) {
      prefix += head->val;
      prefixToNode[prefix] = head;
    }

    prefix = 0;

    for (head = &dummy; head; head = head->next) {
      prefix += head->val;
      head->next = prefixToNode[prefix]->next;
    }

    return dummy.next;
  }
};"
"class Solution:
    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:
        prefDict = {i:preferences[i] for i in range(n)}
        res = set()
        for i, (x1,y1) in enumerate(pairs):
            for j, (x2,y2) in enumerate(pairs):
                if i != j:
                    if prefDict[x1].index(y2) < prefDict[x1].index(y1): # smaller index means higher preference
                        if prefDict[y2].index(x1) < prefDict[y2].index(x2):
                            res.add(x1)
                    if prefDict[x1].index(x2) < prefDict[x1].index(y1):
                        if prefDict[x2].index(x1) < prefDict[x2].index(y2):
                            res.add(x1)
                    if prefDict[y1].index(x2) < prefDict[y1].index(x1):
                        if prefDict[x2].index(y1) < prefDict[x2].index(y2):
                            res.add(y1)
                    if prefDict[y1].index(y2) < prefDict[y1].index(x1):
                        if prefDict[y2].index(y1) < prefDict[y2].index(x2):
                            res.add(y1)
        return len(res)","class Solution {
 public:
  int numPrimeArrangements(int n) {
    constexpr int kMod = 1'000'000'007;
    const int count = countPrimes(n);
    return (factorial(count, kMod) * factorial(n - count, kMod)) % kMod;
  }

 private:
  int countPrimes(int n) {
    vector<bool> prime(n + 1, true);
    prime[0] = false;
    prime[1] = false;

    for (int i = 0; i <= sqrt(n); ++i)
      if (prime[i])
        for (int j = i * i; j <= n; j += i)
          prime[j] = false;

    return count(begin(prime), end(prime), true);
  }

  long factorial(int n, const int kMod) {
    long fact = 1;
    for (int i = 1; i <= n; ++i)
      fact = fact * i % kMod;
    return fact;
  }
};"
"class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        graph = {}
        self.create_graph(points, graph)
        print(graph)
        visited = {0}
        min_heap = MinHeap(graph[0])

        result = 0

        while len(visited) < len(points):
            cost, vertex = min_heap.remove()
            if vertex not in visited:
                visited.add(vertex)
                result += cost
                
                if vertex not in graph:
                    continue
                
                for i in graph[vertex]:
                    cost, node = i
                    if node not in visited:
                        min_heap.insert((cost, node))

        return result
        
    def create_graph(self, points, graph):
        for point in range(len(points)):
            graph[point] = []
        
        for i in range(len(points) - 1):
            # can be with -1 or without
            for j in range(i + 1, len(points)):
                curr_point = points[i]
                next_point = points[j]
                result = self.difference(curr_point[0], curr_point[1],
                                        next_point[0], next_point[1])
                    
                graph[i].append((result, j))
                graph[j].append((result, i))
    
    
    def difference(self, a, b, c, d):
        return abs(a - c) + abs(b - d)
     

class MinHeap:
    def __init__(self, arr):
        self.heap = self.buildHeap(arr)
    
    def check(self):
        return len(self.heap) == 0
    
    def buildHeap(self, arr):
        parentIdx = (len(arr) - 2) // 2
        for i in reversed(range(parentIdx + 1)):
            self.siftDown(i, len(arr) - 1, arr)
        return arr
    
    def peek(self):
        return self.heap[0]
    
    def remove(self):
        to_remove = self.heap[0]
        node = self.heap.pop()
        if len(self.heap) > 0:
            self.heap[0] = node
            self.siftDown(0, len(self.heap) - 1, self.heap)
        return to_remove
    
    def insert(self, value):
        self.heap.append(value)
        self.siftUp()
    
    def siftDown(self, idx, length, arr):
        idxOne = idx * 2 + 1
        while idxOne <= length:
            idxTwo = idx * 2 + 2 if idx * 2 + 2 <= length else -1
            if idxTwo != -1 and arr[idxOne][0] > arr[idxTwo][0]:
                swap = idxTwo
            else:
                swap = idxOne
            
            if arr[swap][0] < arr[idx][0]:
                self.swapValues(swap, idx, arr)
                idx = swap
                idxOne = idx * 2 + 1
            else:
                return
    
    def swapValues(self, i, j, arr):
        arr[i], arr[j] = arr[j], arr[i]
    
    def siftUp(self):
        idx = len(self.heap) - 1
        while idx > 0:
            parentIdx = (idx - 1) // 2
            if self.heap[idx][0] < self.heap[parentIdx][0]:
                self.swapValues(idx, parentIdx, self.heap)
                idx = parentIdx
            else:
                return","class Solution {
 public:
  vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {
    vector<bool> ans;
    vector<int> dp(s.length() + 1);

    for (int i = 1; i <= s.length(); ++i)
      dp[i] = dp[i - 1] ^ 1 << s[i - 1] - 'a';

    for (const vector<int>& query : queries) {
      const int odds = __builtin_popcount(dp[query[1] + 1] ^ dp[query[0]]);
      ans.push_back(odds / 2 <= query[2]);
    }

    return ans;
  }
};"
"class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if sorted(s) != sorted(t): return False # edge case 
        
        pos = [deque() for _ in range(10)]
        for i, ss in enumerate(s): pos[int(ss)].append(i)
            
        for tt in t: 
            i = pos[int(tt)].popleft()
            for ii in range(int(tt)): 
                if pos[ii] and pos[ii][0] < i: return False # cannot swap 
        return True","class Solution {
 public:
  vector<int> findNumOfValidWords(vector<string>& words,
                                  vector<string>& puzzles) {
    vector<int> ans;
    unordered_map<int, int> binaryCount;

    for (const string& word : words) {
      int mask = 0;
      for (char c : word)
        mask |= 1 << c - 'a';
      ++binaryCount[mask];
    }

    for (const string& puzzle : puzzles) {
      int valid = 0;
      const int n = puzzle.length() - 1;
      for (int i = 0; i < (1 << n); ++i) {
        int mask = 1 << puzzle[0] - 'a';
        for (int j = 0; j < n; ++j)
          if (i & 1 << j)
            mask |= 1 << puzzle[j + 1] - 'a';
        if (const auto it = binaryCount.find(mask); it != cend(binaryCount))
          valid += it->second;
      }
      ans.push_back(valid);
    }

    return ans;
  }
};"
"class Solution:
    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:
        chg = [0]*len(nums) # change 
        for i, j in requests: 
            chg[i] += 1
            if j+1 < len(nums): chg[j+1] -= 1
        for i in range(1, len(nums)): chg[i] += chg[i-1] # cumulated change
        return sum(n*c for n, c in zip(sorted(nums), sorted(chg))) % 1_000_000_007","class Solution {
 public:
  vector<string> beforeAndAfterPuzzles(vector<string>& phrases) {
    set<string> ans;
    unordered_map<string, set<string>> firstWordToLasts;
    unordered_map<string, set<string>> lastWordToFirsts;

    for (const string& phrase : phrases) {
      const int firstSpaceIndex = phrase.find(' ');
      const int lastSpaceIndex = phrase.rfind(' ');
      // Index after firstWord.
      const int i =
          firstSpaceIndex == string::npos ? phrase.length() : firstSpaceIndex;
      // Index of lastWord.
      const int j = lastSpaceIndex == string::npos ? 0 : lastSpaceIndex + 1;
      const string firstWord = phrase.substr(0, i);
      const string lastWord = phrase.substr(j);

      // Concatenate `phrase` w/ `last` having the same `firstWord`.
      if (const auto it = firstWordToLasts.find(lastWord);
          it != cend(firstWordToLasts))
        for (const string& last : it->second)
          ans.insert(phrase + last);

      // Concatenate `first` having the same `lastWord` w/ `phrase`.
      if (const auto it = lastWordToFirsts.find(firstWord);
          it != cend(lastWordToFirsts))
        for (const string& first : it->second)
          ans.insert(first + phrase);

      // e.g. ""a b c"" -> {""a"": "" b c""}
      //          ""a"" -> {""a"": """"}
      firstWordToLasts[firstWord].insert(phrase.substr(i));

      // e.g. ""a b c"" -> {""c"": ""a b ""}
      //          ""a"" -> {""a"": """"}
      lastWordToFirsts[lastWord].insert(phrase.substr(0, j));
    }

    return {begin(ans), end(ans)};
  }
};"
"class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        target = sum(nums) % p # targetted remainder 
        ans = inf
        seen = {(prefix := 0): -1}
        for i, x in enumerate(nums): 
            seen[(prefix := (prefix+x)%p)] = i # update seen before check 
            if (prefix-target) % p in seen: 
                ans = min(ans, i - seen[(prefix-target) % p])
        return ans if ans < len(nums) else -1 # not allowed to remove whole array","class Solution {
 public:
  vector<int> shortestDistanceColor(vector<int>& colors,
                                    vector<vector<int>>& queries) {
    constexpr int kNumColor = 3;
    const int n = colors.size();
    vector<int> ans;
    // left[i][c] := closest index of color c in index i to the left.
    vector<vector<int>> left(n, vector<int>(kNumColor + 1));
    // right[i][c] := closest index of color c in index i to the right.
    vector<vector<int>> right(n, vector<int>(kNumColor + 1));

    vector<int> colorToClosestIndex{0, -1, -1, -1};  // 0-indexed, -1 means N/A
    for (int i = 0; i < n; ++i) {
      colorToClosestIndex[colors[i]] = i;
      for (int c = 1; c <= kNumColor; ++c)
        left[i][c] = colorToClosestIndex[c];
    }

    colorToClosestIndex = {0, -1, -1, -1};  // Reset.
    for (int i = n - 1; i >= 0; --i) {
      colorToClosestIndex[colors[i]] = i;
      for (int c = 1; c <= kNumColor; ++c)
        right[i][c] = colorToClosestIndex[c];
    }

    for (const vector<int>& query : queries) {
      const int i = query[0];
      const int c = query[1];
      const int leftDist = left[i][c] == -1 ? INT_MAX : i - left[i][c];
      const int rightDist = right[i][c] == -1 ? INT_MAX : right[i][c] - i;
      const int minDist = min(leftDist, rightDist);
      ans.push_back(minDist == INT_MAX ? -1 : minDist);
    }

    return ans;
  }
};"
"class Solution(object):
    def isPrintable(self, targetGrid):
        """"""
        :type targetGrid: List[List[int]]
        :rtype: bool
        """"""
#doing reverse engineering like toposort concept find that reactangle which is completely independent,and remove and process futher
        m,n=len(targetGrid),len(targetGrid[0])
        # strore upper,left,right,bottom most for every color
        colors={}
        for i in range(m):
            for j in range(n):
                c=targetGrid[i][j]
                if c not in colors:
                    colors[c]=[sys.maxsize,sys.maxsize,-1*sys.maxsize,-1*sys.maxsize]
                colors[c][0]=min(colors[c][0],i)
                colors[c][1]=min(colors[c][1],j)
                colors[c][2]=max(colors[c][2],j)
                colors[c][3]=max(colors[c][3],i)
        # print(colors)
        # this is for check is it possible to fill with this color or not
        def isPossibleTofill(color):
            upper,left,right,bottom=colors[color]
            for i in range(upper,bottom+1):
                for j in range(left,right+1):
                    if targetGrid[i][j]>0 and targetGrid[i][j]!=color:return False
            for i in range(upper,bottom+1):
                for j in range(left,right+1):
                    targetGrid[i][j]=0
            return True
                                 
        c1=colors.keys()
        while c1:
            c2=set()
            for col in c1:
                if isPossibleTofill(col)==False:
                    c2.add(col)
            if len(c2)==len(c1):return False
            c1=c2
        if len(c1)==0:return True
        return False","class Solution {
 public:
  int maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes) {
    int ans = 0;
    vector<vector<int>> submatrix(sideLength, vector<int>(sideLength));
    priority_queue<int> maxHeap;

    for (int i = 0; i < width; ++i)
      for (int j = 0; j < height; ++j)
        ++submatrix[i % sideLength][j % sideLength];

    for (const vector<int>& row : submatrix)
      for (const int a : row)
        maxHeap.push(a);

    for (int i = 0; i < maxOnes; ++i)
      ans += maxHeap.top(), maxHeap.pop();

    return ans;
  }
};"
"class Solution:
    def reorderSpaces(self, text: str) -> str:
        space = text.count(' ')                            # count how many space in total
        text = [word for word in text.split(' ') if word]  # split text to individual word in a list
        n = len(text)                                      # count total words
        if n == 1: return text[0] + space * ' '            # length == 1 is a special case, since no space in between only at the end
        avg, reminder = divmod(space, n-1)                 # get average space between words and spaces left (will be appended the end)
        return (' '*avg).join(text) + ' ' * reminder       # compose result","class Solution {
 public:
  int distanceBetweenBusStops(vector<int>& distance, int start,
                              int destination) {
    int clockwise = 0;
    int counterclockwise = 0;

    if (start > destination)
      swap(start, destination);

    for (int i = 0; i < distance.size(); ++i) {
      if (i >= start && i < destination)
        clockwise += distance[i];
      else
        counterclockwise += distance[i];
    }

    return min(clockwise, counterclockwise);
  }
};"
"class Solution:
    def maxUniqueSplit(self, s: str) -> int:
        strings = set()
        self.max_len = 0
        def split(s) :
            if not s :
                self.max_len = max(self.max_len, len(strings)) 
                return 
            
            for i in range(1,len(s)+1) :
                cs = s[:i] 
                if cs not in strings :
                    strings.add(cs)
                    split(s[i:])
                    strings.remove(cs)
                    
                        
        split(s)
        
        return self.max_len","class Solution {
 public:
  string dayOfTheWeek(int day, int month, int year) {
    vector<string> week = {""Sunday"",   ""Monday"", ""Tuesday"", ""Wednesday"",
                           ""Thursday"", ""Friday"", ""Saturday""};
    vector<int> days = {
        31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int count = 0;

    for (int i = 1971; i < year; ++i)
      count += i % 4 == 0 ? 366 : 365;
    for (int i = 0; i < month - 1; ++i)
      count += days[i];
    count += day;

    return week[(count + 4) % 7];
  }

 private:
  bool isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
  }
};"
"class Solution:
def maxProductPath(self, grid: List[List[int]]) -> int:
    
    MOD = 10**9+7
    m,n = len(grid),len(grid[0])
    dp = [[[0,0] for _ in range(n)] for _ in range(m)]
    dp[0][0][0]=grid[0][0]
    dp[0][0][1]=grid[0][0]
    for i in range(1,m):                     #First Column
        dp[i][0][0] = dp[i-1][0][0]*grid[i][0]
        dp[i][0][1] = dp[i-1][0][1]*grid[i][0]
    
    for j in range(1,n):                     #First Row
        dp[0][j][0] = dp[0][j-1][0]*grid[0][j]
        dp[0][j][1] = dp[0][j-1][1]*grid[0][j]
    
    for i in range(1,m):
        for j in range(1,n):
            if grid[i][j]<0:
                dp[i][j][0] = min(dp[i][j-1][1],dp[i-1][j][1])*grid[i][j]
                dp[i][j][1] = max(dp[i][j-1][0],dp[i-1][j][0])*grid[i][j]
            else:
                dp[i][j][0] = max(dp[i][j-1][0],dp[i-1][j][0])*grid[i][j]
                dp[i][j][1] = min(dp[i][j-1][1],dp[i-1][j][1])*grid[i][j]
    
    if dp[-1][-1][0]<0 and dp[-1][-1][1]<0:
        return -1
    
    return max(dp[-1][-1][0],dp[-1][-1][1])%MOD","class Solution {
 public:
  // Very similar to 53. Maximum Subarray
  int maximumSum(vector<int>& arr) {
    // dp[0][i] := max sum subarray ending w/ i (no deletion)
    // dp[1][i] := max sum subarray ending w/ i (at most 1 deletion)
    vector<vector<int>> dp(2, vector<int>(arr.size()));

    dp[0][0] = arr[0];
    dp[1][0] = arr[0];
    for (int i = 1; i < arr.size(); ++i) {
      dp[0][i] = max(arr[i], dp[0][i - 1] + arr[i]);
      dp[1][i] =
          max({arr[i], dp[1][i - 1] + arr[i], dp[0][i - 1] /*delete arr[i]*/});
    }

    return *max_element(begin(dp[1]), end(dp[1]));
  }
};"
"class Solution:
    def connectTwoGroups(self, cost: List[List[int]]) -> int:
        m, n = len(cost), len(cost[0])
        mn = [min(x) for x in cost] # min cost of connecting points in 1st group 
        
        @lru_cache(None)
        def fn(j, mask):
            """"""Return min cost of connecting group1[i:] and group2 represented as mask.""""""
            if j == n: return sum(mn[i] for i in range(m) if not (mask &amp; (1<<i)))
            return min(cost[i][j] + fn(j+1, mask | 1<<i) for i in range(m))
                
        return fn(0, 0)","class Solution {
 public:
  int makeArrayIncreasing(vector<int>& arr1, vector<int>& arr2) {
    // dp[i] := min steps to reach i at previous round
    unordered_map<int, int> dp{{-1, 0}};

    sort(begin(arr2), end(arr2));

    for (const int a : arr1) {
      unordered_map<int, int> nextDp;
      for (const auto& [val, steps] : dp) {
        // it's possible to use the value in arr1
        if (a > val)
          nextDp[a] = min(nextDp.count(a) ? nextDp[a] : INT_MAX, steps);
        // Also try the value in arr2
        if (const auto it = upper_bound(begin(arr2), end(arr2), val);
            it != cend(arr2))
          nextDp[*it] =
              min(nextDp.count(*it) ? nextDp[*it] : INT_MAX, steps + 1);
      }
      if (nextDp.empty())
        return -1;
      dp = move(nextDp);
    }

    int ans = INT_MAX;
    for (const auto& [_, steps] : dp)
      ans = min(ans, steps);
    return ans;
  }
};"
"class Solution:
    def minOperations(self, logs: List[str]) -> int:
        res=[]
        for word in logs:
            if word==""../"" and len(res)>0:
                res.pop()
            elif word==""./"":
                continue
            elif word!=""../"" and word!=""./"":
                res.append(word)
        return len(res)","// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class BoundedBlockingQueue {
 public:
  BoundedBlockingQueue(int capacity) {
    sem_init(&enqueueSemaphore, /*pshared=*/0, /*value=*/capacity);
    sem_init(&dequeueSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~BoundedBlockingQueue() {
    sem_destroy(&enqueueSemaphore);
    sem_destroy(&dequeueSemaphore);
  }

  void enqueue(int element) {
    sem_wait(&enqueueSemaphore);
    q.push(element);
    sem_post(&dequeueSemaphore);
  }

  int dequeue() {
    sem_wait(&dequeueSemaphore);
    const int element = q.front();
    q.pop();
    sem_post(&enqueueSemaphore);
    return element;
  }

  int size() {
    return q.size();
  }

 private:
  queue<int> q;
  sem_t enqueueSemaphore;
  sem_t dequeueSemaphore;
};"
"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        i=0
        count=0
        profit=0
        rem=0
        onBoard=0
        max_profit_rounds=-1
        max_profit=0
        while True:
            if i>=len(customers)-1 and rem==0:              
                break
            if i<len(customers):
                rem+=customers[i]
                i+=1
            count+=1
            if rem>4:
                onBoard+=4
                rem-=4
            else:
                onBoard+=rem
                rem=0
            profit=(onBoard*boardingCost)-(count*runningCost)
            if profit>max_profit:
                max_profit=profit
                max_profit_rounds=count

            
        if max_profit<0:
            return -1
        
        return max_profit_rounds","class Solution {
 public:
  int maxNumberOfBalloons(string text) {
    int ans = INT_MAX;
    vector<int> count(26);

    for (char c : text)
      ++count[c - 'a'];

    for (char c : string(""ban""))
      ans = min(ans, count[c - 'a']);

    for (char c : string(""lo""))
      ans = min(ans, count[c - 'a'] / 2);

    return ans;
  }
};"
"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        
        def fn(k, mask): 
            """"""Return maximum number of achievable transfer requests.""""""
            if k == len(requests): 
                net = [0]*n
                for i, (u, v) in enumerate(requests): 
                    if mask &amp; 1 << i: 
                        net[u] -= 1
                        net[v] += 1
                return 0 if any(net) else bin(mask).count(""1"")
            return max(fn(k+1, mask), fn(k+1, mask | 1 << k))
        
        return fn(0, 0)","class Solution {
 public:
  string reverseParentheses(string s) {
    stack<int> stack;
    string ans;

    for (const char c : s)
      if (c == '(') {
        stack.push(ans.length());
      } else if (c == ')') {
        // Reverse the corresponding substring between ().
        const int j = stack.top();
        stack.pop();
        reverse(begin(ans) + j, end(ans));
      } else {
        ans += c;
      }

    return ans;
  }
};"
"class Solution:
    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
        ans = set()
        seen = {}
        for key, time in sorted(zip(keyName, keyTime)): 
            if key not in ans: 
                h, m = time.split("":"")
                time = int(h) * 60 + int(m)
                seen.setdefault(key, deque()).append(time)
                if len(seen[key]) == 3: 
                    if seen[key][-1] <= seen[key][0] + 60: ans.add(key)
                    seen[key].popleft()
        return sorted(ans)","class Solution {
 public:
  int kConcatenationMaxSum(vector<int>& arr, int k) {
    constexpr int kMod = 1'000'000'007;
    const int sz = arr.size() * (k == 1 ? 1 : 2);
    const int sum = accumulate(begin(arr), end(arr), 0);
    // The concatenated array will be [arr1, arr2, ..., arrk].
    // If sum(arr) > 0 and k > 2, then arr2, ..., arr(k - 1) should be included.
    // Equivalently, maxSubarraySum is from arr1 and arrk.
    return (sum > 0 && k > 2 ? kadane(arr, sz) + sum * static_cast<long>(k - 2)
                             : kadane(arr, sz)) %
           kMod;
  }

 private:
  int kadane(const vector<int>& A, int sz) {
    int ans = 0;
    int sum = 0;
    for (int i = 0; i < sz; ++i) {
      const int a = A[i % A.size()];
      sum = max(a, sum + a);
      ans = max(ans, sum);
    }
    return ans;
  }
};"
"class Solution:
    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:
        # 0) Initialization
        ROW_SIZE = len(rowSum)
        COL_SIZE = len(colSum)
        mtx = [[0] * COL_SIZE for ri in range(ROW_SIZE)]
        for i, rs in enumerate(rowSum):
            mtx[i][0] = rs
            
		# 1) Iteratively meet column sum by making reduction from first column
        valid_row_set = set(list(filter(lambda ri: mtx[ri][0], range(ROW_SIZE))))
        for ci in range(1, COL_SIZE):
            cs = colSum[ci]
            empty_ri_list = []
            for ri in valid_row_set:
                if mtx[ri][0] < cs:
                    cs -= mtx[ri][0]
                    mtx[ri][ci] = mtx[ri][0]
                    mtx[ri][0] = 0                     
                    empty_ri_list.append(ri)
                elif mtx[ri][0] == cs:
                    mtx[ri][ci] = mtx[ri][0]
                    mtx[ri][0] = cs = 0
                    empty_ri_list.append(ri)
                    break
                elif mtx[ri][0] > cs:
                    mtx[ri][ci] = cs
                    mtx[ri][0] -= cs
                    break
                    
            for eri in empty_ri_list:
                valid_row_set.remove(eri)
                                
        return mtx","class Solution {
 public:
  vector<vector<int>> criticalConnections(int n,
                                          vector<vector<int>>& connections) {
    vector<vector<int>> ans;
    vector<vector<int>> graph(n);

    for (const vector<int>& connection : connections) {
      const int u = connection[0];
      const int v = connection[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    // rank[i] := min node that node i can reach w/ forward edges
    // Initialize w/ NO_RANK = -2 to indicate not visited.
    getRank(graph, 0, 0, vector<int>(n, NO_RANK), ans);
    return ans;
  }

 private:
  static constexpr int NO_RANK = -2;

  // Gets the min rank that u can reach w/ forward edges.
  int getRank(const vector<vector<int>>& graph, int u, int currRank,
              vector<int>&& rank, vector<vector<int>>& ans) {
    if (rank[u] != NO_RANK)  // The rank is already determined.
      return rank[u];

    rank[u] = currRank;
    int minRank = currRank;

    for (const int v : graph[u]) {
      // visited || parent (that's why NO_RANK = -2 instead of -1)
      if (rank[u] == rank.size() || rank[v] == currRank - 1)
        continue;
      const int nextRank = getRank(graph, v, currRank + 1, move(rank), ans);
      // (u, v) is the only way for u go to v.
      if (nextRank == currRank + 1)
        ans.push_back({u, v});
      minRank = min(minRank, nextRank);
    }

    rank[u] = rank.size();  // Mark as visited
    return minRank;
  }
};"
"class Solution:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        busy = [] # min-heap
        free = list(range(k)) # min-heap 
        freq = [0]*k
        
        for i, (ta, tl) in enumerate(zip(arrival, load)): 
            while busy and busy[0][0] <= ta: 
                _, ii = heappop(busy)
                heappush(free, i + (ii - i) % k) # circularly relocate it
            if free: 
                ii = heappop(free) % k 
                freq[ii] += 1
                heappush(busy, (ta+tl, ii))
        
        mx = max(freq)
        return [i for i, x in enumerate(freq) if x == mx]","// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class FizzBuzz {
 public:
  FizzBuzz(int n) : n(n) {
    sem_init(&fizzSemaphore, /*pshared=*/0, /*value=*/0);
    sem_init(&buzzSemaphore, /*pshared=*/0, /*value=*/0);
    sem_init(&fizzbuzzSemaphore, /*pshared=*/0, /*value=*/0);
    sem_init(&numberSemaphore, /*pshared=*/0, /*value=*/1);
  }

  ~FizzBuzz() {
    sem_destroy(&fizzSemaphore);
    sem_destroy(&buzzSemaphore);
    sem_destroy(&fizzbuzzSemaphore);
    sem_destroy(&numberSemaphore);
  }

  // printFizz() outputs ""fizz"".
  void fizz(function<void()> printFizz) {
    for (int i = 1; i <= n; ++i)
      if (i % 3 == 0 && i % 15 != 0) {
        sem_wait(&fizzSemaphore);
        printFizz();
        sem_post(&numberSemaphore);
      }
  }

  // printBuzz() outputs ""buzz"".
  void buzz(function<void()> printBuzz) {
    for (int i = 1; i <= n; ++i)
      if (i % 5 == 0 && i % 15 != 0) {
        sem_wait(&buzzSemaphore);
        printBuzz();
        sem_post(&numberSemaphore);
      }
  }

  // printFizzBuzz() outputs ""fizzbuzz"".
  void fizzbuzz(function<void()> printFizzBuzz) {
    for (int i = 1; i <= n; ++i)
      if (i % 15 == 0) {
        sem_wait(&fizzbuzzSemaphore);
        printFizzBuzz();
        sem_post(&numberSemaphore);
      }
  }

  // printNumber(x) outputs ""x"", where x is an integer.
  void number(function<void(int)> printNumber) {
    for (int i = 1; i <= n; ++i) {
      sem_wait(&numberSemaphore);
      if (i % 15 == 0)
        sem_post(&fizzbuzzSemaphore);
      else if (i % 3 == 0)
        sem_post(&fizzSemaphore);
      else if (i % 5 == 0)
        sem_post(&buzzSemaphore);
      else {
        printNumber(i);
        sem_post(&numberSemaphore);
      }
    }
  }

 private:
  const int n;
  sem_t fizzSemaphore;
  sem_t buzzSemaphore;
  sem_t fizzbuzzSemaphore;
  sem_t numberSemaphore;
};"
"class Solution:
    def specialArray(self, nums: List[int]) -> int:
        nums.sort() 
        fn = lambda x: x - (len(nums) - bisect_left(nums, x))
        lo, hi = 0, nums[-1]
        while lo <= hi: 
            mid = lo + hi >> 1
            if fn(mid) < 0: lo = mid + 1
            elif fn(mid) == 0: return mid
            else: hi = mid - 1
        return -1","class Solution {
 public:
  int minKnightMoves(int x, int y) {
    return dp(abs(x), abs(y));
  }

 private:
  struct pairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };

  unordered_map<pair<int, int>, int, pairHash> memo;

  int dp(int x, int y) {
    if (x + y == 0)  // (0, 0)
      return 0;
    if (x + y == 2)  // (0, 2), (1, 1), (2, 0)
      return 2;
    if (const auto it = memo.find({x, y}); it != cend(memo))
      return it->second;

    return memo[{x, y}] = 1 + min(dp(abs(x - 2), abs(y - 1)),  //
                                  dp(abs(x - 1), abs(y - 2)));
  }
};"
"class Solution:
    def isEvenOddTree(self, root: TreeNode) -> bool:
        
        if not root: return True
        
        queue=[root]
        lvl=0
        while queue:
            order=[]
            for _ in range(len(queue)):
                node=queue.pop(0)
                
                if lvl%2==0:
                    if node.val&amp;1:
                        if not order: order.append(node.val)
                        else:
                            if order[-1]<node.val: order.append(node.val)
                            else: return False
                        if node.left:queue.append(node.left)
                        if node.right: queue.append(node.right)
                    else: return False
                else:
                    if node.val%2==0:
                        if not order: order.append(node.val)
                        else:
                            if order[-1]>node.val: order.append(node.val)
                            else: return False
                        if node.left:queue.append(node.left)
                        if node.right: queue.append(node.right)
                    else: return False
            lvl+=1
        return True","class Solution {
 public:
  int smallestCommonElement(vector<vector<int>>& mat) {
    constexpr int kMax = 10000;
    vector<int> count(kMax + 1);

    for (const vector<int>& row : mat)
      for (const int a : row)
        if (++count[a] == mat.size())
          return a;

    return -1;
  }
};"
"class Solution:
    def visiblePoints(self, points: List[List[int]], angle: int, l: List[int]) -> int:
        
        array = []
        nloc = 0
        for p in points:
            if p == l:
                nloc += 1
            else:
                array.append(math.degrees(atan2(p[1]-l[1], p[0]-l[0])))
        array.sort()
        angles = array + [a+360 for a in array]
        left, maxm = 0, 0
        for right, a in enumerate(angles):
            if a-angles[left] > angle:
                left += 1
            maxm = max(right-left+1, maxm)
        
        return maxm + nloc","class Solution {
 public:
  int minBuildTime(vector<int>& blocks, int split) {
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int block : blocks)
      minHeap.push(block);

    while (minHeap.size() > 1) {
      minHeap.pop();                // Smallest
      const int x = minHeap.top();  // 2nd smallest
      minHeap.pop();
      minHeap.push(x + split);
    }

    return minHeap.top();
  }
};"
"class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        if not n: return 0 # edge case 
        if not (n &amp; (n-1)): return 2*n-1
        b = 1 << n.bit_length()-1 
        return self.minimumOneBitOperations((b>>1)^b^n) + b","class Solution {
 public:
  vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
    vector<vector<int>> ans;
    int min = INT_MAX;

    sort(begin(arr), end(arr));

    for (int i = 0; i + 1 < arr.size(); ++i) {
      int diff = arr[i + 1] - arr[i];
      if (diff < min) {
        min = diff;
        ans.clear();
      }
      if (diff == min)
        ans.push_back({arr[i], arr[i + 1]});
    }

    return ans;
  }
};"
"class Solution:
    def maxDepth(self, s: str) -> int:
        maxDepth:int = 0
        bracketNum:int = 0

        for c in s:
            if c == '(': 
                bracketNum += 1
                if bracketNum > maxDepth: maxDepth = bracketNum
            elif c == ')':
                bracketNum -= 1
        return maxDepth","class Solution {
 public:
  int nthUglyNumber(int n, long a, long b, long c) {
    const long ab = a * b / __gcd(a, b);
    const long ac = a * c / __gcd(a, c);
    const long bc = b * c / __gcd(b, c);
    const long abc = a * bc / __gcd(a, bc);
    int l = 1;
    int r = 2'000'000'000;

    while (l < r) {
      const int m = l + (r - l) / 2;
      if (m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc >= n)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};"
"class Solution:
    def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:
        
        g = defaultdict(list)
        
        for u, v in roads:  # create graph adjacency list
            g[u].append(v)
            g[v].append(u)
        
        res = 0
        
        for i in range(n):
            for j in range(i+1, n):
                val = len(g[i]) + len(g[j]) # sum the amount of roads for each city
                if j in g[i]:   # remove road connected to both cities
                    val -= 1
                res = max(res, val)
        
        
        return res","class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

struct compare {
  bool operator()(const char a, const char b) {
    return a > b;
  }
};

class Solution {
 public:
  string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {
    string ans;
    UnionFind uf(s.length());
    unordered_map<int, priority_queue<char, vector<char>, compare>> map;

    for (const vector<int>& pair : pairs)
      uf.unionByRank(pair[0], pair[1]);

    for (int i = 0; i < s.length(); ++i)
      map[uf.find(i)].push(s[i]);

    for (int i = 0; i < s.length(); ++i)
      ans += map[uf.find(i)].top(), map[uf.find(i)].pop();

    return ans;
  }
};"
"class Solution(object):
    def checkPalindromeFormation(self, a, b):
        """"""
        :type a: str
        :type b: str
        :rtype: bool
        """"""
        if len(a) == 1 or len(b) == 1:
            return True  
        b = b[::-1] # reverse string b
        return (a[0] == b[0] and a[1] == b[1]) or (a[-1] == b[-1] and a[-2] == b[-2]) # search for same substrings : 1) start from head(a_prefix + b_suffix) 
																												# 2) start from tail(b_prefix + a_suffix).","class Solution {
 public:
  vector<int> sortItems(int n, int m, vector<int>& group,
                        vector<vector<int>>& beforeItems) {
    vector<vector<int>> graph(n + m);
    vector<int> inDegree(n + m);

    // Build graph by remapping k-th group to k + n imaginary node
    for (int i = 0; i < group.size(); ++i) {
      if (group[i] == -1)
        continue;
      graph[group[i] + n].push_back(i);
      ++inDegree[i];
    }

    for (int i = 0; i < beforeItems.size(); ++i)
      for (const int b : beforeItems[i]) {
        const int u = group[b] == -1 ? b : group[b] + n;
        const int v = group[i] == -1 ? i : group[i] + n;
        if (u == v) {  // Already in the same group
          graph[b].push_back(i);
          ++inDegree[i];
        } else {
          graph[u].push_back(v);
          ++inDegree[v];
        }
      }

    // Topology
    vector<int> ans;

    for (int i = 0; i < n + m; ++i)
      if (inDegree[i] == 0)  // inDegree[i] == -1 means visited
        dfs(graph, i, inDegree, n, ans);

    return ans.size() == n ? ans : vector<int>();
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, vector<int>& inDegree,
           int n, vector<int>& ans) {
    if (u < n)
      ans.push_back(u);

    inDegree[u] = -1;  // Mark as visited

    for (const int v : graph[u])
      if (--inDegree[v] == 0)
        dfs(graph, v, inDegree, n, ans);
  }
};"
"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        def maxDistance(subtree):
            edges,node,maxD=[0]*3
            for i in range(n):
                if (subtree>>i)&amp;1==0:continue
                node+=1
                for j in range(i+1,n):
                    if (subtree>>j)&amp;1==0:continue
                    edges+=dist[i][j]==1
                    maxD=max(maxD,dist[i][j])
            if edges!=node-1:
                return 0
            else:
                return maxD
        dist=[[float('inf')]*n for i in range(n)]
        for i,j in edges:
            dist[i-1][j-1]=dist[j-1][i-1]=1
        for mid in range(n):
            for n1 in range(n):
                for n2 in range(n):
                    dist[n1][n2]=min(dist[n1][n2],dist[n1][mid]+dist[mid][n2])
        ans=[0]*(n-1)
        for i in range(1,2**n):
            d=maxDistance(i)
            if d>0:
                ans[d-1]+=1
        return ans","class Solution {
 public:
  bool uniqueOccurrences(vector<int>& arr) {
    unordered_map<int, int> count;
    unordered_set<int> occurrences;

    for (const int a : arr)
      ++count[a];

    for (const auto& [_, value] : count)
      if (!occurrences.insert(value).second)
        return false;

    return true;
  }
};"
"class Solution:
    def trimMean(self, arr: List[int]) -> float:
		# Calculate how many elements make the top/bottom 5%. 
		# Since the length of the array will always be a multiple 
		# of 20, we don't need to do any special checks, just divide
        numToRemove = len(arr) // 20
		
		# Remove the top and bottom 5% of the elements by finding 
		# the min/max of the list
        for i in range(numToRemove):
            arr.remove(max(arr))
            arr.remove(min(arr))
        
		# Return the average of the new list
		return sum(arr) / len(arr)","class Solution {
 public:
  int equalSubstring(string s, string t, int maxCost) {
    int j = 0;
    for (int i = 0; i < s.length(); ++i) {
      maxCost -= abs(s[i] - t[i]);
      if (maxCost < 0)
        maxCost += abs(s[j] - t[j++]);
    }

    return s.length() - j;
  }
};"
"class Solution:
    def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:
        return max(
            (
                (sum(qi // (1 + dist) for xi, yi, qi in towers if (dist := sqrt((xi - x) ** 2 + (yi - y) ** 2)) <= radius),
                 [x, y]) for x in range(51) for y in range(51)
            ),
            key=lambda x: (x[0], -x[1][0], -x[1][1])
        )[1]","class Solution {
 public:
  string removeDuplicates(const string& s, int k) {
    string ans;
    vector<pair<char, int>> stack;

    for (const char c : s)
      if (stack.empty() || stack.back().first != c)
        stack.emplace_back(c, 1);
      else if (++stack.back().second == k)  // Stack.back() == c
        stack.pop_back();

    for (const auto& [c, count] : stack)
      ans.append(count, c);

    return ans;
  }
};"
"class Solution:
    def numberOfSets(self, n: int, k: int) -> int:
        
        @cache
        def fn(n, k):
            """"""Return number of sets.""""""
            if n <= k: return 0 
            if k == 0: return 1
            return 2*fn(n-1, k) + fn(n-1, k-1) - fn(n-2, k)
        
        return fn(n, k) % 1_000_000_007","enum class Pos { kHorizontal, kVertical };

class Solution {
 public:
  int minimumMoves(vector<vector<int>>& grid) {
    const int n = grid.size();
    int ans = 0;
    // State of (x, y, pos)
    // Pos := 0 (horizontal) / 1 (vertical)
    queue<tuple<int, int, Pos>> q{{{0, 0, Pos::kHorizontal}}};
    vector<vector<vector<bool>>> seen(n,
                                      vector<vector<bool>>(n, vector<bool>(2)));
    seen[0][0][static_cast<int>(Pos::kHorizontal)] = true;

    auto canMoveRight = [&](int x, int y, Pos pos) -> bool {
      if (pos == Pos::kHorizontal)
        return y + 2 < n && !grid[x][y + 2];
      return y + 1 < n && !grid[x][y + 1] && !grid[x + 1][y + 1];
    };

    auto canMoveDown = [&](int x, int y, Pos pos) -> bool {
      if (pos == Pos::kVertical)
        return x + 2 < n && !grid[x + 2][y];
      return x + 1 < n && !grid[x + 1][y] && !grid[x + 1][y + 1];
    };

    auto canRotateClockwise = [&](int x, int y, Pos pos) -> bool {
      return pos == Pos::kHorizontal && x + 1 < n && !grid[x + 1][y + 1] &&
             !grid[x + 1][y];
    };

    auto canRotateCounterclockwise = [&](int x, int y, Pos pos) -> bool {
      return pos == Pos::kVertical && y + 1 < n && !grid[x + 1][y + 1] &&
             !grid[x][y + 1];
    };

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [x, y, pos] = q.front();
        q.pop();
        if (x == n - 1 && y == n - 2 && pos == Pos::kHorizontal)
          return ans;
        if (canMoveRight(x, y, pos) && !seen[x][y + 1][static_cast<int>(pos)]) {
          q.emplace(x, y + 1, pos);
          seen[x][y + 1][static_cast<int>(pos)] = true;
        }
        if (canMoveDown(x, y, pos) && !seen[x + 1][y][static_cast<int>(pos)]) {
          q.emplace(x + 1, y, pos);
          seen[x + 1][y][static_cast<int>(pos)] = true;
        }
        const Pos newPos =
            pos == Pos::kHorizontal ? Pos::kVertical : Pos::kHorizontal;
        if ((canRotateClockwise(x, y, pos) ||
             canRotateCounterclockwise(x, y, pos)) &&
            !seen[x][y][static_cast<int>(newPos)]) {
          q.emplace(x, y, newPos);
          seen[x][y][static_cast<int>(newPos)] = true;
        }
      }
      ++ans;
    }

    return -1;
  }
};"
"class Solution:
    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        if(len(s)==len(set(s))):
            return -1
			
        maxdiff=0
        dicts=collections.defaultdict(list)
		
        for index,char in enumerate(s):
            dicts[char]+=[index]
           
        for k,v in dicts.items():
            diff=v[-1]-v[0]-1
            if diff>maxdiff:
                maxdiff=diff
				
        return maxdiff","class Solution {
 public:
  vector<int> arraysIntersection(vector<int>& arr1, vector<int>& arr2,
                                 vector<int>& arr3) {
    vector<int> ans;
    int i = 0;
    int j = 0;
    int k = 0;

    while (i < arr1.size() && j < arr2.size() && k < arr3.size()) {
      const int mini = min({arr1[i], arr2[j], arr3[k]});
      if (arr1[i] == mini && arr2[j] == mini && arr3[k] == mini) {
        ans.push_back(mini);
        ++i;
        ++j;
        ++k;
      } else if (arr1[i] == mini) {
        ++i;
      } else if (arr2[j] == mini) {
        ++j;
      } else {
        ++k;
      }
    }

    return ans;
  }
};"
"class Solution:
    def __init__(self):
        self.mn = 'z' * 100
        self.vis = set()
    
    def solve(self, st):
        if ''.join(st) in self.vis:
            return
        self.vis.add(''.join(st))
        new = st
        for i in range(1, len(st), 2):
            st[i] = str((int(st[i]) + self.a) % 10)
        self.mn = min(''.join(st), self.mn)
        
        lp = new[-self.b:]
        fp = new[:self.l - self.b]
        new = lp + fp
        self.mn = min(self.mn, ''.join(new))
        
        self.solve(st)
        self.solve(new)
    
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        self.a = a ; self.b = b
        self.l = len(s)
        self.b = self.b % self.l
        s = list(s)
        self.solve(s)
        return self.mn","class BSTIterator {
 public:
  BSTIterator(TreeNode* root, bool leftToRight) : leftToRight(leftToRight) {
    pushUntilNull(root);
  }

  bool hasNext() {
    return !stack.empty();
  }

  int next() {
    TreeNode* root = stack.top();
    stack.pop();
    pushUntilNull(leftToRight ? root->right : root->left);
    return root->val;
  }

 private:
  stack<TreeNode*> stack;
  bool leftToRight;

  void pushUntilNull(TreeNode* root) {
    while (root != nullptr) {
      stack.push(root);
      root = leftToRight ? root->left : root->right;
    }
  }
};

class Solution {
 public:
  bool twoSumBSTs(TreeNode* root1, TreeNode* root2, int target) {
    BSTIterator bst1(root1, true);
    BSTIterator bst2(root2, false);

    for (int l = bst1.next(), r = bst2.next(); true;) {
      const int sum = l + r;
      if (sum == target)
        return true;
      if (sum < target) {
        if (!bst1.hasNext())
          return false;
        l = bst1.next();
      } else {
        if (!bst2.hasNext())
          return false;
        r = bst2.next();
      }
    }
  }
};"
"class Solution:
    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:
        ages, scores = zip(*sorted(zip(ages, scores)))
        
        @lru_cache(None)
        def fn(i): 
            """"""Return max score up to ith player included.""""""
            if i < 0: return 0 # boundary condition 
            return scores[i] + max((fn(ii) for ii in range(i) if ages[ii] == ages[i] or scores[ii] <= scores[i]), default=0)
        
        return max(fn(i) for i in range(len(scores)))","class Solution {
 public:
  vector<int> countSteppingNumbers(int low, int high) {
    vector<int> ans;
    if (low == 0)
      ans.push_back(0);

    queue<long> q;

    for (int i = 1; i <= 9; ++i)
      q.push(i);

    while (!q.empty()) {
      const long curr = q.front();
      q.pop();
      if (curr > high)
        continue;
      if (curr >= low)
        ans.push_back(curr);
      const int lastDigit = curr % 10;
      if (lastDigit > 0)
        q.push(curr * 10 + lastDigit - 1);
      if (lastDigit < 9)
        q.push(curr * 10 + lastDigit + 1);
    }

    return ans;
  }
};"
"class Solution:
    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
        max_d = -1
        letter = None
        
        
        duration = [releaseTimes[0]]
        
        for i in range(1,len(releaseTimes)):
            duration.append(releaseTimes[i]- releaseTimes[i-1])
        
        for index, i in enumerate(duration):
            if(i > max_d):
                max_d = i
                letter = keysPressed[index]
            elif(i == max_d and ord(keysPressed[index])>ord(letter)):
                letter = keysPressed[index]
        return letter","class Solution {
 public:
  bool isValidPalindrome(string s, int k) {
    return s.length() - longestPalindromeSubseq(s) <= k;
  }

 private:
  // Same as 516. Longest Palindromic Subsequence
  int longestPalindromeSubseq(const string& s) {
    const int n = s.length();
    // dp[i][j] := LPS's length in s[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j])
          dp[i][j] = 2 + dp[i + 1][j - 1];
        else
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
      }

    return dp[0][n - 1];
  }
};"
"class Solution:
    
    def checker(self,nums):
        i = 2
        n = len(nums)
        diff = nums[1] - nums[0]
        while i < n:
            if nums[i] - nums[i-1] != diff:
                return False
            i += 1
        return True
    
    def checkArithmeticSubarrays(self, nums: List[int], left: List[int], right: List[int]) -> List[bool]:
        m, i, ans = len(left), 0, []
        while i < m:
            l, r = left[i], right[i]
            sub = nums[l:r+1]
            sub.sort()
            ans.append(self.checker(sub))
            i += 1
        return ans","class Solution {
 public:
  int minCostToMoveChips(vector<int>& chips) {
    vector<int> count(2);

    for (int chip : chips)
      ++count[chip % 2];

    return min(count[0], count[1]);
  }
};"
"class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        
        M, N = map(len, (heights, heights[0]))
        heap = [(0, 0, 0)]
        seen = set()
        result = 0
        
        while heap:
            
            # Pop
            effort, i, j = heapq.heappop(heap)
            
            # Mark seen
            seen.add((i, j))
            
            # Update minimum ""effort""
            result = max(result, effort)
            
            # Success condition
            if i == M-1 and j == N-1:
                break
                                    
            # BFS
            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if not (x >= 0 <= y): continue
                if x >= M or y >= N: continue
                if (x, y) in seen: continue
                effort = abs(heights[i][j] - heights[x][y])
                heapq.heappush(heap, (effort, x, y))
                                
        return result","class Solution {
 public:
  int longestSubsequence(vector<int>& arr, int difference) {
    int ans = 0;
    unordered_map<int, int> lengthAt;

    for (const int a : arr) {
      if (const auto it = lengthAt.find(a - difference); it != cend(lengthAt))
        lengthAt[a] = it->second + 1;
      else
        lengthAt[a] = 1;
      ans = max(ans, lengthAt[a]);
    }

    return ans;
  }
};"
"class Solution:
    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0])
        
        def find_root(x: int, y: int):
            if parent[x][y] == (x, y):
                return (x, y)
            else:
                r = find_root(parent[x][y][0], parent[x][y][1])
                parent[x][y] = r
                return r
        
        def union(x1, y1, x2, y2):
            root_a = find_root(x1, y1)
            root_b = find_root(x2, y2)
            parent[root_b[0]][root_b[1]] = root_a
            
        ########################################################
        
		# *parent* records the parent of each point in matrix form
		# points with same value in the same row/column should have the same parent
        parent = [[(j, i) for i in range(n)] for j in range(m)]
        
		# sort each row, if there are points with same value, union them
        for i in range(m):
            value = []
            for j in range(n):
                v = tuple([matrix[i][j], i, j])
                value.append(v)
            value.sort()
            for k in range(n - 1):
                if value[k][0] == value[k + 1][0]:
                    union(value[k][1], value[k][2], value[k + 1][1], value[k + 1][2])
					
        # sort each column, if there are points with same value, union them            
        for i in range(n):
            value = []
            for j in range(m):
                v = tuple([matrix[j][i], j, i])
                value.append(v)
            value.sort()
            for k in range(m - 1):
                if value[k][0] == value[k + 1][0]:
                    union(value[k][1], value[k][2], value[k + 1][1], value[k + 1][2])
        
        ########################################################
        
        dic = {} # point index : point that it directs ->
        in_degree = {} # point index : number of incoming arrows <-
		
		# Ex. [20, -21, 14]
		# sort: -21 (0, 1) -> 14 (0, 2) -> 20 (0, 0)
		# dic = { (0, 0) : [], (0, 1) : [(0, 2)], (0, 2) : [(0, 0)] }
		# in_degree = { (0, 0) : 1, (0, 1) : 0, (0, 2) : 1 }
		
		# only select ""root"" points that parent[point] = point itself
        for i in range(m):
            for j in range(n):
                if parent[i][j] == (i, j):
                    dic[(i, j)] = []
                    in_degree[(i, j)] = 0
                    
		# if there are points that parent[point] = its parent but not the ""root"" ancestor
		# make parent[point] = the ""root"" ancestor
		
		# Ex. before: parent[4][4] = (4, 4), parent[8][0] = (4, 4), parent[8][4] = (8, 0)
		# after: parent[4][4] = (4, 4), parent[8][0] = (4, 4), parent[8][4] = (4, 4)
		
        for i in range(m):
            for j in range(n):
                while parent[i][j] not in dic:
                    parent[i][j] = parent[parent[i][j][0]][parent[i][j][1]]
        
		# continue to construct *dic* and *in_degree*
		# make connections in each row
        for i in range(m):
            row = []
            for j in range(n):
                r = tuple([matrix[i][j], parent[i][j][0], parent[i][j][1]])
                row.append(r)
            row.sort()
            for k in range(n - 1):
                if row[k][0] < row[k + 1][0]:
                    if (row[k][1], row[k][2]) in dic and (row[k + 1][1], row[k + 1][2]) in dic:
                        if (row[k + 1][1], row[k + 1][2]) not in dic[(row[k][1], row[k][2])]:
                            dic[(row[k][1], row[k][2])].append((row[k + 1][1], row[k + 1][2]))
                            in_degree[(row[k + 1][1], row[k + 1][2])] += 1
        
		# and make connections in each column
        for i in range(n):
            col = []
            for j in range(m):
                c = tuple([matrix[j][i], parent[j][i][0], parent[j][i][1]])
                col.append(c)
            col.sort()
            for k in range(m - 1):
                if col[k][0] < col[k + 1][0]:
                    if (col[k][1], col[k][2]) in dic and (col[k + 1][1], col[k + 1][2]) in dic:
                        if (col[k + 1][1], col[k + 1][2]) not in dic[(col[k][1], col[k][2])]:
                            dic[(col[k][1], col[k][2])].append((col[k + 1][1], col[k + 1][2]))
                            in_degree[(col[k + 1][1], col[k + 1][2])] += 1
        
        #######################################################################
        
		# *distance* records the rank of the ""root"" points (just my naming habit)
        distance = {} # point index : rank
        for i in range(m):
            for j in range(n):
                if parent[i][j] == (i, j):
                    distance[(i, j)] = 0
        
		# first put ""root"" points that have 0 in_degree (meaning they are the smallest) in queue
        queue = []
        for i in in_degree:
            if in_degree[i] == 0:
                queue.append(i)
                distance[i] = 1
        
        head = 0
        tail = len(queue) - 1
        while head <= tail:
            h = queue[head]

            for p in dic[h]:
                in_degree[p] -= 1
                if in_degree[p] == 0:
                    queue.append(p)
                    distance[p] = distance[h] + 1

            head += 1
            tail = len(queue) - 1
        
        #######################################################################
        
		# *rank* records the final result in matrix form
        rank = [[0 for i in range(n)] for j in range(m)]
        
		# now we already got the rank of those ""root"" points recorded in *distance*
		# let's put them in *rank*, also their descendants'
        for i in range(m):
            for j in range(n):
                rank[i][j] = distance[parent[i][j]]
        
        return rank","class Solution {
 public:
  int getMaximumGold(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        ans = max(ans, dfs(grid, i, j));

    return ans;
  }

 private:
  int dfs(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || j < 0 || i == grid.size() || j == grid[0].size())
      return 0;
    if (grid[i][j] == 0)
      return 0;

    const int gold = grid[i][j];
    grid[i][j] = 0;  // Mark as visited.
    const int maxPath = max({dfs(grid, i + 1, j), dfs(grid, i - 1, j),
                             dfs(grid, i, j + 1), dfs(grid, i, j - 1)});
    grid[i][j] = gold;
    return gold + maxPath;
  }
};"
"class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        counter = [(x[0], len(list(x[1]))) for x in groupby(sorted(nums))]
        sorted_new_array = sorted(counter, key=lambda x: (x[1], -x[0]))
        nums = []
        for i in sorted_new_array:
            nums += ([i[0]] * i[1])
        return nums","class Solution {
 public:
  int balancedStringSplit(string s) {
    int ans = 0;
    int count = 0;

    for (const char c : s) {
      count += c == 'L' ? 1 : -1;
      if (count == 0)
        ++ans;
    }

    return ans;
  }
};"
"class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        last = None
        mx = None
        for i in sorted(points):
            i = i[0]
            if last is not None and (mx is None or i - last > mx):
                mx = i - last
            last = i
        return mx","class Solution {
 public:
  vector<vector<int>> queensAttacktheKing(vector<vector<int>>& queens,
                                          vector<int>& king) {
    vector<vector<int>> ans;
    unordered_set<int> queensSet;

    for (vector<int>& queen : queens)
      queensSet.insert(hash(queen[0], queen[1]));

    vector<vector<int>> directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};
    for (vector<int> d : directions)
      for (int i = king[0] + d[0], j = king[1] + d[1];
           0 <= i && i < 8 && 0 <= j && j < 8; i += d[0], j += d[1])
        if (queensSet.count(hash(i, j))) {
          ans.push_back({i, j});
          break;
        }

    return ans;
  }

 private:
  int hash(int i, int j) {
    return i * 8 + j;
  }
};"
"class Solution:
    def countSubstrings(self, s: str, t: str) -> int:
        ans=0
        for i in range(len(s)):
            for j in range(len(t)):
                x=i
                y=j
                d=0
                while x<len(s) and y<len(t):
                    if s[x]!=t[y]:
                        d+=1
                    if d==1:
                        ans+=1
                    if d==2:
                        break
                    x+=1
                    y+=1
        return ans","class Solution {
 public:
  int maxEqualFreq(vector<int>& nums) {
    int ans = 0;
    int maxFreq = 0;
    unordered_map<int, int> count;
    unordered_map<int, int> freq;

    for (int i = 0; i < nums.size(); ++i) {
      const int num = nums[i];
      --freq[count[num]];
      ++count[num];
      ++freq[count[num]];
      maxFreq = max(maxFreq, count[num]);
      if (maxFreq == 1 || maxFreq * freq[maxFreq] == i ||
          (maxFreq - 1) * (freq[maxFreq - 1] + 1) == i)
        ans = i + 1;
    }

    return ans;
  }
};"
"class Solution:
    def numWays(self, words: List[str], target: str) -> int:
        @lru_cache(None)
		# dfs(i, j) is number of ways to construct taget[:i+1] using chars with index at most j in the word in the words dictionary. 
        def dfs(i, j):
            if i < 0:
                return 1
            if j < 0:
                return 0
            # 
            ans = dfs(i, j-1)
            if chars_count[j][target[i]] > 0:
                ans += dfs(i-1, j-1)*chars_count[j][target[i]]
                ans %= 10**9+7
            return ans
            
        
        m, n = len(target), len(words[0])
        chars_count = [Counter([word[idx] for word in words]) for idx in range(n)]
        return dfs(m-1, n-1)","class Solution {
 public:
  double nthPersonGetsNthSeat(int n) {
    return n == 1 ? 1 : 0.5;
  }
};"
"class Solution:
    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        joined = ""##"".join([str(i) for i in arr])
        joined = ""#"" + joined + ""#""
        pieces.sort()
        for pce in pieces:
            pJoined = ""##"".join(str(i) for i in pce)
            replaceStr = ""#"" + pJoined + ""#""
            joined = joined.replace(replaceStr, """")
        
        if joined == """":
            return True
        return False","class Solution {
 public:
  vector<int> minAvailableDuration(vector<vector<int>>& slots1,
                                   vector<vector<int>>& slots2, int duration) {
    sort(begin(slots1), end(slots1));
    sort(begin(slots2), end(slots2));

    int i = 0;  // slots1's index
    int j = 0;  // slots2's index

    while (i < slots1.size() && j < slots2.size()) {
      const int start = max(slots1[i][0], slots2[j][0]);
      const int end = min(slots1[i][1], slots2[j][1]);
      if (start + duration <= end)
        return {start, start + duration};
      if (slots1[i][1] < slots2[j][1])
        ++i;
      else
        ++j;
    }

    return {};
  }
};"
"class Solution(object):
    def countVowelStrings(self, n, p=0):
        if n == 0:
            return 1
        
        return sum([self.countVowelStrings(n-1, i) for i in range(p, 5)])","class Solution {
 public:
  double probabilityOfHeads(vector<double>& prob, int target) {
    // dp[i][j] := probability of tossing first i coins with j heads
    vector<vector<double>> dp(prob.size() + 1, vector<double>(target + 1));
    dp[0][0] = 1.0;

    for (int i = 1; i <= prob.size(); ++i)
      for (int j = 0; j <= target; ++j)
        dp[i][j] = (j > 0 ? dp[i - 1][j - 1] * prob[i - 1] : 0) +
                   dp[i - 1][j] * (1 - prob[i - 1]);

    return dp[prob.size()][target];
  }
};"
"class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        s = 0
        for i in range(1,len(heights)):
            if heights[i] > heights[i-1]:
                s += heights[i] - heights[i-1]         # height to be climbed
                if bricks >= s:                     # if bricks are available, continue
                    continue
                elif ladders > 0:           # else use ladder and note: remove the height to be climbed from total sum
                    s -= heights[i] - heights[i-1]
                    ladders -= 1                              # remove a ladder
                else:
                    return i - 1                  # i-1 th building was the last building which was reached
                    
        return len(heights) - 1                # last building reached","class Solution {
 public:
  int maximizeSweetness(vector<int>& sweetness, int k) {
    int l = sweetness.size() / (k + 1);
    int r = accumulate(begin(sweetness), end(sweetness), 0) / (k + 1);

    while (l < r) {
      const int m = (l + r) / 2;
      if (canEat(sweetness, k, m))
        l = m + 1;
      else
        r = m;
    }

    return canEat(sweetness, k, l) ? l : l - 1;
  }

 private:
  // Returns true if can eat m sweetness (min sweetness of each piece).
  bool canEat(const vector<int>& sweetness, int k, int m) {
    int pieces = 0;
    int sum = 0;  // Running sum

    for (const int s : sweetness) {
      sum += s;
      if (sum >= m) {
        if (++pieces > k)
          return true;
        sum = 0;
      }
    }

    return false;
  };
};"
"class Solution:
    def fact(self, n):
		""""""factorial with cache""""""
        if n in self.fact_cache:
            return self.fact_cache[n]
        x = self.fact(n-1) * n
        self.fact_cache[n] = x
        return x
    def max_k(self, x, y):
		""""""number of combinations for ordering x and y identical elements
		if x < 0, return 0
		""""""
        if x < 0:  # special case for our problem where there is no H left
            return 0
        return self.fact(x+y) // self.fact(x) // self.fact(y)
    def kthSmallestPath(self, destination: List[int], k: int) -> str:
        self.fact_cache = {0: 1}
        y, x = destination  # numbers of V and H moves
        out = ''
        for i in range(x+y):
		    # the number of combinations if the next element is H
            split = self.max_k(x-1, y)
            if k > split:
                out += 'V'
                y -= 1
                k -= split
            else:
                out += 'H'
                x -= 1
        return out","class Solution {
 public:
  bool checkStraightLine(vector<vector<int>>& coordinates) {
    int x0 = coordinates[0][0];
    int y0 = coordinates[0][1];
    int x1 = coordinates[1][0];
    int y1 = coordinates[1][1];
    int dx = x1 - x0;
    int dy = y1 - y0;

    for (int i = 2; i < coordinates.size(); ++i) {
      int x = coordinates[i][0];
      int y = coordinates[i][1];
      if ((x - x0) * dy != (y - y0) * dx)
        return false;
    }

    return true;
  }
};"
"class Solution:
    def __init__(self):
        self.nums = [0, 1]
        for i in range(2, 101):
            d, r = divmod(i, 2)
            if r == 0:
                self.nums.append(self.nums[d])
            else:
                p = int(i/2)
                self.nums.append(self.nums[d] + self.nums[d+1])
                
        
    def getMaximumGenerated(self, n: int) -> int:
        '''
        0 1 2 3 4 5 6 7 8 9 ...
        0 1 1 2 1 3 2 3 1 4 ...
        '''
        return max(self.nums[:n+1])","class Solution {
 public:
  vector<string> removeSubfolders(vector<string>& folder) {
    vector<string> ans;
    string prev;

    sort(begin(folder), end(folder));

    for (const string& f : folder) {
      if (!prev.empty() && f.find(prev) == 0 && f[prev.length()] == '/')
        continue;
      ans.push_back(f);
      prev = f;
    }

    return ans;
  }
};"
"class Solution:
    def minDeletions(self, s: str) -> int:
        
        cnt_dict = {}
        
        for c in s:
            if c in cnt_dict:
                cnt_dict[c]+=1
            else:
                cnt_dict[c]=1                                   #Store the frequency of each character in a dictionary
                
        cnt_dict = {k: v for k, v in sorted(cnt_dict.items(), reverse=True, key=lambda item: item[1])}  #Sort the dictionary in a non-increasing order of the frequencies
             
        freq_found = []                                         #Store which frequencies have been found till now
        res = 0                                                 #Store how many characters to remove to make frequencies unique
        for c in cnt_dict.keys():
            while cnt_dict[c]>0 and cnt_dict[c] in freq_found:  #Don't reduce the frequency if the frequency is already 0
                cnt_dict[c]-=1
                res+=1
            freq_found.append(cnt_dict[c])                      #Found a unique frequency, append to the list
            
            
        return res","class Solution {
 public:
  int balancedString(string s) {
    const int n = s.length();
    const int k = n / 4;
    int ans = n;
    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (int i = 0, j = 0; i < n; ++i) {
      --count[s[i]];
      while (j < n && count['Q'] <= k && count['W'] <= k && count['E'] <= k &&
             count['R'] <= k) {
        ans = min(ans, i - j + 1);
        ++count[s[j]];
        ++j;
      }
    }

    return ans;
  }
};"
"class Solution:
    def maxProfit(self, inventory: List[int], orders: int) -> int:
        inventory.sort(reverse=True)
        N = len(inventory)
        width = 1
        total = 0
        
        # sum of Arthematic Progression
        def sumAP(startHeight, endHeight):
            sum1 = startHeight * (startHeight + 1) // 2
            sum2 = endHeight * (endHeight + 1) // 2
            return sum1 - sum2
        
        i = 0
        while orders > 0:
            startHeight = inventory[i]
            endHeight = inventory[i+1] if i < N-1 else 0
            if width * (startHeight - endHeight) < orders:
                total += width * sumAP(startHeight, endHeight)
                orders -= width * (startHeight - endHeight)
            else: # enters else only once at the end
                q, r = divmod(orders, width)
                endHeight = inventory[i] - q
                total += width * sumAP(startHeight, endHeight)
                total += r * (startHeight - q)
                return total % (10 ** 9 + 7)
            width += 1
            i += 1","struct Job {
  int startTime;
  int endTime;
  int profit;
  Job(int startTime, int endTime, int profit)
      : startTime(startTime), endTime(endTime), profit(profit) {}
};

class Solution {
 public:
  int jobScheduling(vector<int>& startTime, vector<int>& endTime,
                    vector<int>& profit) {
    const int n = startTime.size();
    // dp[i] := max profit to schedule jobs[i:]
    dp.resize(n + 1);
    vector<Job> jobs;

    for (int i = 0; i < n; ++i)
      jobs.emplace_back(startTime[i], endTime[i], profit[i]);

    sort(begin(jobs), end(jobs), [](const auto& a, const auto& b) {
      return a.startTime < b.startTime;
    });

    // Will use binary search to find the first available startTime
    for (int i = 0; i < n; ++i)
      startTime[i] = jobs[i].startTime;

    return jobScheduling(jobs, startTime, 0);
  }

 private:
  vector<int> dp;

  int jobScheduling(const vector<Job>& jobs, const vector<int>& startTime,
                    int i) {
    if (i == jobs.size())
      return 0;
    if (dp[i] > 0)
      return dp[i];

    const int j = firstGreaterEqual(startTime, i + 1, jobs[i].endTime);
    const int pick = jobs[i].profit + jobScheduling(jobs, startTime, j);
    const int skip = jobScheduling(jobs, startTime, i + 1);
    return dp[i] = max(pick, skip);
  }

  int firstGreaterEqual(const vector<int>& A, int startFrom, int target) {
    return lower_bound(begin(A) + startFrom, end(A), target) - begin(A);
  }
};"
"class Solution:
    def decrypt(self, code: List[int], k: int) -> List[int]:
        
        s=0
        temp=0
        ans=[]
        
        for i in range(0,len(code)):
        
            temp=k
            s=0
            
            if temp==0:
                ans.append(0)
            
            elif temp>0:
                j=i+1
                while temp>0 and j<len(code):
                    s+=code[j]
                    j=j+1
                    temp=temp-1
                
                if temp>0:
                    j=0
                    while temp>0 and j<len(code):
                        s+=code[j]
                        j=j+1
                        temp=temp-1
                
                ans.append(s)
            
            else:
                temp=temp*(-1)
                j=i-1
                while j>=0 and temp>0:
                    s+=code[j]
                    j=j-1
                    temp=temp-1
                
                if temp>0:
                    j=len(code)-1
                    while j>=0 and temp>0:
                        s+=code[j]
                        j=j-1
                        temp=temp-1
                    
       
                ans.append(s)
        
        return ans","/**
 * // This is the HtmlParser's API interface.
 * // You should not implement it, or speculate about its implementation
 * class HtmlParser {
 *  public:
 *   vector<string> getUrls(string url);
 * };
 */

class Solution {
 public:
  vector<string> crawl(string startUrl, HtmlParser htmlParser) {
    queue<string> q{{startUrl}};
    unordered_set<string> seen{{startUrl}};
    const string& hostname = getHostname(startUrl);

    while (!q.empty()) {
      const string currUrl = q.front();
      q.pop();
      for (const string& url : htmlParser.getUrls(currUrl)) {
        if (seen.count(url))
          continue;
        if (url.find(hostname) != string::npos) {
          q.push(url);
          seen.insert(url);
        }
      }
    }

    return {begin(seen), end(seen)};
  }

 private:
  string getHostname(const string& url) {
    const int firstSlash = url.find_first_of('/');
    const int thirdSlash = url.find_first_of('/', firstSlash + 2);
    return url.substr(firstSlash + 2, thirdSlash - firstSlash - 2);
  }
};"
"class Solution:
    def minimumDeletions(self, s: str) -> int:
                        
        a_idx = [0] + list(itertools.accumulate([1 if c == 'a' else 0 for c in s]))
        b_idx = [0] + list(itertools.accumulate([1 if c == 'b' else 0 for c in s]))
        
        result = float('inf')
        
        for idx in range(len(s)):
            result = min(
                result,
                a_idx[-1] - a_idx[idx+1] +  b_idx[idx] - b_idx[0]
            )
        
        return result","class Solution {
 public:
  vector<vector<int>> findSolution(CustomFunction& customfunction, int z) {
    vector<vector<int>> ans;
    int x = 1;
    int y = 1000;

    while (x <= 1000 && y >= 1) {
      int f = customfunction.f(x, y);
      if (f < z)
        ++x;
      else if (f > z)
        --y;
      else
        ans.push_back({x++, y--});
    }

    return ans;
  }
};"
"class Solution:
    def minimumJumps(self, forbidden, a, b, x):
        limit, visited = max(x,max(forbidden)) + a + b, set()

        stack = [(0,0,False)]

        while stack:
            val, steps, par = stack.pop(0)

            if val > limit or val < 0 or val in forbidden or (val,par) in visited:
                continue
            else:
                visited.add((val,par))

            if val == x:
                return steps

            stack.append((val+a,steps+1,False))

            if not par:
                stack.append((val-b,steps+1,True))

        return -1","class Solution {
 public:
  vector<int> circularPermutation(int n, int start) {
    vector<int> ans;

    for (int i = 0; i < 1 << n; ++i)
      ans.push_back(start ^ i ^ i >> 1);

    return ans;
  }
};"
"class Solution:
    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:
        
        arr=[0]*(1001)
        for i in nums:
            arr[i]+=1
            
        arr.sort(reverse=True)
        #print(arr)
        arr=arr[:10]
        dict={}
        def dfs(ind,arr):
            if ind==m:
                return True
            if (ind,tuple(arr)) in dict:
                return dict[(ind,tuple(arr))]
            
            for i in range(0,10):
                if arr[i]>=quantity[ind]:
                    arr[i]-=quantity[ind]
                    a=dfs(ind+1,arr)
                    arr[i]+=quantity[ind]
                    if a:
                        dict[(ind,tuple(arr))]=True
                        
                        return True
                    
            dict[(ind,tuple(arr))]=False
            return False
        m=len(quantity)
        return dfs(0,arr)","class Solution {
 public:
  int maxLength(vector<string>& arr) {
    vector<int> masks;

    for (const string& s : arr) {
      const int mask = getMask(s);
      if (mask != -1)
        masks.push_back(mask);
    }

    return dfs(masks, 0, /*usedMask=*/0);
  }

 private:
  int dfs(const vector<int>& masks, int s, int usedMask) {
    int res = __builtin_popcount(usedMask);
    for (int i = s; i < masks.size(); ++i)
      if ((usedMask & masks[i]) == 0)
        res = max(res, dfs(masks, i + 1, usedMask | masks[i]));
    return res;
  }

  int getMask(const string& s) {
    int mask = 0;
    for (const char c : s) {
      const int i = c - 'a';
      if ((mask & (1 << i)) != 0)
        return -1;
      mask |= 1 << i;
    }
    return mask;
  }
};"
"class Solution(object):
    def closeStrings(self, word1, word2):
        def ans(word):
            dict1 ={}
            for i in word:
                if i not in dict1:dict1[i]=1
                else:dict1[i]+=1
            return sorted(dict1.values())
        return ans(word1)==ans(word2) and set(word1)==set(word2)","class Solution {
 public:
  int tilingRectangle(int n, int m) {
    return tilingRectangle(n, m, 0, vector<int>(m));
  }

 private:
  static constexpr int kBase = 13;
  unordered_map<long, int> dp;

  int tilingRectangle(int n, int m, long hashedHeights, vector<int>&& heights) {
    if (const auto it = dp.find(hashedHeights); it != cend(dp))
      return it->second;

    const auto it = min_element(begin(heights), end(heights));
    const int minHeight = *it;
    if (minHeight == n)  // All filled
      return 0;

    int ans = m * n;
    const int start = it - begin(heights);
    // Try to put square of different size that doesn't exceed the width/height
    for (int sz = 1; sz <= min(m - start, n - minHeight); ++sz) {
      // heights[start:start + sz] must has the same height
      if (heights[start + sz - 1] != minHeight)
        break;
      // Put a square of size `sz` to cover heights[start:start + sz]
      for (int i = start; i < start + sz; ++i)
        heights[i] += sz;
      ans = min(ans, tilingRectangle(n, m, hash(heights), move(heights)));
      for (int i = start; i < start + sz; ++i)
        heights[i] -= sz;
    }

    return dp[hashedHeights] = 1 + ans;
  }

  long hash(const vector<int>& heights) {
    long hashed = 0;
    for (int i = heights.size() - 1; i >= 0; --i)
      hashed = hashed * kBase + heights[i];
    return hashed;
  }
};"
"class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        total_sum = sum(nums)
        
        left, right = 0, 0
        max_len_win = -1
        current_win_sum = 0
        
        while right < len(nums):
            current_win_sum += nums[right]
            
            while current_win_sum > total_sum - x and left <= right:
                current_win_sum -= nums[left]
                left += 1
            
            if current_win_sum == total_sum - x:
                max_len_win = max(max_len_win, right - left + 1)
        
            right += 1

        return len(nums) - max_len_win if max_len_win != -1 else -1","/**
 * // This is the HtmlParser's API interface.
 * // You should not implement it, or speculate about its implementation
 * class HtmlParser {
 *  public:
 *   vector<string> getUrls(string url);
 * };
 */

class Solution {
 public:
  vector<string> crawl(string startUrl, HtmlParser htmlParser) {
    queue<string> q{{startUrl}};
    unordered_set<string> seen{{startUrl}};
    const string& hostname = getHostname(startUrl);

    // Threading
    const int nThreads = std::thread::hardware_concurrency();
    vector<thread> threads;
    std::mutex mtx;
    std::condition_variable cv;

    auto t = [&]() {
      while (true) {
        unique_lock<mutex> lock(mtx);
        cv.wait_for(lock, 30ms, [&]() { return q.size(); });

        if (q.empty())
          return;

        auto cur = q.front();
        q.pop();

        lock.unlock();

        const vector<string> urls = htmlParser.getUrls(cur);

        lock.lock();
        for (const string& url : urls) {
          if (seen.count(url))
            continue;
          if (url.find(hostname) != string::npos) {
            q.push(url);
            seen.insert(url);
          }
        }
        lock.unlock();
        cv.notify_all();
      }
    };

    for (int i = 0; i < nThreads; ++i)
      threads.emplace_back(t);

    for (std::thread& t : threads)
      t.join();

    return {begin(seen), end(seen)};
  }

 private:
  string getHostname(const string& url) {
    const int firstSlash = url.find_first_of('/');
    const int thirdSlash = url.find_first_of('/', firstSlash + 2);
    return url.substr(firstSlash + 2, thirdSlash - firstSlash - 2);
  }
};"
"class Solution:
    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:
        
        @cache
        def fn(prev, i, j, intro, extro): 
            """"""Return max grid happiness at (i, j).""""""
            if i == m: return 0 # no more position
            if j == n: return fn(prev, i+1, 0, intro, extro)
            if intro == extro == 0: return 0 
            
            prev0 = prev[:j] + (0,) + prev[j+1:]
            ans = fn(prev0, i, j+1, intro, extro)
            if intro: 
                val = 120 
                if i and prev[j]: # neighbor from above 
                    val -= 30 
                    if prev[j] == 1: val -= 30 
                    else: val += 20 
                if j and prev[j-1]: # neighbor from left 
                    val -= 30 
                    if prev[j-1] == 1: val -= 30 
                    else: val += 20 
                prev0 = prev[:j] + (1,) + prev[j+1:]
                ans = max(ans, val + fn(prev0, i, j+1, intro-1, extro))
            if extro: 
                val = 40 
                if i and prev[j]: 
                    val += 20 
                    if prev[j] == 1: val -= 30 
                    else: val += 20 
                if j and prev[j-1]: 
                    val += 20 
                    if prev[j-1] == 1: val -= 30 
                    else: val += 20 
                prev0 = prev[:j] + (2,) + prev[j+1:]
                ans = max(ans, val + fn(prev0, i, j+1, intro, extro-1))
            return ans 
        
        return fn((0,)*n, 0, 0, introvertsCount, extrovertsCount)","class Solution {
 public:
  int treeDiameter(vector<vector<int>>& edges) {
    const int n = edges.size();
    int ans = 0;
    vector<vector<int>> tree(n + 1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    maxDepth(tree, 0, -1, ans);
    return ans;
  }

 private:
  int maxDepth(const vector<vector<int>>& tree, int u, int parent, int& ans) {
    int maxDepth1 = 0;   // The max depth
    int maxDepth2 = -1;  // The 2nd max depth

    for (const int v : tree[u]) {
      if (v == parent)
        continue;
      const int depth = maxDepth(tree, v, u, ans);
      if (depth > maxDepth1) {
        maxDepth2 = maxDepth1;
        maxDepth1 = depth;
      } else if (depth > maxDepth2) {
        maxDepth2 = depth;
      }
    }

    ans = max(ans, maxDepth1 + maxDepth2);
    return 1 + maxDepth1;
  }
};"
"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        return """".join(word1) == """".join(word2)","class Solution {
 public:
  int minimumMoves(vector<int>& arr) {
    const int n = arr.size();
    // dp[i][j] := min # of moves to remove all numbers from arr[i..j]
    vector<vector<int>> dp(n, vector<int>(n, n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int i = 0; i + 1 < n; ++i)
      dp[i][i + 1] = arr[i] == arr[i + 1] ? 1 : 2;

    for (int d = 2; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        // Remove arr[i] and arr[j] within the move of
        // Removing arr[i + 1..j - 1]
        if (arr[i] == arr[j])
          dp[i][j] = dp[i + 1][j - 1];
        // Try all possible partitions
        for (int k = i; k < j; ++k)
          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);
      }

    return dp[0][n - 1];
  }
};"
"class Solution:
    def getSmallestString(self, n: int, k: int) -> str:
        # set all 'a' char
        res = ['a' for _ in range(n)]
        k -= n
        
        idx = n - 1
        while k > 0:
            k += 1 # return num value of current 'a' char
            char_num_val = min(k, 26) # 26 - num value of 'z' char
            
            k -= char_num_val
            res[idx] = chr(char_num_val + 97 - 1) # '97' ascii code of 'a', but 1-indexed, so we must remove 1
            idx -= 1 # move idx
            
        return ''.join(res)","class Solution {
 public:
  int minimumSwap(string s1, string s2) {
    // (""xx"", ""yy"") = (2 ""xy""s) -> 1 swap
    // (""yy"", ""xx"") = (2 ""yx""s) -> 1 swap
    // (""xy"", ""yx"") = (1 ""xy"" and 1 ""yx"") -> 2 swaps
    int xy = 0;  // # of index i s.t. s1[i] = 'x' and s2[i] 'y'
    int yx = 0;  // # of index i s.t. s1[i] = 'y' and s2[i] 'x'

    for (int i = 0; i < s1.length(); ++i) {
      if (s1[i] == s2[i])
        continue;
      if (s1[i] == 'x')
        ++xy;
      else
        ++yx;
    }

    if ((xy + yx) % 2 == 1)
      return -1;
    return xy / 2 + yx / 2 + (xy % 2 == 1 ? 2 : 0);
  }
};"
"class Solution:
    def waysToMakeFair(self, nums: List[int]) -> int:
        
        even=[]
        odd=[]
        e=0
        o=0
        
        for i in range(len(nums)):
            if i%2==0:
                e+=nums[i]
                
            else:
                o+=nums[i]
            
            even.append(e)
            odd.append(o)
            
        ans=0
        
        for i in range(len(nums)):
            if i%2==0:
                
                e1=even[i]
                e1-=nums[i]
                e1+= odd[len(nums)-1]
                e1-=odd[i]
                
                o1=odd[i]
                o1+=even[len(nums)-1]
                o1-=even[i]
                
                if e1==o1:
                    ans+=1
            else:
                o1=odd[i]
                o1-=nums[i]
                o1+=even[len(nums)-1]
                o1-=even[i]
                
                e1=even[i]
                e1+=odd[len(nums)-1]
                e1-=odd[i]
                
                if o1==e1:
                    ans+=1
        return ans","class Solution {
 public:
  int numberOfSubarrays(vector<int>& nums, int k) {
    return numberOfSubarraysAtMost(nums, k) -
           numberOfSubarraysAtMost(nums, k - 1);
  }

 private:
  int numberOfSubarraysAtMost(vector<int>& nums, int k) {
    int ans = 0;

    for (int l = 0, r = 0; r <= nums.size();)
      if (k >= 0) {
        ans += r - l;
        if (r == nums.size())
          break;
        if (nums[r] & 1)
          --k;
        ++r;
      } else {
        if (nums[l] & 1)
          ++k;
        ++l;
      }

    return ans;
  }
};"
"class Solution:
    def minimumEffort(self, tasks: List[List[int]]) -> int:
        energy=0
        remain=0
        ar=[]
        
        for task in range(len(tasks)):
            ar.append((tasks[task][1]-tasks[task][0],task))
        ar.sort()

        for task in ar[::-1]:
            if tasks[task[1]][1]>remain:
                energy+=(tasks[task[1]][1]-remain)
                remain=task[0]
            else:
                remain-=tasks[task[1]][1]
                remain+=task[0]
                
        return energy","class Solution {
 public:
  string minRemoveToMakeValid(string s) {
    stack<int> stack;  // Unpaired '(' indices

    for (int i = 0; i < s.length(); ++i)
      if (s[i] == '(') {
        stack.push(i);  // Record unpaired '(' index
      } else if (s[i] == ')') {
        if (stack.empty())
          s[i] = '*';  // Mark unpaired ')' as '*'
        else
          stack.pop();  // Find a pair!
      }

    // Mark unpaired '(' as '*'
    while (!stack.empty())
      s[stack.top()] = '*', stack.pop();

    s.erase(remove(begin(s), end(s), '*'), end(s));
    return s;
  }
};"
"class Solution:
    def maxRepeating(self, sequence: str, word: str) -> int:
        if word in sequence:
            replaced = sequence.replace(word, '0')
        else:
            return 0
        
        flag, ans = 0, 0
        for char in replaced:
            if char == '0':
                flag += 1
            else:
                ans = max(ans, flag)
                flag = 0
        ans = max(ans, flag)
        
        return ans","class Solution {
 public:
  bool isGoodArray(vector<int>& nums) {
    int g = nums[0];

    for (const int num : nums)
      g = __gcd(g, num);

    return g == 1;
  }
};"
"class Solution:
    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:
        head=list1
        c=0
        while(c<=b):
            if c==a-1:
                prev=list1
                list1=list1.next
                prev.next=list2
            else:
                list1=list1.next
            c+=1
        while(list2.next):
            list2=list2.next
        list2.next=list1
        return head","class Solution {
 public:
  int oddCells(int m, int n, vector<vector<int>>& indices) {
    int ans = 0;
    // rows[i] and cols[i] :=
    //   true (flipped even times) / false (flipped odd times)
    vector<bool> rows(m);
    vector<bool> cols(n);

    for (const vector<int>& index : indices) {
      rows[index[0]] = rows[index[0]] ^ true;
      cols[index[1]] = cols[index[1]] ^ true;
    }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        ans += rows[i] ^ cols[j];

    return ans;
  }
};"
"class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        
        def fn(nums): 
            """"""Return length of LIS (excluding x) ending at x.""""""
            ans, vals = [], []
            for i, x in enumerate(nums): 
                k = bisect_left(vals, x)
                if k == len(vals): vals.append(x)
                else: vals[k] = x
                ans.append(k)
            return ans 
        
        left, right = fn(nums), fn(nums[::-1])[::-1]
        
        ans = inf
        for i in range(1, len(nums)-1): 
            if left[i] and right[i]:
                ans = min(ans, len(nums) - left[i] - right[i] - 1)
        return ans","class Solution {
 public:
  vector<vector<int>> reconstructMatrix(int upper, int lower,
                                        vector<int>& colsum) {
    if (upper + lower != accumulate(begin(colsum), end(colsum), 0))
      return {};
    if (min(upper, lower) <
        count_if(begin(colsum), end(colsum), [](int c) { return c == 2; }))
      return {};

    vector<vector<int>> ans(2, vector<int>(colsum.size()));

    for (int j = 0; j < colsum.size(); ++j)
      if (colsum[j] == 2) {
        ans[0][j] = 1;
        ans[1][j] = 1;
        --upper;
        --lower;
      }

    for (int j = 0; j < colsum.size(); ++j) {
      if (colsum[j] == 1 && upper > 0) {
        ans[0][j] = 1;
        --colsum[j];
        --upper;
      }

      if (colsum[j] == 1 && lower > 0) {
        ans[1][j] = 1;
        --lower;
      }
    }

    return ans;
  }
};"
"class Solution:
    def maximumWealth(self, accounts: List[List[int]]) -> int:
        maxwealth=0
        for i in range(len(accounts)):
            maxwealth=max(maxwealth,sum(accounts[i]))
        return maxwealth","class Solution {
 public:
  int closedIsland(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();

    // Remove lands connected to edge
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i * j == 0 || i == m - 1 || j == n - 1)
          if (grid[i][j] == 0)
            dfs(grid, i, j);

    int ans = 0;

    // Reduce to 200. Number of Islands
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 0) {
          dfs(grid, i, j);
          ++ans;
        }

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] == 1)
      return;

    grid[i][j] = 1;
    dfs(grid, i + 1, j);
    dfs(grid, i - 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i, j - 1);
  };
};"
"class Solution:   # time limit
    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:
        return min(combinations(nums, k))","class Solution {
 public:
  int maxScoreWords(vector<string>& words, vector<char>& letters,
                    vector<int>& score) {
    vector<int> count(26);
    for (const char c : letters)
      ++count[c - 'a'];
    return dfs(words, 0, count, score);
  }

 private:
  // Max score you can get from words[s:]
  int dfs(const vector<string>& words, int s, vector<int>& count,
          const vector<int>& score) {
    int ans = 0;
    for (int i = s; i < words.size(); ++i) {
      const int earned = useWord(words, i, count, score);
      if (earned > 0)
        ans = max(ans, earned + dfs(words, i + 1, count, score));
      unuseWord(words, i, count);
    }
    return ans;
  }

  int useWord(const vector<string>& words, int i, vector<int>& count,
              const vector<int>& score) {
    bool isValid = true;
    int earned = 0;
    for (const char c : words[i]) {
      if (--count[c - 'a'] < 0)
        isValid = false;
      earned += score[c - 'a'];
    }
    return isValid ? earned : -1;
  }

  void unuseWord(const vector<string>& words, int i, vector<int>& count) {
    for (const char c : words[i])
      ++count[c - 'a'];
  }
};"
"class Solution:
    def minMoves(self, nums: List[int], limit: int) -> int:
        freq = {} # frequency table 
        lower, upper = [], []
        
        for i in range(len(nums)//2): 
            x = nums[i] + nums[~i]
            freq[x] = 1 + freq.get(x, 0)
            lower.append(min(nums[i], nums[~i]))
            upper.append(max(nums[i], nums[~i]) + 1 + limit)
        
        lower.sort()
        upper.sort()
        
        ans = inf
        for x in freq: 
            k = len(lower) - bisect_left(lower, x)
            kk = bisect_right(upper, x)
            val = len(nums)//2 - freq[x] + k + kk
            ans = min(ans, val)
        return ans","class Solution {
 public:
  string encode(int num) {
    string binaryStr = bitset<30>(num + 1).to_string();
    binaryStr.erase(0, binaryStr.find_first_not_of('0'));
    return binaryStr.substr(1);
  }
};"
"class Solution:
    def minimumDeviation(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            if nums[i]%2!=0:
                nums[i]*=2
        minVal=min(nums)
        nums=[-val for val in nums]
        nums,ans=nums,float('inf')
        heapify(nums)
        while nums and abs(nums[0])%2==0:
            maxVal=abs(heappop(nums))
            ans=min(ans,abs(maxVal-minVal))
            maxVal=maxVal//2
            minVal=min(minVal,maxVal)
            heappush(nums,-maxVal)
        return min(ans,abs(min(nums))-abs(max(nums)))","class Solution {
 public:
  string findSmallestRegion(vector<vector<string>>& regions, string region1,
                            string region2) {
    unordered_map<string, string> parent;
    unordered_set<string> ancestors;  // region1's ancestors

    for (const vector<string>& region : regions)
      for (int i = 1; i < region.size(); ++i)
        parent[region[i]] = region[0];

    // Insert all of region1's ancestors
    while (region1 != """") {
      ancestors.insert(region1);
      region1 = parent[region1];  // Region1 becomes """" in the end
    }

    // Go up from region2 until meet any of region1's ancestors
    while (!ancestors.count(region2))
      region2 = parent[region2];

    return region2;
  }
};"
"class Solution:
    def interpret(self, command: str) -> str:
        res = """"
        i = 0
        while i < len(command):
            if command[i] == ""G"":
                res += ""G""
                i += 1
            elif command[i] == ""("" and command[i+1] == "")"":
                res += ""o""
                i += 2
            else:
                res += ""al""
                i += 4
        return res","class Solution {
 public:
  vector<string> generateSentences(vector<vector<string>>& synonyms,
                                   string text) {
    set<string> ans;
    unordered_map<string, vector<string>> graph;
    queue<string> q{{text}};

    for (const vector<string>& synonym : synonyms) {
      const string& s = synonym[0];
      const string& t = synonym[1];
      graph[s].push_back(t);
      graph[t].push_back(s);
    }

    while (!q.empty()) {
      const string u = q.front();
      q.pop();
      ans.insert(u);
      vector<string> words = split(u);
      for (string& word : words) {
        const auto it = graph.find(word);
        if (it == cend(graph))
          continue;
        for (const string& synonym : it->second) {
          // Replace words[i] with its synonym.
          word = synonym;
          const string newText = join(words, ' ');
          if (!ans.count(newText))
            q.push(newText);
        }
      }
    }

    return {begin(ans), end(ans)};
  }

 private:
  vector<string> split(const string& s) {
    vector<string> words;
    istringstream iss(s);
    for (string token; iss >> token;)
      words.push_back(token);
    return words;
  }

  string join(const vector<string>& words, char c) {
    string joined;
    for (int i = 0; i < words.size(); ++i) {
      joined += words[i];
      if (i != words.size() - 1)
        joined += c;
    }
    return joined;
  }
};"
"class Solution:
    def maxOperations(self, nums: List[int], k: int) -> int:
        ans = 0
        if not nums or len(nums) == 1:
            return ans
        nums.sort()
        l = 0
        r = len(nums) - 1
        while l < r:
            s = nums[l] + nums[r]
            if s == k:
                ans += 1
                l +=1
                r -=1
            elif s > k:
                r -= 1
            else:
                l += 1
        return ans","class Solution {
 public:
  int numberOfWays(int numPeople) {
    constexpr int kMod = 1'000'000'007;
    // dp[i] := # of ways i handshakes pair w/o crossing
    vector<long> dp(numPeople / 2 + 1);
    dp[0] = 1;

    for (int i = 1; i <= numPeople / 2; ++i)
      for (int j = 0; j < i; ++j) {
        dp[i] += dp[j] * dp[i - 1 - j];
        dp[i] %= kMod;
      }

    return dp[numPeople / 2];
  }
};"
"class Solution:
    def concatenatedBinary(self, n: int) -> int:
        s=''
        for i in range(1, n+1):
            s+=bin(i).replace(""0b"", """")
            # print(s)
        return int(s,2)%1000000007","class Solution {
 public:
  vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<int>> ans(m, vector<int>(n));

    k %= m * n;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        int index = (i * n + j + k) % (m * n);
        int x = index / n;
        int y = index % n;
        ans[x][y] = grid[i][j];
      }

    return ans;
  }
};"
"class Solution:
    def minimumIncompatibility(self, nums: List[int], k: int) -> int:
                        
        partition_len = len(nums) // k        
                
        @functools.lru_cache(maxsize=None)
        def recurse(nums):            
            if not nums: return 0      
            
            result = float('inf')
            
            for combo in itertools.combinations(nums, partition_len):                
                
                if len(set(combo)) < partition_len: continue
                                                 
                updated_nums = list(nums) 
                for i in combo:
                    updated_nums.remove(i)
                                    
                result = min(
                    result,
                    max(combo) - min(combo) + recurse(tuple(updated_nums))
                )
                
            return result
        
        result = recurse(tuple(nums))
        
        return result if result != float('inf') else -1","class FindElements {
 public:
  FindElements(TreeNode* root) {
    dfs(root, 0);
  }

  bool find(int target) {
    return vals.count(target);
  }

 private:
  unordered_set<int> vals;

  void dfs(TreeNode* root, int val) {
    if (root == nullptr)
      return;

    root->val = val;
    vals.insert(val);
    dfs(root->left, val * 2 + 1);
    dfs(root->right, val * 2 + 2);
  }
};"
"class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        
        consistentStringCount = 0
        setAllowed = set(allowed)
        
        for word in words:
            setWord = set(word)
            if len(setWord - setAllowed) == 0:
                consistentStringCount +=1
        return consistentStringCount","class Solution {
 public:
  int maxSumDivThree(vector<int>& nums) {
    vector<int> dp(3);  // dp[i] := max sum so far s.t. sum % 3 == i

    for (const int num : nums)
      for (const int sum : vector<int>(dp))
        dp[(sum + num) % 3] = max(dp[(sum + num) % 3], sum + num);

    return dp[0];
  }
};"
"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        ans = []
        for i, x in enumerate(nums): 
            ans.append(prefix[-1] - 2*prefix[i] + (2*i - len(nums)) * nums[i])
        return ans","class Solution {
 public:
  int minPushBox(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<int> box;
    vector<int> player;
    vector<int> target;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 'B')
          box = {i, j};
        else if (grid[i][j] == 'S')
          player = {i, j};
        else if (grid[i][j] == 'T')
          target = {i, j};

    int ans = 0;
    // (boxX, boxY, playerX, playerY)
    queue<tuple<int, int, int, int>> q{
        {{box[0], box[1], player[0], player[1]}}};
    vector<vector<vector<vector<bool>>>> seen(
        m, vector<vector<vector<bool>>>(
               n, vector<vector<bool>>(m, vector<bool>(n))));
    seen[box[0]][box[1]][player[0]][player[1]] = true;

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [boxX, boxY, playerX, playerY] = q.front();
        q.pop();
        if (boxX == target[0] && boxY == target[1])
          return ans;
        for (int k = 0; k < 4; ++k) {
          const int nextBoxX = boxX + dirs[k];
          const int nextBoxY = boxY + dirs[k + 1];
          if (isInvalid(grid, nextBoxX, nextBoxY))
            continue;
          if (seen[nextBoxX][nextBoxY][boxX][boxY])
            continue;
          const int fromX = boxX + dirs[(k + 2) % 4];
          const int fromY = boxY + dirs[(k + 3) % 4];
          if (isInvalid(grid, fromX, fromY))
            continue;
          if (canGoTo(grid, playerX, playerY, fromX, fromY, boxX, boxY)) {
            seen[nextBoxX][nextBoxY][boxX][boxY] = true;
            q.emplace(nextBoxX, nextBoxY, boxX, boxY);
          }
        }
      }
      ++ans;
    }

    return -1;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};

  // Returns true if (playerX, playerY) can go to (fromX, fromY).
  bool canGoTo(const vector<vector<char>>& grid, int playerX, int playerY,
               int fromX, int fromY, int boxX, int boxY) {
    queue<pair<int, int>> q{{{playerX, playerY}}};
    vector<vector<bool>> seen(grid.size(), vector<bool>(grid[0].size()));
    seen[playerX][playerY] = true;

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      if (i == fromX && j == fromY)
        return true;
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (isInvalid(grid, x, y))
          continue;
        if (seen[x][y])
          continue;
        if (x == boxX && y == boxY)
          continue;
        q.emplace(x, y);
        seen[x][y] = true;
      }
    }

    return false;
  }

  bool isInvalid(const vector<vector<char>>& grid, int playerX, int playerY) {
    return playerX < 0 || playerX == grid.size() || playerY < 0 ||
           playerY == grid[0].size() || grid[playerX][playerY] == '#';
  }
};"
"class Solution:
    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:
        pq = [(-x-y, x, y) for x, y in zip(aliceValues, bobValues)]
        heapify(pq)
        
        s0 = s1 = i = 0
        while pq: 
            _, x, y = heappop(pq)
            if i: s1 += y
            else: s0 += x
            i ^= 1
        if s0 > s1: return 1
        if s0 < s1: return -1
        return 0","/**
 * // This is the ImmutableListNode's API interface.
 * // You should not implement it, or speculate about its implementation.
 * class ImmutableListNode {
 *  public:
 *   void printValue(); // Print the value of the node.
 *   ImmutableListNode* getNext(); // Returns the next node.
 * };
 */

class Solution {
 public:
  void printLinkedListInReverse(ImmutableListNode* head) {
    if (head == nullptr)
      return;

    printLinkedListInReverse(head->getNext());
    head->printValue();
  }
};"
"class Solution:
    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:
        dp = [0] + [inf]*len(boxes)
        trips = 2
        ii = 0
        for i in range(len(boxes)):
            maxWeight -= boxes[i][1]
            if i and boxes[i-1][0] != boxes[i][0]: trips += 1
            while maxBoxes < i - ii + 1 or maxWeight < 0 or ii < i and dp[ii] == dp[ii+1]:
                maxWeight += boxes[ii][1]
                if boxes[ii][0] != boxes[ii+1][0]: trips-=1
                ii += 1
            dp[i+1] = dp[ii] + trips
        return dp[-1]","class Solution {
 public:
  int minTimeToVisitAllPoints(vector<vector<int>>& points) {
    int ans = 0;

    for (int i = 1; i < points.size(); ++i)
      ans += max(abs(points[i][0] - points[i - 1][0]),
                 abs(points[i][1] - points[i - 1][1]));

    return ans;
  }
};"
"class Solution:
    def numberOfMatches(self, n: int) -> int:
        matches=0
        while n > 1:
            if n%2==0:
                matches+=int(n/2)
                n = n/2
            else:
                matches+=int((n-1)/2)
                n = (n+1)/2
        return matches","class Solution {
 public:
  int countServers(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;
    vector<int> rows(m);
    vector<int> cols(n);

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1) {
          ++rows[i];
          ++cols[j];
        }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1 && (rows[i] > 1 || cols[j] > 1))
          ++ans;

    return ans;
  }
};"
"class Solution:
    def minPartitions(self, n: str) -> int:
        return int(max(n))","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  const string* word = nullptr;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  vector<vector<string>> suggestedProducts(vector<string>& products,
                                           string searchWord) {
    vector<vector<string>> ans;

    for (const string& product : products)
      insert(product);

    shared_ptr<TrieNode> node = root;

    for (const char c : searchWord) {
      if (node == nullptr || node->children[c - 'a'] == nullptr) {
        node = nullptr;
        ans.push_back({});
        continue;
      }
      node = node->children[c - 'a'];
      ans.push_back(search(node));
    }

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->word = &word;
  }

  vector<string> search(shared_ptr<TrieNode> node) {
    vector<string> res;
    dfs(node, res);
    return res;
  }

  void dfs(shared_ptr<TrieNode> node, vector<string>& ans) {
    if (ans.size() == 3)
      return;
    if (node == nullptr)
      return;
    if (node->word != nullptr)
      ans.push_back(*node->word);
    for (shared_ptr<TrieNode> child : node->children)
      dfs(child, ans);
  }
};"
"class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        n=len(stones)
        total=[stones[0]]
        for i in stones[1:]:
            total.append(total[-1]+i)
        new=[[0 for i in range(0,n)] for i in range(0,n)]
        for gap in range(1,n):
            for j in range(gap,n):
                i=j-gap
                if gap==1:
                    new[i][j]=max(stones[i],stones[j])
                else:
                    s1=total[j]-total[i]
                    if i==0:
                        s2=total[j-1]
                    else:
                        s2=total[j-1]-total[i-1]
                    new[i][j]=max(s1-new[i+1][j],s2-new[i][j-1])
        return new[0][-1]","class Solution {
 public:
  int numWays(int steps, int arrLen) {
    constexpr int kMod = 1'000'000'007;
    const int n = min(arrLen, steps / 2 + 1);
    // dp[i] := # of ways to stay on index i
    vector<long> dp(n);
    dp[0] = 1;

    while (steps--) {
      vector<long> newDp(n);
      for (int i = 0; i < n; ++i) {
        newDp[i] = dp[i];
        if (i - 1 >= 0)
          newDp[i] += dp[i - 1];
        if (i + 1 < n)
          newDp[i] += dp[i + 1];
        newDp[i] %= kMod;
      }
      dp = move(newDp);
    }

    return dp[0];
  }
};"
"class Solution:
    def maxHeight(self, cuboids: List[List[int]]) -> int:
        cuboids = sorted((sorted(x, reverse=True) for x in cuboids), reverse=True)
        
        @lru_cache(None)
        def fn(i, h, l, w): 
            """"""Return max heights of stacking cuboids[i:].""""""
            if i == len(cuboids): return 0 # no cuboids left 
            hi, li, wi = cuboids[i]
            if hi <= h and li <= l and wi <= w: 
                return max(hi + fn(i+1, hi, li, wi), fn(i+1, h, l, w))
            else:
                return fn(i+1, h, l, w)
            
        return fn(0, inf, inf, inf)","class Solution {
 public:
  vector<vector<int>> removeInterval(vector<vector<int>>& intervals,
                                     vector<int>& toBeRemoved) {
    vector<vector<int>> ans;

    for (const vector<int>& interval : intervals) {
      const int a = interval[0];
      const int b = interval[1];
      if (a >= toBeRemoved[1] || b <= toBeRemoved[0]) {
        ans.push_back(interval);
      } else {  // a < toBeRemoved[1] && b > toBeRemoved[0]
        if (a < toBeRemoved[0])
          ans.push_back({a, toBeRemoved[0]});
        if (b > toBeRemoved[1])
          ans.push_back({toBeRemoved[1], b});
      }
    }

    return ans;
  }
};"
"class Solution:
    def reformatNumber(self, number: str):
        pure_digits = number.replace(' ', '').replace('-', '')
        pure_digits_lengh = len(pure_digits)
        if pure_digits_lengh > 2:
            new_array = []
            count = 0
            temp = """"
            for d in pure_digits:
                if pure_digits_lengh - len("""".join(new_array)) == 4 and temp == """":
                    new_array.append(pure_digits[-4:-2])
                    new_array.append(pure_digits[-2:])
                    break
                count += 1
                temp += d
                if count == 3:
                    count = 0
                    new_array.append(temp)
                    temp = """"
            if temp:
                new_array.append(temp)

            return '-'.join(new_array)

        else:
            return pure_digits","struct T {
  int sum;
  int count;
};

class Solution {
 public:
  int deleteTreeNodes(int nodes, vector<int>& parent, vector<int>& value) {
    vector<vector<int>> graph(nodes);

    for (int i = 1; i < parent.size(); ++i)
      graph[parent[i]].push_back(i);

    return dfs(graph, 0, value).count;
  }

 private:
  T dfs(const vector<vector<int>>& graph, int u, const vector<int>& value) {
    int sum = value[u];  // Root value
    int count = 1;       // This root

    for (const int v : graph[u]) {
      const T t = dfs(graph, v, value);
      sum += t.sum;
      count += t.count;
    }

    if (sum == 0)     // Delete this u
      return {0, 0};  // So its count = 0
    return {sum, count};
  }
};"
"class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        
        res = 0
        start = 0
        cur = 0
        d = defaultdict(int)
        
        for end in range(len(nums)):
            item = nums[end]
            cur += item
            d[item] += 1
            while d[item] > 1:
                d[nums[start]] -= 1
                cur -= nums[start]
                if d[nums[start]] == 0:
                    del d[nums[start]]
                start += 1
            res = max(res, cur)
        return res","/**
 * // This is Sea's API interface.
 * // You should not implement it, or speculate about its implementation
 * class Sea {
 *  public:
 *   bool hasShips(vector<int> topRight, vector<int> bottomLeft);
 * };
 */

class Solution {
 public:
  int countShips(Sea sea, vector<int> topRight, vector<int> bottomLeft) {
    if (topRight[0] < bottomLeft[0] || topRight[1] < bottomLeft[1])
      return 0;
    if (!sea.hasShips(topRight, bottomLeft))
      return 0;

    // Sea.hashShips(topRight, bottomLeft) == true
    if (topRight[0] == bottomLeft[0] && topRight[1] == bottomLeft[1])
      return 1;

    const int mx = (topRight[0] + bottomLeft[0]) / 2;
    const int my = (topRight[1] + bottomLeft[1]) / 2;
    int ans = 0;
    // Top right
    ans += countShips(sea, topRight, {mx + 1, my + 1});
    // Bottom right
    ans += countShips(sea, {topRight[0], my}, {mx + 1, bottomLeft[1]});
    // Top left
    ans += countShips(sea, {mx, topRight[1]}, {bottomLeft[0], my + 1});
    // Bottom left
    ans += countShips(sea, {mx, my}, bottomLeft);
    return ans;
  }
};"
"class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        n = len(nums)
        t = [0 for _ in range(n)]
        t[n-1] = nums[n-1]
        for i in range(n-2, -1, -1):
            start = i+1
            end = min(n-1, i+k)
            temp = max(t[start:end+1])
            t[i] = nums[i] + temp
        return t[0]","class Solution {
 public:
  string tictactoe(vector<vector<int>>& moves) {
    vector<vector<int>> row(2, vector<int>(3));
    vector<vector<int>> col(2, vector<int>(3));
    vector<int> diag1(2);
    vector<int> diag2(2);

    for (int i = 0; i < moves.size(); ++i) {
      int r = moves[i][0];
      int c = moves[i][1];
      int j = i % 2;
      if (++row[j][r] == 3 || ++col[j][c] == 3 || r == c && ++diag1[j] == 3 ||
          r + c == 2 && ++diag2[j] == 3)
        return j == 0 ? ""A"" : ""B"";
    }

    return moves.size() == 9 ? ""Draw"" : ""Pending"";
  }
};"
"class Solution:
    def distanceLimitedPathsExist(self, n: int, A: List[List[int]], B: List[List[int]]) -> List[bool]:
        par = {}
        A.sort(key = lambda x: x[2])
        
        for i, query in enumerate(B):
            query.append(i)
        B.sort(key = lambda x: x[2])
        
        def find(a):
            par.setdefault(a, a)
            if par[a] != a:
                par[a] = find(par[a])
            return par[a]
        
        def union(a, b):
            par.setdefault(a, a)
            par.setdefault(b, b)
            par[find(a)] = par[find(b)]
        
        ans = [False]*len(B)
        i = 0
        for a, b, lim, idx in B:
            while i < len(A) and A[i][2] < lim:
                union(A[i][0], A[i][1])
                i += 1
            
            if find(a) == find(b):
                ans[idx] = True
        return ans","class Solution {
 public:
  vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {
    if (tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices ||
        tomatoSlices > cheeseSlices * 4)
      return {};

    int jumboBurgers = (tomatoSlices - 2 * cheeseSlices) / 2;

    return {jumboBurgers, cheeseSlices - jumboBurgers};
  }
};"
"class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int: 
        counts = [len(students) - sum(students), sum(students)]        
        for s in sandwiches:
            if not counts[s]:
                return sum(counts)
            counts[s] -= 1            
        return 0","class Solution {
 public:
  int countSquares(vector<vector<int>>& matrix) {
    for (int i = 0; i < matrix.size(); ++i)
      for (int j = 0; j < matrix[0].size(); ++j)
        if (matrix[i][j] == 1 && i > 0 && j > 0)
          matrix[i][j] +=
              min({matrix[i - 1][j - 1], matrix[i - 1][j], matrix[i][j - 1]});
    return accumulate(begin(matrix), end(matrix), 0, [](int a, const auto& A) {
      return a + accumulate(begin(A), end(A), 0);
    });
  }
};"
"class Solution:
    def averageWaitingTime(self, customers: List[List[int]]) -> float:
        next_wt = customers[0][0]+customers[0][1]
        time = []
        
        time.append(next_wt-customers[0][0])
        
        for i  in range(1,len(customers)):
            arr = customers[i][0]
            dep = customers[i][1]
            if arr < next_wt:
                wt = (next_wt-arr)+(arr+dep)
            else:
                wt = arr+dep
            time.append(wt  - arr)
            next_wt = wt
        #print(time)
        return sum(time)/len(time)","class Solution {
 public:
  int palindromePartition(string s, int k) {
    const int n = s.length();
    // dp[i][k] := min cost to make k palindromes by s[0..i)
    dp.resize(n + 1, vector<int>(k + 1, n));
    // cost[i][j] := min cost to make s[i..j] palindrome
    cost.resize(n, vector<int>(n));

    for (int d = 1; d < n; ++d)
      for (int i = 0, j = d; j < n; ++i, ++j)
        cost[i][j] = (s[i] != s[j]) + cost[i + 1][j - 1];

    return palindromePartition(n, k);
  }

 private:
  vector<vector<int>> dp;
  vector<vector<int>> cost;

  int palindromePartition(int n, int k) {
    if (k == 1)
      return cost[0][n - 1];
    int& ans = dp[n][k];
    if (ans < n)
      return ans;

    // Try all possible partitions
    for (int i = k - 1; i < n; ++i)
      ans = min(ans, palindromePartition(i, k - 1) + cost[i][n - 1]);

    return ans;
  }
};"
"class Solution:
    def maximumBinaryString(self, binary: str) -> str:
        if binary.count(""0"") <= 1: return binary 
        ones = binary.count(""1"", binary.index(""0""))
        return (len(binary)-ones-1)*""1"" + ""0"" + ones*""1""","class Solution {
 public:
  int subtractProductAndSum(int n) {
    int prod = 1;
    int summ = 0;

    for (; n > 0; n /= 10) {
      prod *= n % 10;
      summ += n % 10;
    }

    return prod - summ;
  }
};"
"class Solution:
    def minMoves(self, nums: List[int], k: int) -> int:
        loc = [i for i, x in enumerate(nums) if x]
        prefix = [0]
        for x in loc: prefix.append(prefix[-1] + x)
        
        ans = inf
        for i in range(len(loc)-k+1): 
            ans = min(ans, (prefix[i+k] - prefix[i+(k+1)//2]) - (prefix[i+k//2] - prefix[i]))
        return ans - (k//2)*((k+1)//2)","class Solution {
 public:
  vector<vector<int>> groupThePeople(vector<int>& groupSizes) {
    vector<vector<int>> ans;
    unordered_map<int, vector<int>> groupSizeToIndices;

    for (int i = 0; i < groupSizes.size(); ++i)
      groupSizeToIndices[groupSizes[i]].push_back(i);

    for (const auto& [groupSize, indices] : groupSizeToIndices) {
      vector<int> groupIndices;
      for (const int index : indices) {
        groupIndices.push_back(index);
        if (groupIndices.size() == groupSize) {
          ans.push_back(groupIndices);
          groupIndices.clear();
        }
      }
    }

    return ans;
  }
};"
"class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        return sum(1 if i < len(s)//2 else -1 for i, c in enumerate(s) if c in 'aeiouAEIOU') == 0","class Solution {
 public:
  int smallestDivisor(vector<int>& nums, int threshold) {
    int l = 1;
    int r = *max_element(begin(nums), end(nums));

    while (l < r) {
      const int m = (l + r) / 2;
      if (sumDivision(nums, m) <= threshold)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int sumDivision(const vector<int>& nums, int m) {
    int sum = 0;
    for (const int num : nums)
      sum += (num - 1) / m + 1;
    return sum;
  }
};"
"class Solution:
    def eatenApples(self, apples: List[int], days: List[int]) -> int:
        n=len(days)
        l=[]
        le=0
        for i in range(n):
            if days[i]!=0 or apples[i]!=0:
                l.append([apples[i],days[i]+i])
                le+=1
        l.sort(key=lambda x:x[1])
        day=0
        res=0
        i=0
        while(i<le):
            A=l[i][0]
            D=l[i][1]
            if day<D:
                diff_days=D-day
  
                mn=min(diff_days,A)
                day+=mn
                res+=mn
            i+=1
  
        return res","class Solution {
 public:
  int minFlips(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    const int hashed = hash(mat, m, n);
    if (hashed == 0)
      return 0;

    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<int> q{{hashed}};
    unordered_set<int> seen{hashed};

    for (int step = 1; !q.empty(); ++step) {
      for (int sz = q.size(); sz > 0; --sz) {
        const int curr = q.front();
        q.pop();
        for (int i = 0; i < m; ++i) {
          for (int j = 0; j < n; ++j) {
            int next = curr ^ 1 << (i * n + j);
            // Flip four neighbors
            for (int k = 0; k < 4; ++k) {
              const int x = i + dirs[k];
              const int y = j + dirs[k + 1];
              if (x < 0 || x == m || y < 0 || y == n)
                continue;
              next ^= 1 << (x * n + y);
            }
            if (next == 0)
              return step;
            if (seen.count(next))
              continue;
            q.push(next);
            seen.insert(next);
          }
        }
      }
    }

    return -1;
  }

 private:
  int hash(const vector<vector<int>>& mat, int m, int n) {
    int hashed = 0;
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (mat[i][j])
          hashed |= 1 << (i * n + j);
    return hashed;
  }
};"
"class Solution:
    def findBall(self, grid: List[List[int]]) -> List[int]:
        def DFS(rows, columns, cur_row, cur_column):
            //Base Case
            if cur_row == rows:
                return cur_column
            //If direction is Right
            if cur_column < columns - 1 and (grid[cur_row][cur_column] == 1 and grid[cur_row][cur_column + 1] == 1):
                return DFS(rows, columns,  cur_row + 1, cur_column + 1)
            //If direction if Left
            elif 0 < cur_column and (grid[cur_row][cur_column] == -1 and grid[cur_row][cur_column - 1] == -1):
                return DFS(rows, columns,  cur_row + 1, cur_column - 1)
            //If direction is invalid
            else:
                return ""X""

        rows = len(grid)
        columns = len(grid[0])
        res = deque([])
        for i in range(columns):
            temp = DFS(rows, columns, 0, i)
            res.append(-1) if temp == ""X"" else res.append(temp)
        return res","class CombinationIterator {
  public CombinationIterator(String characters, int combinationLength) {
    final int n = characters.length();
    final int k = combinationLength;

    // generate bitmasks from 0..00 to 1..11
    for (int bitmask = 0; bitmask < 1 << n; bitmask++) {
      // use bitmasks with k 1-bits
      if (Integer.bitCount(bitmask) == k) {
        // convert bitmask into combination
        // 111 --> ""abc"", 000 --> """"
        // 110 --> ""ab"", 101 --> ""ac"", 011 --> ""bc""
        StringBuilder curr = new StringBuilder();
        for (int j = 0; j < n; j++) {
          if ((bitmask & (1 << n - j - 1)) != 0) {
            curr.append(characters.charAt(j));
          }
        }
        combinations.push(curr.toString());
      }
    }
  }

  public String next() {
    return combinations.pop();
  }

  public boolean hasNext() {
    return (!combinations.isEmpty());
  }

  private Deque<String> combinations = new ArrayDeque<String>();
}"
"class Solution:
    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        nums.sort()
        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))
        ans = [-1]*len(queries)
        
        trie = {}
        k = 0
        for m, x, i in queries: 
            while k < len(nums) and nums[k] <= m: 
                node = trie
                val = bin(nums[k])[2:].zfill(32)
                for c in val: node = node.setdefault(int(c), {})
                node[""#""] = nums[k]
                k += 1
            if trie: 
                node = trie
                val = bin(x)[2:].zfill(32)
                for c in val: node = node.get(1-int(c)) or node.get(int(c))
                ans[i] = x ^ node[""#""]
        return ans","class Solution {
 public:
  int findSpecialInteger(vector<int>& arr) {
    const int n = arr.size();
    const int quarter = n / 4;

    for (int i = 0; i < n - quarter; ++i)
      if (arr[i] == arr[i + quarter]) return arr[i];

    throw;
  }
};"
"class Solution:
    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        res = 0
        q = deque(sorted(boxTypes, key=lambda b: b[1], reverse=True))
        
        while q and truckSize:
            boxes, units = q.popleft()
            while boxes:
                if boxes <= truckSize:
                    res += boxes * units
                    truckSize -= boxes
                    boxes = 0
                else:
                    boxes -= 1
                    
        return res","class Solution {
 public:
  int removeCoveredIntervals(vector<vector<int>>& intervals) {
    // If two intervals have the same start, put the one with larger end first.
    sort(begin(intervals), end(intervals),
         [](const vector<int>& a, const vector<int>& b) {
      return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];
    });

    int ans = 0;
    int prevEnd = 0;

    for (const vector<int>& interval : intervals)
      // Current interval is not covered by the previous one.
      if (prevEnd < interval[1]) {
        ++ans;
        prevEnd = interval[1];
      }

    return ans;
  }
};"
"class Solution:
    def countPairs(self, deliciousness: List[int]) -> int:
        """"""
        
            A + B == 1 << i
        
            A = 2 << i - B
        """"""
        
        result = 0
        seen = defaultdict(int)
        deliciousness.sort()
        
        for d in deliciousness:
            n = 1
            
            # because it is a sorted array. 
            # the maximum sum it can get by i-th number is deliciousness[i] + deliciousness[i]
            while n <= d + d:
                result = (result + seen[n-d]) % (10 ** 9 + 7)
                n = n << 1
                
            seen[d] += 1
        
        return result","class Solution {
 public:
  int minFallingPathSum(vector<vector<int>>& grid) {
    const int n = grid.size();

    for (int i = 1; i < n; ++i) {
      const vector<pair<int, int>> twoMinNumAndIndexs =
          getTwoMinNumAndIndexs(grid[i - 1]);
      const auto& [firstMinNum, firstMinIndex] = twoMinNumAndIndexs[0];
      const auto& [secondMinNum, _] = twoMinNumAndIndexs[1];
      for (int j = 0; j < n; ++j)
        if (j == firstMinIndex)
          grid[i][j] += secondMinNum;
        else
          grid[i][j] += firstMinNum;
    }

    return *min_element(begin(grid.back()), end(grid.back()));
  }

 private:
  vector<pair<int, int>> getTwoMinNumAndIndexs(const vector<int>& A) {
    vector<pair<int, int>> numAndIndexs;

    for (int i = 0; i < A.size(); ++i)
      numAndIndexs.emplace_back(A[i], i);

    sort(begin(numAndIndexs), end(numAndIndexs));
    return {numAndIndexs[0], numAndIndexs[1]};
  }
};"
"class Solution:
    def waysToSplit(self, nums: List[int]) -> int:
        pre_sum = [0]
        for n in nums:
            pre_sum.append(pre_sum[-1] + n)
        length = len(nums)
        ret, mid_l, mid_r = 0, 0, 0
        for i in range(1, length): 
            mid_l = max(mid_l, i + 1)
            while mid_l < length and 2 * pre_sum[i] > pre_sum[mid_l]:
                mid_l += 1
            mid_r = max(mid_r, mid_l)
            while mid_r < length and 2 * pre_sum[mid_r] <= pre_sum[i] + pre_sum[-1]:
                mid_r += 1
            ret += mid_r - mid_l
        return ret % 1_000_000_007","class Solution {
 public:
  int getDecimalValue(ListNode* head) {
    int ans = 0;

    for (; head; head = head->next)
      ans = ans * 2 + head->val;

    return ans;
  }
};"
"class Solution(object):
    def minOperations(self, target, arr):
        d = {num: idx for idx, num in enumerate(target)}
        arr = [d.get(num, -1) for num in arr]
        res = []
        for num in arr:
            if num == -1: continue
            else:
                pos = bisect.bisect_left(res, num)
                if pos == len(res):
                    res.append(num)
                else:
                    res[pos] = min(res[pos], num)
        return len(target) - len(res)","class Solution {
 public:
  vector<int> sequentialDigits(int low, int high) {
    vector<int> ans;
    queue<int> q{{1, 2, 3, 4, 5, 6, 7, 8, 9}};

    while (!q.empty()) {
      const int num = q.front();
      q.pop();
      if (num > high)
        return ans;
      if (low <= num && num <= high)
        ans.push_back(num);
      const int lastDigit = num % 10;
      if (lastDigit < 9)
        q.push(num * 10 + lastDigit + 1);
    }

    return ans;
  }
};"
"class Solution:
    def totalMoney(self, n: int) -> int:
        return n//7*28 + n//7*(n//7-1)//2*7 + (n%7)*(n//7+1) + (n%7-1)*(n%7)//2
            

class Solution2:
    def totalMoney(self, n: int) -> int:
        fullWeeks=n//7
        reminder=n%7
        totalMoney=28*fullWeeks + 7*(fullWeeks-1)*fullWeeks//2 + reminder*(fullWeeks+1) + (reminder-1)*reminder//2
        return totalMoney
            

class Solution1:
    def totalMoney(self, n: int) -> int:
        fullWeeks=0
        totalMoney=0
        for day in range(n):
            if day%7==0: fullWeeks+=1
            totalMoney+=fullWeeks+day%7
        return totalMoney","class Solution {
 public:
  int maxSideLength(vector<vector<int>>& mat, int threshold) {
    const int m = mat.size();
    const int n = mat[0].size();
    int ans = 0;
    vector<vector<int>> prefix(m + 1, vector<int>(n + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        prefix[i + 1][j + 1] =
            mat[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        for (int length = ans; length < min(m - i, n - j); ++length) {
          if (squareSum(prefix, i, j, i + length, j + length) > threshold)
            break;
          ans = max(ans, length + 1);
        }

    return ans;
  }

 private:
  int squareSum(vector<vector<int>>& prefix, int r1, int c1, int r2, int c2) {
    return prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] +
           prefix[r1][c1];
  }
};"
"class Solution:
    def maximumGain(self, s: str, x: int, y: int) -> int:
        a, b = ""a"", ""b""
        if x < y: 
            x, y = y, x
            a, b = b, a
        ans = cnt0 = cnt1 = 0
        for c in s: 
            if c not in ""ab"": 
                ans += min(cnt0, cnt1) * y
                cnt0 = cnt1 = 0 
            elif c == b:
                if cnt0: 
                    cnt0 -= 1
                    ans += x
                else: cnt1 += 1
            else: cnt0 += 1
        return ans + min(cnt0, cnt1) * y","class Solution {
 public:
  int shortestPath(vector<vector<int>>& grid, int k) {
    const int m = grid.size();
    const int n = grid[0].size();
    if (m == 1 && n == 1)
      return 0;

    const vector<int> dirs{0, 1, 0, -1, 0};
    int steps = 0;
    queue<tuple<int, int, int>> q{{{0, 0, k}}};  // (i, j, eliminate)
    vector<vector<vector<bool>>> seen(
        m, vector<vector<bool>>(n, vector<bool>(k + 1)));
    seen[0][0][k] = true;

    while (!q.empty()) {
      ++steps;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j, eliminate] = q.front();
        q.pop();
        for (int l = 0; l < 4; ++l) {
          const int x = i + dirs[l];
          const int y = j + dirs[l + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (x == m - 1 && y == n - 1)
            return steps;
          if (grid[x][y] == 1 && eliminate == 0)
            continue;
          const int newEliminate = eliminate - grid[x][y];
          if (seen[x][y][newEliminate])
            continue;
          q.emplace(x, y, newEliminate);
          seen[x][y][newEliminate] = true;
        }
      }
    }

    return -1;
  }
};"
"class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
		# to check what all numbers have been used
        vis = [False] * (n + 1)
		
		# intermediate array to build the final sequence
        curr_list = [-1] * (2*n - 1)
        li, ans_list = self.recur(vis, curr_list, 0, n, n)
        return ans_list
        
    def recur(self, vis, curr_list, curr_ind, n, rem):
		# base conditon which is to check that we have used all the 'n' numbers
        if rem == 0:
            return True, curr_list
		
		# check what index we have to fill in the intermediate array
        while(curr_list[curr_ind] != -1 and curr_ind < 2 * n - 1):
            curr_ind += 1
        ans = False
        ans_list = None
        for i in range(len(vis) - 1, 0, -1):
			addition = i
			
			# special handling of '1'
            if i == 1:
                addition = 0
				
			# only numbers that are not already used and check for feasibility using the constraints given
           if not vis[i] and self.check_feasible(curr_list, curr_ind, addition, n):
                vis[i] = True
                curr_list[curr_ind] = i
                curr_list[curr_ind + addition] = i
                is_list, li = self.recur(vis, curr_list, curr_ind + 1, n, rem - 1)
                if is_list:
                    ans = True
                    ans_list = li
                    break
                curr_list[curr_ind] = -1
                curr_list[curr_ind + addition] = -1
                vis[i] = False
        return ans, ans_list
    
    def check_feasible(self, curr_list, curr_ind, addition, n):
        if curr_ind + addition < 2*n - 1 and curr_list[curr_ind] == -1 and curr_list[curr_ind + addition] == -1:
            return True
        return False","class Solution {
 public:
  int findNumbers(vector<int>& nums) {
    int ans = 0;

    for (int num : nums)
      if (9 < num && num < 100 || 999 < num && num < 10000 || num == 100000)
        ++ans;

    return ans;
  }
};"
"class Solution:
    def checkWays(self, pairs: List[List[int]]) -> int:
        nodes = set()
        graph = {}
        degree = {}
        for x, y in pairs: 
            nodes |= {x, y}
            graph.setdefault(x, set()).add(y)
            graph.setdefault(y, set()).add(x)
            degree[x] = 1 + degree.get(x, 0)
            degree[y] = 1 + degree.get(y, 0)
        
        if max(degree.values()) < len(nodes) - 1: return 0 # no root
        for n in nodes: 
            if degree[n] < len(nodes)-1: 
                nei = set()
                for nn in graph[n]: 
                    if degree[n] >= degree[nn]: nei |= graph[nn] # brothers &amp; childrens
                if nei - {n} - graph[n]: return 0 # impossible
        
        for n in nodes: 
            if any(degree[n] == degree[nn] for nn in graph[n]): return 2 # brothers 
        return 1","class Solution {
 public:
  bool isPossibleDivide(vector<int>& nums, int k) {
    map<int, int> count;

    for (const int num : nums)
      ++count[num];

    for (const auto& [start, _] : count) {
      const int value = count[start];
      if (value > 0)
        for (int i = start; i < start + k; ++i) {
          count[i] -= value;
          if (count[i] < 0)
            return false;
        }
    }

    return true;
  }
};"
"class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        arr = [first]
        for i in range(len(encoded)):
            arr.append(arr[i]^encoded[i])
        return arr","class Solution {
 public:
  int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
    // Greedily consider strings with `minSize`, so ignore `maxSize`.
    int ans = 0;
    int letters = 0;
    vector<int> count(26);
    unordered_map<string, int> substringCount;

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (++count[s[r] - 'a'] == 1)
        ++letters;
      while (letters > maxLetters || r - l + 1 > minSize)
        if (--count[s[l++] - 'a'] == 0)
          --letters;
      if (r - l + 1 == minSize)
        ans = max(ans, ++substringCount[s.substr(l, minSize)]);
    }

    return ans;
  }
};"
"class Solution:
    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        fast = head
        slow = head
        for i in range(1,k):
            fast = fast.next
        beg = fast
        while fast.next:
            fast = fast.next
            slow = slow.next
        
        tmp = beg.val
        beg.val = slow.val
        slow.val = tmp
        return head","class Solution {
 public:
  int maxCandies(vector<int>& status, vector<int>& candies,
                 vector<vector<int>>& keys, vector<vector<int>>& containedBoxes,
                 vector<int>& initialBoxes) {
    int ans = 0;
    queue<int> q;
    vector<bool> reachedClosedBoxes(status.size());

    auto pushBoxesIfPossible =
        [&status, &q, &reachedClosedBoxes](const vector<int>& boxes) {
      for (const int box : boxes)
        if (status[box])
          q.push(box);
        else
          reachedClosedBoxes[box] = true;
    };

    pushBoxesIfPossible(initialBoxes);

    while (!q.empty()) {
      const int currBox = q.front();
      q.pop();

      // Add candies
      ans += candies[currBox];

      // Push `reachedClosedBoxes` by `key` obtained this turn and change their
      // Statuses
      for (const int key : keys[currBox]) {
        if (!status[key] && reachedClosedBoxes[key])
          q.push(key);
        status[key] = 1;  // boxes[key] is now open
      }

      // Push boxes contained in `currBox`
      pushBoxesIfPossible(containedBoxes[currBox]);
    }

    return ans;
  }
};"
"class Solution:
    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:
        
        # idx to group id
        idx_to_group = {}
        # group id to index set
        group_to_idx = {}
        global_group_id = 0
        
        for swap in allowedSwaps:
            foundGroups = set()
            
            for idx in swap:
                if idx in idx_to_group:
                    foundGroups.add(idx_to_group[idx])
            
            if foundGroups:
                pivot = min(foundGroups)
                for group_id in foundGroups:
                    if pivot != group_id:
                        group_to_idx[pivot].update(group_to_idx[group_id])
                        group_to_idx.pop(group_id)

                group_to_idx[pivot].update(swap)

                for idx in group_to_idx[pivot]:
                    idx_to_group[idx] = pivot
            else:
                for idx in swap:
                    idx_to_group[idx] = global_group_id
                group_to_idx[global_group_id] = set(swap)
                global_group_id += 1
                
        ans = 0
        if group_to_idx == {}:
            for i in range(len(source)):
                if source[i]!=target[i]:
                    ans += 1
        else:
            for group_id in group_to_idx:
                src = {}
                tgt = {}
                for idx in group_to_idx[group_id]:
                    if source[idx] not in src:
                        src[source[idx]] = 0
                    src[source[idx]] += 1

                    if target[idx] not in tgt:
                        tgt[target[idx]] = 0
                    tgt[target[idx]] += 1

                for key in src:
                    if key in tgt:
                        if src[key] > tgt[key]:
                            ans += src[key] - tgt[key]
                    else:
                        ans += src[key]
            
            for i in range(len(source)):
                if i not in idx_to_group and source[i]!=target[i]:
                    ans += 1
            
        return ans","class Solution {
 public:
  vector<int> replaceElements(vector<int>& arr) {
    int maxOfRight = -1;
    for (int i = arr.size() - 1; i >= 0; --i)
      maxOfRight = max(maxOfRight, exchange(arr[i], maxOfRight));
    return arr;
  }
};"
"class Solution:    
    def minimumTimeRequired(self, jobs: List[int], num_workers: int) -> int:
        n = len(jobs)
        worker_cost = [0] * (1 << n)
        for state in range(1 << n):
            for i in range(n):
                if state &amp; (1 << i):
                    worker_cost[state] += jobs[i]
                    
        @functools.cache
        def compute_time(state: int, curr_workers: int) -> int:
            if curr_workers == 1:
                return worker_cost[state]
            
            best = float(""inf"")
            worker_state = state
            while worker_state:
                if worker_cost[worker_state] < best:
                    best = min(best, max(compute_time(state ^ worker_state, curr_workers - 1), worker_cost[worker_state]))
                worker_state = (worker_state - 1) &amp; state
            
            return best
            
        return compute_time((1 << n) - 1, num_workers)","class Solution {
 public:
  int findBestValue(vector<int>& arr, int target) {
    const int n = arr.size();
    const double err = 1e-9;

    int prefix = 0;

    sort(begin(arr), end(arr));

    for (int i = 0; i < n; ++i) {
      int ans = round((target - prefix - err) / (double)(n - i));
      if (ans <= arr[i])
        return ans;
      prefix += arr[i];
    }

    return arr.back();
  }
};"
"class Solution:
    def countGoodRectangles(self, r: List[List[int]]) -> int:
        
        an=0
        ans=0
        for j in r:
            a=min(j)
            if a > an:
                an= a
                ans=1
            elif a==an:
                ans+=1
                
            
        return ans","class Solution {
 public:
  vector<int> pathsWithMaxScore(vector<string>& board) {
    constexpr int kMod = 1'000'000'007;
    const int n = board.size();
    const vector<pair<int, int>> dirs{{0, 1}, {1, 0}, {1, 1}};
    // dp[i][j] := max sum from (n - 1, n - 1) -> (i, j)
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));
    // count[i][j] := # of paths to get dp[i][j] from (n - 1, n - 1) -> (i, j)
    vector<vector<int>> count(n + 1, vector<int>(n + 1));

    dp[0][0] = 0;
    dp[n - 1][n - 1] = 0;
    count[n - 1][n - 1] = 1;

    for (int i = n - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j) {
        if (board[i][j] == 'S' || board[i][j] == 'X')
          continue;
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (dp[i][j] < dp[x][y]) {
            dp[i][j] = dp[x][y];
            count[i][j] = count[x][y];
          } else if (dp[i][j] == dp[x][y]) {
            count[i][j] += count[x][y];
            count[i][j] %= kMod;
          }
        }
        // If there's path(s) from 'S' to (i, j)
        // And the cell is not 'E'
        if (dp[i][j] != -1 && board[i][j] != 'E') {
          dp[i][j] += board[i][j] - '0';
          dp[i][j] %= kMod;
        }
      }

    return {dp[0][0], count[0][0]};
  }
};"
"class Solution:
    def tupleSameProduct(self, nums: List[int]) -> int:
        hmap = {}
        output = 0
        for i in range(len(nums)):
            for j in range(i):
				# Skip if same number
                if i == j:
                    continue
                candidate = nums[i] * nums[j]
                if candidate in hmap:
                    output += hmap[candidate] * 8
                    hmap[candidate] += 1
                else:
                    hmap[candidate] = 1
        return output","class Solution {
 public:
  int deepestLeavesSum(TreeNode* root) {
    int ans = 0;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      ans = 0;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        ans += node->val;
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
    }

    return ans;
  }
};"
"class Solution:
    def largestSubmatrix(self, matrix: List[List[int]]) -> int:
        m, n = len(matrix), len(matrix[0]) # dimensions
        ans = 0
        hist = [0] * n
        for i in range(m): 
            for j in range(n): 
                hist[j] = hist[j] + 1 if matrix[i][j] else 0
            for i, x in enumerate(sorted(hist, reverse=True)): 
                ans = max(ans, x*(i+1))
        return ans","class Solution {
 public:
  vector<int> sumZero(int n) {
    vector<int> ans(n);

    for (int i = 0; i < n; ++i)
      ans[i] = i * 2 - n + 1;

    return ans;
  }
};"
"class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        m, n = len(grid), len(grid[0]) # dimensions 
        walls = set()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == ""F"": food = (i, j)
                elif grid[i][j] == ""C"": cat = (i, j)
                elif grid[i][j] == ""M"": mouse = (i, j)
                elif grid[i][j] == ""#"": walls.add((i, j))
                    
        @lru_cache(None)
        def fn(cat, mouse, turn): 
            """"""Return True if mouse wins.""""""
            if cat == food or cat == mouse or turn >= m*n*2: return False 
            if mouse == food: return True  # mouse reaching food
            
            if not turn &amp; 1: # mouse moving 
                x, y = mouse
                for dx, dy in (-1, 0), (0, 1), (1, 0), (0, -1): 
                    for jump in range(0, mouseJump+1):
                        xx, yy = x+jump*dx, y+jump*dy
                        if not (0 <= xx < m and 0 <= yy < n) or (xx, yy) in walls: break 
                        if fn(cat, (xx, yy), turn+1): return True 
                return False 
            else: # cat moving
                x, y = cat
                for dx, dy in (-1, 0), (0, 1), (1, 0), (0, -1): 
                    for jump in range(0, catJump+1):
                        xx, yy = x+jump*dx, y+jump*dy
                        if not (0 <= xx < m and 0 <= yy < n) or (xx, yy) in walls: break 
                        if not fn((xx, yy), mouse, turn+1): return False
                return True
                    
        return fn(cat, mouse, 0)","class BSTIterator {
 public:
  BSTIterator(TreeNode* root) {
    pushLeftsUntilNull(root);
  }

  int peek() {
    return stack.top()->val;
  }

  void next() {
    TreeNode* node = stack.top();
    stack.pop();
    pushLeftsUntilNull(node->right);
  }

  bool hasNext() {
    return !stack.empty();
  }

 private:
  stack<TreeNode*> stack;

  void pushLeftsUntilNull(TreeNode* node) {
    while (node) {
      stack.push(node);
      node = node->left;
    }
  }
};

class Solution {
 public:
  vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {
    vector<int> ans;
    BSTIterator bstIterator1(root1);
    BSTIterator bstIterator2(root2);

    while (bstIterator1.hasNext() && bstIterator2.hasNext())
      if (bstIterator1.peek() < bstIterator2.peek()) {
        ans.push_back(bstIterator1.peek());
        bstIterator1.next();
      } else {
        ans.push_back(bstIterator2.peek());
        bstIterator2.next();
      }

    while (bstIterator1.hasNext()) {
      ans.push_back(bstIterator1.peek());
      bstIterator1.next();
    }

    while (bstIterator2.hasNext()) {
      ans.push_back(bstIterator2.peek());
      bstIterator2.next();
    }

    return ans;
  }
};"
"class Solution:
    def largestAltitude(self, gain: List[int]) -> int:
        return max(0,max(itertools.accumulate(gain)))","class Solution {
 public:
  bool canReach(vector<int>& arr, int start) {
    const int n = arr.size();
    queue<int> q{{start}};
    vector<bool> seen(n);

    while (!q.empty()) {
      const int node = q.front();
      q.pop();

      if (arr[node] == 0)
        return true;
      if (seen[node])
        continue;

      // Check available next steps
      if (node - arr[node] >= 0)
        q.push(node - arr[node]);
      if (node + arr[node] < n)
        q.push(node + arr[node]);

      seen[node] = true;
    }

    return false;
  }
};"
"class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        
        languages = [None] + list(map(set, languages))
        friendships = [[u, v] for u, v in friendships if not languages[u] &amp; languages[v]]
        
        # teach whoever needs it
        return min([len({u
                        for pair in friendships
                        for u in pair
                        if lan not in languages[u]})
                   for lan in range(1, n+1)])","class Solution {
 public:
  bool isSolvable(vector<string>& words, string result) {
    usedDigit = vector<bool>(10);
    words.push_back(result);
    rows = words.size();
    for (const string& word : words)
      cols = max(cols, static_cast<int>(word.length()));
    return dfs(words, 0, 0, 0);
  }

 private:
  unordered_map<char, int> letterToDigit;
  vector<bool> usedDigit;
  int rows;
  int cols;

  bool dfs(vector<string>& words, int row, int col, int sum) {
    if (col == cols)
      return sum == 0;
    if (row == rows)
      return sum % 10 == 0 && dfs(words, 0, col + 1, sum / 10);

    string word = words[row];
    if (col >= word.length())
      return dfs(words, row + 1, col, sum);

    char letter = word[word.length() - col - 1];
    int sign = row == rows - 1 ? -1 : 1;

    if (const auto it = letterToDigit.find(letter);
        it != cend(letterToDigit) &&
        (it->second > 0 || col < word.length() - 1))
      return dfs(words, row + 1, col, sum + sign * letterToDigit[letter]);

    for (int digit = 0; digit < 10; ++digit)
      if (!usedDigit[digit] && (digit > 0 || col + 1 < word.length())) {
        letterToDigit[letter] = digit;
        usedDigit[digit] = true;
        if (dfs(words, row + 1, col, sum + sign * digit))
          return true;
        usedDigit[digit] = false;
        letterToDigit.erase(letter);
      }

    return false;
  }
};"
"class Solution:
    def decode(self, encoded: List[int]) -> List[int]:
        x = reduce(xor, list(range(1, len(encoded) + 2)))
        for i in range(1, len(encoded), 2): x ^= encoded[i]
        ans = [x]
        for x in encoded: ans.append(ans[-1] ^ x)
        return ans","class Solution {
 public:
  string freqAlphabets(string s) {
    string ans;

    for (int i = 0; i < s.length();) {
      if (i + 2 < s.length() && s[i + 2] == '#') {
        ans += stoi(s.substr(i, 2)) + 'a' - 1;
        i += 3;
      } else {
        ans += (s[i] - '0') + 'a' - 1;
        i += 1;
      }
    }

    return ans;
  }
};"
"class Solution:
    def __init__(self):
        self.dp = {}
        
    def waysToFillArray(self, queries: List[List[int]]) -> List[int]:
        mod = 10 ** 9 + 7
        
        def dfs(n, val):
            if (n, val) not in self.dp:
                if n == 1: return 1
                temp = 1
                for k in range(val//2, 0, -1):
                    if val % k == 0:
                        temp += dfs(n-1, val // k)
                self.dp[n, val] = temp % mod
            return self.dp[n, val]
        
        res = []
        for n, val in queries:
            res.append(dfs(n, val))
        return res","class Solution {
 public:
  vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
    vector<int> ans;
    vector<int> xors(arr.size() + 1);

    for (int i = 0; i < arr.size(); ++i)
      xors[i + 1] ^= xors[i] ^ arr[i];

    for (const vector<int>& query : queries)
      ans.push_back(xors[query[0]] ^ xors[query[1] + 1]);

    return ans;
  }
};"
"class Solution:
    def maximumTime(self, time: str) -> str:
        maxValues = {
            '0': '2',
            '1': {'0': '9', '1': '9', '2': '3'},
            '3': '5',
            '4': '9'
        }

        result = []
        for i, char in enumerate(time):
            if char == '?':
                if i == 0 and time[i + 1] != '?' and time[i + 1] >= '4':
                    result.append('1')
                elif i == 1:
                    result.append(maxValues['1'][result[i - 1]])

                else:
                    result.append(maxValues[str(i)])
            else:
                result.append(char)

        return ''.join(result)","class Solution {
 public:
  vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos,
                                        vector<vector<int>>& friends, int id,
                                        int level) {
    vector<string> ans;
    vector<bool> visited(friends.size());
    visited[id] = true;
    queue<int> queue{{id}};
    unordered_map<string, int> count;
    set<pair<int, string>> freqAndVideo;

    for (int i = 0; i < level; ++i)
      for (int j = queue.size(); j > 0; --j) {
        for (int f : friends[queue.front()])
          if (visited[f] == false) {
            visited[f] = true;
            queue.push(f);
          }
        queue.pop();
      }

    for (int i = queue.size(); i > 0; --i) {
      for (const string& video : watchedVideos[queue.front()])
        ++count[video];
      queue.pop();
    }

    for (const auto& [video, freq] : count)
      freqAndVideo.insert({freq, video});

    for (const auto& [_, video] : freqAndVideo)
      ans.push_back(video);

    return ans;
  }
};"
"class Solution:
    def minCharacters(self, a: str, b: str) -> int:
        pa, pb = [0]*26, [0]*26
        for x in a: pa[ord(x)-97] += 1
        for x in b: pb[ord(x)-97] += 1
        
        ans = len(a) - max(pa) + len(b) - max(pb) # condition 3
        for i in range(25): 
            pa[i+1] += pa[i]
            pb[i+1] += pb[i]
            ans = min(ans, pa[i] + len(b) - pb[i]) # condition 2
            ans = min(ans, len(a) - pa[i] + pb[i]) # condition 1
        return ans","class Solution {
 public:
  int minInsertions(string s) {
    return s.length() - longestPalindromeSubseq(s);
  }

 private:
  // Same as 516. Longest Palindromic Subsequence
  int longestPalindromeSubseq(const string& s) {
    const int n = s.length();
    // dp[i][j] := LPS's length in s[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j])
          dp[i][j] = 2 + dp[i + 1][j - 1];
        else
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
      }

    return dp[0][n - 1];
  }
};"
"class Solution:
    def kthLargestValue(self, matrix, k: int) -> int:
        large = [matrix[0][0]]
        n = len(matrix)
        m = len(matrix[0])
        for i in range(1, n):
            matrix[i][0] ^= matrix[i - 1][0]
            large.append(matrix[i][0])

        for j in range(1, m):
            matrix[0][j] ^= matrix[0][j - 1]
            large.append(matrix[0][j])

        for i in range(1, n):
            for j in range(1, m):
                matrix[i][j] ^= matrix[i][j - 1] ^ matrix[i - 1][j] ^ matrix[i - 1][j - 1]
                large.append(matrix[i][j])

        large.sort()
        return large[-k]","class Solution {
 public:
  vector<int> decompressRLElist(vector<int>& nums) {
    vector<int> ans;

    for (int i = 0; i < nums.size(); i += 2)
      ans.insert(end(ans), nums[i], nums[i + 1]);

    return ans;
  }
};"
"class Solution:
    def minimumBoxes(self, n: int) -> int:
        boxesPlaced = 0
        maxFloor = 1
        boxesOnFloor = 0
        while boxesPlaced < n:
            for i in range(1, maxFloor + 1):
                boxesPlaced += i
                boxesOnFloor += 1
                if boxesPlaced >= n:
                    break
            maxFloor += 1
        return boxesOnFloor","class Solution {
 public:
  vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
    const int m = mat.size();
    const int n = mat[0].size();
    vector<vector<int>> ans(m, vector<int>(n));
    vector<vector<int>> prefix(m + 1, vector<int>(n + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        prefix[i + 1][j + 1] =
            mat[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        const int r1 = max(0, i - k) + 1;
        const int c1 = max(0, j - k) + 1;
        const int r2 = min(m - 1, i + k) + 1;
        const int c2 = min(n - 1, j + k) + 1;
        ans[i][j] = prefix[r2][c2] - prefix[r2][c1 - 1] - prefix[r1 - 1][c2] +
                    prefix[r1 - 1][c1 - 1];
      }

    return ans;
  }
};"
"class Solution:
    def countBalls(self, lowLimit: int, highLimit: int) -> int:
        d = {}
        for i in range(lowLimit, highLimit+1):
            d[sum(list(map(int,list(str(i)))))] = d.get(sum(list(map(int,list(str(i))))),0) + 1
        return max(d.values())","class Solution {
 public:
  int sumEvenGrandparent(TreeNode* root) {
    return dfs(root, 1, 1);  // Parent and grandparent are odd at first.
  }

 private:
  int dfs(TreeNode* root, int p, int gp) {
    if (root == nullptr)
      return 0;
    return (gp % 2 == 0 ? root->val : 0) +  //
           dfs(root->left, root->val, p) +  //
           dfs(root->right, root->val, p);
  }
};"
"class Solution:
    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
        # map the relations between two elements using dictionary
        # key=element, value=[elements it is paired with]
        dict1={}
        for ii in adjacentPairs:
            if ii[0] in dict1.keys():
                dict1[ii[0]].append(ii[1])
            if ii[0] not in dict1.keys():
                dict1[ii[0]]=[ii[1]]
            if ii[1] in dict1.keys():
                dict1[ii[1]].append(ii[0])
            if ii[1] not in dict1.keys():
                dict1[ii[1]]=[ii[0]]
                
                
        # 1st and last element of series will have only pairing element in the list
        # finding those 2 elements
        #temp array to store those 2 elements
        gajab=[]  
        for ii in dict1.keys():
            if len(dict1[ii])==1:    # if len==1 it can be start or ending elemnt of list
                gajab.append(ii)
                
        # Initializing Solution array with all elemnts as Zero
        # len of solution array = len(pairs)+1
        ans=[0]*((len(adjacentPairs))+1)
        
        #Placing 1st and last element in array.You can make any of two element as STARTING or ENDING
        ans[0]=gajab[0]
        ans[-1]=gajab[1]
        
        #using 1st element in ANS array to find its relation element and then so on...
        for ii in range(len(ans)-1):
            pp=dict1[ans[ii]][0]
            dict1[pp].remove(ans[ii]) # removing the element relation that is already in ANS array
            ans[ii+1]=pp              # adding the element in ANS array at correct position
    
        return(ans)","class Solution {
 public:
  int distinctEchoSubstrings(string text) {
    unordered_set<string> seen;

    for (int k = 1; k <= text.length() / 2; ++k) {  // Target length
      int same = 0;
      for (int l = 0, r = k; r < text.length(); ++l, ++r) {
        if (text[l] == text[r])
          ++same;
        else
          same = 0;
        if (same == k) {
          seen.insert(text.substr(l - k + 1, k));
          // Move the window thus leaving a char behind,
          // So we need to decrease the counter
          --same;
        }
      }
    }

    return seen.size();
  }
};"
"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x) # prefix sum 
        return [prefix[t] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]","class Solution {
 public:
  vector<int> getNoZeroIntegers(int n) {
    for (int A = 1; A < n; ++A) {
      int B = n - A;
      if (to_string(A).find('0') == string::npos &&
          to_string(B).find('0') == string::npos)
        return {A, B};
    }

    throw;
  }
};"
"class Solution:
    def checkPartitioning(self, s: str) -> bool:
        n=len(s)
        pal=[[False]*n for i in range(n)]
        for i in range(n):
            pal[i][i]=True

        for i in range(n-1,-1,-1):
            for j in range(i+1,n):
                if i+1==j and s[i]==s[j]:
                    pal[i][j]=True
                if pal[i+1][j-1] and s[i]==s[j]:
                    pal[i][j]=True

        dp=[[False for i in range(4)] for j in range(n+1)]
        dp[n][3]=True     
        for ind in range(n-1,-1,-1):
            for i in range(ind,n):
                if pal[ind][i]:
                    dp[ind][2] |= dp[i+1][3]
                    dp[ind][1] |= dp[i+1][2]
                    dp[ind][0] |= dp[i+1][1]
        return dp[0][0]","class Solution {
 public:
  int minFlips(int a, int b, int c) {
    constexpr int kMaxBit = 30;
    int ans = 0;

    for (int i = 0; i < kMaxBit; ++i)
      if ((c >> i & 1) == 1)
        ans += (a >> i & 1) == 0 && (b >> i & 1) == 0;
      else  // (c >> i & 1) == 0
        ans += ((a >> i & 1) == 1) + ((b >> i & 1) == 1);

    return ans;
  }
};"
"class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        c = Counter(nums)
        return sum(n for n, c in c.items() if c == 1)","class Solution {
 public:
  int makeConnected(int n, vector<vector<int>>& connections) {
    // To connect n nodes, we need at least n - 1 edges
    if (connections.size() < n - 1)
      return -1;

    int numOfConnected = 0;
    vector<vector<int>> graph(n);
    unordered_set<int> seen;

    for (const vector<int>& conn : connections) {
      graph[conn[0]].push_back(conn[1]);
      graph[conn[1]].push_back(conn[0]);
    }

    for (int i = 0; i < n; ++i)
      if (seen.insert(i).second) {
        dfs(graph, i, seen);
        ++numOfConnected;
      }

    return numOfConnected - 1;
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, unordered_set<int>& seen) {
    for (const int v : graph[u])
      if (seen.insert(v).second)
        dfs(graph, v, seen);
  }
};"
"class Solution:
    def maxAbsoluteSum(self, nums: List[int]) -> int:
        
        def kadane(x):
            cmax = 0
            gmax = 0
            
            for i in x:
                if cmax < 0:
                    cmax = i
                else:
                    cmax+=i
                gmax = max(cmax, gmax)
            return gmax
        
        return max(kadane(nums), kadane(-i for i in nums))","class Solution {
 public:
  int minimumDistance(string word) {
    // dp[i][j][k] := min distance with left finger on i-th char and right
    // Finger on j-th char that already have written k first words
    dp.resize(27, vector<vector<int>>(27, vector<int>(word.length(), -1)));
    return minimumDistance(word, 26, 26, 0);
  }

 private:
  vector<vector<vector<int>>> dp;

  int minimumDistance(const string& word, int i, int j, int k) {
    if (k == word.length())
      return 0;
    if (dp[i][j][k] != -1)
      return dp[i][j][k];
    const int next = word[k] - 'A';
    const int moveLeft = dist(i, next) + minimumDistance(word, next, j, k + 1);
    const int moveRight = dist(j, next) + minimumDistance(word, i, next, k + 1);
    return dp[i][j][k] = min(moveLeft, moveRight);
  }

  int dist(int a, int b) {
    if (a == 26)  // First hovering state
      return 0;
    const int x1 = a / 6;
    const int y1 = a % 6;
    const int x2 = b / 6;
    const int y2 = b % 6;
    return abs(x1 - x2) + abs(y1 - y2);
  }
};"
"class Solution:
    def minimumLength(self, s: str) -> int:
        left = 0
        right = len(s)-1
        if len(s) == 1:
            return 1
        while left < right and s[left] == s[right] :
            while left < right and s[left] == s[left + 1]:
                left+=1
            if left == right:
                return 0
            left+=1
            while left < right and s[right] == s[right - 1]:
                right-=1
            right-=1
        return right - left + 1
		
``","class Solution {
 public:
  int maximum69Number(int num) {
    string ans = to_string(num);

    for (char& c : ans)
      if (c == '6') {
        c = '9';
        break;
      }

    return stoi(ans);
  }
};"
"class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        n=len(events)
        events.sort()
        @lru_cache(None)
        def dfs(ind,k):
            if ind==n or k==0:
                return 0
            ans=dfs(ind+1,k)
            nextInd=bisect.bisect_left(events,[events[ind][1]+1])
            ans=max(ans,events[ind][2]+dfs(nextInd,k-1))
            return ans
        return dfs(0,k)","class Solution {
 public:
  vector<string> printVertically(string s) {
    vector<string> ans;
    vector<string> words = split(s);
    size_t maxLength = 0;

    for (const string& word : words)
      maxLength = max(maxLength, word.length());

    for (size_t i = 0; i < maxLength; ++i) {
      string row;
      for (const string& word : words)
        row += i < word.length() ? word[i] : ' ';
      while (row.back() == ' ')
        row.pop_back();
      ans.push_back(row);
    }

    return ans;
  }

 private:
  vector<string> split(const string& s) {
    vector<string> words;
    istringstream iss(s);
    for (string token; iss >> token;)
      words.push_back(token);
    return words;
  }
};"
"class Solution:
    
    def check(self, nums: List[int]) -> bool:
        res = 0
        n = len(nums)
        for i in range(n):
            if nums[i] > nums[(i+1) % n]:
                res += 1
        return res <= 1","class Solution {
 public:
  TreeNode* removeLeafNodes(TreeNode* root, int target) {
    if (root == nullptr)
      return nullptr;
    root->left = removeLeafNodes(root->left, target);
    root->right = removeLeafNodes(root->right, target);
    return isLeaf(root) && root->val == target ? nullptr : root;
  }

 private:
  bool isLeaf(TreeNode* root) {
    return root->left == nullptr && root->right == nullptr;
  }
};"
"class Solution:
    def maximumScore(self, a: int, b: int, c: int) -> int:
        a, b, c = sorted((a, b, c))
        
        if a + b <= c:
            return a + b
        
        return a + (b + c - a) // 2","class Solution {
 public:
  int minTaps(int n, vector<int>& ranges) {
    vector<int> nums(n + 1);

    for (int i = 0; i <= n; ++i) {
      int l = max(0, i - ranges[i]);
      int r = min(n, i + ranges[i]);
      nums[l] = max(nums[l], r - l);
    }

    int ans = 0;
    int end = 0;
    int farthest = 0;

    for (int i = 0; i < n; i++) {
      farthest = max(farthest, i + nums[i]);
      if (i == end) {
        ++ans;
        end = farthest;
      }
    }

    return end == n ? ans : -1;
  }
};"
"class Solution:
    def largestMerge(self, w1: str, w2: str) -> str:
        
        def dfs(m, w1, w2):
            if not w1 or not w2:
                return m + (w1 if w1 else w2)
            if w1 >= w2:
                return dfs(m+w1[0], w1[1:], w2)
            elif w1 < w2:
                return dfs(m+w2[0], w1, w2[1:])
            #else:
                #return max(dfs(m+w1[0], w1[1:], w2), dfs(m+w2[0], w1, w2[1:]))
        return dfs("""", w1, w2)","class Solution {
 public:
  string breakPalindrome(string palindrome) {
    if (palindrome.length() == 1)
      return """";

    for (int i = 0; i < palindrome.length() / 2; ++i)
      if (palindrome[i] != 'a') {
        palindrome[i] = 'a';
        return palindrome;
      }

    palindrome.back() = 'b';
    return palindrome;
  }
};"
"class Solution:
    def solve(self, nums, i, val, sums):
        if i == len(nums):
            sums.append(val)
            return
        self.solve(nums, i+1, val+nums[i], sums)
        self.solve(nums, i+1, val, sums)
        
    def minAbsDifference(self, nums: List[int], goal: int) -> int:
        n = len(nums)
        sum1, sum2 = [], []
        self.solve(nums[:n//2], 0, 0, sum1)
        self.solve(nums[n//2:], 0, 0, sum2)
        
        sum2 = sorted(sum2)
        #print(sum1, sum2)
        n2 = len(sum2)
        ans = float(""inf"")
        for s in sum1:
            rem = goal-s
            i = bisect_left(sum2, rem)
            if i < n2:
                ans = min(ans, abs(rem-sum2[i]))
            if i > 0:
                ans = min(ans, abs(rem-sum2[i-1]))
        return ans","class Solution {
 public:
  vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();

    unordered_map<int, priority_queue<int>> count;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        count[i - j].push(mat[i][j]);

    for (int i = m - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j)
        mat[i][j] = count[i - j].top(), count[i - j].pop();

    return mat;
  }
};"
"class Solution:
    def minOperations(self, s: str) -> int:
        return min((cnt := s[::2].count('1') + s[1::2].count('0')), len(s) - cnt)","class Solution {
 public:
  int maxValueAfterReverse(vector<int>& nums) {
    int total = 0;
    int min = INT_MAX;
    int max = INT_MIN;

    for (int i = 0; i + 1 < nums.size(); ++i) {
      int a = nums[i];
      int b = nums[i + 1];
      total += abs(a - b);
      min = std::min(min, std::max(a, b));
      max = std::max(max, std::min(a, b));
    }
    int diff = std::max(0, (max - min) * 2);

    for (int i = 0; i + 1 < nums.size(); ++i) {
      int a = nums[i];
      int b = nums[i + 1];
      int headDiff = -abs(a - b) + abs(nums.front() - b);
      int tailDiff = -abs(a - b) + abs(nums.back() - a);
      diff = std::max({diff, headDiff, tailDiff});
    }

    return total + diff;
  }
};"
"class Solution:
    def countHomogenous(self, s: str) -> int:
        cnt = 0
        i = 0
        j = 1
        
        while j < len(s):
            if s[i] != s[j]:
                diff = j-i
                cnt += ((diff) * (diff+1)) // 2
                i = j
                j += 1
            
            else:
                j += 1
        
        diff = j-i
        cnt += ((diff) * (diff+1)) // 2
        
        return cnt % ((10**9) + 7)","class Solution {
 public:
  vector<int> arrayRankTransform(vector<int>& arr) {
    vector<int> sortedArr(arr);
    unordered_map<int, int> rank;

    sort(begin(sortedArr), end(sortedArr));

    for (const int a : sortedArr)
      if (!rank.count(a))
        rank[a] = rank.size() + 1;

    for (int& a : arr)
      a = rank[a];

    return arr;
  }
};"
"class Solution:
    def minimumSize(self, nums: List[int], maxOperations: int) -> int:
        l = 1
        r = max(nums)
        
        while l < r:
            mid = l + (r-l) // 2
            count = self.count(mid,nums)
            if count <= maxOperations:
                r = mid
            else:
                l = mid+1
        return r  # or l
    
    
    def count(self,n,arr):
        return sum((a-1) // n for a in arr)","class Solution {
 public:
  vector<int> filterRestaurants(vector<vector<int>>& restaurants,
                                int veganFriendly, int maxPrice,
                                int maxDistance) {
    vector<int> ans;
    vector<vector<int>> filtered;

    for (vector<int>& restaurant : restaurants)
      if (restaurant[2] >= veganFriendly && restaurant[3] <= maxPrice &&
          restaurant[4] <= maxDistance)
        filtered.push_back(restaurant);

    sort(begin(filtered), end(filtered), [](const auto& a, const auto& b) {
      return a[1] == b[1] ? a[0] > b[0] : a[1] > b[1];
    });

    for (const vector<int>& f : filtered)
      ans.push_back(f[0]);

    return ans;
  }
};"
"class Solution:
    def getAdjLists(self, edges):
        adj = defaultdict(list)
        for u,v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return adj
    def getAdjSets(self, edges):
        adj = defaultdict(set)
        for u,v in edges:
            adj[u].add(v)
            adj[v].add(u)
        return adj
    
    def minTrioDegree1TLE(self, n: int, edges: List[List[int]]) -> int:
        # somehow compress the trio so it is considered a single node?
        # O(N^3) keep picking random three points, check if trio and 
        res = math.inf

        adj = self.getAdjLists(edges)
        adjSet = self.getAdjSets(edges)
        
        for u in range(1,n+1):
            for v in adj[u]:
                for choice in adj[v]:
                    if choice in adjSet[u] or u in adjSet[choice]: 
                        # it is a common point!
                        res = min(res, len(adj[u]) + len(adj[v]) + len(adj[choice]) - 3)
        return res if res < math.inf else -1
    
    def minTrioDegree2TLE(self, n: int, edges: List[List[int]]) -> int:
        # O(EN) pick any random two connected points(edge), search for 
        # possible third points e.g. [1,2] is an edge so adj[1] intersect adj[2]
        res = math.inf
        # after getting this how to get the degree?
        # len(adj[1]) + len(adj[2]) + len(adj[3]) - 6 (the trio edges)
        adj = self.getAdjSets(edges)
        for u,v in edges:
            # search for all the 'trio' points
            for trio_point in adj[u] &amp; adj[v]:
                res = min(res, len(adj[u]) + len(adj[v]) + len(adj[trio_point]) - 3 - 3)
                
        return res if res < math.inf else -1
    
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        # O(N^3) pick any random two connected points(edge), search for 
        res = math.inf
        adj = self.getAdjSets(edges)

        for u in range(1,n+1):
            for v in range(u+1, n+1):
                for trio_point in range(v+1, n+1):
                    if v in adj[u] and trio_point in adj[u] and trio_point in adj[v]:
                        res = min(res, len(adj[u]) + len(adj[v]) + len(adj[trio_point]) - 3 - 3)
        
        return res if res < math.inf else -1","class Solution {
 public:
  int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
    int ans = -1;
    int minCitiesCount = n;
    const vector<vector<int>> dist = floydWarshall(n, edges, distanceThreshold);

    for (int i = 0; i < n; ++i) {
      int citiesCount = 0;
      for (int j = 0; j < n; ++j)
        if (dist[i][j] <= distanceThreshold)
          ++citiesCount;
      if (citiesCount <= minCitiesCount) {
        ans = i;
        minCitiesCount = citiesCount;
      }
    }

    return ans;
  }

 private:
  vector<vector<int>> floydWarshall(int n, const vector<vector<int>>& edges,
                                    int distanceThreshold) {
    vector<vector<int>> dist(n, vector<int>(n, distanceThreshold + 1));

    for (int i = 0; i < n; ++i)
      dist[i][i] = 0;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int w = edge[2];
      dist[u][v] = w;
      dist[v][u] = w;
    }

    for (int k = 0; k < n; ++k)
      for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);

    return dist;
  }
};"
"class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        def isNice(s):
            pivot = -1
            if len(s) < 2:
                return ["""", 0]
            unorderedSet = set([x for x in s])
            for i in range(len(s)):
                if ord(s[i])<96:
                    if s[i].lower() not in unorderedSet:
                        pivot = i
                else:
                    if s[i].upper() not in unorderedSet:
                        pivot = i                        
            if pivot>=0:
                if pivot == len(s)-1:
                    return isNice(s[:pivot])
                a = isNice(s[:pivot])
                b = isNice(s[pivot+1:])            
                return a if a[1]>=b[1] else b
            else:
                print(s, len(s))
                return [s, len(s)]
        [x1, x2] = isNice(s)
        return x1","class Solution {
 public:
  int minDifficulty(vector<int>& jobDifficulty, int d) {
    const int n = jobDifficulty.size();
    if (n < d)
      return -1;

    // dp[i][k] := min difficulty to schedule the first i jobs in k days
    vector<vector<int>> dp(n + 1, vector<int>(d + 1, INT_MAX / 2));
    dp[0][0] = 0;

    for (int i = 1; i <= n; ++i)
      for (int k = 1; k <= d; ++k) {
        int maxDifficulty = 0;                  // Max(job[j + 1..i])
        for (int j = i - 1; j >= k - 1; --j) {  // 1-based
          maxDifficulty = max(maxDifficulty, jobDifficulty[j]);  // 0-based
          dp[i][k] = min(dp[i][k], dp[j][k - 1] + maxDifficulty);
        }
      }

    return dp[n][d];
  }
};"
"class Solution:
    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:
        groups_n = sum(len(group) for group in groups)
        nums_n = len(nums)
        
        if groups_n > nums_n:
            return False
        
        i = 0
        for group in groups:
            n = len(group)
            while nums_n - i >= n:
                if nums[i:i+n] == group:
                    break
                i += 1
            if nums_n - i < n:
                return False
            else:
                i += n
        return True","class Solution {
 public:
  vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {
    vector<int> ans;
    vector<vector<int>> rowSum;

    for (int i = 0; i < mat.size(); ++i)
      rowSum.push_back({accumulate(begin(mat[i]), end(mat[i]), 0), i});

    sort(begin(rowSum), end(rowSum), [](const auto& a, const auto& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0];
    });

    for (int i = 0; i < k; ++i)
      ans.push_back(rowSum[i][1]);

    return ans;
  }
};"
"class Solution:
    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:
        queue = deque()
        rows = len(isWater)
        cols = len(isWater[0])
        
        for i in range(rows):
            for j in range(cols):
                if isWater[i][j] == 1:
                    queue.append((i,j))
                    isWater[i][j] = 0 # set height of water as 0
                else:
                    isWater[i][j] = '$' # mark the land
                    
        while queue:
            row, col = queue.popleft()
            
            for x, y in [(0,1),(1,0),(0,-1),(-1,0)]:
                nRow = row + x
                nCol = col + y
                
                if 0<=nRow<rows and 0<=nCol<cols and isWater[nRow][nCol] == '$':
                    isWater[nRow][nCol] = isWater[row][col]+1
                    queue.append((nRow, nCol))
                    
        return isWater","class Solution {
 public:
  int minSetSize(vector<int>& arr) {
    const int n = arr.size();
    int sum = 0;
    unordered_map<int, int> map;
    vector<pair<int, int>> count;

    for (const int a : arr)
      ++map[a];

    for (const auto& [a, freq] : map)
      count.push_back(make_pair(a, freq));

    sort(begin(count), end(count),
         [](const auto& a, const auto& b) { return a.second > b.second; });

    for (int i = 0; i < count.size(); ++i) {
      sum += count[i].second;
      if (sum >= n / 2)
        return i + 1;
    }

    throw;
  }
};"
"class Solution:
    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:
        
        gcdset = [set() for i in range(51)]
        for i in range(1,51):
            for j in range(1,51):
                if math.gcd(i,j) == 1:
                    gcdset[i].add(j)
                    gcdset[j].add(i)
        
        graph = defaultdict(list)
        for v1, v2 in edges:
            graph[v1].append(v2)
            graph[v2].append(v1)
        
        ans = [-1]*len(nums)
        q = [[0, {}]]
        seen = set([0])
        depth = 0
        while q:
            temp = []
            for node, ancestors in q:
                index_depth = (-1,-1)
                for anc in list(ancestors.keys()):
                    if anc in gcdset[nums[node]]:
                        index, d = ancestors[anc]
                        if d > index_depth[1]:
                            index_depth = (index,d)
                ans[node] = index_depth[0]
                
                copy = ancestors.copy()
                copy[nums[node]] = (node,depth)
                
                for child in graph[node]:
                    if child not in seen:
                        seen.add(child)
                        temp.append([child, copy])
            q = temp
            depth += 1
        return ans
'''

**:)**","class Solution {
 public:
  int maxProduct(TreeNode* root) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    vector<int> allSums;
    const long totalSum = treeSum(root, allSums);

    for (const long sum : allSums)
      ans = max(ans, sum * (totalSum - sum));

    return ans % kMod;
  }

 private:
  int treeSum(TreeNode* root, vector<int>& allSums) {
    if (root == nullptr)
      return 0;

    const int leftSum = treeSum(root->left, allSums);
    const int rightSum = treeSum(root->right, allSums);
    const int sum = root->val + leftSum + rightSum;
    allSums.push_back(sum);
    return sum;
  }
};"
"class Solution(object):
    def mergeAlternately(self, word1, word2):
        """"""
        :type word1: str
        :type word2: str
        :rtype: str
        """"""
        # edge cases - 
        if word1 is None:
            return word2
        if word2 is None:
            return word1
        if word1 is None and word2 is None:
            return """"
        else:
            strr = """"
            l1 = len(word1)
            l2 = len(word2)
            for (i,j) in zip(range(l1), range(l2)):
                strr +=word1[i]
                strr +=word2[j]
            if i!=l1-1:
                strr += word1[i+1:]
            if j!=l2-1:
                strr += word2[j+1:]
            #print(strr)
            return strr","class Solution {
 public:
  int maxJumps(vector<int>& arr, int d) {
    const int n = arr.size();
    // dp[i] := max jumps starting from arr[i]
    vector<int> dp(n, 1);
    // Decreasing stack stores indices
    stack<int> stack;

    for (int i = 0; i <= n; ++i) {
      while (!stack.empty() && (i == n || arr[stack.top()] < arr[i])) {
        vector<int> indices{stack.top()};
        stack.pop();
        while (!stack.empty() && arr[stack.top()] == arr[indices[0]])
          indices.push_back(stack.top()), stack.pop();
        for (const int j : indices) {
          if (i < n && i - j <= d)
            // Can jump from i to j
            dp[i] = max(dp[i], dp[j] + 1);
          if (!stack.empty() && j - stack.top() <= d)
            // Can jump from stack.top() to j
            dp[stack.top()] = max(dp[stack.top()], dp[j] + 1);
        }
      }
      stack.push(i);
    }

    return *max_element(begin(dp), end(dp));
  }
};"
"class Solution:
    def minOperations(self, b: str) -> List[int]:
        l=[]
        for i in range(len(b)):
            a=0
            for j in range(len(b)):
                if(i!=j and b[j]==""1""):
                    a+=abs(j-i)
            l.append(a)
        return l","class Solution {
 public:
  int numOfSubarrays(vector<int>& arr, int k, int threshold) {
    int ans = 0;
    int windowSum = 0;

    for (int i = 0; i < arr.size(); ++i) {
      windowSum += arr[i];
      if (i >= k)
        windowSum -= arr[i - k];
      if (i >= k - 1 && windowSum / k >= threshold)
        ++ans;
    }

    return ans;
  }
};"
"class Solution:
    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:
        m, n = len(multipliers), len(nums)
        # let dp[i][j] denote the maximum score using the first i elements
        # and last j elements from nums
        dp = [[-float(""inf"")]*(m+1) for _ in range(m+1)]
        
        # initialization, populate the first row and column of the
        # dp table
        dp[0][0] = 0
        for i in range(1, m+1):
            dp[i][0] = dp[i-1][0]+multipliers[i-1]*nums[i-1]
            dp[0][i] = dp[0][i-1]+multipliers[i-1]*nums[-i]
        
        # state transition, populate the dp table inward
        # dp[n_left][n_right] = max(score if the last num used was from the left,
        #                           score if the last num used was from the right)
        ret = -float(""inf"")
        for n_used in range(1, m+1):
            for n_left in range(n_used+1):
                n_right = n_used-n_left
                dp[n_left][n_right] = max(dp[n_left-1][n_right]+multipliers[n_used-1]*nums[n_left-1],
                                          dp[n_left][n_right-1]+multipliers[n_used-1]*nums[-n_right])
                if n_used == m:
                    ret = max(ret, dp[n_left][n_right])
                    
        return ret","class Solution {
 public:
  double angleClock(int hour, int minutes) {
    const double hourHand = (hour % 12 + minutes / 60.0) * 30;
    const double minuteHand = minutes * 6;
    const double diff = abs(hourHand - minuteHand);
    return min(diff, 360 - diff);
  }
};"
"class Solution(object):
  def countMatches(self, items, ruleKey, ruleValue):
    output = 0
    itemsi = [""type"",""color"",""name""]
    ruleKey = itemsi.index(ruleKey)
    for i in items:
      if i[ruleKey] == ruleValue:
        output += 1
    return output","class Solution {
 public:
  int minJumps(vector<int>& arr) {
    const int n = arr.size();
    // {a: indices}
    unordered_map<int, vector<int>> graph;
    queue<int> q{{0}};
    vector<bool> seen(n);
    seen[0] = true;

    for (int i = 0; i < n; ++i)
      graph[arr[i]].push_back(i);

    for (int steps = 0; !q.empty(); ++steps) {
      for (int sz = q.size(); sz > 0; --sz) {
        const int i = q.front();
        q.pop();
        if (i == n - 1)
          return steps;
        seen[i] = true;
        const int u = arr[i];
        if (i + 1 < n)
          graph[u].push_back(i + 1);
        if (i - 1 >= 0)
          graph[u].push_back(i - 1);
        for (const int v : graph[u]) {
          if (seen[v])
            continue;
          q.push(v);
        }
        graph[u].clear();
      }
    }

    throw;
  }
};"
"class Solution:
    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:        
        @lru_cache(None)
        def dp(t, i):
            if t <= 0 or i == len(toppingCosts):
                return t
            
            useOne = dp(t - toppingCosts[i], i + 1)
            if useOne == 0:
                return 0
            useTwo = dp(t - toppingCosts[i] * 2, i + 1)
            if useTwo == 0:
                return 0
            useNone = dp(t, i + 1)
            if useNone == 0:
                return 0
            
            minimum = min((abs(useOne), -useOne), (abs(useTwo), -useTwo), (abs(useNone), -useNone))
            return -minimum[1]
        
        minimum = float('inf')
        for b in baseCosts:
            toFind = target - b
            res = b + toFind - dp(toFind, 0)
            minimum = min((abs(target - minimum), minimum), (abs(target - res), res))[1]
            if minimum == target:
                return minimum
        
        return minimum","class Solution {
 public:
  int minSteps(string s, string t) {
    vector<int> count(26);

    for (const char c : s)
      ++count[c - 'a'];

    for (const char c : t)
      --count[c - 'a'];

    return accumulate(begin(count), end(count), 0,
                      [](int subtotal, int c) { return subtotal + abs(c); }) /
           2;
  }
};"
"class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:
                        
        # Get the delta
        # We want sum(nums1) > sum(nums2) so we can use logic below
        delta = sum(nums1) - sum(nums2) 
        if delta < 0:
            nums1, nums2 = nums2, nums1
            delta = -delta
            
        # Dumb edge case
        if delta == 0: return 0
            
        # Their ranges do not overlap, impossible to return result
        if len(nums1)*1 > len(nums2)*6: return -1
        
        # Calculate the max subtractions
        max_subtract = collections.defaultdict(int)        
        for i in nums1: max_subtract[i-1] += 1
        for j in nums2: max_subtract[6-j] += 1
            
        # Greedily subtract from delta
        result = 0
        for val, count in sorted(max_subtract.items(), key = lambda x: x[0], reverse=True):
            for _ in range(count):                
                delta -= min(val, delta)
                result += 1       
                if delta == 0:
                    return result
                    
        return result","class Solution {
 public:
  int maxStudents(vector<vector<char>>& seats) {
    return accumulate(
               begin(seats), end(seats), 0,
               [&](int a, const auto& seat) {
      return a + count(begin(seat), end(seat), '.');
               }) -
        hungarian(seats);
  }

 private:
  const vector<pair<int, int>> dirs{{-1, -1}, {0, -1}, {1, -1},
                                    {-1, 1},  {0, 1},  {1, 1}};

  int hungarian(const vector<vector<char>>& seats) {
    const int m = seats.size();
    const int n = seats[0].size();
    int count = 0;
    vector<vector<int>> seen(m, vector<int>(n));
    vector<vector<int>> match(m, vector<int>(n, -1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (seats[i][j] == '.' && match[i][j] == -1) {
          const int sessionId = i * n + j;
          seen[i][j] = sessionId;
          count += dfs(seats, i, j, sessionId, seen, match);
        }

    return count;
  }

  int dfs(const vector<vector<char>>& seats, int i, int j, int sessionId,
          vector<vector<int>>& seen, vector<vector<int>>& match) {
    const int m = seats.size();
    const int n = seats[0].size();

    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x == m || y < 0 || y == n)
        continue;
      if (seats[x][y] != '.' || seen[x][y] == sessionId)
        continue;
      seen[x][y] = sessionId;
      if (match[x][y] == -1 || dfs(seats, match[x][y] / n, match[x][y] % n,
                                   sessionId, seen, match)) {
        match[x][y] = i * n + j;
        match[i][j] = x * n + y;
        return 1;
      }
    }

    return 0;
  }
};"
"class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        times = [float(-1) for _ in range(len(cars))]
        for i in range(1, len(cars)):
            if cars[i-1][1] > cars[i][1]:
                times[i-1] = self.timeToCollide(cars, i-1, i)
        for i in range(len(cars)-3, -1, -1):
            if times[i+1] == - 1.0: continue
			# if car[i+1] collided before car[i], then we have to adjust times[i]
            if times[i] > times[i+1]:
                times[i] = self.correctTime(cars, times, i)
                cars[i+1][1] = cars[i+2][1]
			# if car[i+1] collided and speed became slower than cars[i], then we also have to adjust times[i]
            elif cars[i][1] <= cars[i+1][1] and times[i+1] > 0.0:
                if cars[i][1] > cars[i+2][1]:
                    times[i] = self.timeToCollide(cars, i, i+2)
        return times
        
    def timeToCollide(self, cars, i, j): 
        return (cars[j][0]-cars[i][0])/(cars[i][1] - cars[j][1])
    def correctTime(self, cars, times, i):
        return times[i+1] + (times[i]-times[i+1])*(cars[i][1] - cars[i+1][1])/(cars[i][1] - cars[i+2][1])","class Solution {
 public:
  int countNegatives(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;
    int i = m - 1;
    int j = 0;

    while (i >= 0 && j < n) {
      if (grid[i][j] < 0) {
        ans += n - j;
        --i;
      } else {
        ++j;
      }
    }

    return ans;
  }
};"
"class Solution:
    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:
        
		def manhattan_dist(x1, y1, x2, y2):
            return abs(x1-x2) + abs(y1-y2)
        
		# It's always handy to initialize using float('inf') or float('-inf') if you want really
		# large or small numbers! :)
        min_dist = float('inf')
        min_idx = -1
        
        for i in range(len(points)):
			# If coordinate is valid, then do checks on manhattan_dist
            if points[i][0] == x or points[i][1] == y:
			
				# If the valid coordinate is smaller, then update the index and min_dist
				dist = manhattan_dist(x, y, points[i][0], points[i][1])
                if min_dist > dist:
                    min_dist = dist
                    min_idx = i
                
        return min_idx","class Solution {
 public:
  int maxEvents(vector<vector<int>>& events) {
    int ans = 0;
    int d = 0;  // Current day
    int i = 0;  // events' index
    priority_queue<int, vector<int>, greater<>> minHeap;

    sort(begin(events), end(events));

    while (!minHeap.empty() || i < events.size()) {
      // If no events are available to attend today, let time flies to the next
      // available event.
      if (minHeap.empty())
        d = events[i][0];
      // All events starting from today are newly available.
      while (i < events.size() && events[i][0] == d)
        minHeap.push(events[i++][1]);
      // Greedily attend the event that'll end the earliest since it has higher
      // chance can't be attended in the future.
      minHeap.pop();
      ++ans;
      ++d;
      // Pop events that can't be attended.
      while (!minHeap.empty() && minHeap.top() < d)
        minHeap.pop();
    }

    return ans;
  }
};"
"class Solution:
    def checkPowersOfThree(self, n: int) -> bool:
        
        '''
        Here we make a ternary representation of given n
        If n has '2' in it return False, else return True
        [See: hint]
        '''
        
        ternary = ''                       #ternary string is the reverse representation of original ternary
        
        while n>0:
            ternary+=str(n%3)              #ternary means base 3
            n=n//3
            
        if '2' in ternary:
            return False
        return True","class Solution {
 public:
  bool isPossible(vector<int>& target) {
    if (target.size() == 1)
      return target[0] == 1;

    long sum = accumulate(begin(target), end(target), 0L);
    priority_queue<int> maxHeap;

    for (const int num : target)
      maxHeap.push(num);

    while (maxHeap.top() > 1) {
      const long max = maxHeap.top();
      maxHeap.pop();
      const long restSum = sum - max;
      // Only occurs if n == 2.
      if (restSum == 1)
        return true;
      const long updated = max % restSum;
      // Updated == 0 (invalid) or didn't change.
      if (updated == 0 || updated == max)
        return false;
      maxHeap.push(updated);
      sum = sum - max + updated;
    }

    return true;
  }
};"
"class Solution(object):
    def beautySum(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        res = 0
        h = [0 for _ in range(26)]
        for i in range(len(s)):
            h = [0 for _ in range(26)]
            for j in range(i, len(s)):
                h[ord(s[j]) - ord('a')] += 1
                minv, maxv = 501, -1
                for x in h:
                    if x > 0:
                        minv = min(minv, x)
                        maxv = max(maxv, x)
                res += maxv - minv
        return res","class Solution {
 public:
  vector<int> sortByBits(vector<int>& arr) {
    sort(begin(arr), end(arr), [](const int a, int b) {
      const int x = bitset<32>(a).count();
      const int y = bitset<32>(b).count();
      return x == y ? a < b : x < y;
    });
    return arr;
  }
};"
"class Solution:
    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:
        degree = [0]*n
        freq = defaultdict(int)
        for u, v in edges: 
            degree[u-1] += 1
            degree[v-1] += 1
            freq[min(u-1, v-1), max(u-1, v-1)] += 1
        
        vals = sorted(degree)
        
        ans = []
        for query in queries: 
            cnt = 0 
            lo, hi = 0, n-1
            while lo < hi: 
                if query < vals[lo] + vals[hi]: 
                    cnt += hi - lo # (lo, hi), (lo+1, hi), ..., (hi-1, hi) all valid
                    hi -= 1
                else: lo += 1
            for u, v in freq: 
                if degree[u] + degree[v] - freq[u, v] <= query < degree[u] + degree[v]: cnt -= 1
            ans.append(cnt)
        return ans","class Solution {
 public:
  // Similar to 3. Longest Substring Without Repeating Characters
  int numberOfSubstrings(string s) {
    int ans = 0;
    vector<int> count(3);

    int l = 0;
    for (const char c : s) {
      ++count[c - 'a'];
      while (count[0] > 0 && count[1] > 0 && count[2] > 0)
        --count[s[l++] - 'a'];
      // s[0..r], s[1..r], ..., s[l - 1..r] are satified strings.
      ans += l;
    }

    return ans;
  }
};"
"class Solution:
def checkOnesSegment(self, s: str) -> bool:
    flag=0
    for i in s:
        if i=='1' and flag==1:
            return False 
        elif i=='0':
            flag=1
            
    return True","class Solution {
 public:
  int countOrders(int n) {
    constexpr int kMod = 1'000'000'007;
    long ans = 1;

    for (int i = 1; i <= n; ++i)
      ans = ans * i * (i * 2 - 1) % kMod;

    return ans;
  }
};"
"class Solution:
def minElements(self, nums: List[int], limit: int, goal: int) -> int:
    return abs(goal-sum(nums))//limit+(abs(goal-sum(nums))%limit!=0)*1","class Solution {
 public:
  bool validateBinaryTreeNodes(int n, vector<int>& leftChild,
                               vector<int>& rightChild) {
    vector<int> inDegree(n);
    int root = -1;

    // If inDegree of any node > 1, return false
    for (const int child : leftChild)
      if (child != -1 && ++inDegree[child] == 2)
        return false;

    for (const int child : rightChild)
      if (child != -1 && ++inDegree[child] == 2)
        return false;

    // Find the root (node with inDegree == 0)
    for (int i = 0; i < n; ++i)
      if (inDegree[i] == 0)
        if (root == -1)
          root = i;
        else
          return false;  // Multiple roots

    // didn't find the root
    if (root == -1)
      return false;

    return countNodes(root, leftChild, rightChild) == n;
  }

 private:
  int countNodes(int root, const vector<int>& leftChild,
                 const vector<int>& rightChild) {
    if (root == -1)
      return 0;
    return 1 +  //
           countNodes(leftChild[root], leftChild, rightChild) +
           countNodes(rightChild[root], leftChild, rightChild);
  }
};"
"class Solution:
    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
        # Dijkstra's algorithm
        distances = {i: float('inf') for i in range(1, n+1)}
        distances[n] = 0
        graph = defaultdict(list)
        for edge in edges:
            graph[edge[0]].append((edge[1], edge[2]))
            graph[edge[1]].append((edge[0], edge[2]))
        pq = [(0, n)]
        while len(pq) > 0:
            curDistance, curVertex = heapq.heappop(pq)
			# skip the following steps if we've already visited the vertex
            if curDistance > distances[curVertex]:
                continue
            for edge in graph[curVertex]:
                neighbor = edge[0]
                weight = edge[1]
                distance = curDistance + weight
                # update neighbor's distance if the path via cur node has a shorter distance
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))
		# Bottom-up DP
        # initialize dp array, which stores how many restricted paths between endnode and curnode
        dp = [0]*(n+1)
        dp[n] = 1
        dist = sorted(list(distances.keys()), key=lambda item:distances[item])
        for index in dist:
            neighbors = [edge[0] for edge in graph[index]]
            for neighbor in neighbors:
                if distances[neighbor] < distances[index]:
                    dp[index] += dp[neighbor]
                    dp[index] = int(dp[index]%(1e9+7))
            # when we've reached node 1 (start node), we could return the result
            if index == 1:
                return dp[1]
        return -1","class Solution {
 public:
  vector<int> closestDivisors(int num) {
    for (int root = sqrt(num + 2); root > 0; --root)
      for (int cand : {num + 1, num + 2})
        if (cand % root == 0)
          return {root, cand / root};

    throw;
  }
};"
"class Solution:
    def minChanges(self, nums: List[int], k: int) -> int:
        freq = defaultdict(lambda: defaultdict(int))
        for i, x in enumerate(nums): freq[i%k][x] += 1 # freq by row
        
        n = 1 << 10
        dp = [0] + [-inf]*(n-1)
        for i in range(k): 
            mx = max(dp)
            tmp = [0]*n
            for x, c in enumerate(dp): 
                for xx, cc in freq[i].items(): 
                    tmp[x^xx] = max(tmp[x^xx], c + cc, mx)
            dp = tmp 
        return len(nums) - dp[0]","class Solution {
 public:
  string largestMultipleOfThree(vector<int>& digits) {
    string ans;
    vector<int> mod1{1, 4, 7, 2, 5, 8};
    vector<int> mod2{2, 5, 8, 1, 4, 7};
    vector<int> count(10);
    int sum = accumulate(begin(digits), end(digits), 0);

    for (const int digit : digits)
      ++count[digit];

    while (sum % 3 != 0)
      for (int i : sum % 3 == 1 ? mod1 : mod2)
        if (count[i]) {
          --count[i];
          sum -= i;
          break;
        }

    for (int digit = 9; digit >= 0; --digit)
      ans += string(count[digit], '0' + digit);

    return ans.size() && ans[0] == '0' ? ""0"" : ans;
  }
};"
"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if not set(s1) == set(s2):
            return False
        return sum(1 for i in range(len(s1)) if not s1[i] == s2[i]) < 3","struct Team {
  char name;
  vector<int> rank;
  Team(char name, int teamSize) : name(name), rank(teamSize) {}
};

class Solution {
 public:
  string rankTeams(vector<string>& votes) {
    const int teamSize = votes[0].size();
    string ans;
    vector<Team> teams;

    for (int i = 0; i < 26; ++i)
      teams.push_back(Team('A' + i, teamSize));

    for (const string& vote : votes)
      for (int i = 0; i < teamSize; ++i)
        ++teams[vote[i] - 'A'].rank[i];

    sort(begin(teams), end(teams), [](const Team& a, const Team& b) {
      return a.rank == b.rank ? a.name < b.name : a.rank > b.rank;
    });

    for (int i = 0; i < teamSize; ++i)
      ans += teams[i].name;

    return ans;
  }
};"
"class Solution:
    def findCenter(self, edge: List[List[int]]) -> int:
        if edge[0][0] in edge[1]:
            return edge[0][0]
        else:
            return edge[0][1]","class Solution {
 public:
  bool isSubPath(ListNode* head, TreeNode* root) {
    if (root == nullptr)
      return false;
    return isContinuousSubPath(head, root) || isSubPath(head, root->left) ||
           isSubPath(head, root->right);
  }

 private:
  bool isContinuousSubPath(ListNode* head, TreeNode* root) {
    if (head == nullptr)
      return true;
    if (root == nullptr)
      return false;
    return head->val == root->val &&
           (isContinuousSubPath(head->next, root->left) ||
            isContinuousSubPath(head->next, root->right));
  }
};"
"class Solution:
    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:
        heap_classes = []
        for p, t in classes:
            heappush(heap_classes, (-((p + 1) / (t + 1) - p / t), p, t))
        for _ in range(extraStudents):
            diff, p, t = heappop(heap_classes)
            p += 1
            t += 1
            heappush(heap_classes, (-((p + 1) / (t + 1) - p / t), p, t))
        return sum(p / t for d, p, t in heap_classes) / len(classes)","class Solution {
 public:
  int minCost(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    dp.resize(m, vector<int>(n, -1));
    queue<pair<int, int>> q;

    dfs(grid, 0, 0, /*cost=*/0, q);

    for (int cost = 1; !q.empty(); ++cost)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs)
          dfs(grid, i + dx, j + dy, cost, q);
      }

    return dp.back().back();
  }

 private:
  const vector<pair<int, int>> dirs{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
  vector<vector<int>> dp;

  void dfs(const vector<vector<int>>& grid, int i, int j, int cost,
           queue<pair<int, int>>& q) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (dp[i][j] != -1)
      return;

    dp[i][j] = cost;
    q.emplace(i, j);
    const auto [dx, dy] = dirs[grid[i][j] - 1];
    dfs(grid, i + dx, j + dy, cost, q);
  }
};"
"class Solution:
    def maximumScore(self, n: List[int], kk: int) -> int:
        
        vmin = n[kk]
        for i in range(kk,-1,-1):
            if n[i]<vmin:
                vmin = n[i]
            else:
                n[i] = vmin

        vmin = n[kk]
        for i in range(kk,len(n)):
            if n[i]<vmin:
                vmin = n[i]
            else:
                n[i] = vmin

        good = 0
        li = 0
        ri = len(n)-1
        while li<=kk and ri>= kk:
            vmin = min(n[li],n[ri])
            if vmin*(ri-li+1)>good:
                good = min(n[li],n[ri])*(ri-li+1)
            
            if li == ri:
                break
                
            while li<kk and n[li]==vmin:
                li += 1
                
            while ri>kk and n[ri]==vmin:
                ri -= 1
            
        
        return good","class Solution {
 public:
  int findTheLongestSubstring(string s) {
    int ans = 0;
    int prefix = 0;  // Binary prefix
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < s.length(); ++i) {
      const int index = string(""aeiou"").find(s[i]);
      if (index != -1)
        prefix ^= 1 << index;
      if (!prefixToIndex.count(prefix))
        prefixToIndex[prefix] = i;
      ans = max(ans, i - prefixToIndex[prefix]);
    }

    return ans;
  }
};"
"class Solution:
    def secondHighest(self, s: str) -> int:
        seen = set()
        for c in s: 
            if c.isdigit(): 
                seen.add(int(c))
        return -1 if len(seen) < 2 else sorted(seen)[-2]","struct T {
  int leftMax;
  int rightMax;
  int subtreeMax;
};

class Solution {
 public:
  int longestZigZag(TreeNode* root) {
    return dfs(root).subtreeMax;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {-1, -1, -1};
    const T left = dfs(root->left);
    const T right = dfs(root->right);
    const int leftZigZag = left.rightMax + 1;
    const int rightZigZag = right.leftMax + 1;
    const int subtreeMax =
        max({leftZigZag, rightZigZag, left.subtreeMax, right.subtreeMax});
    return {leftZigZag, rightZigZag, subtreeMax};
  }
};"
"class Solution:
    def getMaximumConsecutive(self, coins: List[int]) -> int:
        ans = 1
        for x in sorted(coins): 
            if ans < x: break 
            ans += x
        return ans","struct T {
  bool isBST;
  int max;
  int min;
  int sum;
  T() : isBST(false) {}
  T(bool isBST, int max, int min, int sum)
      : isBST(isBST), max(max), min(min), sum(sum) {}
};

class Solution {
 public:
  int maxSumBST(TreeNode* root) {
    int ans = 0;
    traverse(root, ans);
    return ans;
  }

 private:
  T traverse(TreeNode* root, int& ans) {
    if (root == nullptr)
      return T(true, INT_MIN, INT_MAX, 0);

    const T left = traverse(root->left, ans);
    const T right = traverse(root->right, ans);

    if (!left.isBST || !right.isBST)
      return T();
    if (root->val <= left.max || root->val >= right.min)
      return T();

    // Root is a valid BST
    const int sum = root->val + left.sum + right.sum;
    ans = max(ans, sum);
    return T(true, max(root->val, right.max), min(root->val, left.min), sum);
  }
};"
"class Solution:
    def maxScore(self, nums: List[int]) -> int:
        def combination(count=1, bitmask=0):
            if count==size//2+1:
                return 0
            max_ = 0
            for i in range(size):
                if bitmask>>i&amp;1:
                    continue
                newBitmask = bitmask|1<<i
                for j in range(size):
                    if newBitmask>>j&amp;1:
                        continue
                    newBitmask = bitmask|1<<i|1<<j
                    if dp[newBitmask]:
                        max_ = max(max_, table[i][j]*count+dp[newBitmask])
                    else:
                        max_ = max(max_, table[i][j]*count+combination(count+1, newBitmask))
            dp[bitmask] = max_
            return max_
        size = len(nums)
        dp = [0]*(2**size)
        table = [[0]*size for i in range(size)]
        for i in range(size):
            for j in range(i+1, size):
                table[i][j] = table[j][i] = math.gcd(nums[i], nums[j])
        return combination()","class Solution {
 public:
  int numTimesAllBlue(vector<int>& flips) {
    int ans = 0;
    int rightmost = 0;

    for (int i = 0; i < flips.size(); ++i) {
      rightmost = max(rightmost, flips[i]);
      // max(flips[0..i]) = rightmost = i + 1,
      // so flips[0..i] is a permutation of 1, 2, ..., i + 1.
      if (rightmost == i + 1)
        ++ans;
    }

    return ans;
  }
};"
"class Solution:
    def maxAscendingSum(self, nums: List[int]) -> int:
        total = 0
        max_total = 0
        i = 0

        while i < len(nums):
            if nums[i] <= nums[i-1]:
                total = 0
            total += nums[i]
            max_total = max(total, max_total)
            i += 1
        return max_total","class Solution {
 public:
  int numOfMinutes(int n, int headID, vector<int>& manager,
                   vector<int>& informTime) {
    int ans = 0;

    for (int i = 0; i < n; ++i)
      ans = max(ans, dfs(i, headID, manager, informTime, {}));

    return ans;
  }

 private:
  int dfs(int i, int headID, const vector<int>& manager,
          const vector<int>& informTime, unordered_map<int, int>&& memo) {
    if (const auto it = memo.find(i); it != cend(memo))
      return it->second;
    if (i == headID)
      return 0;

    const int parent = manager[i];
    return memo[i] = informTime[parent] +
                     dfs(parent, headID, manager, informTime, move(memo));
  }
};"
"class Solution:
    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:
        backlog = defaultdict(list)
        for price, amount, ordertype in orders:
            #sell
            if ordertype == 1:
                if backlog[0]:
                    condition = True
                    while condition and backlog[0]:
                        bp, ba = heapq.heappop(backlog[0])
                        if -bp >= price:
                            if amount < ba:
                                ba -= amount
                                amount = 0
                                heapq.heappush(backlog[0], [bp, ba])
                                condition = False
                            elif amount > ba:
                                amount -=ba 
                            else:
                                amount = 0
                        else:
                            heapq.heappush(backlog[0], [bp,ba])
                            heapq.heappush(backlog[1], [price, amount])
                            amount = 0
                            condition = False
                    if amount:
                        heapq.heappush(backlog[1], [price, amount])
                else:
                    heapq.heappush(backlog[1], [price, amount])
            #buy
            if ordertype == 0:
                if backlog[1]:
                    condition = True
                    while condition and backlog[1]:
                        sp, sa = heapq.heappop(backlog[1])
                        if sp <= price:
                            if amount < sa:
                                sa -= amount
                                amount = 0
                                heapq.heappush(backlog[1], [sp, sa])
                                condition = False
                            elif amount > sa:
                                amount -=sa
                            else:
                                amount = 0
                        else:
                            heapq.heappush(backlog[1], [sp, sa])
                            heapq.heappush(backlog[0], [-price, amount])
                            amount = 0
                            condition = False
                    if amount:
                        heapq.heappush(backlog[0], [-price, amount])
                else:
                    heapq.heappush(backlog[0], [-price, amount])
            #print(backlog[0], backlog[1])
        res = 0
        for i,j in backlog[0]:
            res += j
        for i,j in backlog[1]:
            res += j
        return res % (10**9 + 7)","class Solution {
 public:
  double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
    vector<vector<int>> tree(n + 1);
    queue<int> q{{1}};
    vector<bool> seen(n + 1);
    vector<double> prob(n + 1);

    seen[1] = true;
    prob[1] = 1.0;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    while (!q.empty() && t-- > 0)
      for (int sz = q.size(); sz > 0; --sz) {
        const int a = q.front();
        q.pop();
        const int nChildren = count_if(begin(tree[a]), end(tree[a]),
                                       [&seen](int b) { return !seen[b]; });
        for (const int b : tree[a]) {
          if (seen[b])
            continue;
          seen[b] = true;
          prob[b] = prob[a] / nChildren;
          q.push(b);
        }
        if (nChildren > 0)
          prob[a] = 0.0;
      }

    return prob[target];
  }
};"
"class Solution:

    @classmethod
    def min_area(cls, len_arr, idx, target):
        if target + idx >= len_arr:
            sum_r = (2 * target - len_arr + idx) * (len_arr - 1 - idx) // 2
        else:
            sum_r = target * (target - 1) // 2 + len_arr - idx - target
        if target - idx >= 1:
            sum_l = (2 * target - 1 - idx) * idx // 2
        else:
            sum_l = target * (target - 1) // 2 + idx - target + 1
        return sum_l + sum_r + target

    def maxValue(self, n: int, index: int, maxSum: int) -> int:
        left, right = 1, maxSum - n + 2
        while left + 1 < right:
            middle = (left + right) // 2
            if Solution.min_area(n, index, middle) <= maxSum:
                left = middle
            else:
                right = middle
        return left","class Solution {
 public:
  TreeNode* balanceBST(TreeNode* root) {
    vector<int> nums;
    inorder(root, nums);
    return build(nums, 0, nums.size() - 1);
  }

 private:
  void inorder(TreeNode* root, vector<int>& nums) {
    if (root == nullptr)
      return;
    inorder(root->left, nums);
    nums.push_back(root->val);
    inorder(root->right, nums);
  }

  // Same as 108. Convert Sorted Array to Binary Search Tree
  TreeNode* build(const vector<int>& nums, int l, int r) {
    if (l > r)
      return nullptr;
    const int m = (l + r) / 2;
    return new TreeNode(nums[m], build(nums, l, m - 1), build(nums, m + 1, r));
  }
};"
"class Solution:
    def numDifferentIntegers(self, word: str) -> int:
        nums = ""0123456789""
        for i in range(len(word)):
            if word[i] not in nums:
                word = word.replace(word[i], "" "")
    
        w = word.split()
        for i in range(len(w)):
            w[i] = int(w[i])
        w = set(w)
       return len(w)","class Solution {
 public:
  // Similar to 857. Minimum Cost to Hire K Workers
  int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency,
                     int k) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    long speedSum = 0;
    // (efficiency[i], speed[i]) sorted by efficiency[i] in descending order.
    vector<pair<int, int>> A;
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (int i = 0; i < n; ++i)
      A.emplace_back(efficiency[i], speed[i]);

    sort(begin(A), end(A), greater<>());

    for (const auto& [e, s] : A) {
      minHeap.push(s);
      speedSum += s;
      if (minHeap.size() > k)
        speedSum -= minHeap.top(), minHeap.pop();
      ans = max(ans, speedSum * e);
    }

    return ans % kMod;
  }
};"
"class Solution:
    def reinitializePermutation(self, n: int) -> int:
        perm=[i for i in range(n)]
        op=list(perm)
        arr=[0]*n
        c=0
        nn=n//2
        
        while arr!=op:
            for i in range(n):
                if i%2 == 0:
                    arr[i] = perm[i // 2]
                else:
                    arr[i] = perm[int(nn + (i - 1) // 2)]
            perm = list(arr)

            c+=1
        return c","class Solution {
 public:
  int maxNumberOfFamilies(int n, vector<vector<int>>& reservedSeats) {
    int ans = 0;
    unordered_map<int, int> rowToSeats;

    for (const vector<int>& reservedSeat : reservedSeats) {
      const int row = reservedSeat[0];
      const int seat = reservedSeat[1];
      rowToSeats[row] |= 1 << (seat - 1);
    }

    for (const auto& [_, seats] : rowToSeats)
      if ((seats & 0b0111111110) == 0)
        // Can fit 2 four-person groups.
        ans += 2;
      else if ((seats & 0b0111100000) == 0 ||  // Left not occupied.
               (seats & 0b0001111000) == 0 ||  // Mid not occupied.
               (seats & 0b0000011110) == 0)    // Right not occupied.
        // Can fit 1 four-person group.
        ans += 1;

    // Any empty rows can fit 2 four-person groups.
    return ans + (n - rowToSeats.size()) * 2;
  }
};"
"class Solution:
    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:
        answers = {}
        keys = [n.split('(')[-1] for n in s.split(')')][:-1]
        
        for k, v in knowledge:
            answers[k] = v

        for key in keys:
            s = s.replace(f'({key})', answers.get(key, '?'))

        return s","class Solution {
 public:
  int getKth(int lo, int hi, int k) {
    vector<pair<int, int>> powAndVals;  // (pow, val)

    for (int i = lo; i <= hi; ++i)
      powAndVals.emplace_back(getPow(i), i);

    nth_element(begin(powAndVals), begin(powAndVals) + k - 1, end(powAndVals));
    return powAndVals[k - 1].second;
  }

 private:
  int getPow(int n) {
    if (n == 1)
      return 0;
    return 1 + (n % 2 == 0 ? getPow(n / 2) : getPow(n * 3 + 1));
  }
};"
"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        mod = 1_000_000_007
        if primeFactors % 3 == 0: return pow(3, primeFactors//3, mod)
        if primeFactors % 3 == 1: return 1 if primeFactors == 1 else 4*pow(3, (primeFactors-4)//3, mod) % mod
        return 2*pow(3, primeFactors//3, mod) % mod","class Solution {
 public:
  int sumFourDivisors(vector<int>& nums) {
    int ans = 0;

    for (int num : nums) {
      int divisor = 0;
      for (int i = 2; i * i <= num; ++i)
        if (num % i == 0) {
          if (divisor == 0)
            divisor = i;
          else {
            divisor = 0;
            break;
          }
        }
      if (divisor > 0 && divisor * divisor < num)
        ans += 1 + num + divisor + num / divisor;
    }

    return ans;
  }
};"
"class Solution:
    def squareIsWhite(self, c: str) -> bool:
        return True if (ord(c[0])-96 + int(c[1]))%2!=0 else False","class Solution {
 public:
  bool hasValidPath(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    // G := upscaled grid
    vector<vector<bool>> g(m * 3, vector<bool>(n * 3));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        switch (grid[i][j]) {
          case 1:
            g[i * 3 + 1][j * 3 + 0] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 2] = true;
            break;
          case 2:
            g[i * 3 + 0][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 2][j * 3 + 1] = true;
            break;
          case 3:
            g[i * 3 + 1][j * 3 + 0] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 2][j * 3 + 1] = true;
            break;
          case 4:
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 2] = true;
            g[i * 3 + 2][j * 3 + 1] = true;
            break;
          case 5:
            g[i * 3 + 0][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 0] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            break;
          case 6:
            g[i * 3 + 0][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 2] = true;
            break;
        }

    return dfs(g, 1, 1);
  }

 private:
  bool dfs(vector<vector<bool>>& g, int i, int j) {
    if (i < 0 || i == g.size() || j < 0 || j == g[0].size())
      return false;
    if (!g[i][j])  // No path here
      return false;
    if (i == g.size() - 2 && j == g[0].size() - 2)
      return true;

    g[i][j] = false;  // Mark as visited
    return dfs(g, i + 1, j) || dfs(g, i - 1, j) || dfs(g, i, j + 1) ||
           dfs(g, i, j - 1);
  }
};"
"class Solution:
    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:
        # this is the solution for comparing char-wise, but the question is asking for word-wise :(
        #############################################################################
        # According to the 'similarity' definition given, 
        # if we can insert some chars (could be empty) to make 
        # inserted sentence1 == sentence2 (assume len(sentence1) <= len(sentence2))
        #############################################################################
        # Idea: 
        #       view sentence 1 as prefix + arbitrary sentence to insert (possibly empty) + suffix 
        #       view sentence 2 as prefix + middle chars + suffix 
        # 1. compare sentence1 and sentence2 until they are not matched (it is prefix)
        # 2. rest of sentence2 is suffix -> if this suffix exists in sentence1 -> similar (otherwise not)
        ''' this is the solution for comparing char-wise, but the question is asking for word-wise :(
        if len(sentence1) == len(sentence2):
            return sentence1 == sentence2 
        
        # make sure sentence1 has shorted length 
        if len(sentence1) > len(sentence2):
            sentence1, sentence2 = sentence2, sentence1

        # find the end of prefix 
        # if char is unmatched => compare suffix
        for idx, c in enumerate(sentence1):
            if not (c == sentence2[idx]):
                return sentence1[idx:] == sentence2[-(len(sentence1)-idx):]
        return True 
        '''
        
        # adjust from our char-wise solution
        # w for word 
        s1 = sentence1.split() 
        s2 = sentence2.split() 
        if len(s1) == len(s2):
            return all([w1==w2 for (w1, w2) in zip(s1, s2)])
        
        # make sure sentence1 has shorted length 
        if len(s1) > len(s2):
            s1, s2 = s2, s1 

        # find the end of prefix &amp; compare suffix 
        for idx, w in enumerate(s1):
            if not (w == s2[idx]):
                return all([w1==w2 for (w1, w2) in zip(s1[idx:], s2[-(len(s1)-idx):])])
        return True","class Solution {
 public:
  string longestPrefix(string s) {
    constexpr int kBase = 26;
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    int maxLength = 0;
    long pow = 1;
    long prefixHash = 0;  // Hash of s[0..i]
    long suffixHash = 0;  // Hash of s[j..n)

    for (int i = 0, j = n - 1; i < n - 1; ++i, --j) {
      prefixHash = (prefixHash * kBase + val(s[i])) % kMod;
      suffixHash = (val(s[j]) * pow + suffixHash) % kMod;
      pow = pow * kBase % kMod;
      if (prefixHash == suffixHash)
        maxLength = i + 1;
    }

    return s.substr(0, maxLength);
  }

 private:
  constexpr int val(char c) {
    return c - 'a';
  }
};"
"class Solution:
    def countNicePairs(self, nums: List[int]) -> int:
        ans = 0 
        freq = defaultdict(int)
        for x in nums: 
            x -= int(str(x)[::-1])
            ans += freq[x]
            freq[x] += 1
        return ans % 1_000_000_007","class Solution {
 public:
  int numTeams(vector<int>& rating) {
    int ans = 0;

    for (int i = 1; i < rating.size() - 1; ++i) {
      // Calculate soldiers on the left with less/greater ratings.
      int leftLess = 0;
      int leftGreater = 0;
      for (int j = 0; j < i; ++j)
        if (rating[j] < rating[i])
          ++leftLess;
        else if (rating[j] > rating[i])
          ++leftGreater;
      // Calculate soldiers on the right with less/greater ratings.
      int rightLess = 0;
      int rightGreater = 0;
      for (int j = i + 1; j < rating.size(); ++j)
        if (rating[j] < rating[i])
          ++rightLess;
        else if (rating[j] > rating[i])
          ++rightGreater;
      ans += leftLess * rightGreater + leftGreater * rightLess;
    }

    return ans;
  }
};"
"class Solution:
    def maxHappyGroups(self, bs: int, gs: List[int]) -> int:
        c = {i: 0 for i in range(bs)}
        for g in gs:
            c[g % bs] += 1
        ret = c[0]
        c[0] = 0
        
        
        def get_keys(num):
            keys = []
            def rec(stack):
                if len(stack) == num:
                    if sum(stack) % bs == 0:
                        keys.append(Counter(stack))
                else:
                    for i in range(stack[-1] if stack else bs - 1, - 1, - 1):
                        stack.append(i)
                        rec(stack)
                        stack.pop()
            rec([])
            return keys
        
        def get_diff_keys(num):
            keys = []
            def rec(stack):
                if len(stack) == num:
                    if sum(stack) % bs == 0:
                        keys.append(Counter(stack))
                else:
                    for i in range(stack[-1] - 1 if stack else bs - 1, - 1, - 1):
                        stack.append(i)
                        rec(stack)
                        stack.pop()
            rec([])
            return keys
        
        for tc in range(2, bs):
            for keys in get_diff_keys(tc):
                add = min(c[key] // keys[key] for key in keys)
                if add == 0: continue
                ret += add
                for key in keys:
                    c[key] -= add * keys[key]
        tc = 2
        while True:
            for keys in get_keys(tc):
                add = min(c[key] // keys[key] for key in keys)
                if add == 0: continue
                ret += add
                for key in keys:
                    c[key] -= add * keys[key]
            if tc > sum(c.values()): break
            tc += 1
        return ret + bool(sum(c.values()))
            
        ```","struct CheckIn {
  string stationName;
  int time;
};

struct CheckOut {
  int numTrips;
  int totalTime;
};

class UndergroundSystem {
 public:
  void checkIn(int id, string stationName, int t) {
    checkIns[id] = {stationName, t};
  }

  void checkOut(int id, string stationName, int t) {
    const auto [startStation, startTime] = checkIns[id];
    checkIns.erase(id);
    const string& route = startStation + ""->"" + stationName;
    ++checkOuts[route].numTrips;
    checkOuts[route].totalTime += t - startTime;
  }

  double getAverageTime(string startStation, string endStation) {
    const auto& [numTrips, totalTime] =
        checkOuts[startStation + ""->"" + endStation];
    return totalTime / (double)numTrips;
  }

 private:
  unordered_map<int, CheckIn> checkIns;       // {id: (stationName, time)}
  unordered_map<string, CheckOut> checkOuts;  // {route: (numTrips, totalTime)}
};"
"class Solution:
    def truncateSentence(self, s: str, k: int) -> str:
        return ' '.join(s.split()[0:k])","class Solution {
 public:
  int findGoodStrings(int n, string s1, string s2, string evil) {
    // dp[i][j][k1][k2] := # of good strings for s[i:] and there're already j
    // Matches with `evil`, where k1 is the 0/1 tight constraint for s1 and k2
    // Is the 0/1 tight constraint for s2
    dp.resize(n,
              vector<vector<vector<int>>>(
                  evil.length(), vector<vector<int>>(2, vector<int>(2, -1))));
    // nextMatchedCount[i][j] := # next matched evil count given that there're
    // Already i matches with `evil` and the current char is ('a' + j)
    nextMatchedCount.resize(evil.length(), vector<int>(26, -1));
    return find(s1, s2, evil, 0, 0, true, true, getLPS(evil));
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<vector<vector<vector<int>>>> dp;
  vector<vector<int>> nextMatchedCount;

  int find(const string& s1, const string& s2, const string& evil, int i,
           int matchedEvilCount, bool isS1Prefix, bool isS2Prefix,
           const vector<int>& evilLPS) {
    // s[:i] contains `evil`, so don't consider any ongoing strings
    if (matchedEvilCount == evil.length())
      return 0;
    // Run out of string, contributes one
    if (i == s1.length())
      return 1;
    int& ans = dp[i][matchedEvilCount][isS1Prefix][isS2Prefix];
    if (ans != -1)
      return ans;
    ans = 0;
    const char minChar = isS1Prefix ? s1[i] : 'a';
    const char maxChar = isS2Prefix ? s2[i] : 'z';
    for (char c = minChar; c <= maxChar; ++c) {
      const int nextMatchedEvilCount =
          getNextMatchedEvilCount(evil, matchedEvilCount, c, evilLPS);
      ans += find(s1, s2, evil, i + 1, nextMatchedEvilCount,
                  isS1Prefix && c == s1[i], isS2Prefix && c == s2[i], evilLPS);
      ans %= kMod;
    }
    return ans;
  }

  // Get Longest Prefix also Suffix
  vector<int> getLPS(const string& s) {
    vector<int> lps(s.length());
    for (int i = 1, j = 0; i < s.length(); ++i) {
      while (j > 0 && s[j] != s[i])
        j = lps[j - 1];
      if (s[i] == s[j])
        lps[i] = ++j;
    }
    return lps;
  }

  // J := the next index we're trying to match with `currChar`
  int getNextMatchedEvilCount(const string& evil, int j, char currChar,
                              const vector<int>& evilLPS) {
    int& ans = nextMatchedCount[j][currChar - 'a'];
    if (ans != -1)
      return ans;
    while (j > 0 && evil[j] != currChar)
      j = evilLPS[j - 1];
    return ans = (evil[j] == currChar ? j + 1 : j);
  }
};"
"class Solution:
    def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:
        log = defaultdict(set)
        for x, y in logs:
            log[x].add(y)
        
        output = [0]*k
        for i in log.values():
            output[len(i)-1] += 1
        
        return output","class Solution {
 public:
  bool canConstruct(string s, int k) {
    // If the s.length() < k, we cannot construct k strings from s.
    if (s.length() < k)
      return false;

    bitset<26> odd;

    for (const char c : s)
      odd.flip(c - 'a');

    // If the # of characters that have odd counts is > k, the min # of
    // palindrome strings we can construct is > k.
    return odd.count() <= k;
  }
};"
"class Solution:
    def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:
        
        n = len(nums1)
        MOD = 10**9+7
        
        # Maintain a MAX heap defined as structure - (abs_diffi, nums1[i], nums[j])
        heap = []
        abs_sum = 0
        for i in range(n):
            abs_diff = abs(nums1[i]-nums2[i])
            abs_sum = (abs_sum+abs_diff)%MOD
            heapq.heappush(heap,(-abs_diff, nums1[i], nums2[i])) # note the -ve sign to make it max_heap
        
        print(heap)
        
        # Get the element with max absolute difference from heap
        top = heapq.heappop(heap)
        abs_sum -= abs(top[0]) # subtract previous abs_diff as we'll update it below
        k = top[2]
        
        # find a new_val closest to k
        # and min_diff is the new absoulte diff with k
        min_diff = abs(top[0])
        new_val = 0
        for num1 in nums1:
            new_diff = abs(num1-k)
            if new_diff<min_diff:
                min_diff = new_diff
                new_val = num1
        
        # add the new diff to calculate updated sum
        abs_sum = (abs_sum+min_diff)%MOD
        
        return abs_sum","class Solution {
 public:
  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1,
                    int x2, int y2) {
    auto clamp = [&](int center, int mini, int maxi) {
      return max(mini, min(maxi, center));
    };

    // The closest point to the circle within the rectangle
    int closestX = clamp(x_center, x1, x2);
    int closestY = clamp(y_center, y1, y2);

    // The distance between the circle's center and this closest point
    int distanceX = x_center - closestX;
    int distanceY = y_center - closestY;

    // If the distance is less than the circle's radius, an intersection occurs
    return (distanceX * distanceX) + (distanceY * distanceY) <=
           (radius * radius);
  }
};"
"class Solution:
    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        nums = set(nums)
        
        ans = 0
        m = max(nums)
        for x in range(1, m+1): 
            g = 0
            for xx in range(x, m+1, x): 
                if xx in nums: 
                    g = gcd(g, xx)
            if g == x: ans += 1
        return ans","class Solution {
 public:
  int maxSatisfaction(vector<int>& satisfaction) {
    int ans = 0;
    int sumSatisfaction = 0;

    sort(begin(satisfaction), end(satisfaction), greater<>());

    for (const int s : satisfaction) {
      sumSatisfaction += s;
      if (sumSatisfaction <= 0)
        return ans;
      ans += sumSatisfaction;
    }

    return ans;
  }
};"
"class Solution:
    def arraySign(self, nums: List[int]) -> int:
        if 0 in nums:
            return 0
        count = 1
        for i in nums:
            if i < 0:
                count *= -1
        return count","class Solution {
 public:
  int numSteps(string s) {
    int ans = 0;

    // All trailing 0s can be popped by 1 step.
    while (s.back() == '0') {
      s.pop_back();
      ++ans;
    }

    if (s == ""1"")
      return ans;

    // s is now odd, so add 1 to s and cost 1 step.
    ++ans;

    // All 1s will become 0s and be popped by 1 step.
    // All 0s will become 1s and be popped by 2 step (add 1 then divide by 2).
    for (const char c : s)
      ans += c == '1' ? 1 : 2;

    return ans;
  }
};"
"class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        class Node:
            def __init__(self,val):
                self.prev = None
                self.next = None
                self.val = val
        
        head = Node(1)
        temp = head
        i = 2
        while i<n:
            nnode = Node(i)
            temp.next = nnode
            nnode.prev = temp
            temp = temp.next
            i += 1
        lastnode = Node(n)
        temp.next = lastnode
        lastnode.prev = temp
        lastnode.next = head
        head.prev = lastnode
        
        
        ##game
        start,prevnode = head,head.prev
        while start:
            if start == start.next:                             #case to check if this node is the winner
                return start.val
            i = 1
            while i<k:                                             #move k number of steps 
                prevnode = start
                start = start.next
                i += 1
            
            #delete this node
            p = start.next
            prevnode.next = p
            p.prev = prevnode
            start = p","class Solution {
 public:
  string longestDiverseString(int a, int b, int c, char A = 'a', char B = 'b',
                              char C = 'c') {
    if (a < b)
      return longestDiverseString(b, a, c, B, A, C);
    if (b < c)
      return longestDiverseString(a, c, b, A, C, B);
    if (b == 0)
      return string(min(a, 2), A);

    const int useA = min(a, 2);
    const int useB = (a - useA >= b) ? 1 : 0;
    return string(useA, A) + string(useB, B) +
           longestDiverseString(a - useA, b - useB, c, A, B, C);
  }
};"
"class Solution:
    def minSideJumps(self, obstacles: List[int]) -> int:
        lanes = [1, 0, 1]
        for obstacle_id in obstacles:
            if obstacle_id == 0:
                lanes[0] = min(lanes[0], lanes[1] + 1, lanes[2] + 1)
                lanes[1] = min(lanes[1], lanes[0] + 1, lanes[2] + 1)
                lanes[2] = min(lanes[2], lanes[0] + 1, lanes[1] + 1)
            elif obstacle_id == 1:
                lanes[0] = inf
                lanes[1] = min(lanes[1], lanes[2] + 1)
                lanes[2] = min(lanes[1] + 1, lanes[2])
            elif obstacle_id == 2:
                lanes[1] = inf
                lanes[0] = min(lanes[0], lanes[2] + 1)
                lanes[2] = min(lanes[2], lanes[0] + 1)
            elif obstacle_id == 3:
                lanes[2] = inf
                lanes[0] = min(lanes[0], lanes[1] + 1)
                lanes[1] = min(lanes[1], lanes[0] + 1)
        return min(lanes)","class Solution {
 public:
  string stoneGameIII(vector<int>& stoneValue) {
    // dp[i] := max ""relative score"" Alice can make w/ stoneValue[i:]
    dp.resize(stoneValue.size(), INT_MIN);

    const int score = stoneGameIII(stoneValue, 0);
    return score > 0 ? ""Alice"" : score < 0 ? ""Bob"" : ""Tie"";
  }

 private:
  vector<int> dp;

  int stoneGameIII(const vector<int>& stoneValue, int i) {
    if (i == stoneValue.size())
      return 0;
    if (dp[i] > INT_MIN)
      return dp[i];

    int sum = 0;
    for (int j = i; j < i + 3 && j < stoneValue.size(); ++j) {
      sum += stoneValue[j];
      dp[i] = max(dp[i], sum - stoneGameIII(stoneValue, j + 1));
    }

    return dp[i];
  };
};"
"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        minimumOperations = 0
        
        for i in range(1, len(nums)): # Note that for loop starts with index 1 (we skip the index 0)
            if nums[i] <= nums[i-1]:
                oldNumber = nums[i]
                nums[i] = nums[i-1] + 1 # update the current number to new number in the input list
                newNumber = nums[i]
                
                minimumOperations += (newNumber - oldNumber)
                
        return minimumOperations","class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  vector<int> processQueries(vector<int>& queries, int m) {
    vector<int> ans;
    // Map [-m, m] to [0, 2 * m].
    FenwickTree tree(2 * m + 1);
    unordered_map<int, int> numToIndex;

    for (int num = 1; num <= m; ++num) {
      numToIndex[num] = num + m;
      tree.update(num + m, 1);
    }

    int nextEmptyIndex = m;  // Map 0 to m.

    for (const int query : queries) {
      const int index = numToIndex[query];
      ans.push_back(tree.get(index - 1));
      // Move `query` from `index` to `nextEmptyIndex`.
      tree.update(index, -1);
      tree.update(nextEmptyIndex, 1);
      numToIndex[query] = nextEmptyIndex--;
    }

    return ans;
  }
};"
"class Solution:
    def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:
        
        res = []
        for x,y,r in queries:
            rsq = pow(r,2)
            count = 0
            for px,py in points:
                ans = pow(px-x,2)+pow(py-y,2)
                if ans<= rsq:
                    count += 1
            res.append(count)
        return res","class Solution {
 public:
  string entityParser(string text) {
    const unordered_map<string, char> entityToChar{
        {""&quot;"", '""'}, {""&apos;"", '\''}, {""&amp;"", '&'},
        {""&gt;"", '>'},   {""&lt;"", '<'},    {""&frasl;"", '/'}};
    string ans;
    int j = 0;  // text[j..ampersandIndex - 1] is the pending substring.
    int ampersandIndex = -1;

    for (int i = 0; i < text.length(); ++i)
      if (text[i] == '&') {
        ampersandIndex = i;
      } else if (text[i] == ';' && ampersandIndex >= j) {
        const string sub = text.substr(ampersandIndex, i - ampersandIndex + 1);
        ans += text.substr(j, ampersandIndex - j);
        ans += getCharIfMatched(text, sub, entityToChar);
        j = i + 1;
      }

    return ans + text.substr(j);
  }

 private:
  string getCharIfMatched(const string& text, const string& sub,
                          const unordered_map<string, char>& entityToChar) {
    for (const auto& [entity, c] : entityToChar)
      if (entity == sub)
        return string(1, c);
    return sub;
  }
};"
"class Solution:
    '''
    Step 1: Building a xor array.
    eg :[0,1,1,3]
    xor = [0]
    now 0 xor 1 [0,1]
    now 1 xor 1 [0,1,0]
    finally 0 xor 3 [0,1,0,3]
    
    step 2:
    Now to find the value of k at each query we just want to take the len(2^maxbit-1 )so here its 2 digit(maxBit =2 so 2^2 = 4 ) .
    no.of bits in 3 are 2
    value of k will be inverse of xor value[i]
    eg :
    when i = 0 xor[i] = 0 what will be the value of k in this case when bits are 2
    00 xor inverse(00)
    inverse(00) = 11
    hence k = 3
    
    '''
    def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:
        xor = []
        maxb = len(bin(pow(2,maximumBit)-1)[2:])
        
        n = len(nums)
        xor.append(nums[0])
        for i in range(1,n):                                        #step 1
            xor.append(nums[i]^xor[i-1])
        
        res = []
        for xor_val in xor: 
            bin_xor_val = list(bin(xor_val)[2:])
            temp = []
            for i in range(maxb-len(bin_xor_val)):                  
                temp.append('1')
            
            for bit in bin_xor_val:                                 #performing inverse of the xor value
                if bit == '0':
                    temp.append('1')
                else:
                    temp.append('0')
            res.append(int(''.join(temp),2))
        
        res.reverse()
        return res","class Solution {
 public:
  int numOfWays(int n) {
    constexpr int kMod = 1'000'000'007;
    long color2 = 6;  // 121, 131, 212, 232, 313, 323
    long color3 = 6;  // 123, 132, 213, 231, 312, 321

    for (int i = 1; i < n; ++i) {
      const long nextColor2 = color2 * 3 + color3 * 2;
      const long nextColor3 = color2 * 2 + color3 * 2;
      color2 = nextColor2 % kMod;
      color3 = nextColor3 % kMod;
    }

    return (color2 + color3) % kMod;
  }
};"
"class Solution:
    def makeStringSorted(self, s: str) -> int:
        freq = [0]*26
        for c in s: freq[ord(c) - 97] += 1
        
        MOD = 1_000_000_007
        fac = cache(lambda x: x*fac(x-1)%MOD if x else 1)
        ifac = cache(lambda x: pow(fac(x), MOD-2, MOD)) # Fermat's little theorem (a**(p-1) = 1 (mod p))
        
        ans, n = 0, len(s)
        for c in s: 
            val = ord(c) - 97
            mult = fac(n-1)
            for k in range(26): mult *= ifac(freq[k])
            for k in range(val): ans += freq[k] * mult
            n -= 1
            freq[val] -= 1
        return ans % MOD","class Solution {
 public:
  int findMinFibonacciNumbers(int k) {
    if (k < 2)  // k == 0 || k == 1
      return k;

    int a = 1;  // F_1
    int b = 1;  // F_2

    while (b <= k) {
      //    a, b = F_{i + 1}, F_{i + 2}
      // -> a, b = F_{i + 2}, F_{i + 3}
      const int temp = a;
      a = b;
      b = a + temp;
    }

    return 1 + findMinFibonacciNumbers(k - a);
  }
};"
"class Solution:
    def checkIfPangram(self, sentence: str) -> bool:
        s=set(sentence)
        if len(s)==26:
            return True
        return False","class Solution {
 public:
  string getHappyString(int n, int k) {
    const unordered_map<char, string> nextLetters{
        {'a', ""bc""}, {'b', ""ac""}, {'c', ""ab""}};
    queue<string> q{{{""a"", ""b"", ""c""}}};

    while (q.front().length() != n) {
      const string u = q.front();
      q.pop();
      for (const char nextLetter : nextLetters.at(u.back()))
        q.push(u + nextLetter);
    }

    if (q.size() < k)
      return """";

    for (int i = 0; i < k - 1; ++i)
      q.pop();
    return q.front();
  }
};"
"class Solution:
    def maxIceCream(self, costs: List[int], coins: int) -> int:
        if min(costs) > coins:
            return 0
        if sum(costs) < coins:
            return len(costs)
        costs.sort()
        count = 0
        for i in costs:
            if coins < i:
                break
            count += 1
            coins -= i
        return count","class Solution {
 public:
  int numberOfArrays(string s, int k) {
    // dp[i] := # of arrays to restore s[i..n) w/ k
    dp.resize(s.length(), -1);
    return numberOfArrays(s, 0, k);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<int> dp;

  int numberOfArrays(const string& s, int i, int k) {
    if (i == s.length())
      return 1;  // Empty string """"""""
    if (s[i] == '0')
      return 0;  // Leading zero
    if (dp[i] >= 0)
      return dp[i];

    int ans = 0;
    long num = 0;

    for (int j = i; j < s.length(); ++j) {
      num = num * 10 + (s[j] - '0');
      if (num > k)
        break;
      ans = (ans + numberOfArrays(s, j + 1, k)) % kMod;
    }

    return dp[i] = ans;
  }
};"
"class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:
        for i in range(len(tasks)):
            tasks[i] = [tasks[i][0],tasks[i][1],i]   #add index into tasks array
        tasks.sort(key = lambda x: (x[0],x[1]))   #sort task according to arrival time and burst time
        cpu_timestamp = tasks[0][0] + tasks[0][1]  #save the current cpu time arrival + burst
        temp = []   #array for heapq operations
        res = [tasks[0][2]] #store the starting index result, this is final since we have sorted and got the optimal
        i = 1
        while i<len(tasks):
            if cpu_timestamp < tasks[i][0]: #cant use a time which is less than current cpu time
                if temp: #process already stored items in heap
                    burst,index,arri = heapq.heappop(temp)
                    res.append(index)
                    cpu_timestamp += burst
                else: #if heap is empty, we need to jump to the next value . This is for case like [100,100],[1000000000,100000000]
                    heapq.heappush(temp, [tasks[i][1],tasks[i][2],tasks[i][0]])
                    i+=1
            if i < len(tasks) and cpu_timestamp >=tasks[i][0]: #store all times that are greater than current cpu time
                heapq.heappush(temp, [tasks[i][1],tasks[i][2],tasks[i][0]])
                i+=1
        while temp: # if we reached the end of tasks array, but still have items in heap, pop one by one
            burst,index,arri = heapq.heappop(temp)
            res.append(index)
        return res","class Solution {
 public:
  vector<vector<string>> displayTable(vector<vector<string>>& orders) {
    vector<vector<string>> ans{{""Table""}};
    unordered_map<string, int> tableNumberToRowIndex;
    unordered_map<string, int> foodItemToColIndex;

    // Create the first row and column of ans.
    for (const vector<string>& order : orders) {
      const string& tableNumber = order[1];
      const string& foodItem = order[2];
      // Init indices with 0.
      tableNumberToRowIndex[tableNumber] = 0;
      foodItemToColIndex[foodItem] = 0;
    }
    for (const auto& [tableNumber, _] : tableNumberToRowIndex)
      ans.push_back({tableNumber});
    for (const auto& [foodItem, _] : foodItemToColIndex)
      ans[0].push_back(foodItem);

    // Sort the first row and column, except ans[0][0].
    sort(begin(ans[0]) + 1, end(ans[0]));
    sort(begin(ans) + 1, end(ans),
         [](const vector<string>& a, const vector<string>& b) {
      return stoi(a[0]) < stoi(b[0]);
    });

    // Set indices after sorting.
    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)
      tableNumberToRowIndex[ans[i + 1][0]] = i;
    for (int i = 0; i < foodItemToColIndex.size(); ++i)
      foodItemToColIndex[ans[0][i + 1]] = i;

    // Get all the counts of each food item in each table.
    vector<vector<int>> count;
    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)
      count.push_back(vector<int>(foodItemToColIndex.size()));
    for (const vector<string>& order : orders) {
      const string& tableNumber = order[1];
      const string& foodItem = order[2];
      const int rowIndex = tableNumberToRowIndex[tableNumber];
      const int colIndex = foodItemToColIndex[foodItem];
      ++count[rowIndex][colIndex];
    }

    // Set the counts to ans.
    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)
      for (int j = 0; j < foodItemToColIndex.size(); ++j)
        ans[i + 1].push_back(to_string(count[i][j]));

    return ans;
  }
};"
"class Solution:
    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:
        """"""
        (a^b) &amp; (d^e^f) = a&amp;d ^ a&amp;e ^ a&amp;f ^ b&amp;d ^ b&amp;e ^ b&amp;f
        """"""
        N1 = len(arr1)
        N2 = len(arr2)
        tmp1 = 0
        tmp2 = 0
        for i in range(max(N1, N2)):
            if i < N1:
                tmp1 = tmp1^arr1[i]
            if i < N2:
                tmp2 = tmp2^arr2[i]
        return tmp1 &amp; tmp2","class Solution {
 public:
  int minNumberOfFrogs(string croakOfFrogs) {
    const string kCroak = ""croak"";
    int ans = 0;
    int frogs = 0;
    vector<int> count(5);

    for (const char c : croakOfFrogs) {
      ++count[kCroak.find(c)];
      for (int i = 1; i < 5; ++i)
        if (count[i] > count[i - 1])
          return -1;
      if (c == 'c')
        ++frogs;
      else if (c == 'k')
        --frogs;
      ans = max(ans, frogs);
    }

    return frogs == 0 ? ans : -1;
  }
};"
"class Solution:
    def sumBase(self, num: int, base: int) -> int:
            tot = 0
            base_num = """"
            while num>0:
                dig = int(num%base)
                if dig<10:
                    base_num += str(dig)
                else:
                    base_num += chr(ord('A')+dig-10)  
                num //= base

            base_num = base_num[::-1]  
            tot = 0
            for i in base_num:
                tot += int(i)
            return tot","class Solution {
 public:
  int numOfArrays(int n, int m, int k) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j][k] := # of ways to build an array of length i, where j is the
    // Max used num and k is the search_cost
    vector<vector<vector<int>>> dp(
        n + 1, vector<vector<int>>(m + 1, vector<int>(k + 1)));

    for (int j = 1; j <= m; ++j)
      dp[1][j][1] = 1;

    for (int i = 2; i <= n; ++i)                 // For each length
      for (int j = 1; j <= m; ++j)               // For each max value
        for (int cost = 1; cost <= k; ++cost) {  // For each cost
          // 1. appending any of [1, j] in i-th position
          //    doesn't change the max and cost
          dp[i][j][cost] = static_cast<long>(j) * dp[i - 1][j][cost] % kMod;
          // 2. appending j in i-th position
          //    make j the new max and cost 1
          for (int prevMax = 1; prevMax < j; ++prevMax) {
            dp[i][j][cost] += dp[i - 1][prevMax][cost - 1];
            dp[i][j][cost] %= kMod;
          }
        }

    int ans = 0;
    for (int j = 1; j <= m; ++j) {
      ans += dp[n][j][k];
      ans %= kMod;
    }
    return ans;
  }
};"
"class Solution:        
    def maxFrequency(self, nums: List[int], k: int) -> int:
        def freqExists(freq):
            for i in range(freq, n):
                if freq * nums[i-1] - (prefix_sum[i] - prefix_sum[i-freq]) <= k:
                    return True
            return False
        
        nums.sort()
        prefix_sum = [0] + list(accumulate(nums))             
		n = len(prefix_sum)
        l, r = 1, len(nums)+1
        ret = 1

        while l < r:
            mid = (l+r)//2
            if freqExists(mid):
                ret = mid
                l = mid + 1
            else:
                r = mid
                
        return ret","class Solution {
 public:
  int maxScore(vector<int>& cardPoints, int k) {
    const int n = cardPoints.size();
    const int sum = accumulate(begin(cardPoints), end(cardPoints), 0);
    int windowSum = accumulate(begin(cardPoints), begin(cardPoints) + n - k, 0);
    int ans = sum - windowSum;

    for (int i = 0; i < k; ++i) {
      windowSum -= cardPoints[i];
      windowSum += cardPoints[i + n - k];
      ans = max(ans, sum - windowSum);
    }

    return ans;
  }
};"
"class Solution:
    def longestBeautifulSubstring(self, word: str) -> int:
        if word == 'aeiou':
            return 5
        def check(s):
            res = ''
            ind = []
            for i,c in enumerate(s):
                if res =='':
                    res+=c
                    ind.append(i)
                elif c == 'a' and res[-1] != c:
                    res+=c
                    ind.append(i)
                elif c == 'u' and res[-1] == c:
                    ind[-1] = i
                elif res[-1] != c:
                    res+=c
                    ind.append(i)
            return ind
        ind = check(word)
        #print(ind)
        mx = 0
        for i in range(len(ind)):
            for j in range(i,i+5):
                if j+4 <len(ind):
                    if (word[ind[j]],word[ind[j+1]],word[ind[j+2]],word[ind[j+3]],word[ind[j+4]]) == ('a','e','i','o','u'):
                        mx = max(mx, ind[j+4]-ind[j]+1)
                        #print(ind[j+4], ind[j])
        return mx","class Solution {
 public:
  vector<int> findDiagonalOrder(vector<vector<int>>& nums) {
    vector<int> ans;
    unordered_map<int, vector<int>> keyToNums;  // Key = row + col
    int maxKey = 0;

    for (int i = 0; i < nums.size(); ++i)
      for (int j = 0; j < nums[i].size(); ++j) {
        const int key = i + j;
        keyToNums[key].push_back(nums[i][j]);
        maxKey = max(maxKey, key);
      }

    for (int i = 0; i <= maxKey; ++i)
      for (auto it = rbegin(keyToNums[i]); it != rend(keyToNums[i]); ++it)
        ans.push_back(*it);

    return ans;
  }
};"
"class Solution:
    def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:
        if not restrictions:
            return n - 1
        restrictions.append([1, 0])  # Add the restriction for the initial position
        restrictions.sort(key=lambda x: x[1] + x[0])  # Sort by increasing i + h
        idx = 0  # The index in the restrictions array
        max_height = 0
        while idx < len(restrictions):
            pos, h = restrictions[idx]
            idx += 1
            while idx < len(restrictions) and restrictions[idx][1] - restrictions[idx][0] >= h - pos:
				# skip the next restriction if it is ""above"" the line starting from the current one
                idx += 1
            if idx == len(restrictions):
				# Handles the last restriction: fill the line until the last position at n
                max_height = max(max_height, h + n - pos)
                break
            next_pos, next_h = restrictions[idx]
			# A bit of maths gives us the formula for the maximum height between two consecutive
			# restrictions
            max_height = max(max_height, (h + next_h + next_pos - pos) // 2)
        return max_height","class Solution {
 public:
  int constrainedSubsetSum(vector<int>& nums, int k) {
    // dp[i] := max sum of non-empty subsequence in nums[0..i]
    vector<int> dp(nums.size());
    // Q stores dp[i - k], dp[i - k + 1], ..., dp[i - 1] whose values are > 0 in
    // Decreasing order
    deque<int> q;

    for (int i = 0; i < nums.size(); ++i) {
      if (q.empty())
        dp[i] = nums[i];
      else
        dp[i] = max(q.front(), 0) + nums[i];
      while (!q.empty() && q.back() < dp[i])
        q.pop_back();
      q.push_back(dp[i]);
      if (i >= k && dp[i - k] == q.front())
        q.pop_front();
    }

    return *max_element(begin(dp), end(dp));
  }
};"
"class Solution:
    def replaceDigits(self, s: str) -> str:
        o=''
        for i in range(0,len(s),2):
            if i!= len(s)-1:
                o+=s[i]+chr((ord(s[i])+int(s[i+1])))
            else:
                o+=s[i]
        return o","/**
 * // This is the BinaryMatrix's API interface.
 * // You should not implement it, or speculate about its implementation
 * class BinaryMatrix {
 *  public:
 *   int get(int row, int col);
 *   vector<int> dimensions();
 * };
 */

class Solution {
 public:
  int leftMostColumnWithOne(BinaryMatrix& binaryMatrix) {
    const vector<int> dimensions = binaryMatrix.dimensions();
    const int m = dimensions[0];
    const int n = dimensions[1];
    int ans = -1;
    int l = 0;
    int r = n - 1;

    while (l <= r) {
      const int mid = (l + r) / 2;
      if (existOne(binaryMatrix, m, mid)) {
        ans = mid;
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }

    return ans;
  }

 private:
  bool existOne(BinaryMatrix& binaryMatrix, int m, int col) {
    for (int i = 0; i < m; ++i)
      if (binaryMatrix.get(i, col) == 1)
        return true;
    return false;
  }
};"
"class Solution:
    def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:
        arr.sort() # sort the elements
        if arr[0] == 1: # if arr[0] is 1 then simply give pass as it satisfies the 1st condition
            pass
        else: # else make arr[0] to 1 to satisfy condition 1
            arr[0] = 1
        for i in range(len(arr)-1): #run the loop upto length of the array -1 times
            arr[i+1] = min(arr[i+1],arr[i]+1)# assign arr[i+1] to minimum value of arr[i+1], arr[i]+1
        return arr[-1]#return max(arr)","class Solution {
 public:
  int maxDiff(int num) {
    const string s = to_string(num);
    int firstNot9 = s.find_first_not_of('9');
    int firstNot01 = s.find_first_not_of(""01"");
    if (firstNot9 == string::npos)
      firstNot9 = 0;
    if (firstNot01 == string::npos)
      firstNot01 = 0;

    string a = s;
    string b = s;
    replace(begin(a), end(a), s[firstNot9], '9');
    replace(begin(b), end(b), s[firstNot01], firstNot01 == 0 ? '1' : '0');
    return stoi(a) - stoi(b);
  }
};"
"class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        ans = [0] * len(queries)
        
        # sort queries to handle largest size queries first
        q = deque(sorted([(size, room, i) for i, (room, size) in enumerate(queries)], key=lambda a: (-a[0], a[1], a[2])))

        # sort rooms by descending size
        rooms = deque(sorted(rooms, key=lambda x: -x[1]))

        # current available room ids
        cands = []
        
        
        while q:
            size, room, i = q.popleft()
            # add room ids to candidates as long as top of room size meet the requirements
            while rooms and rooms[0][1] >= size:
                bisect.insort(cands, rooms.popleft()[0])
                    
            # if no room size available, return -1
            if not cands: ans[i] = -1
                
            # else use bisect to find optimal room ids
            else:
                loc = bisect.bisect_left(cands, room)
                if loc == 0: ans[i] = cands[loc]
                elif loc == len(cands): ans[i] = cands[-1]
                else: ans[i] = cands[loc - 1] if room - cands[loc - 1] <= cands[loc] - room else cands[loc]
        
        return ans","class Solution {
 public:
  bool checkIfCanBreak(string s1, string s2) {
    vector<int> count1(26);
    vector<int> count2(26);

    for (const char c : s1)
      ++count1[c - 'a'];

    for (const char c : s2)
      ++count2[c - 'a'];

    return canBreak(count1, count2) || canBreak(count2, count1);
  }

 private:
  // Returns True if count1 can break count2.
  bool canBreak(const vector<int>& count1, const vector<int>& count2) {
    int diff = 0;
    for (int i = 0; i < 26; ++i) {
      diff += count2[i] - count1[i];
      // count2 is alphabetically greater than count1.
      if (diff < 0)
        return false;
    }
    return true;
  }
};"
"class Solution:
    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        mini = 10**9
        for i,num in enumerate(nums):
            if num == target:
                mini = min(mini,abs(i-start))
        return mini","class Solution {
 public:
  int numberWays(vector<vector<int>>& hats) {
    constexpr int nHats = 40;
    const int nPeople = hats.size();
    hatToPeople.resize(nHats + 1);
    // dp[i][j] := # of ways to assign hats 1, 2, ..., i to people in mask j
    dp.resize(nHats + 1, vector<int>(1 << nPeople, -1));

    for (int i = 0; i < nPeople; ++i)
      for (const int hat : hats[i])
        hatToPeople[hat].push_back(i);

    return ways(hats, 0, 1);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<vector<int>> hatToPeople;
  vector<vector<int>> dp;

  int ways(const vector<vector<int>>& hats, int assignment, int h) {
    // All people are assigned
    if (assignment == (1 << hats.size()) - 1)
      return 1;
    if (h > 40)
      return 0;
    if (dp[h][assignment] != -1)
      return dp[h][assignment];

    // don't wear hat h
    int ans = ways(hats, assignment, h + 1);

    for (const int p : hatToPeople[h]) {
      // Person p was assigned hat h before
      if (assignment & 1 << p)
        continue;

      // Assigned hat h to person p
      ans += ways(hats, assignment | 1 << p, h + 1);
      ans %= kMod;
    }

    return dp[h][assignment] = ans;
  }
};"
"class Solution:
    def splitString(self, s: str) -> bool:
        
        def fn(i, x): 
            """"""Return True if s[i:] can be split following x.""""""
            if i == len(s): return True 
            if x == 0: return False 
            ans = False 
            for ii in range(i, len(s) - int(i == 0)):
                if x is None or int(s[i:ii+1]) == x - 1: 
                    ans = ans or fn(ii+1, int(s[i:ii+1]))
            return ans 
        
        return fn(0, None)","class Solution {
 public:
  int longestSubarray(vector<int>& nums, int limit) {
    int ans = 1;
    deque<int> minQ;
    deque<int> maxQ;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      while (!minQ.empty() && minQ.back() > nums[r])
        minQ.pop_back();
      minQ.push_back(nums[r]);
      while (!maxQ.empty() && maxQ.back() < nums[r])
        maxQ.pop_back();
      maxQ.push_back(nums[r]);
      while (maxQ.front() - minQ.front() > limit) {
        if (minQ.front() == nums[l])
          minQ.pop_front();
        if (maxQ.front() == nums[l])
          maxQ.pop_front();
        ++l;
      }
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};"
"class Solution:
    def getMinSwaps(self, num: str, k: int) -> int:
        nums = [int(i) for i in num]
        orig = [int(i) for i in num]
        right = len(nums) - 1

        ans = 0
        for _ in range(k):
            for x in range(right, 0, -1):
                if nums[x] > nums[x-1]:
                    iter = x
                    mini = (float('inf'), -1)
                    while iter <= right:
                        # Number should be greater than nums[x-1]
                        # Number should be closer to nums[x-1] than the temp value at mini[0]
                        if nums[iter] > nums[x-1] and (mini[0] - nums[x-1]) > (nums[iter] - nums[x-1]):
                            mini = (nums[iter], iter)
                        iter += 1

                    # Swap the item found at index that is immediately greater than number at x-1
                    nums[x-1], nums[mini[1]] = nums[mini[1]], nums[x-1]
                    ans += (mini[1] - (x-1))

                    # Sort the numbers to the right of swapped number
                    nums[x:] = sorted(nums[x:])
                    # print ("""".join([str(i) for i in nums]))
                    break

        # print (nums, orig)

        i = 0
        count = 0
        
        # minimum number of adjacent swaps to get to nums from orig. 
        # check where the number differs in the array and count the number of swaps to get the right number in the slot. 
        while i < len(nums):
            if nums[i] == orig[i]:
                i+=1
            else:
                j = i
                while nums[i] != orig[j]:
                    j+=1

                while j > i:
                    ## swap the number so that the calculations are correct as you traverse!
                    orig[j-1], orig[j] = orig[j], orig[j-1]
                    j -= 1
                    count += 1

        return count","struct T {
  int i;
  int j;
  int sum;  // nums1[i] + nums2[j]
  T(int i, int j, int sum) : i(i), j(j), sum(sum) {}
};

class Solution {
 public:
  int kthSmallest(vector<vector<int>>& mat, int k) {
    vector<int> row = mat[0];

    for (int i = 1; i < mat.size(); ++i)
      row = kSmallestPairSums(row, mat[i], k);

    return row.back();
  }

 private:
  // Similar to 373. Find K Pairs with Smallest Sums
  vector<int> kSmallestPairSums(vector<int>& nums1, vector<int>& nums2, int k) {
    vector<int> ans;
    auto compare = [&](const T& a, const T& b) { return a.sum > b.sum; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < k && i < nums1.size(); ++i)
      minHeap.emplace(i, 0, nums1[i] + nums2[0]);

    while (!minHeap.empty() && ans.size() < k) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      ans.push_back(nums1[i] + nums2[j]);
      if (j + 1 < nums2.size())
        minHeap.emplace(i, j + 1, nums1[i] + nums2[j + 1]);
    }

    return ans;
  }
};"
"class Solution:
    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
        
        # sort queries from small to large
        q = deque(sorted([(x, i) for i, x in enumerate(queries)]))
        
        # answer to queries, initial state set to -1
        ans = [-1] * len(queries)

        # sort intervals by low, high and size
        ivals = deque(sorted([(a, b, b - a + 1) for a, b in intervals]))
        
        # available intervals
        cands = []

        
        while q:
            x, i = q.popleft()
            
            # if lower bound of intervals on the top of stack <= current query
            while ivals and x >= ivals[0][0]:
                a, b, c = ivals.popleft()
                # if higher bound of intervals also meets the requirements
                # if not then discard the interval
                if x <= b:
                    heappush(cands, (c, b, a))
            
            # udpate available intervals by removing old ones which no longer has a eligible higher bound
            while cands:
                c, b, a = heappop(cands)
                if x <= b:
                    ans[i] = c
                    heappush(cands, (c, b, a))
                    break

        return ans","class Solution {
 public:
  int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {
    vector<vector<int>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    return dfs(graph, 0, vector<bool>(n), hasApple);
  }

 private:
  int dfs(const vector<vector<int>>& graph, int u, vector<bool>&& seen,
          const vector<bool>& hasApple) {
    seen[u] = true;
    int totalCost = 0;

    for (const int v : graph[u]) {
      if (seen[v])
        continue;
      const int cost = dfs(graph, v, move(seen), hasApple);
      if (cost > 0 || hasApple[v])
        totalCost += cost + 2;
    }

    return totalCost;
  }
};"
"class Solution:
    def maximumPopulation(self, logs: List[List[int]]) -> int:
        
        
        u=[0]*(3000)
        
        
        for j in logs:
            u[j[0]]+=1
            
            u[j[1]]-=1
            
        p=[u[0]]
        
        for j in range(1,len(u)):
            p.append(p[-1]+u[j])
            
        return p.index(max(p))","class Solution {
 public:
  int ways(vector<string>& pizza, int k) {
    const int M = pizza.size();
    const int N = pizza[0].size();
    // dp[m][n][k] := # of ways to cut pizza[m:M][n:N] w/ k cuts
    dp.resize(M, vector<vector<int>>(N, vector<int>(k, -1)));
    prefix.resize(M + 1, vector<int>(N + 1));

    for (int i = 0; i < M; ++i)
      for (int j = 0; j < N; ++j)
        prefix[i + 1][j + 1] = (pizza[i][j] == 'A') + prefix[i][j + 1] +
                               prefix[i + 1][j] - prefix[i][j];

    return ways(0, 0, k - 1, M, N);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<vector<vector<int>>> dp;
  vector<vector<int>> prefix;

  // HasApple of pizza[row1..row2)[col1..col2)
  bool hasApple(int row1, int row2, int col1, int col2) {
    return (prefix[row2][col2] - prefix[row1][col2] - prefix[row2][col1] +
            prefix[row1][col1]) > 0;
  };

  int ways(int m, int n, int k, const int M, const int N) {
    if (k == 0)
      return 1;
    if (dp[m][n][k] >= 0)
      return dp[m][n][k];

    dp[m][n][k] = 0;

    for (int i = m + 1; i < M; ++i)  // Cut horizontally
      if (hasApple(m, i, n, N) && hasApple(i, M, n, N))
        dp[m][n][k] = (dp[m][n][k] + ways(i, n, k - 1, M, N)) % kMod;

    for (int j = n + 1; j < N; ++j)  // Cut vertically
      if (hasApple(m, M, n, j) && hasApple(m, M, j, N))
        dp[m][n][k] = (dp[m][n][k] + ways(m, j, k - 1, M, N)) % kMod;

    return dp[m][n][k];
  }
};"
"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        ###################################################################
        # Assumption/Requirement
        ###################################################################
        # nums1 and nums2 are both decreasing 
        # return max distance (j-1) where j >= i and nums2[j] >= nums1[i]
        ###################################################################
        
        ###################################################################
        # Explanation 
        ###################################################################
        # 1. if i is fixed, we want to find out the largest j 
        # --> keep increase j if the condition ""nums2[j] >= nums1[i]"" is valid 
        # 2. if (i, j) is valid, but (i, j+1) is not valid, 
        # --> start with (i+1, j+1) instead of (i+1, i+1)
        # --> since (i, j) is valid, it indicates (i+1, j) must be also valid (nums1[i] >= nums1[i+1])
        # --> we will start with (i+1, j+1) to test whether it is valid ornot 
        ###################################################################
        
        res = 0 
        i, j = 0, 0 
        while i < len(nums1) and j < len(nums2):
            if nums2[j] >= nums1[i]:
                res = max(res, j-i)
                j += 1 
            else: 
                i += 1
            
        return res","class Solution {
 public:
  vector<string> simplifiedFractions(int n) {
    vector<string> ans;
    for (int denominator = 2; denominator <= n; ++denominator)
      for (int numerator = 1; numerator < denominator; ++numerator)
        if (__gcd(denominator, numerator) == 1)
          ans.push_back(to_string(numerator) + ""/"" + to_string(denominator));
    return ans;
  }
};"
"class Solution:
    def maxSumMinProduct(self, nums: List[int]) -> int:
        n = len(nums)
        s = list(accumulate(nums)) # sum
        t = sorted([(v, i) for i, v in enumerate(nums)], reverse=True) # to greedily iterate over values
        j = [i for i in range(n)] # jump array, at first one can only jump in it's own position
        seen = [False] * n # to keep check if already seen a position(i.e. index) or not
        mx = 0 # keep the maximum
        for v, p in t:
            if seen[p]: # if already seen position `p`, then just skip
                continue
            l, r = p, p # we start from position p
            while l >= 0 and nums[l] >= v: # jump left as long as we found values >= v
                seen[l] = True # marked the position as seen
                l = j[l] - 1;
            l += 1
            while r < n and nums[r] >= v: # jump right as long as we find values >= v
                seen[r] = True # marked the position as seen
                r = j[r] + 1
            r -= 1
            ls = 0 if l == 0 else s[l-1]
            rs = s[r]
            mx = max(mx, v * (rs - ls)) # now update the maximum min-product
            j[l], j[r] = r, l # update the jump pointers for position  l and r
        return mx % (10**9+7)","class Solution {
 public:
  int goodNodes(TreeNode* root, int maxi = INT_MIN) {
    if (root == nullptr)
      return 0;

    const int newMax = max(maxi, root->val);
    return (root->val >= maxi) +            //
           goodNodes(root->left, newMax) +  //
           goodNodes(root->right, newMax);
  }
};"
"class Solution:
    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:
        d = defaultdict(list)
        for v1, v2 in edges:
            d[v1].append(v2)
        visited = {}
        counts = [[0] * 26 for _ in range(len(colors))]
        stack = []
        global_max = 0
        for root in d.keys():
            if root in visited:
                continue
            stack.append(root)
            while stack:
                v1 = stack[-1]
                if v1 in visited:
                    if visited[v1] == 1:
                        visited[v1] = 2
                        stack.pop()
                        if v1 in d:
                            for v2 in d[v1]:
                                for c in range(26):
                                    counts[v1][c] = max(counts[v1][c], counts[v2][c])
                        counts[v1][ord(colors[v1])-ord('a')] += 1
                else:
                    visited[v1] = 1
                    if v1 in d:
                        for v2 in d[v1]:
                            if v2 in visited:
                                if visited[v2] == 1:
                                    return -1
                            else:
                                stack.append(v2)
            global_max = max(global_max, max(counts[root]))
        if global_max == 0 and len(d) < len(colors): # in case input is like (""abcde"", [])
            global_max = 1
        return global_max","class Solution {
 public:
  string largestNumber(vector<int>& cost, int target) {
    // dp[i] := max length that cost i can achieve
    vector<int> dp(target + 1, INT_MIN);
    dp[0] = 0;  // When cost = 0, the best is empty string """"

    for (int i = 1; i <= target; ++i)
      for (int d = 0; d < 9; ++d)
        if (i >= cost[d])
          dp[i] = max(dp[i], dp[i - cost[d]] + 1);

    if (dp[target] < 0)
      return ""0"";

    string ans;

    // Greedily build the ans string
    for (int d = 8; d >= 0; --d)
      while (target >= cost[d] && dp[target] == dp[target - cost[d]] + 1) {
        target -= cost[d];
        ans += '1' + d;
      }

    return ans;
  }
};"
"class Solution:
    def sortSentence(self, s: str) -> str:
        
        words = s.split(' ')
		
		# sort based on last char ex. is2 this1 nice3
        words.sort(key=lambda x: x[-1])
                
        return ' '.join(i[:-1] for i in words)","class Solution {
 public:
  int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {
    const int n = startTime.size();
    int ans = 0;

    for (int i = 0; i < n; ++i)
      if (startTime[i] <= queryTime && queryTime <= endTime[i])
        ++ans;

    return ans;
  }
};"
"class Solution(object):
    def memLeak(self, m1, m2):
        i=1
        while(1):
            if(m1>=m2):
                if(m1>=i):
                    m1-=i
                else:
                    break
            else:
                if(m2>=i):
                    m2-=i
                else:
                    break
            i+=1
        return [i,m1,m2]","struct Point {
  double x;
  double y;
  Point(double x, double y) : x(x), y(y) {}
};

class Solution {
 public:
  int numPoints(vector<vector<int>>& darts, int r) {
    int ans = 1;
    vector<Point> points = convertToPoints(darts);

    for (int i = 0; i < points.size(); ++i)
      for (int j = i + 1; j < points.size(); ++j)
        for (const Point& c : getCircles(points[i], points[j], r)) {
          int count = 0;
          for (const Point& point : points)
            if (dist(c, point) - r <= kErr)
              ++count;
          ans = max(ans, count);
        }

    return ans;
  }

 private:
  static constexpr double kErr = 1e-6;

  vector<Point> convertToPoints(const vector<vector<int>>& darts) {
    vector<Point> points;
    for (const vector<int>& dart : darts)
      points.emplace_back(dart[0], dart[1]);
    return points;
  }

  vector<Point> getCircles(const Point& p, const Point& q, int r) {
    if (dist(p, q) - 2.0 * r > kErr)
      return {};
    const Point m{(p.x + q.x) / 2, (p.y + q.y) / 2};
    const double distCM = sqrt(pow(r, 2) - pow(dist(p, q) / 2, 2));
    const double alpha = atan2(p.y - q.y, q.x - p.x);
    return {Point{m.x - distCM * sin(alpha), m.y - distCM * cos(alpha)},
            Point{m.x + distCM * sin(alpha), m.y + distCM * cos(alpha)}};
  }

  double dist(const Point& p, const Point& q) {
    return sqrt(pow(p.x - q.x, 2) + pow(p.y - q.y, 2));
  }
};"
"class Solution:
    def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:
        rows=[]
        for i in box:
            row = """".join(i).split(""*"")
            for j in range(len(row)):
                row[j]="""".join(sorted(row[j], reverse=True))
            row=""*"".join(row)
            rows.append(row)
        return zip(*rows[::-1])","class Solution {
 public:
  int pseudoPalindromicPaths(TreeNode* root) {
    int ans = 0;
    dfs(root, 0, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int path, int& ans) {
    if (root == nullptr)
      return;
    if (root->left == nullptr && root->right == nullptr) {
      path ^= 1 << root->val;
      if ((path & (path - 1)) == 0)
        ++ans;
      return;
    }

    dfs(root->left, path ^ 1 << root->val, ans);
    dfs(root->right, path ^ 1 << root->val, ans);
  }
};"
"class Solution:
    def sumOfFlooredPairs(self, nums: List[int]) -> int:
        ans, hi, n, c = 0, max(nums)+1, len(nums), Counter(nums)
        pre = [0] * hi
        for i in range(1, hi):
            pre[i] = pre[i-1] + c[i]
        for num in set(nums):
            for i in range(num, hi, num):
                ans += c[num] * (pre[-1] - pre[i-1])
        return ans % (10**9 + 7)","class Solution {
 public:
  int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {
    const int m = nums1.size();
    const int n = nums2.size();
    // dp[i][j] := max dot product of two subseqs nums[0..i) and nums2[0..j)
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MIN));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        dp[i + 1][j + 1] = max({dp[i][j + 1], dp[i + 1][j],
                                max(0, dp[i][j]) + nums1[i] * nums2[j]});

    return dp[m][n];
  }
};"
"class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        n = len(nums)
        def helper(i):
            if i == n:
                return [0]
            
            xors = helper(i + 1)
            return xors + [nums[i] ^ xor for xor in xors]     
        
        return sum(helper(0))","class Solution {
 public:
  bool hasAllCodes(string s, int k) {
    const int n = 1 << k;
    if (s.length() < n)
      return false;

    // used[i] := true if i is a substring of s.
    vector<bool> used(n);

    int window = k == 1 ? 0 : stoi(s.substr(0, k - 1), nullptr, 2);
    for (int i = k - 1; i < s.length(); ++i) {
      // Include s[i].
      window = (window << 1) + (s[i] - '0');
      // Discard s[i - k].
      window &= n - 1;
      used[window] = true;
    }

    return all_of(begin(used), end(used), [](bool u) { return u; });
  }
};"
"class Solution:
    def minSwaps(self, s: str) -> int:
        if abs(s.count('1') - s.count('0')) > 1:
            return -1
        
        ln = len(s)
        x, y = ""10""*(ln//2), ""01""*(ln//2)
        cnt = 0
        
        if s.count('1') > s.count('0'):
            x = x + ""1""
            for i in range(ln):
                if s[i]!=x[i]: cnt+=1
            
        elif s.count('1') < s.count('0'):
            y = y + ""0""
            for i in range(ln):
                if s[i]!=y[i]: cnt+=1
        else:
            cntx = cnty = 0
            for i in range(ln):
                if s[i]!=x[i]: cntx+=1
            for i in range(ln):
                if s[i]!=y[i]: cnty+=1
            cnt = min(cntx, cnty)
        
        return cnt//2","class Solution {
 public:
  vector<bool> checkIfPrerequisite(int numCourses,
                                   vector<vector<int>>& prerequisites,
                                   vector<vector<int>>& queries) {
    vector<bool> ans;
    vector<vector<int>> graph(numCourses);
    // isPrerequisite[i][j] := true if course i is a prerequisite of course j.
    vector<vector<bool>> isPrerequisite(numCourses, vector<bool>(numCourses));

    for (const vector<int>& prerequisite : prerequisites) {
      const int u = prerequisite[0];
      const int v = prerequisite[1];
      graph[u].push_back(v);
    }

    // DFS from every course.
    for (int i = 0; i < numCourses; ++i)
      dfs(graph, i, isPrerequisite[i]);

    for (const vector<int>& query : queries) {
      const int u = query[0];
      const int v = query[1];
      ans.push_back(isPrerequisite[u][v]);
    }

    return ans;
  }

  void dfs(const vector<vector<int>>& graph, int u, vector<bool>& used) {
    for (const int v : graph[u]) {
      if (used[v])
        continue;
      used[v] = true;
      dfs(graph, v, used);
    }
  }
};"
"class Solution:
    def rearrangeSticks(self, n: int, k: int) -> int:
        
        @cache 
        def fn(n, k): 
            """"""Return number of ways to rearrange n sticks to that k are visible.""""""
            if n == k: return 1
            if k == 0: return 0
            return ((n-1)*fn(n-1, k) + fn(n-1, k-1)) % 1_000_000_007
        
        return fn(n, k)","class Solution {
 public:
  int cherryPickup(vector<vector<int>>& grid) {
    this->m = grid.size();
    this->n = grid[0].size();
    // dp[x][y1][y2] := max cherries we can collect w/
    // Robot #1 on (x, y1) and Robot #2 on (x, y2) first
    dp.resize(m, vector<vector<int>>(n, vector<int>(n, -1)));
    return cherryPick(grid, 0, 0, n - 1);
  }

 private:
  int m;
  int n;
  vector<vector<vector<int>>> dp;

  int cherryPick(const vector<vector<int>>& grid, int x, int y1, int y2) {
    if (x == m)
      return 0;
    if (y1 < 0 || y1 == n || y2 < 0 || y2 == n)
      return 0;
    if (dp[x][y1][y2] != -1)
      return dp[x][y1][y2];

    const int currRow = grid[x][y1] + (y1 != y2) * grid[x][y2];

    for (int d1 = -1; d1 <= 1; ++d1)
      for (int d2 = -1; d2 <= 1; ++d2)
        dp[x][y1][y2] = max(
            dp[x][y1][y2], currRow + cherryPick(grid, x + 1, y1 + d1, y2 + d2));

    return dp[x][y1][y2];
  }
};"
"class Solution:
    def checkZeroOnes(self, s: str) -> bool:
        
        numOnes = s.count('1')
        numZeros = s.count('0')
        
        while True:
            if '1'*numOnes in s:
                break
            else:
                numOnes -= 1
        
        while True:
            if '0'*numZeros in s:
                break
            else:
                numZeros -= 1
        return numOnes > numZeros","class Solution {
 public:
  int minReorder(int n, vector<vector<int>>& connections) {
    vector<vector<int>> graph(n);

    for (const vector<int>& conn : connections) {
      graph[conn[0]].push_back(conn[1]);
      graph[conn[1]].push_back(-conn[0]);  // - := conn[0] -> conn[1]
    }

    return dfs(graph, 0, -1);
  }

 private:
  int dfs(const vector<vector<int>>& graph, int u, int parent) {
    int change = 0;

    for (const int v : graph[u]) {
      if (abs(v) == parent)
        continue;
      if (v > 0)
        ++change;
      change += dfs(graph, abs(v), u);
    }

    return change;
  }
};"
"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        len_dist = len(dist)
        if sum(dist) <= hour:
            return 1
        elif len_dist - 1 > hour:
            return -1
        elif len_dist - 1 == int(hour):
            if int(hour) == hour:
                return -1
            return max(max(dist), ceil(round(dist[-1] / (hour - int(hour)), 2)))
        left, right = 1, max(dist)
        while left + 1 < right:
            middle = (left + right) // 2
            travel_time = (sum(ceil(d / middle) for d in dist[:-1])
                           + dist[-1] / middle)
            if travel_time > hour:
                left = middle
            else:
                right = middle
        return right","enum class BoxCase { kEqualBalls, kEqualDistantBalls };

class Solution {
 public:
  double getProbability(vector<int>& balls) {
    const int n = accumulate(begin(balls), end(balls), 0) / 2;
    return cases(balls, 0, 0, 0, 0, 0, n, BoxCase::kEqualDistantBalls) /
           cases(balls, 0, 0, 0, 0, 0, n, BoxCase::kEqualBalls);
  }

 private:
  const vector<int> fact{1, 1, 2, 6, 24, 120, 720};

  // Assume we have two boxes A and B
  double cases(const vector<int>& balls, int i, int ballsCountA,
               int ballsCountB, int colorsCountA, int colorsCountB, int n,
               BoxCase boxCase) {
    if (ballsCountA > n || ballsCountB > n)
      return 0;
    if (i == balls.size())
      return boxCase == BoxCase::kEqualBalls ? 1 : colorsCountA == colorsCountB;

    double ans = 0;

    // Balls taken from A for `balls[i]`
    for (int ballsTakenA = 0; ballsTakenA <= balls[i]; ++ballsTakenA) {
      const int ballsTakenB = balls[i] - ballsTakenA;
      const int newcolorsCountA = colorsCountA + (ballsTakenA > 0);
      const int newcolorsCountB = colorsCountB + (ballsTakenB > 0);
      ans += cases(balls, i + 1, ballsCountA + ballsTakenA,
                   ballsCountB + ballsTakenB, newcolorsCountA, newcolorsCountB,
                   n, boxCase) /
             (fact[ballsTakenA] * fact[ballsTakenB]);
    }

    return ans;
  }
};"
"class Solution:
    def stoneGameVIII(self, stones: List[int]) -> int:
        prefix = [0]
        for x in stones: prefix.append(prefix[-1] + x)
        
        @cache
        def fn(i): 
            """"""Return max score difference.""""""
            if i+1 == len(stones): return prefix[-1]
            return max(fn(i+1), prefix[i+1] - fn(i+1))
        
        return fn(1)","class Solution {
 public:
  vector<int> getLonelyNodes(TreeNode* root) {
    vector<int> ans;

    dfs(root, false, ans);

    return ans;
  }

 private:
  void dfs(TreeNode* root, bool isLonely, vector<int>& ans) {
    if (root == nullptr)
      return;
    if (isLonely)
      ans.push_back(root->val);

    dfs(root->left, root->right == nullptr, ans);
    dfs(root->right, root->left == nullptr, ans);
  }
};"
"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        substring = []
        for i in range(0,len(s)-2):
            a = s[i:i+3]
            substring.append(a)

        ans = 0
        for i in substring:
            if len(set(i)) == 3:
                ans += 1
        return ans","class Solution {
 public:
  vector<int> getStrongest(vector<int>& arr, int k) {
    sort(begin(arr), end(arr));

    const int n = arr.size();
    const int median = arr[(n - 1) / 2];
    vector<int> ans;

    for (int l = 0, r = n - 1; k > 0; --k)
      if (median - arr[l] > arr[r] - median)
        ans.push_back(arr[l++]);
      else
        ans.push_back(arr[r--]);

    return ans;
  }
};"
"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        start, end = 0, len(nums) - 1
        max_sum = 0
        while start <= end:
            curr_sum = nums[start] + nums[end]
            max_sum = max(max_sum,curr_sum)
            start += 1
            end -= 1
        return max_sum
    #TC -> O(n*logn)
    #SC -> O(1)","class BrowserHistory {
 public:
  BrowserHistory(string homepage) {
    visit(homepage);
  }

  void visit(string url) {
    if (++index < urls.size())
      urls[index] = url;
    else
      urls.push_back(url);
    lastIndex = index;
  }

  string back(int steps) {
    index = max(0, index - steps);
    return urls[index];
  }

  string forward(int steps) {
    index = min(lastIndex, index + steps);
    return urls[index];
  }

 private:
  vector<string> urls;
  int index = -1;
  int lastIndex = -1;
};"
"class Solution:
    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0]) # dimensions 
        anti, diag = {}, {}
        for i in range(m):
            for j in range(n): 
                key = i+j
                if key not in anti: anti[key] = [0]
                anti[key].append(anti[key][-1] + grid[i][j])
                
                key = i-j 
                if key not in diag: diag[key] = [0]
                diag[key].append(diag[key][-1] + grid[i][j])
        
        def fn(i, j, k): 
            """"""Return sum of k diagonal elements starting from (i, j)""""""
            if i >= j: return diag[i-j][j+k] - diag[i-j][j]
            return diag[i-j][i+k] - diag[i-j][i]
        
        def gn(i, j, k):
            """"""Return sum of k anti-diagonal elements starting from (i, j)""""""
            if i+j < n: return anti[i+j][i+k] - anti[i+j][i]
            return anti[i+j][n-1-j+k] - anti[i+j][n-1-j]
        
        ans = set()
        for i in range(m):
            for j in range(n): 
                ans.add(grid[i][j])
                for ii in range(i+2, m, 2): 
                    r = (ii-i)//2
                    if j-r < 0 or j+r >= n: break 
                    val = 0 
                    val += fn(i, j, r+1)
                    val += gn(i, j, r+1)
                    val += fn((ii+i)//2, j-r, r+1)
                    val += gn((ii+i)//2, j+r, r+1)
                    val -= grid[i][j] + grid[(ii+i)//2][j-r] + grid[(ii+i)//2][j+r] + grid[ii][j]
                    ans.add(val)
        return sorted(ans, reverse=True)[:3]","class Solution {
 public:
  int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n,
              int target) {
    // dp[k][i][prevColor] := min cost to paint houses[i..m) to k neighborhoods
    // W/ houses[i - 1]'s color = prevColor
    dp.resize(target + 1, vector<vector<int>>(m, vector<int>(n + 1)));

    // Init: prevColor = 0 (virtual neighbor)
    const int c = minCost(houses, cost, m, n, target, 0, 0);
    return c == kMax ? -1 : c;
  }

 private:
  static constexpr int kMax = 1'000'001;
  vector<vector<vector<int>>> dp;

  int minCost(const vector<int>& houses, const vector<vector<int>>& cost,
              const int& m, const int& n, int k, int i, int prevColor) {
    if (i == m || k < 0)
      return k == 0 ? 0 : kMax;
    if (dp[k][i][prevColor] > 0)
      return dp[k][i][prevColor];
    if (houses[i] > 0)  // Painted last year
      return minCost(houses, cost, m, n, k - (prevColor != houses[i]), i + 1,
                     houses[i]);

    int ans = kMax;

    // Try to paint houses[i] with each color in 1..n
    for (int color = 1; color <= n; ++color)
      ans = min(ans, cost[i][color - 1] + minCost(houses, cost, m, n,
                                                  k - (prevColor != color),
                                                  i + 1, color));

    return dp[k][i][prevColor] = ans;
  }
};"
"class Solution:
    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        
        @cache 
        def fn(mask, k): 
            """"""Return min xor sum.""""""
            if not mask: return 0 
            ans = inf 
            for i in range(n): 
                if mask &amp; (1<<i): 
                    ans = min(ans, (nums1[i]^nums2[k]) + fn(mask^(1<<i), k+1))
            return ans 
        
        return fn((1<<n)-1, 0)","class Solution {
 public:
  int minSumOfLengths(vector<int>& arr, int target) {
    int ans = INT_MAX;
    int leftLength = INT_MAX;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < arr.size(); ++i) {
      prefix += arr[i];
      prefixToIndex[prefix] = i;
    }

    prefix = 0;

    for (int i = 0; i < arr.size(); ++i) {
      prefix += arr[i];
      if (const auto it = prefixToIndex.find(prefix - target);
          it != cend(prefixToIndex))
        leftLength = min(leftLength, i - it->second);
      if (leftLength < INT_MAX)
        if (const auto it = prefixToIndex.find(prefix + target);
            it != cend(prefixToIndex))
          ans = min(ans, leftLength + it->second - i);
    }

    return ans == INT_MAX ? -1 : ans;
  }
};"
"class Solution:
    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:
        d1={'a':0,'b':1,'c':2,'d':3,'e':4,'f':5,'g':6,'h':7,'i':8,'j':9}
        a=0
        x=[0]
        y=[0]
        z=[0]
        for i,v in enumerate(firstWord):
            if d1[v]==0 and a==0:
                continue
            x.append(d1[v])
            a=1
        b=0
        for i,v in enumerate(secondWord):
            if d1[v]==0 and b==0:
                continue
            y.append(d1[v])
            b=1
        c=0
        for i,v in enumerate(targetWord):
            if d1[v]==0 and c==0:
                continue
            z.append(d1[v])
            c=1
        if a==1:
            x=int("""".join(map(str,x)))
        else:
            x=0
        if b==1:
            y=int("""".join(map(str,y)))
        else:
            y=0
        if c==1:
            z=int("""".join(map(str,z)))
        else:
            z=0
        print(x,y,z)
        if(x+y==z):
            return True
        return False","class Solution {
 public:
  int minDistance(vector<int>& houses, int k) {
    const int n = houses.size();
    // dp[i][j] := min distance to allocate i mailboxes in houses[j:]
    dp.resize(k + 1, vector<int>(n, INT_MAX));
    // cost[i][j] := minCost to allocate mailbox between houses[i] and houses[j]
    cost.resize(n, vector<int>(n));

    sort(begin(houses), end(houses));

    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j) {
        const int median = houses[(i + j) / 2];
        for (int x = i; x <= j; ++x)
          cost[i][j] += abs(houses[x] - median);
      }

    return minDistance(houses, k, 0);
  }

 private:
  static constexpr int kMax = 1'000'000;
  vector<vector<int>> dp;
  vector<vector<int>> cost;

  int minDistance(const vector<int>& houses, int k, int i) {
    if (k == 0 && i == houses.size())
      return 0;
    if (k == 0 || i == houses.size())
      return kMax;
    if (dp[k][i] != INT_MAX)
      return dp[k][i];

    for (int j = i; j < houses.size(); ++j)
      dp[k][i] = min(dp[k][i], cost[i][j] + minDistance(houses, k - 1, j + 1));

    return dp[k][i];
  }
};"
"class Solution:
    def maxValue(self, n: str, x: int) -> str:
        x = str(x)
        if n[0] == ""-"": 
            for i in range(1, len(n)): 
                if x < n[i]: return n[:i] + x + n[i:]
        else: 
            for i in range(0, len(n)): 
                if x > n[i]: return n[:i] + x + n[i:]
        return n + x","class Solution {
 public:
  int findLeastNumOfUniqueInts(vector<int>& arr, int k) {
    unordered_map<int, int> count;
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int a : arr)
      ++count[a];

    for (const auto& [_, freq] : count)
      minHeap.push(freq);

    // Greedily remove k least frequent nums to have least # of unique integers.
    while (k > 0)
      k -= minHeap.top(), minHeap.pop();

    return minHeap.size() + (k < 0 ? 1 : 0);
  }
};"
"class Solution:
    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:
        ans = [0] * len(tasks)
        free_servers = []
        busy_servers = []
        for idx, weight in enumerate(servers):
            heappush(free_servers, (weight, idx))
        for sec, task_len in enumerate(tasks):
            if busy_servers:
                sec_free, weight, idx = heappop(busy_servers)
                while sec_free <= sec:
                    heappush(free_servers, (weight, idx))
                    if busy_servers:
                        sec_free, weight, idx = heappop(busy_servers)
                    else:
                        break
                if sec_free > sec:
                    heappush(busy_servers, (sec_free, weight, idx))
            if free_servers:
                weight, idx = heappop(free_servers)
                ans[sec] = idx
                heappush(busy_servers, (sec + task_len, weight, idx))
            else:
                sec_free, weight, idx = heappop(busy_servers)
                ans[sec] = idx
                heappush(busy_servers, (sec_free + task_len, weight, idx))
        return ans","class Solution {
 public:
  int minDays(vector<int>& bloomDay, int m, int k) {
    if (bloomDay.size() < static_cast<long>(m) * k)
      return -1;

    int l = *min_element(begin(bloomDay), end(bloomDay));
    int r = *max_element(begin(bloomDay), end(bloomDay));

    while (l < r) {
      const int mid = (l + r) / 2;
      if (getBouquetCount(bloomDay, k, mid) >= m)
        r = mid;
      else
        l = mid + 1;
    }

    return l;
  }

 private:
  // Returns # of bouquet (k flowers needed) can be made after `waitingDays`.
  int getBouquetCount(const vector<int>& bloomDay, int k, int waitingDays) {
    int bouquetCount = 0;
    int requiredFlowers = k;
    for (const int day : bloomDay)
      if (day > waitingDays) {
        // Reset `requiredFlowers` since there was not enough adjacent flowers.
        requiredFlowers = k;
      } else if (--requiredFlowers == 0) {
        // Use k adjacent flowers to make a bouquet.
        ++bouquetCount;
        requiredFlowers = k;
      }
    return bouquetCount;
  }
};"
"class Solution:
    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:
        if sum(dist)/speed > hoursBefore: return -1 # impossible 
        
        @cache
        def fn(i, k): 
            """"""Return min time (in distance) of traveling first i roads with k skips.""""""
            if k < 0: return inf # impossible 
            if i == 0: return 0 
            return min(ceil((fn(i-1, k) + dist[i-1])/speed) * speed, dist[i-1] + fn(i-1, k-1))
        
        for k in range(len(dist)):
            if fn(len(dist)-1, k) + dist[-1] <= hoursBefore*speed: return k","class TreeAncestor {
 public:
  TreeAncestor(int n, vector<int>& parent)
      : maxLevel(32 - __builtin_clz(n)), dp(n, vector<int>(maxLevel)) {
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < maxLevel; ++j)
        if (j == 0)  // Node i's 2^0 ancestor is its direct parent
          dp[i][j] = parent[i];
        else if (dp[i][j - 1] == -1)  // No such ancestor
          dp[i][j] = -1;
        else  // A(i, 2^j) = A(A(i, 2^{j - 1}), 2^{j - 1})
          dp[i][j] = dp[dp[i][j - 1]][j - 1];
  }

  int getKthAncestor(int node, int k) {
    for (int j = 0; j < maxLevel && node != -1; ++j)
      if (k & 1 << j)
        node = dp[node][j];
    return node;
  }

 private:
  const int maxLevel;
  vector<vector<int>> dp;  // dp[i][j] := node i's 2^j-th ancestor
};"
"class Solution:
    def twoEggDrop(self, n: int) -> int:
        N = 0
        res = 0
		# find k = 1+2+3+...+i , where i is the maximum number that allows k <= n then return k
        while res < n:
            N += 1
            res += N
        return N","class Solution {
 public:
  NodeCopy* copyRandomBinaryTree(Node* root) {
    if (root == nullptr)
      return nullptr;
    if (const auto it = map.find(root); it != cend(map))
      return it->second;

    NodeCopy* newNode = new NodeCopy(root->val);
    map[root] = newNode;

    newNode->left = copyRandomBinaryTree(root->left);
    newNode->right = copyRandomBinaryTree(root->right);
    newNode->random = copyRandomBinaryTree(root->random);
    return newNode;
  }

 private:
  unordered_map<Node*, NodeCopy*> map;
};"
"class Solution:
def findRotation(self, matrix: List[List[int]], target: List[List[int]]) -> bool:
    
    def transpose(mat):
        n=len(mat)
        for i in range(n):
            for j in range(i,n):
                mat[i][j],mat[j][i]=mat[j][i],mat[i][j]
    
    def reverse(mat):
        n=len(mat)
        for i in range(n):
            for j in range(n//2+n%2):
                mat[i][j],mat[i][n-j-1]=mat[i][n-j-1],mat[i][j]
        
    if target==matrix:
        return True
    # Rotating 1st time
    transpose(matrix)
    reverse(matrix)
    if target==matrix:
        return True
    # Rotating 2nd time
    transpose(matrix)
    reverse(matrix)
    if target==matrix:
        return True
    # Rotating 3rd time
    transpose(matrix)
    reverse(matrix)
    if target==matrix:
        return True

    return False","class Solution {
 public:
  vector<string> getFolderNames(vector<string>& names) {
    vector<string> ans;
    unordered_map<string, int> nameToSuffix;

    for (const string& name : names)
      if (const auto it = nameToSuffix.find(name); it != cend(nameToSuffix)) {
        int suffix = it->second;
        string newName = getName(name, ++suffix);
        while (nameToSuffix.count(newName))
          newName = getName(name, ++suffix);
        nameToSuffix[name] = suffix;
        nameToSuffix[newName] = 0;
        ans.push_back(newName);
      } else {
        nameToSuffix[name] = 0;
        ans.push_back(name);
      }

    return ans;
  }

 private:
  string getName(const string& name, int suffix) {
    return name + ""("" + to_string(suffix) + "")"";
  }
};"
"class Solution:
    def reductionOperations(self, nums: List[int]) -> int:
        return sum(i * len(tuple(g)) for i, (_, g)
                   in enumerate(groupby(sorted(nums))))","class Solution {
 public:
  vector<int> avoidFlood(vector<int>& rains) {
    vector<int> ans(rains.size(), -1);
    unordered_map<int, int> lakeIdToFullDay;
    set<int> emptyDays;  // indices of rains[i] == 0

    for (int i = 0; i < rains.size(); ++i) {
      const int lakeId = rains[i];
      if (lakeId == 0) {
        emptyDays.insert(i);
        continue;
      }
      if (const auto itFullDay = lakeIdToFullDay.find(lakeId);
          itFullDay != cend(lakeIdToFullDay)) {
        // The lake was full in a previous day. Greedily find the closest day
        // to make the lake empty.
        const auto itEmptyDay = emptyDays.upper_bound(itFullDay->second);
        if (itEmptyDay == cend(emptyDays))  // Not found.
          return {};
        // Empty the lake at this day.
        ans[*itEmptyDay] = lakeId;
        emptyDays.erase(itEmptyDay);
      }
      // Lake with `lakeId` becomes full at day i.
      lakeIdToFullDay[lakeId] = i;
    }

    // Pick a arbitrary lake to empty if there are remaining empty days.
    for (const int emptyDay : emptyDays)
      ans[emptyDay] = 1;

    return ans;
  }
};"
"class Solution:
    def minFlips(self, s: str) -> int:
        n = len(s)

        s = s+s
        fip1 = [('0' if i%2==0 else '1') for i in range(len(s))]
        fip2 = [('1' if i%2==0 else '0') for i in range(len(s))]
        i = 0
        min1 = 0
        min2 = 0
        final = len(s)
        for j in range(len(s)):
            
            if fip1[j]!=(s[j]):
                min1+=1
            if fip2[j]!= (s[j]):
                min2+=1

            if (j-i+1) == n:
                final = min(final,min1,min2)
                if (s[i]) != fip1[i]:
                    min1-=1
                if (s[i]) != fip2[i]:
                    min2-=1
                i+=1
        return final","class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  vector<vector<int>> findCriticalAndPseudoCriticalEdges(
      int n, vector<vector<int>>& edges) {
    vector<int> criticalEdges;
    vector<int> pseudoCriticalEdges;

    // Record the index information, so edges[i] := (u, v, weight, index).
    for (int i = 0; i < edges.size(); ++i)
      edges[i].push_back(i);

    // Sort by weight.
    sort(
        begin(edges), end(edges),
        [](const vector<int>& a, const vector<int>& b) { return a[2] < b[2]; });

    const int mstWeight = getMSTWeight(n, edges, {}, -1);

    for (const vector<int>& edge : edges) {
      const int index = edge[3];
      // Deleting `e` makes the MST weight increase or can't form a MST.
      if (getMSTWeight(n, edges, {}, index) > mstWeight)
        criticalEdges.push_back(index);
      // If an edge can be in any MST, we can always add `edge` to the edge set.
      else if (getMSTWeight(n, edges, edge, -1) == mstWeight)
        pseudoCriticalEdges.push_back(index);
    }

    return {criticalEdges, pseudoCriticalEdges};
  }

 private:
  int getMSTWeight(int n, const vector<vector<int>>& edges,
                   const vector<int>& firstEdge, int deletedEdgeIndex) {
    int mstWeight = 0;
    UnionFind uf(n);

    if (!firstEdge.empty()) {
      uf.unionByRank(firstEdge[0], firstEdge[1]);
      mstWeight += firstEdge[2];
    }

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int weight = edge[2];
      const int index = edge[3];
      if (index == deletedEdgeIndex)
        continue;
      if (uf.find(u) == uf.find(v))
        continue;
      uf.unionByRank(u, v);
      mstWeight += weight;
    }

    const int root = uf.find(0);
    for (int i = 0; i < n; ++i)
      if (uf.find(i) != root)
        return INT_MAX;

    return mstWeight;
  }
};"
"class Solution:
    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:
        # prefix sum to save time
        acc = [0] + [*accumulate(packages)]
        packages.sort()

        ans = float('inf')
        for box in boxes:
            tmp = 0
            # deal with smallest box first
            box.sort()
            
            # record number of packages already dealt with
            start = 0
            
            for b in box:
                loc = bisect.bisect(packages, b)
                if loc == 0: continue
                tmp += b * (loc - start) - (acc[loc] - acc[start])
                
                # all are packaged
                if loc == len(packages):
                    ans = min(ans, tmp)
                    break
                    
                start = loc
        
        return ans % (10 **9+7) if ans != float('inf') else -1","class Solution {
 public:
  Node* cloneTree(Node* root) {
    if (root == nullptr)
      return nullptr;
    if (const auto it = map.find(root); it != cend(map))
      return it->second;

    Node* newNode = new Node(root->val);
    map[root] = newNode;

    for (Node* child : root->children)
      newNode->children.push_back(cloneTree(child));

    return newNode;
  }

 private:
  unordered_map<Node*, Node*> map;
};"
"class Solution:
    def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:
        
        seen = set()
        
        for interval in ranges:
            
            start = interval[0]
            end = interval[1]
            
			# adds all numbers in range to the seen numbers
            for x in range(start, end+1):
                seen.add(x)
            
		# make sure all numbers from left to right have been seen
        for x in range(left, right+1):
            if x not in seen:
                return False
        
        return True","class Solution {
 public:
  int kthFactor(int n, int k) {
    // If i is a divisor of n, then n / i is also a divisor of n. So, we can
    // find all the divisors of n by processing the numbers <= sqrt(n).
    int factor = 1;
    int i = 0;  // i-th factor

    for (; factor * factor < n; ++factor)
      if (n % factor == 0 && ++i == k)
        return factor;

    for (factor = n / factor; factor >= 1; --factor)
      if (n % factor == 0 && ++i == k)
        return n / factor;

    return -1;
  }
};"
"class Solution:
    def chalkReplacer(self, chalk: List[int], k: int) -> int:
        k %= sum(chalk)
        n = len(chalk)
        for i in range(n):
            if chalk[i] > k:
                return i
            k -= chalk[i]","class Solution {
 public:
  int longestSubarray(vector<int>& nums) {
    int ans = 0;
    int count0 = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (nums[r] == 0)
        ++count0;
      while (count0 == 2)
        if (nums[l++] == 0)
          --count0;
      ans = max(ans, r - l);
    }

    return ans;
  }
};"
"class Solution:

    @staticmethod
    def is_magic(mat: List[List[int]]):
        n, s = len(mat), sum(mat[0])
        for r in range(1, n):
            if sum(mat[r]) != s:
                return False
        if any(sum(col) != s for col in zip(*mat)):
            return False
        d1 = d2 = 0
        n1 = n - 1
        for i in range(n):
            d1 += mat[i][i]
            d2 += mat[n1 - i][i]
        return d1 == d2 == s

    def largestMagicSquare(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        max_size = 1
        for r in range(rows):
            if rows - r < max_size:
                break
            for c in range(cols):
                if cols - c < max_size:
                    break
                max_len = min(rows - r, cols - c) + 1
                for size in range(max_size + 1, max_len):
                    sub_mat = [grid[row_id][c: c + size]
                               for row_id in range(r, r + size)]
                    if Solution.is_magic(sub_mat):
                        max_size = size
        return max_size","class Solution {
 public:
  int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {
    // dp[i] := min # of semesters to take all courses in mask i
    vector<int> dp(1 << n, n);
    // prereq[i] := bit mask of all dependencies of course i
    vector<int> prereq(n);

    for (const vector<int>& r : relations) {
      const int prevCourse = r[0] - 1;
      const int nextCourse = r[1] - 1;
      prereq[nextCourse] |= 1 << prevCourse;
    }

    dp[0] = 0;  // No need time to finish 0 course

    for (int i = 0; i < dp.size(); ++i) {
      // Bit mask of all the courses can be taken.
      int coursesCanBeTaken = 0;
      // Can take course j if i contains all j's prerequisites.
      for (int j = 0; j < n; ++j)
        if (i & prereq[j] == prereq[j])
          coursesCanBeTaken |= 1 << j;
      // Don't take any course which is already taken.
      // (i represents set of courses that are already taken)
      coursesCanBeTaken &= ~i;
      // Enumerate all bit subset of `coursesCanBeTaken`.
      for (int s = coursesCanBeTaken; s; s = (s - 1) & coursesCanBeTaken)
        if (__builtin_popcount(s) <= k)
          // Any combination of courses (if <= k) can be taken now.
          // i | s := combining courses taken with courses can be taken.
          dp[i | s] = min(dp[i | s], dp[i] + 1);
    }

    return dp.back();
  }
};"
"class Solution:
    def minOperationsToFlip(self, expression: str) -> int:
        loc = {}
        stack = []
        for i in reversed(range(len(expression))):
            if expression[i] == "")"": stack.append(i)
            elif expression[i] == ""("": loc[stack.pop()] = i 
        
        def fn(lo, hi): 
            """"""Return value and min op to change value.""""""
            if lo == hi: return int(expression[lo]), 1
            if expression[hi] == "")"" and loc[hi] == lo: return fn(lo+1, hi-1) # strip parenthesis 
            mid = loc.get(hi, hi) - 1 
            v, c = fn(mid+1, hi)
            vv, cc = fn(lo, mid-1)
            if expression[mid] == ""|"": 
                val = v | vv 
                if v == vv == 0: chg = min(c, cc)
                elif v == vv == 1: chg = 1 + min(c, cc)
                else: chg = 1 
            else: # expression[k] == ""&amp;""
                val = v &amp; vv
                if v == vv == 0: chg = 1 + min(c, cc)
                elif v == vv == 1: chg = min(c, cc)
                else: chg = 1
            return val, chg
                    
        return fn(0, len(expression)-1)[1]","class Solution {
 public:
  bool isPathCrossing(string path) {
    set<int> seen;

    seen.insert(0);

    int x = 0;
    int y = 0;

    for (const char c : path) {
      switch (c) {
        case 'N':
          ++y;
          break;
        case 'S':
          --y;
          break;
        case 'E':
          ++x;
          break;
        case 'W':
          --x;
          break;
      }
      const int key = x * 20001 + y;
      if (seen.count(key))
        return true;
      seen.insert(key);
    }

    return false;
  }
};"
"class Solution:
    def makeEqual(self, words: List[str]) -> bool:
        x = {}
        for word in words:
            for i in word:
                if i in x:
                    x[i]+=1
                else:
                    x[i]=1
        return all(i%len(words) == 0 for i in x.values())","class Solution {
 public:
  bool canArrange(vector<int>& arr, int k) {
    vector<int> bucket(k);

    for (const int a : arr) {
      int i = a % k;
      if (i < 0)
        i += k;
      ++bucket[i];
    }

    for (int i = 0; i < k; ++i)
      if (i == 0) {
        if (bucket[i] % 2 != 0)
          return false;
      } else if ((bucket[i] + bucket[k - i]) % 2 != 0) {
        return false;
      }

    return true;
  }
};"
"class Solution:
    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:
        indices = {}
        for i in range(len(removable)):
            indices[removable[i]] = i
        
        def check(mid):
            i, j = 0, 0
            while i < len(s) and j < len(p):
                if s[i] == p[j] and (i not in indices or indices[i] > mid):
                    j += 1
                i += 1
            
            if j == len(p):
                return True
            else:
                return False
        
        l, r = 0, len(removable) - 1
        ans = -1
        
        while l <= r:
            mid = (l + r) // 2
            if check(mid):
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
                
        return ans + 1","class Solution {
 public:
  int numSubseq(vector<int>& nums, int target) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    int ans = 0;
    vector<int> pows(n, 1);  // pows[i] = 2^i % kMod

    for (int i = 1; i < n; ++i)
      pows[i] = pows[i - 1] * 2 % kMod;

    sort(begin(nums), end(nums));

    for (int l = 0, r = n - 1; l <= r;)
      if (nums[l] + nums[r] <= target) {
        ans += pows[r - l];
        ans %= kMod;
        ++l;
      } else {
        --r;
      }

    return ans;
  }
};"
"class Solution:
    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        x = y = z = -inf 
        for a, b, c in triplets: 
            if a <= target[0] and b <= target[1] and c <= target[2]: 
                x, y, z = max(x, a), max(y, b), max(z, c)
        return [x, y, z] == target","class Solution {
 public:
  int findMaxValueOfEquation(vector<vector<int>>& points, int k) {
    int ans = INT_MIN;
    priority_queue<pair<int, int>> maxHeap;  // (y - x, x)

    for (const vector<int>& p : points) {
      const int x = p[0];
      const int y = p[1];
      while (!maxHeap.empty() && x - maxHeap.top().second > k)
        maxHeap.pop();
      if (!maxHeap.empty())
        ans = max(ans, x + y + maxHeap.top().first);
      maxHeap.emplace(y - x, x);
    }

    return ans;
  }
};"
"class Solution:
    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:
        firstPlayer, secondPlayer = firstPlayer-1, secondPlayer-1 # 0-indexed
        
        @cache
        def fn(k, mask): 
            """"""Return earliest and latest rounds.""""""
            can = deque()
            for i in range(n): 
                if mask &amp; (1 << i): can.append(i)
                    
            cand = [] # eliminated player
            while len(can) > 1: 
                p1, p2 = can.popleft(), can.pop()
                if p1 == firstPlayer and p2 == secondPlayer or p1 == secondPlayer and p2 == firstPlayer: return [k, k] # game of interest 
                if p1 in (firstPlayer, secondPlayer): cand.append([p2]) # p2 eliminated 
                elif p2 in (firstPlayer, secondPlayer): cand.append([p1]) # p1 eliminated 
                else: cand.append([p1, p2]) # both could be elimited 
            
            minn, maxx = inf, -inf
            for x in product(*cand): 
                mask0 = mask
                for i in x: mask0 ^= 1 << i
                mn, mx = fn(k+1, mask0)
                minn = min(minn, mn)
                maxx = max(maxx, mx)
            return minn, maxx
        
        return fn(1, (1<<n)-1)","class Solution {
 public:
  bool canMakeArithmeticProgression(vector<int>& arr) {
    const int n = arr.size();
    const int max = *max_element(begin(arr), end(arr));
    const int min = *min_element(begin(arr), end(arr));
    const int range = max - min;
    if (range % (n - 1) != 0)
      return false;
    const int diff = range / (n - 1);
    if (diff == 0)
      return true;

    unordered_set<int> seen;

    for (const int a : arr) {
      if ((a - min) % diff != 0)
        return false;
      if (!seen.insert(a).second)
        return false;
    }

    return true;
  }
};"
"class Solution:
    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:
        M = len(mat)
        N = len(mat[0])
        @cache
        def rmax(r):
            return max(mat[r])
        l,r = 0,M
        while r-l>1:
            m = l+(r-l)//2
            assert(m>0)
            if rmax(m)>rmax(m-1):
                l = m
            else:
                r = m
        return [l, mat[l].index(rmax(l))]","class Solution {
 public:
  int getLastMoment(int n, vector<int>& left, vector<int>& right) {
    const int maxLeft = left.empty() ? 0 : *max_element(begin(left), end(left));
    const int minRight =
        right.empty() ? n : *min_element(begin(right), end(right));
    return max(maxLeft, n - minRight);
  }
};"
"class Solution:
    def largestOddNumber(self, num: str) -> str:
        val, idx = '', len(num) - 1
        
        while idx > -1:
            odd = int(num[idx]) % 2
            while odd and idx > -1:
                val = num[idx] + val
                idx -= 1
            idx -= 1
        return val","class Solution {
 public:
  int numSubmat(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    int ans = 0;

    for (int baseRow = 0; baseRow < m; ++baseRow) {
      vector<int> row(n, 1);
      for (int i = baseRow; i < m; ++i) {
        for (int j = 0; j < n; ++j)
          row[j] &= mat[i][j];
        ans += count(row);
      }
    }

    return ans;
  }

 private:
  int count(vector<int>& row) {
    int ans = 0;
    int length = 0;

    for (const int a : row) {
      length = a == 0 ? 0 : length + 1;
      ans += length;
    }

    return ans;
  }
};"
"class Solution:
    def numberOfRounds(self, startTime: str, finishTime: str) -> int:
        start_time = sum(t if i else 60 * t
                         for i, t in enumerate(map(int, startTime.split("":""))))
        finish_time = sum(t if i else 60 * t
                          for i, t in enumerate(map(int, finishTime.split("":""))))
        if finish_time < start_time:
            finish_time += 1440
        return (floor(finish_time / 15) - ceil(start_time / 15)
                if finish_time - start_time >= 15 else 0)","class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += i & -i;
    }
  }

  int get(int i) {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= i & -i;
    }
    return sum;
  }

 private:
  vector<int> sums;
};

class Solution {
 public:
  string minInteger(string num, int k) {
    const int n = num.length();
    string ans;
    FenwickTree tree(n);
    vector<bool> used(n);
    vector<queue<int>> numToIndices(10);

    for (int i = 0; i < n; ++i)
      numToIndices[num[i] - '0'].push(i);

    while (k > 0 && ans.length() < n)
      for (int d = 0; d < 10; ++d) {
        if (numToIndices[d].empty())
          continue;
        const int i = numToIndices[d].front();
        const int cost = i - tree.get(i);  // Note the offset 1 in FenwickTree
        if (cost > k)
          continue;
        k -= cost;
        ans += '0' + d;
        used[i] = true;
        tree.update(i + 1, 1);
        numToIndices[d].pop();
        break;  // Scan from 0 -> 9 again
      }

    for (int i = 0; i < n; ++i)
      if (!used[i])
        ans += num[i];

    return ans;
  }
};"
"class Solution:
    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:
        
        rows = len(grid1)
        cols = len(grid1[0])
        directions = [(1,0),(-1,0),(0,1),(0,-1)]
        
        islands = 0
        
        for row in range(rows):
            for col in range(cols):
                if grid2[row][col] == 1 and grid1[row][col] == 1:
                    grid2[row][col] = '#'
                    q = collections.deque([])
                    q.append((row, col))
                    is_island = True
                    while q:
                        r, c = q.popleft()
                        for y, x in directions:
                            nr = r + y
                            nc = c + x
                            if 0 <= nr < rows and 0 <= nc < cols and grid2[nr][nc] == 1:
                                if grid1[nr][nc] != 1:
                                    is_island = False
                                grid2[nr][nc] = '#'
                                q.append((nr, nc))
                                
                    if is_island:
                        islands += 1
                    
        return islands","class Solution {
 public:
  int rangeSum(vector<int>& nums, int n, int left, int right) {
    constexpr int kMod = 1'000'000'007;

    auto subarraysAndSumNoGreaterThan = [&](int m) -> pair<int, long> {
      int count = 0;   // # of subarrays <= m
      long total = 0;  // Sum(subarrays)
      int sum = 0;     // Current sum (will be added to `total` in each loop)
      int window = 0;  // Window sum (can be extend and shrink)

      for (int i = 0, j = 0; j < n; ++j) {
        sum += nums[j] * (j - i + 1);
        window += nums[j];  // Extend each subarray ends w/ j
        while (window > m) {
          sum -= window;
          window -= nums[i++];  // Shrink the window
        }
        count += j - i + 1;
        total += sum;
      }

      return {count, total};
    };

    // [L, R] is the possible range of the sum of any subarray
    const int L = *min_element(begin(nums), end(nums));
    const int R = accumulate(begin(nums), end(nums), 0);

    auto firstKSubarraysSum = [&](int k) -> long {
      int l = L;
      int r = R;

      while (l < r) {
        const int m = l + (r - l) / 2;
        if (subarraysAndSumNoGreaterThan(m).first < k)
          l = m + 1;
        else
          r = m;
      }

      const auto& [count, total] = subarraysAndSumNoGreaterThan(l);
      // When count != k, there're subarray(s) have the same sum as l
      return total - l * (count - k);
    };

    return (firstKSubarraysSum(right) - firstKSubarraysSum(left - 1)) % kMod;
  }
};"
"class Solution:
    def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        loc = {}
        for i, x in enumerate(nums): loc.setdefault(x, []).append(i)
        keys = sorted(loc)
        
        ans = []
        for l, r in queries: 
            prev, val = 0, inf
            for x in keys: 
                i = bisect_left(loc[x], l)
                if i < len(loc[x]) and loc[x][i] <= r: 
                    if prev: val = min(val, x - prev)
                    prev = x 
            ans.append(val if val < inf else -1)
        return ans","class Solution {
 public:
  int minDifference(vector<int>& nums) {
    const int n = nums.size();
    if (n < 5)
      return 0;

    int ans = INT_MAX;

    sort(begin(nums), end(nums));

    // Change nums[0..i) to nums[i] and
    // Change nums[n - 3 + i..n) to nums[n - 4 + i]
    for (int i = 0; i <= 3; ++i)
      ans = min(ans, nums[n - 4 + i] - nums[i]);

    return ans;
  }
};"
"class Solution:
    def canBeIncreasing(self, nums: List[int]) -> bool:
        for i in range(len(nums)):
            x = nums[:i]+nums[i+1:]
            if sorted(x)==x and len(set(x))==len(x): return True
        return False","class Solution {
 public:
  bool winnerSquareGame(int n) {
    // dp[i] := the winning result for n = i
    vector<bool> dp(n + 1);

    for (int i = 1; i <= n; ++i)
      for (int j = 1; j * j <= i; ++j)
        if (!dp[i - j * j]) {  // Remove j^2 stones make the opponent lose
          dp[i] = true;        // So we win
          break;
        }

    return dp[n];
  }
};"
"class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        if part in s:
            a = s.index(part)
            return self.removeOccurrences(s[:a] + s[a+len(part):], part)
        else:
            return s","class Solution {
 public:
  int numIdenticalPairs(vector<int>& nums) {
    int ans = 0;
    vector<int> count(101);

    for (const int num : nums)
      ans += count[num]++;

    return ans;
  }
};"
"class Solution:
    def maxAlternatingSum(self, nums: List[int]) -> int:
        n = len(nums)
        dp_odd = [0]*n
        dp_even = [0]*n
        dp_even[0] = nums[0]
        max_even = nums[0]
        max_odd = 0
        ans = nums[0]
        i = 1
        while i<n:
            dp_odd[i] = max_even - nums[i]
            dp_even[i] = max_odd + nums[i]
            max_even = max(max_even, dp_even[i])
            max_odd = max(max_odd,dp_odd[i] )
            ans = max(ans, dp_odd[i], dp_even[i])
            i += 1
        return ans","class Solution {
 public:
  int numSub(string s) {
    constexpr int kMod = 1'000'000'007;

    int ans = 0;
    int l = -1;

    for (int i = 0; i < s.length(); ++i) {
      if (s[i] == '0')
        l = i;  // Handle reset value
      ans = (ans + i - l) % kMod;
    }

    return ans;
  }
};"
"class Solution:
    def maxProductDifference(self, nums: List[int]) -> int:
        nums.sort()
        return nums[-1] * nums[-2] - nums[0] * nums[1]","class Solution {
 public:
  double maxProbability(int n, vector<vector<int>>& edges,
                        vector<double>& succProb, int start, int end) {
    vector<vector<pair<int, double>>> graph(n);  // {a: [(b, prob_ab)]}
    priority_queue<pair<double, int>> maxHeap;   // (prob to reach u, u)
    maxHeap.emplace(1.0, start);
    vector<bool> seen(n);

    for (int i = 0; i < edges.size(); ++i) {
      const int u = edges[i][0];
      const int v = edges[i][1];
      const double prob = succProb[i];
      graph[u].emplace_back(v, prob);
      graph[v].emplace_back(u, prob);
    }

    while (!maxHeap.empty()) {
      const auto [prob, u] = maxHeap.top();
      maxHeap.pop();
      if (u == end)
        return prob;
      if (seen[u])
        continue;
      seen[u] = true;
      for (const auto& [nextNode, edgeProb] : graph[u]) {
        if (seen[nextNode])
          continue;
        maxHeap.emplace(prob * edgeProb, nextNode);
      }
    }

    return 0;
  }
};"
"class Solution:
    def rotateGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        ans = [[0] * n for _ in range(m)]
        # x, y is starting point; m, n is desired length and width of the layer
        def helper(x, y, l, w):
            tmp = deque([grid[x][y]])
            a, b = 0, 0
            # extract all number in the layer
            while len(tmp) < 2 * (l + w) - 4:
                if a == 0 and b < w - 1:
                    b += 1
                elif b == w - 1 and a < l - 1:
                    a += 1
                elif a == l - 1 and b > 0:
                    b -= 1
                elif b == 0 and a > 0:
                    a -= 1
                tmp.append(grid[x + a][y + b])
            
            # rotate counter-clockwise
            tmp.rotate(len(tmp) - k % len(tmp))

            # reassign
            a, b = 0, 0
            ans[x][y] = tmp.popleft()
            while tmp:
                if a == 0 and b < w - 1:
                    b += 1
                elif b == w - 1 and a < l - 1:
                    a += 1
                elif a == l - 1 and b > 0:
                    b -= 1
                elif b == 0 and a > 0:
                    a -= 1
                ans[x + a][y + b] = tmp.popleft()
        
        x, y = 0, 0
        while m >= 2 and n >= 2:
            helper(x, y, m, n)
            x += 1
            y += 1
            m -= 2
            n -= 2
        
        return ans","class Solution {
 public:
  double getMinDistSum(vector<vector<int>>& positions) {
    constexpr double kErr = 1e-6;
    double currX = 50;
    double currY = 50;
    double ans = distSum(positions, currX, currY);
    double step = 1;

    while (step > kErr) {
      bool shouldDecreaseStep = true;
      for (const auto& [dx, dy] : vector<pair<double, double>>{
               {0, step}, {0, -step}, {step, 0}, {-step, 0}}) {
        const double x = currX + dx;
        const double y = currY + dy;
        const double newDistSum = distSum(positions, x, y);
        if (newDistSum < ans) {
          ans = newDistSum;
          currX = x;
          currY = y;
          shouldDecreaseStep = false;
        }
      }
      if (shouldDecreaseStep)
        step /= 10;
    }

    return ans;
  }

 private:
  double distSum(const vector<vector<int>>& positions, double a, double b) {
    double sum = 0;
    for (const vector<int>& p : positions)
      sum += sqrt(pow(a - p[0], 2) + pow(b - p[1], 2));
    return sum;
  }
};"
"class Solution:
    def wonderfulSubstrings(self, word: str) -> int:
        n = len(word)
        mask = 0
        prefix = defaultdict(int)
        prefix[0] += 1
        ans = 0
        for w in word:
            mask ^= 1 << (ord(w) - ord('a'))
            # no difference
            ans += prefix[mask]
            for i in range(10):
                # only differed by one digit 
                tmp = mask ^ (1 << i)
                ans += prefix[tmp]
            prefix[mask] += 1
        return ans","class Solution {
 public:
  Node* moveSubTree(Node* root, Node* p, Node* q) {
    if (find(begin(q->children), end(q->children), p) != end(q->children))
      return root;

    // Create a dummy Node for the case when root == p
    Node* dummy = new Node(0, {root});

    // Get each parent of p and q
    Node* pParent = getParent(dummy, p);
    Node* qParent = getParent(p, q);

    // Get p's original index in p's parent
    vector<Node*>& pSiblings = pParent->children;
    const int pIndex =
        find(begin(pSiblings), end(pSiblings), p) - begin(pSiblings);
    pSiblings.erase(begin(pSiblings) + pIndex);

    q->children.push_back(p);

    // If q is in the p's subtree, qParent != nullptr
    if (qParent != nullptr) {
      vector<Node*>& qSiblings = qParent->children;
      qSiblings.erase(remove(begin(qSiblings), end(qSiblings), q),
                      end(qSiblings));
      pSiblings.insert(begin(pSiblings) + pIndex, q);
    }

    return dummy->children[0];
  }

 private:
  Node* getParent(Node* root, Node* target) {
    for (Node* child : root->children) {
      if (child == target)
        return root;
      Node* res = getParent(child, target);
      if (res != nullptr)
        return res;
    }
    return nullptr;
  }
};"
"class Solution:
    def waysToBuildRooms(self, prevRoom: List[int]) -> int:
        tree = defaultdict(list)
        for i, x in enumerate(prevRoom): tree[x].append(i)
        
        def fn(n): 
            """"""Return number of nodes and ways to build sub-tree.""""""
            if not tree[n]: return 1, 1 # leaf 
            c, m = 0, 1
            for nn in tree[n]: 
                cc, mm = fn(nn)
                c += cc
                m = (m * comb(c, cc) * mm) % 1_000_000_007
            return c+1, m
        
        return fn(0)[1]","class Solution {
 public:
  int numWaterBottles(int numBottles, int numExchange) {
    int ans = numBottles;

    while (numBottles >= numExchange) {
      ans += numBottles / numExchange;
      numBottles = numBottles / numExchange + numBottles % numExchange;
    }

    return ans;
  }
};"
"class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
        x=[nums[nums[i]] for i in range(0,len(nums))]
        return x;","class Solution {
 public:
  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {
    vector<int> ans(n);
    vector<vector<int>> tree(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    dfs(tree, 0, -1, labels, ans);
    return ans;
  }

 private:
  vector<int> dfs(const vector<vector<int>>& tree, int u, int parent,
                  const string& labels, vector<int>& ans) {
    // count[i] := # of letters down from 'a' + i
    vector<int> count(26);

    for (const int v : tree[u]) {
      if (v == parent)
        continue;
      vector<int> childCount = dfs(tree, v, u, labels, ans);
      for (int i = 0; i < 26; ++i)
        count[i] += childCount[i];
    }

    ans[u] = ++count[labels[u] - 'a'];  // The u itself
    return count;
  }
};"
"class Solution:
def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
    
    time = [d/s for d,s in zip(dist,speed)]
    time.sort()
    c=0
    for i,t in enumerate(time):
        if i<t:
            c+=1
        else:
            break
    
    return c","class Solution {
 public:
  vector<string> maxNumOfSubstrings(string s) {
    const int n = s.length();
    vector<string> ans;
    vector<int> leftmost(26, n);    // Leftmost index of each letter
    vector<int> rightmost(26, -1);  // Rightmost index of each letter

    for (int i = 0; i < n; ++i) {
      leftmost[s[i] - 'a'] = min(leftmost[s[i] - 'a'], i);
      rightmost[s[i] - 'a'] = i;
    }

    auto getNewRight = [&](int i) {
      int right = rightmost[s[i] - 'a'];
      for (int j = i; j <= right; ++j) {
        if (leftmost[s[j] - 'a'] < i)  // Find a letter's first index < i
          return -1;
        right = max(right, rightmost[s[j] - 'a']);  // Right expands dynamically
      }
      return right;
    };

    int right = -1;  // Last substring's rightmost index
    for (int i = 0; i < n; ++i) {
      if (i == leftmost[s[i] - 'a']) {  // Current index is the first appearance
        const int newRight = getNewRight(i);
        if (newRight == -1)
          continue;  // Find a letter's first index < i
        if (i <= right && !ans.empty())
          ans.back() = s.substr(i, newRight - i + 1);
        else
          ans.push_back(s.substr(i, newRight - i + 1));
        right = newRight;
      }
    }

    return ans;
  }
};"
"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        odds = n // 2
        return (pow(5, n - odds, 1_000_000_007) * pow(4, odds, 1_000_000_007)
                % 1_000_000_007)","class Solution {
 public:
  int closestToTarget(vector<int>& arr, int target) {
    int ans = INT_MAX;
    // S(j) := arr[i] & arr[i + 1] & ... & arr[j] for all 0 <= i <= j (fixed)
    unordered_set<int> s;

    for (const int a : arr) {
      unordered_set<int> s2{a};
      for (const int b : s)
        s2.insert(a & b);
      for (const int c : s = s2)
        ans = min(ans, abs(c - target));
    }

    return ans;
  }
};"
"class Solution:
    cache = {1:0, 2:0, 3:0, 4:0}
    
    def countTriples(self, n: int) -> int:        
        if n in self.cache.keys():
            return self.cache[n]
        else:
            self.cache[n] = self.findTriples(n) + self.countTriples(n-1)
            return self.cache[n]
        
    def findTriples(self, n: int) -> int:
        count = 0
        
        for a in range(0, n):
            for b in range(a, n):
                if self.isSquareTriple(a, b, n):
                    count += 1
                    
        return count*2
        
    def isSquareTriple(self, a: int, b: int, c: int) -> bool:
        if ((a*a) + (b*b) == (c*c)):
            return True
        else:
            return False","class Solution {
 public:
  int countOdds(int low, int high) {
    return (high + 1) / 2 - low / 2;
  }
};"
"class Solution:
    def nearestExit(self, maze, entrance) -> int:
        '''
        for val in maze:
            print(val)
        '''
        m, n = len(maze), len(maze[0])
        q, ans = [entrance], 0

        while q:
            num = len(q)
            for i in range(num):
                x, y = q[0]
                if (x == 0 or y == 0 or x == m - 1 or y == n - 1) and ans > 0:
                    return ans
                q.pop(0)
                maze[x][y] = '+'
                if x > 0 and maze[x - 1][y] == '.':
                    q.append([x - 1, y])
                if y > 0 and maze[x][y - 1] == '.':
                    q.append([x, y - 1])
                if x < m - 1 and maze[x + 1][y] == '.':
                    q.append([x + 1, y])
                if y < n - 1 and maze[x][y + 1] == '.':
                    q.append([x, y + 1])
            ans += 1

        return -1","class Solution {
 public:
  int numOfSubarrays(vector<int>& arr) {
    constexpr int kMod = 1'000'000'007;
    const int n = arr.size();
    long ans = 0;
    // dp0[i] := # of subarrays ends with arr[i - 1] having even sum
    vector<int> dp0(n + 1);
    // dp1[i] := # of subarrays ends with arr[i - 1] having odd sum
    vector<int> dp1(n + 1);

    for (int i = 1; i <= n; ++i) {
      if (arr[i - 1] & 1) {
        dp0[i] = dp1[i - 1];
        dp1[i] = dp0[i - 1] + 1;
      } else {
        dp0[i] = dp0[i - 1] + 1;
        dp1[i] = dp1[i - 1];
      }
      ans = (ans + dp1[i]) % kMod;
    }

    return ans;
  }
};"
"class Solution:
    def sumGame(self, num: str) -> bool:
        diff = qm = 0 
        for i, ch in enumerate(num): 
            if ch == ""?"": qm += 1 if i < len(num)//2 else -1
            else: diff += int(ch) if i < len(num)//2 else -int(ch)
        return diff * 2 + qm * 9 != 0","class Solution {
 public:
  int numSplits(string s) {
    const int n = s.length();
    int ans = 0;
    vector<int> prefix(n);  // prefix[i] := of unique letters in s[0..i]
    vector<int> suffix(n);  // suffix[i] := of unique letters in s[i..n)
    unordered_set<int> seen;

    for (int i = 0; i < n; ++i) {
      seen.insert(s[i]);
      prefix[i] = seen.size();
    }

    seen.clear();

    for (int i = n - 1; i >= 0; --i) {
      seen.insert(s[i]);
      suffix[i] = seen.size();
    }

    for (int i = 0; i + 1 < n; ++i)
      if (prefix[i] == suffix[i + 1])
        ++ans;

    return ans;
  }
};"
"class Solution:
    def minCost(self, maxTime: int, edges: List[List[int]], fee: List[int]) -> int:
        g = defaultdict(lambda: defaultdict(lambda: float('inf')))
        n = len(fee)
        
        # select edges with minimal time
        for u, v, t in edges:
            if t < g[u][v]:
                g[u][v] = t
            if t < g[v][u]:
                g[v][u] = t
        
        
        vis = defaultdict(tuple, {0: (0, fee[0])})
        
        q = [(fee[0], 0, 0)]
        while q:
            f, t, cur = heappop(q)
            if cur == n - 1:
                return f
            for nei in g[cur]:
                nf = f + fee[nei]
                nt = t + g[cur][nei]
                if nt > maxTime: continue
                    
                # global vis set (either less time or fare)
                if not vis[nei] or (nt < vis[nei][0] or nf < vis[nei][1]):
                    if not vis[nei]: 
                        vis[nei] = (nt, nf)
                    else:
                        vis[nei] = (min(nt, vis[nei][0]), min(nf, vis[nei][1]))
                    heappush(q, (nf, nt, nei))
        return -1","class Solution {
 public:
  int minNumberOperations(vector<int>& target) {
    int ans = target.front();

    for (int i = 1; i < target.size(); ++i)
      if (target[i] > target[i - 1])
        ans += target[i] - target[i - 1];

    return ans;
  }
};"
"class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        return nums * 2","class Solution {
 public:
  string restoreString(string s, vector<int>& indices) {
    string ans(s.length(), '.');

    for (int i = 0; i < indices.size(); ++i)
      ans[indices[i]] = s[i];

    return ans;
  }
};"
"class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        
        first = {}
        last = {}
        
        for i,c in enumerate(s):
            if c not in first:
                first[c] = i
            last[c] = i
            
        ans = 0
        for c in ""abcdefghijklmnopqrstuvwxyz"":
            if c not in last:
                continue
            uniq = set()
            for i in range(first[c]+1,last[c]):
                uniq.add(s[i])
            ans += len(uniq)
            
        return ans","class Solution {
 public:
  int minFlips(string target) {
    int ans = 0;
    int state = 0;

    for (const char c : target)
      if (c - '0' != state) {
        state = c - '0';
        ++ans;
      }

    return ans;
  }
};"
"class Solution:
    def colorTheGrid(self, m: int, n: int) -> int:
        M = 10**9 + 7
        ans = 3
        if m == 1:
            for i in range(n-1):
                ans *= 2
                ans %= M
            return ans % M
        
        def IsValid(a):
            return all ( a[i] != a[i+1] for i in range(len(a) - 1) )
            
        if m >= 2:
            # AllStates contains all colorings of a single row of length m using 3 colors (0, 1, 2), hence of size 3^m
            # For example, m = 2, AllStates = [(0,0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
            AllStates = [[0], [1], [2]]
            colors = [0, 1, 2]
            for j in range(m-1):
                L = len(AllStates)
                for i in range(L):
                    x = AllStates.pop(0)
                    for c in colors:
                        AllStates.append(tuple([*x, c]))
            
            # v contains all valid colorings of a single row of length m using 3 colors
            v = set()
            for a in AllStates:
                if IsValid(a):
                    v.add(a)
            d = {i:a for i, a in enumerate(v)}
            
            # construct a graph where vertices are valid single row colorings
            # an edge is present if two colorings satisfy the constraints
            numStates = len(v)
            def IsValidNeigbor(a, b):
                if a not in v or b not in v:
                    return False
                else:
                    for i in range(len(a)):
                        if a[i] == b[i]:
                            return False
                    return True
            
            adj = {i:[] for i in range(numStates)}
            for i in range(numStates):
                for j in range(i+1, numStates):
                    if IsValidNeigbor(d[i], d[j]):
                        adj[i].append(j)
                        adj[j].append(i)
            
            # then the problem becomes: finding the number of paths of length n in the constructed graph,
            # which can be done by an easy-to-understand dp.
            dp = [[0 for _ in range(n+1)] for _ in range(numStates)]
            for i in range(numStates):
                dp[i][1] = 1
            
            
            for j in range(2, n+1):
                for i in range(numStates):
                    for k in adj[i]:
                        dp[i][j] += dp[k][j-1]
                        dp[i][j] %= M
            return sum(dp[i][n] for i in range(numStates)) % M","class Solution {
 public:
  int countPairs(TreeNode* root, int distance) {
    int ans = 0;

    dfs(root, distance, ans);

    return ans;
  }

 private:
  vector<int> dfs(TreeNode* root, int distance, int& ans) {
    vector<int> d(distance + 1);  // {distance: # of leaf nodes}
    if (root == nullptr)
      return d;
    if (root->left == nullptr && root->right == nullptr) {
      d[0] = 1;
      return d;
    }

    const vector<int> dl = dfs(root->left, distance, ans);
    const vector<int> dr = dfs(root->right, distance, ans);

    for (int i = 0; i < distance; ++i)
      for (int j = 0; j < distance; ++j)
        if (i + j + 2 <= distance)
          ans += dl[i] * dr[j];

    for (int i = 0; i < distance; ++i)
      d[i + 1] = dl[i] + dr[i];

    return d;
  }
};"
"class Solution:
    def canMerge(self, trees: List[TreeNode]) -> TreeNode:
        roots, leaves, loners, n = {}, {}, set(), len(trees)
        if n == 1:
            return trees[0]
        for tree in trees:
            if not tree.left and not tree.right:
                loners.add(tree.val)
                continue
            roots[tree.val] = tree
            for node in [tree.left, tree.right]:
                if node:
                    if node.val in leaves:
                        return None
                    leaves[node.val] = node
                
        for loner in loners:
            if loner not in leaves and loner not in roots:
                return None
            
        orphan = None
        for val, tree in roots.items():
            if val not in leaves:
                if orphan:
                    return None
                orphan = tree
        if not orphan:
            return None
        
        def build(node, small, big):
            nonlocal roots
            if not node:
                return True
            if small >= node.val or node.val >= big:
                return False
            
            if node.val in roots:
                node.left, node.right = roots[node.val].left, roots[node.val].right
                del roots[node.val]
            return build(node.left, small, node.val) and build(node.right, node.val, big)
        del roots[orphan.val]
        result = build(orphan.left, -inf, orphan.val) and build(orphan.right, orphan.val, inf)
        return orphan if result and not roots.keys() else None","class Solution {
 public:
  int getLengthOfOptimalCompression(string s, int k) {
    // dp[i][k] := length of optimal compression of s[i:] w/ at most k deletion
    dp.resize(s.length(), vector<int>(k + 1, kMax));
    return compression(s, 0, k);
  }

 private:
  static constexpr int kMax = 101;
  vector<vector<int>> dp;

  int compression(const string& s, int i, int k) {
    if (k < 0)
      return kMax;
    if (i == s.length() || s.length() - i <= k)
      return 0;
    if (dp[i][k] != kMax)
      return dp[i][k];

    int maxFreq = 0;  // Max freq in s[i..j]
    vector<int> count(128);

    // Make chars in s[i..j] be same
    // Keep the char that has max freq in this range and remove other chars
    for (int j = i; j < s.length(); ++j) {
      maxFreq = max(maxFreq, ++count[s[j]]);
      dp[i][k] = min(  //
          dp[i][k],    //
          getLength(maxFreq) +
              compression(s, j + 1, k - (j - i + 1 - maxFreq)));
    }

    return dp[i][k];
  }

  int getLength(int maxFreq) {  // The length to compress `maxFreq`
    if (maxFreq == 1)
      return 1;  // C
    if (maxFreq < 10)
      return 2;  // [1-9]c
    if (maxFreq < 100)
      return 3;  // [1-9][0-9]c
    return 4;    // [1-9][0-9][0-9]c
  }
};"
"class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        t=text.split("" "")
        b=list(brokenLetters)
        print(t,b)
        ans=[]
        for i in range(len(t)):
            c=0
            for j in range(len(b)):
                if(b[j] in t[i]):
                    c+=1
                    break
            if(c==0):
                ans.append(t[i])
        return len(ans)","class Solution {
 public:
  int getWinner(vector<int>& arr, int k) {
    int ans = arr[0];
    int wins = 0;

    for (int i = 1; i < arr.size() && wins < k; ++i)
      if (arr[i] > ans) {
        ans = arr[i];
        wins = 1;
      } else {
        ++wins;
      }

    return ans;
  }
};"
"class Solution:
    def addRungs(self, rungs: List[int], dist: int) -> int:
        n = len(rungs)
        count = 0
        if dist == 1:
            if rungs[0]>1:
                count += rungs[0]-1
            for i in range(n-1):
                if rungs[i+1]-rungs[i] > 1:
                    count+= rungs[i+1]-rungs[i] - 1
            return count
        else:
            if rungs[0] > dist:
                count += (rungs[0]-1)//dist
            for i in range(n-1):
                if rungs[i+1] - rungs[i] > dist:
                    count += (rungs[i+1] - rungs[i] -1)//dist
            return count","class Solution {
 public:
  int minSwaps(vector<vector<int>>& grid) {
    const int n = grid.size();
    int ans = 0;
    // suffixZeros[i] := # of suffix zeros in i-th row
    vector<int> suffixZeros;

    for (const vector<int> row : grid) {
      const auto itLastOne = find(rbegin(row), rend(row), 1);
      const int suffixZeroCount = distance(rbegin(row), itLastOne);
      suffixZeros.push_back(suffixZeroCount);
    }

    for (int i = 0; i < n; ++i) {
      const int neededZeros = n - i - 1;
      // Get the first row w/ suffix zeros >= `neededZeros` in suffixZeros[i:].
      const auto it = find_if(begin(suffixZeros) + i, end(suffixZeros),
                              [&](int count) { return count >= neededZeros; });
      if (it == end(suffixZeros))
        return -1;
      const int j = distance(begin(suffixZeros), it);
      // Move rows[j] to rows[i].
      for (int k = j; k > i; --k)
        suffixZeros[k] = suffixZeros[k - 1];
      ans += j - i;
    }

    return ans;
  }
};"
"class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        m, n = len(points), len(points[0])
        for i in range(1, m): 
            for j in range(n-2, -1, -1): 
                points[i-1][j] = max(points[i-1][j], points[i-1][j+1]-1)
            prefix = 0 
            for j in range(n): 
                points[i][j] += max(prefix, points[i-1][j])
                prefix = max(prefix, points[i-1][j]) - 1
        return max(points[-1])","class Solution {
 public:
  int maxSum(vector<int>& nums1, vector<int>& nums2) {
    constexpr int kMod = 1'000'000'007;

    // Keep running sum of nums1 and nums2 before next rendezvous
    // Because nums1 and nums2 are increasing, move forward on the smaller one
    // To ensure we don't miss any rendezvous
    // When meet rendezvous, choose the better path
    long ans = 0;
    long sum1 = 0;  // Sum of nums1 in (prev rendezvous, next rendezvous)
    long sum2 = 0;  // Sum of nums2 in (prev rendezvous, next rendezvous)
    int i = 0;      // nums1's index
    int j = 0;      // nums2's index

    while (i < nums1.size() && j < nums2.size())
      if (nums1[i] < nums2[j]) {
        sum1 += nums1[i++];
      } else if (nums1[i] > nums2[j]) {
        sum2 += nums2[j++];
      } else {  // Rendezvous
        ans += max(sum1, sum2) + nums1[i];
        sum1 = 0;
        sum2 = 0;
        ++i;
        ++j;
      }

    while (i < nums1.size())
      sum1 += nums1[i++];

    while (j < nums2.size())
      sum2 += nums2[j++];

    return (ans + max(sum1, sum2)) % kMod;
  }
};"
"class Solution:
    def areOccurrencesEqual(self, s: str) -> bool:
        counts = list(Counter(s).values())
        return all(count == counts[0] for count in counts)","class Solution {
 public:
  int findKthPositive(vector<int>& arr, int k) {
    int l = 0;
    int r = arr.size();

    // Find the first index l s.t. nMissing(l) = A[l] - l - 1 >= k
    while (l < r) {
      const int m = (l + r) / 2;
      if (arr[m] - m - 1 >= k)
        r = m;
      else
        l = m + 1;
    }

    // The k-th missing positive
    // = A[l - 1] + k - nMissing(l - 1)
    // = A[l - 1] + k - (A[l - 1] - (l - 1) - 1)
    // = A[l - 1] + k - (A[l - 1] - l)
    // = l + k
    return l + k;
  }
};"
"class Solution:
    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:
      #track the friend of interest since we are going to 
      #sort the array later
      target_start, target_end = times[targetFriend]
	  
      #sort array by the time each friend arrive
      times.sort(key = lambda x : x[0])
	  
      #preallocate the maximum num of chairs needed
      #priority queue 1 - chairs, since we always want to
      #get the chair with smallest index
      chairs = list(range(len(times)+1))
      heapify(chairs)
	  
      #priority queue 2 - occupied, we release chairs by
      #the time they are done occupied
      occupied = []
      heapify(occupied)
	  
      for start, end in times:
        #release the chairs that has no one sitting on 
        while occupied and occupied[0][0] <= start:
          time, release = heappop(occupied)
          heappush(chairs, release)
		  
        #get the chair with smallest index
        target_chair = heappop(chairs)
		
        #if friend of interest if found, return chair index
        if start == target_start and end == target_end:
          return target_chair
        #otherwise, label this chair as occupied
        heappush(occupied, (end, target_chair))","class Solution {
 public:
  bool canConvertString(string s, string t, int k) {
    if (s.length() != t.length())
      return false;

    // E.g. s = ""aab"", t = ""bbc"", so shiftCount[1] = 3
    // For a -> b, need 1 move
    //     a -> b, need 1 + 26 moves
    //     b -> c, need 1 + 26 * 2 moves
    vector<int> shiftCount(26);

    for (int i = 0; i < s.length(); ++i)
      ++shiftCount[(t[i] - s[i] + 26) % 26];

    for (int shift = 1; shift < 26; ++shift)
      if (shift + 26 * (shiftCount[shift] - 1) > k)
        return false;

    return true;
  }
};"
"class Solution:
    def splitPainting(self, segment: List[List[int]]) -> List[List[int]]:
        f=[]
        for a,b,c in segment:
            f.append([a,c])
            f.append([b,-c])
        f.sort()
        s=0
        ft=[]
        n=len(f)
        for i in range(n-1):
            s+=f[i][1]
            if(f[i][0]!=f[i+1][0] and s!=0):
                ft.append([f[i][0],f[i+1][0],s])
        
        return ft","class Solution {
 public:
  int minInsertions(string s) {
    int neededRight = 0;   // Increment by 2 for each '('.
    int missingLeft = 0;   // Increment by 1 for each missing '('.
    int missingRight = 0;  // Increment by 1 for each missing ')'.

    for (const char c : s)
      if (c == '(') {
        if (neededRight % 2 == 1) {
          // E.g. ""()(...""
          ++missingRight;
          --neededRight;
        }
        neededRight += 2;
      } else if (--neededRight < 0) {  // c == ')'
        // E.g. ""()))...""
        ++missingLeft;
        neededRight += 2;
      }

    return neededRight + missingLeft + missingRight;
  }
};"
"class Solution:
    def canSeePersonsCount(self, heights: List[int]) -> List[int]:
        stk=[heights[-1]]
        ans=[0]*len(heights)
        for i in range(len(heights)-2,-1,-1):
            h=heights[i]
            cansee=0
            while stk and h>stk[0]:
                cansee+=1
                stk.pop(0)
            ans[i]=cansee+1 if stk else cansee
            stk.insert(0,h)
        return ans","class Solution {
 public:
  int longestAwesome(string s) {
    int ans = 0;
    int prefix = 0;  // Binary prefix
    vector<int> prefixToIndex(1024, s.length());
    prefixToIndex[0] = -1;

    for (int i = 0; i < s.length(); ++i) {
      prefix ^= 1 << s[i] - '0';
      ans = max(ans, i - prefixToIndex[prefix]);
      for (int j = 0; j < 10; ++j)
        ans = max(ans, i - prefixToIndex[prefix ^ 1 << j]);
      prefixToIndex[prefix] = min(prefixToIndex[prefix], i);
    }

    return ans;
  }
};"
"class Solution:
    def getLucky(self, s: str, k: int) -> int:
        al = {""a"":1,""b"":2,""c"":3,""d"":4,""e"":5,""f"":6,""g"":7,""h"":8,""i"":9,""j"":1,""k"":2,""l"":3,""m"":4,""n"":5,""o"":6,""p"":7,""q"":8,""r"":9,""s"":10,""t"":2,""u"":3,""v"":4,""w"":5,""x"":6,""y"":7,""z"":8}
        res, tmp = 0, 0
        for c in s:
            res += al[c]
        for _ in range(k-1):
            tmp = str(res)
            res = 0
            for char in tmp:
                res += int(char)
        return res","class Solution {
 public:
  char findKthBit(int n, int k) {
    if (n == 1)
      return '0';
    const int midIndex = pow(2, n - 1);  // 1-indexed
    if (k == midIndex)
      return '1';
    if (k < midIndex)
      return findKthBit(n - 1, k);
    return findKthBit(n - 1, midIndex * 2 - k) == '0' ? '1' : '0';
  }
};"
"class Solution:
    def maximumNumber(self, num: str, change: List[int]) -> str:
        
        res = ''
        startChange = False
        for idx,i in enumerate(num):
            val = int(i)
            if change[val] > val:
                startChange = True
                res += str(change[val])
            else:
                if startChange and not change[val] == val:
                    break
                res += str(val)
        
        return res + num[idx:] if len(res) < len(num) else res","class Solution {
 public:
  int maxNonOverlapping(vector<int>& nums, int target) {
    // Ending the subarray ASAP always has a better result.
    int ans = 0;
    int prefix = 0;
    unordered_set<int> prefixes{0};

    // Greedily find the subarrays that equal to the target.
    for (const int num : nums) {
      // Check if there is a subarray ends here and equals to the target.
      prefix += num;
      if (prefixes.count(prefix - target)) {
        // Find one and discard all the prefixes that have been used.
        ++ans;
        prefix = 0;
        prefixes = {0};
      } else {
        prefixes.insert(prefix);
      }
    }

    return ans;
  }
};"
"class Solution:
    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:
        return self.mySoldfs(students, mentors, set(), 0)
        
    def mySoldfs(self, students, mentors, hashSet, indS):
        if indS>=len(students):
            return 0
        res=0
        maxx=0
        for i in range(len(mentors)):
            if i not in hashSet:
                res = self.match(students[indS], mentors[i])
                hashSet.add(i)
                maxx = max(maxx, res+self.mySoldfs(students, mentors, hashSet, indS+1))
                hashSet.remove(i)
        return maxx
    
    def match(self, x, y):
        res=0
        i=j=0
        while(i<len(x)and j<len(y)):
            if x[i]==y[j]:
                res+=1
            i+=1;
            j+=1;
        return res","class Solution {
 public:
  int minCost(int n, vector<int>& cuts) {
    cuts.push_back(0);
    cuts.push_back(n);
    sort(begin(cuts), end(cuts));

    // dp[i][j] := minCost(cuts[i..j])
    dp.resize(cuts.size(), vector<int>(cuts.size()));
    return minCost(cuts, 0, cuts.size() - 1);
  }

 private:
  vector<vector<int>> dp;

  int minCost(const vector<int>& cuts, int i, int j) {
    if (j - i <= 1)
      return 0;
    if (dp[i][j] > 0)
      return dp[i][j];

    dp[i][j] = INT_MAX;

    for (int k = i + 1; k < j; ++k)
      dp[i][j] = min(dp[i][j], cuts[j] - cuts[i] + minCost(cuts, i, k) +
                                   minCost(cuts, k, j));

    return dp[i][j];
  }
};"
"class Solution:
    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
        leaves = []
        trie_lambda = lambda: collections.defaultdict(trie_lambda)
        trie = trie_lambda()
        trie['*'] = trie['**'] = '*'
        
        for p in paths:
            t = trie
            for f in p:
                parent, t = t, t[f]
                t['*'] = parent
                t['**'] = f
        
        def traverse(t):
            if len(t) == 2:
                leaves.append(t)
            else:
                for k, v in t.items():
                    if k[0] != '*':
                        traverse(v)
        traverse(trie)
        
        leaf_ids = set(id(leaf) for leaf in leaves)
        candidates = {id(leaf['*']):leaf['*'] for leaf in leaves}
        
        while candidates:
            new = {}
            dup = collections.defaultdict(list)
            for cand in candidates.values():
                if any(id(v) not in leaf_ids for k, v in cand.items() if k[0] != '*'):
                    continue
                dup[','.join(sorted(cand.keys()))].append(cand)
            for k, v in dup.items():
                if len(v) > 1:
                    for cand in v:
                        f = cand['**']
                        parent = cand['*']
                        del parent[f]
                        leaf_ids.add(id(parent['*' + f]))
                        new[id(parent)] = parent
            candidates = new
        path = []
        ans = []
        def dfs(t):
            for f in t:
                if f[0] != '*':
                    path.append(f)
                    ans.append(list(path))
                    dfs(t[f])
                    path.pop()
        dfs(trie)
        return ans","class Solution {
 public:
  vector<int> mostSimilar(int n, vector<vector<int>>& roads,
                          vector<string>& names, vector<string>& targetPath) {
    this->names = names;
    this->targetPath = targetPath;
    // cost[i][j] := min cost to start from names[i] in path[j]
    this->cost.resize(names.size(), vector<int>(targetPath.size(), -1));
    // next[i][j] := best next of names[i] in path[j
    this->next.resize(names.size(), vector<int>(targetPath.size()));
    this->graph.resize(n);

    for (const vector<int>& road : roads) {
      graph[road[0]].push_back(road[1]);
      graph[road[1]].push_back(road[0]);
    }

    int minDist = INT_MAX;
    int start = 0;

    for (int i = 0; i < n; ++i) {
      const int dist = dfs(i, 0);
      if (dist < minDist) {
        minDist = dist;
        start = i;
      }
    }

    vector<int> ans;

    while (ans.size() < targetPath.size()) {
      ans.push_back(start);
      start = next[start][ans.size() - 1];
    }

    return ans;
  }

 private:
  vector<string> names;
  vector<string> targetPath;
  vector<vector<int>> cost;
  vector<vector<int>> next;
  vector<vector<int>> graph;

  int dfs(int nameIndex, int pathIndex) {
    if (cost[nameIndex][pathIndex] != -1)
      return cost[nameIndex][pathIndex];

    const int editDist = names[nameIndex] != targetPath[pathIndex];
    if (pathIndex == targetPath.size() - 1)
      return editDist;

    int minDist = INT_MAX;

    for (const int v : graph[nameIndex]) {
      const int dist = dfs(v, pathIndex + 1);
      if (dist < minDist) {
        minDist = dist;
        next[nameIndex][pathIndex] = v;
      }
    }

    return cost[nameIndex][pathIndex] = editDist + minDist;
  }
};"
"class Solution:
    def isThree(self, n: int) -> bool:
        is_div = [i * (n//i) == n for i in range(2, int(math.sqrt(n))+1)]
        return sum(is_div) == 1 and is_div[-1] == 1","class Solution {
 public:
  int minOperations(int n) {
    //     median := median of arr
    //   diffs[i] := median - arr[i] where i <= i <= n / 2
    //        ans := sum(diffs)
    // E.g.
    // n = 5, arr = [1, 3, 5, 7, 9], diffs = [4, 2]
    //        ans = (4 + 2) * 2 / 2 = 6
    // n = 6, arr = [1, 3, 5, 7, 9, 11], diffs = [5, 3, 1]
    //        ans = (5 + 1) * 3 / 2 = 9
    const int halfSize = n / 2;
    const int median = (arr(n) + arr(1)) / 2;
    const int firstDiff = median - arr(1);
    const int lastDiff = median - arr(halfSize);
    return (firstDiff + lastDiff) * halfSize / 2;
  }

 private:
  // Return i-th element of arr, where 1 <= i <= n.
  int arr(int i) {
    return (i - 1) * 2 + 1;
  }
};"
"class Solution(object):
    def numberOfWeeks(self, milestones):
        """"""
        :type milestones: List[int]
        :rtype: int
        """"""
        milestones.sort()
        s = sum(milestones[:-1])
        if milestones[-1] > s:
            return s * 2 + 1
        else:
            return s + milestones[-1]","class Solution {
 public:
  bool containsCycle(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        if (seen[i][j])
          continue;
        if (dfs(grid, i, j, -1, -1, grid[i][j], seen))
          return true;
      }

    return false;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};

  bool dfs(const vector<vector<char>>& grid, int i, int j, int prevI, int prevJ,
           char c, vector<vector<bool>>& seen) {
    seen[i][j] = true;

    for (int k = 0; k < 4; ++k) {
      const int x = i + dirs[k];
      const int y = j + dirs[k + 1];
      if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())
        continue;
      if (x == prevI && y == prevJ)
        continue;
      if (grid[x][y] != c)
        continue;
      if (seen[x][y])
        return true;
      if (dfs(grid, x, y, i, j, c, seen))
        return true;
    }

    return false;
  }
};"
"class Solution:
    def minimumPerimeter(self, neededApples: int) -> int:
        total=0
        for i in range(neededApples):
            total+=12*(i+1)*(i+1)
            if total>=neededApples:
                return 8*(i+1)","class Solution {
 public:
  int stoneGameV(vector<int>& stoneValue) {
    const int n = stoneValue.size();
    // dp[i][j] := max score that Alice can obtain from stoneValue[i..j]
    dp.resize(n, vector<int>(n, INT_MIN));
    prefix.resize(n + 1);

    partial_sum(begin(stoneValue), end(stoneValue), begin(prefix) + 1);
    return stoneGameV(stoneValue, 0, n - 1);
  }

 private:
  vector<vector<int>> dp;
  vector<int> prefix;

  int stoneGameV(const vector<int>& stoneValue, int i, int j) {
    if (i == j)
      return 0;
    if (dp[i][j] > 0)
      return dp[i][j];

    // Try all possible partitions
    for (int p = i; p < j; ++p) {
      // Sum of stoneValue[i..p]
      const int leftSum = prefix[p + 1] - prefix[i];
      const int throwRight = leftSum + stoneGameV(stoneValue, i, p);
      // Sum of stoneValue[p + 1..j]
      const int rightSum = prefix[j + 1] - prefix[p + 1];
      const int throwLeft = rightSum + stoneGameV(stoneValue, p + 1, j);
      if (leftSum < rightSum)  // Bob throws right row
        dp[i][j] = max(dp[i][j], throwRight);
      else if (leftSum > rightSum)  // Bob throws left row
        dp[i][j] = max(dp[i][j], throwLeft);
      else  // Alice decide which row to throw
        dp[i][j] = max({dp[i][j], throwLeft, throwRight});
    }

    return dp[i][j];
  }
};"
"class Solution:
    def countSpecialSubsequences(self, nums: List[int]) -> int:
        MOD = 1_000_000_007 
        s0 = s1 = s2 = 0 
        for x in nums: 
            if x == 0: s0 = (1 + 2*s0) % MOD
            elif x == 1: s1 = (s0 + 2*s1) % MOD
            else: s2 = (s1 + 2*s2) % MOD
        return s2","class Solution {
 public:
  int numOfWays(vector<int>& nums) {
    comb = generate(nums.size() + 1);
    return ways(nums) - 1;
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  // comb[n][k] := C(n, k)
  vector<vector<int>> comb;

  int ways(const vector<int>& nums) {
    if (nums.size() <= 2)
      return 1;

    vector<int> left;
    vector<int> right;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] < nums[0])
        left.push_back(nums[i]);
      else
        right.push_back(nums[i]);

    long ans = comb[nums.size() - 1][left.size()];
    ans = (ans * ways(left)) % kMod;
    ans = (ans * ways(right)) % kMod;
    return ans;
  }

  // 118. Pascal's Triangle
  vector<vector<int>> generate(int numRows) {
    vector<vector<int>> comb;

    for (int i = 0; i < numRows; ++i)
      comb.push_back(vector<int>(i + 1, 1));

    for (int i = 2; i < numRows; ++i)
      for (int j = 1; j < comb[i].size() - 1; ++j)
        comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % kMod;

    return comb;
  }
};"
"class Solution:
    def makeFancyString(self, s: str) -> str:
        fancy = []
        for idx in range(len(s)):
            if idx < 2 or not s[idx] == s[idx-1] == s[idx-2]:
                fancy.append(s[idx])
        return """".join(fancy)","class SparseVector {
 public:
  SparseVector(vector<int>& nums) {
    for (int i = 0; i < nums.size(); ++i)
      if (nums[i])
        indexToNum[i] = nums[i];
  }

  // Return the dotProduct of two sparse vectors
  int dotProduct(SparseVector& vec) {
    if (indexToNum.size() < vec.indexToNum.size())
      return vec.dotProduct(*this);

    int ans = 0;

    for (const auto& [index, num] : vec.indexToNum)
      if (const auto it = indexToNum.find(index); it != cend(indexToNum))
        ans += num * it->second;

    return ans;
  }

 private:
  unordered_map<int, int> indexToNum;  // {index: num}
};"
"class Solution:
    def maxProduct(self, s: str) -> int:
        n = len(s)
        
        # Manacher's algo
        hlen = [0]*n # half-length
        center = right = 0 
        for i in range(n): 
            if i < right: hlen[i] = min(right - i, hlen[2*center - i])
            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: 
                hlen[i] += 1
            if right < i+hlen[i]: center, right = i, i+hlen[i]
        
        prefix = [0]*n
        suffix = [0]*n
        for i in range(n): 
            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)
            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)
        
        for i in range(1, n): 
            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)
            suffix[i] = max(suffix[i], suffix[i-1]-2)
        
        for i in range(1, n): 
            prefix[i] = max(prefix[i-1], prefix[i])
            suffix[~i] = max(suffix[~i], suffix[~i+1])
        
        return max(prefix[i-1]*suffix[i] for i in range(1, n))","class Solution {
 public:
  int unhappyFriends(int n, vector<vector<int>>& preferences,
                     vector<vector<int>>& pairs) {
    int ans = 0;
    vector<int> matches(n);
    vector<unordered_map<int, int>> prefer(n);

    for (const vector<int>& pair : pairs) {
      const int x = pair[0];
      const int y = pair[1];
      matches[x] = y;
      matches[y] = x;
    }

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n - 1; ++j)
        prefer[i][preferences[i][j]] = j;

    for (int x = 0; x < n; ++x)
      for (const auto& [u, _] : prefer[x]) {
        const int y = matches[x];
        const int v = matches[u];
        if (prefer[x][u] < prefer[x][y] && prefer[u][x] < prefer[u][v]) {
          ++ans;
          break;
        }
      }

    return ans;
  }
};"
"class Solution:
    def isPrefixString(self, s: str, words: List[str]) -> bool:
        n = len(s)
        m = 0
        c = """"
        for i in words:
            m+=len(i)
            c+=i
            if m > n:
                return False
            elif m == n and s == c:
                return True
        return False","class Solution {
 public:
  string reorderSpaces(string text) {
    const int spaces = count(begin(text), end(text), ' ');
    string ans;
    vector<string> words;

    istringstream iss(text);
    string word;

    while (iss >> word)
      words.push_back(word);

    if (words.size() == 1)
      return word + string(spaces, ' ');

    const int gapSize = spaces / (words.size() - 1);
    const int remains = spaces % (words.size() - 1);

    for (int i = 0; i < words.size() - 1; ++i)
      ans += words[i] + string(gapSize, ' ');
    ans += words.back() + string(remains, ' ');

    return ans;
  }
};"
"class Solution:
def minStoneSum(self, piles: List[int], k: int) -> int:
    
    local = [-p for p in piles]
    heapq.heapify(local)
    for i in range(k):
        tmp = -1*heapq.heappop(local)
        tmp = (tmp+1)//2
        heapq.heappush(local,-tmp)
    
    return -sum(local)","class Solution {
 public:
  int maxUniqueSplit(string s) {
    size_t ans = 0;
    dfs(s, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int start, unordered_set<string>&& seen,
           size_t& ans) {
    if (start == s.length()) {
      ans = max(ans, seen.size());
      return;
    }

    for (int i = 1; start + i <= s.length(); ++i) {
      const string cand = s.substr(start, i);
      if (seen.count(cand))
        continue;
      seen.insert(cand);
      dfs(s, start + i, move(seen), ans);
      seen.erase(cand);
    }
  }
};"
"class Solution:
    def minSwaps(self, s: str) -> int:
        return (reduce(lambda mismatch, ch: mismatch + (-1 if (mismatch > 0 and ch == ']') else 1), s, 0) + 1) // 2","class Solution {
 public:
  int maxProductPath(vector<vector<int>>& grid) {
    constexpr int kMod = 1'000'000'007;
    const int m = grid.size();
    const int n = grid[0].size();
    // dpMin[i][j] := the min product from (0, 0) to (i, j)
    // dpMax[i][j] := the max product from (0, 0) to (i, j)
    vector<vector<long>> dpMin(m, vector<long>(n));
    vector<vector<long>> dpMax(m, vector<long>(n));

    dpMin[0][0] = dpMax[0][0] = grid[0][0];

    for (int i = 1; i < m; ++i)
      dpMin[i][0] = dpMax[i][0] = dpMin[i - 1][0] * grid[i][0];

    for (int j = 1; j < n; ++j)
      dpMin[0][j] = dpMax[0][j] = dpMin[0][j - 1] * grid[0][j];

    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        if (grid[i][j] < 0) {
          dpMin[i][j] = max(dpMax[i - 1][j], dpMax[i][j - 1]) * grid[i][j];
          dpMax[i][j] = min(dpMin[i - 1][j], dpMin[i][j - 1]) * grid[i][j];
        } else {
          dpMin[i][j] = min(dpMin[i - 1][j], dpMin[i][j - 1]) * grid[i][j];
          dpMax[i][j] = max(dpMax[i - 1][j], dpMax[i][j - 1]) * grid[i][j];
        }

    const long maxi = max(dpMin.back().back(), dpMax.back().back());
    return maxi < 0 ? -1 : maxi % kMod;
  }
};"
"class Solution:
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        ans, vals = [], []
        for i, x in enumerate(obstacles): 
            k = bisect_right(vals, x)
            ans.append(k+1)
            if k == len(vals): vals.append(x)
            else: vals[k] = x
        return ans","class Solution {
 public:
  Node* expTree(string s) {
    stack<Node*> nodes;  // Stores nodes (new Node(val)).
    stack<char> ops;     // Stores operators and parentheses.

    for (const char c : s)
      if (isdigit(c)) {
        nodes.push(new Node(c));
      } else if (c == '(') {
        ops.push(c);
      } else if (c == ')') {
        while (ops.top() != '(')
          nodes.push(buildNode(pop(ops), pop(nodes), pop(nodes)));
        ops.pop();  // Remove '('.
      } else if (c == '+' || c == '-' || c == '*' || c == '/') {
        while (!ops.empty() && compare(ops.top(), c))
          nodes.push(buildNode(pop(ops), pop(nodes), pop(nodes)));
        ops.push(c);
      }

    while (!ops.empty())
      nodes.push(buildNode(pop(ops), pop(nodes), pop(nodes)));

    return nodes.top();
  }

 private:
  Node* buildNode(char op, Node* right, Node* left) {
    return new Node(op, left, right);
  }

  // Returns true if op1 is a operator and priority(op1) >= priority(op2)
  bool compare(char op1, char op2) {
    if (op1 == '(' || op1 == ')')
      return false;
    return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-';
  }

  char pop(stack<char>& ops) {
    const char op = ops.top();
    ops.pop();
    return op;
  }

  Node* pop(stack<Node*>& nodes) {
    Node* node = nodes.top();
    nodes.pop();
    return node;
  }
};"
"class Solution:
    def numOfStrings(self, patterns: List[str], word: str) -> int:
        count=0
        for i in range(len(patterns)):
            if patterns[i] in word:
                count+=1
        return count","class Solution {
 public:
  int minOperations(vector<string>& logs) {
    int ans = 0;

    for (const string& log : logs) {
      if (log == ""./"")
        continue;
      if (log == ""../"")
        ans = max(0, ans - 1);
      else
        ++ans;
    }

    return ans;
  }
};"
"class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        for i in range(1, len(nums)-1): 
            if nums[i-1] < nums[i] < nums[i+1] or nums[i-1] > nums[i] > nums[i+1]: 
                nums[i], nums[i+1] = nums[i+1], nums[i]
        return nums","class Solution {
 public:
  int minOperationsMaxProfit(vector<int>& customers, int boardingCost,
                             int runningCost) {
    int waiting = 0;
    int profit = 0;
    int maxProfit = 0;
    int rotate = 0;
    int maxRotate = -1;
    int i = 0;

    while (waiting > 0 || i < customers.size()) {
      if (i < customers.size())
        waiting += customers[i++];
      // Onboard new customers
      const int newOnboard = min(waiting, 4);
      waiting -= newOnboard;
      profit += newOnboard * boardingCost - runningCost;
      ++rotate;
      if (profit > maxProfit) {
        maxProfit = profit;
        maxRotate = rotate;
      }
    }

    return maxRotate;
  }
};"
"class Solution:
    def minNonZeroProduct(self, p: int) -> int:
        MOD = 10 ** 9 + 7
        res = pow(pow(2, p, MOD) - 2, pow(2, (p - 1)) - 1, MOD) * (pow(2, p, MOD) - 1)
        return int(res) % MOD","class ThroneInheritance {
 public:
  ThroneInheritance(string kingName) : kingName(kingName) {}

  void birth(string parentName, string childName) {
    family[parentName].push_back(childName);
  }

  void death(string name) {
    dead.insert(name);
  }

  vector<string> getInheritanceOrder() {
    vector<string> ans;
    dfs(kingName, ans);
    return ans;
  }

 private:
  unordered_set<string> dead;
  unordered_map<string, vector<string>> family;
  string kingName;

  void dfs(const string& name, vector<string>& ans) {
    if (!dead.count(name))
      ans.push_back(name);
    if (!family.count(name))
      return;

    for (const string& child : family[name])
      dfs(child, ans);
  }
};"
"class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        _board = [[0 for _ in range(col)] for _ in range(row)]
        board = None
        
        def search(days):
            def dfs(x, y):
                res = False
                for _x, _y in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
                    if not (0 <= _x < row and 0 <= _y < col):
                        continue
                    if board[_x][_y]:
                        continue
                    if _x == row - 1:
                        return True
                    board[_x][_y] = 1
                    res |= dfs(_x, _y)
                return res
            
            flood(days)
            for j in range(col):
                if not board[0][j]:
                    board[0][j] = 1
                    if dfs(0, j):
                        return True
            return False
        
        def flood(days):
            nonlocal board
            board = deepcopy(_board)
            for i in range(days):
                board[cells[i][0] - 1][cells[i][1] - 1] = 1
        
        l, r = 0, len(cells)
        while l < r:
            mid = l + (r - l) // 2
            if search(mid):
                l = mid + 1
            else:
                r = mid
        return l - 1","class Solution {
 public:
  int maximumRequests(int n, vector<vector<int>>& requests) {
    int ans = 0;
    vector<int> degree(n);  // degree[i] := degree of building i

    function<void(int, int)> dfs = [&](int i, int processedReqs) {
      if (i == requests.size()) {
        if (all_of(begin(degree), end(degree), [](int d) { return d == 0; }))
          ans = max(ans, processedReqs);
        return;
      }

      // Skip requests[i]
      dfs(i + 1, processedReqs);

      // Process requests[i]
      --degree[requests[i][0]];
      ++degree[requests[i][1]];
      dfs(i + 1, processedReqs + 1);
      --degree[requests[i][1]];
      ++degree[requests[i][0]];
    };

    dfs(0, 0);

    return ans;
  }
};"
"class Solution:
    def validPath(self, n: int, edges: List[List[int]], start: int, end: int) -> bool:
        if start == end: return True
        if len(edges) == 0: return False
        
        adj = [set() for _ in range(n)]
        seen = set()
        for u, v in edges:
            adj[u].add(v)
            adj[v].add(u)
        queue = []
        queue.append(start)
        while len(queue)>0:
            st = queue.pop(0)
            if st == end:
                return True
            if st not in seen: 
                queue += list(adj[st])
            seen.add(st)
        return False","class ParkingSystem {
 public:
  ParkingSystem(int big, int medium, int small) {
    count = {big, medium, small};
  }

  bool addCar(int carType) {
    return count[carType - 1]-- > 0;
  }

 private:
  vector<int> count;
};"
"class Solution:
def minTimeToType(self, word: str) -> int:
    count = 0
    curr = ""a""
    
    for i in word:
        t = abs(ord(i)-ord(curr))
        if t <= 12:
            count += 1 + t
            curr = i
        else:
            count += 1 + 26 - t
            curr = i
    
    return count","class Solution {
 public:
  vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {
    vector<int> ans;
    vector<int> times(k);
    set<int> idleServers;
    // (endTime, server)
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;

    for (int i = 0; i < k; ++i)
      idleServers.insert(i);

    for (int i = 0; i < arrival.size(); ++i) {
      // Pop all servers that are available now.
      while (!minHeap.empty() && minHeap.top().first <= arrival[i]) {
        idleServers.insert(minHeap.top().second);
        minHeap.pop();
      }
      // Get next available server.
      const int server = getNextAvailableServer(idleServers, i, k);
      if (server == -1)
        continue;
      ++times[server];
      minHeap.emplace(arrival[i] + load[i], server);
      idleServers.erase(server);
    }

    const int busiest = *max_element(begin(times), end(times));
    for (int i = 0; i < k; ++i)
      if (times[i] == busiest)
        ans.push_back(i);
    return ans;
  }

 private:
  int getNextAvailableServer(const set<int>& idleServers, int ithRequest,
                             int k) {
    if (idleServers.empty())
      return -1;
    const auto it = idleServers.lower_bound(ithRequest % k);
    return it == cend(idleServers) ? *begin(idleServers) : *it;
  }
};"
"class Solution(object):
    def maxMatrixSum(self, matrix):
        """"""
        :type matrix: List[List[int]]
        :rtype: int
        """"""
        n = len(matrix)
        s = 0 
        s_abs = 0 
        neg = 0 
        maxneg = float('-inf')
        minabs = float('inf')
        for i in range(n):
            for j in range(n):
                s += matrix[i][j]
                s_abs += abs(matrix[i][j])
                if matrix[i][j] <= 0:
                    neg += 1
                if abs(matrix[i][j]) < abs(minabs):
                    minabs = matrix[i][j]
       
        if neg % 2 == 0:
            return s_abs
        else:
            return s_abs - 2*abs(minabs)","class Solution {
 public:
  int visiblePoints(vector<vector<int>>& points, int angle,
                    vector<int>& location) {
    const int posX = location[0];
    const int posY = location[1];
    int maxVisible = 0;
    int same = 0;
    vector<double> pointAngles;

    for (const vector<int>& p : points) {
      const int x = p[0];
      const int y = p[1];
      if (x == posX && y == posY)
        ++same;
      else
        pointAngles.push_back(getAngle(y - posY, x - posX));
    }

    sort(begin(pointAngles), end(pointAngles));

    const int n = pointAngles.size();
    for (int i = 0; i < n; ++i)
      pointAngles.push_back(pointAngles[i] + 360);

    for (int l = 0, r = 0; r < pointAngles.size(); ++r) {
      while (pointAngles[r] - pointAngles[l] > angle)
        ++l;
      maxVisible = max(maxVisible, r - l + 1);
    }

    return maxVisible + same;
  }

 private:
  double getAngle(int dy, int dx) {
    return atan2(dy, dx) * 180 / M_PI;
  }
};"
"class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        g = defaultdict(set)
        deg = [0] * n
        for u, v, t in roads:
            if u > v:
                u, v = v, u
            g[u].add((v, t))
            deg[v] += 1

        vis = defaultdict(lambda: float('inf'), {0: 0})
        q = [(0, 0)]
        ways = [0] * n
        ways[0] = 1
        while q:
            t, cur = heappop(q)
            for nei, nei_t in g[cur]:
                deg[nei] -= 1
                if vis[nei] > t + nei_t:
                    vis[nei] = t + nei_t
                    ways[nei] = ways[cur]
                elif vis[nei] == t + nei_t:
                    ways[nei] += ways[cur]
                
                # only traverse if degree = 0 or spent time starts to exceed minimum
                if deg[nei] == 0 or vis[nei] < t + nei_t:
                    if nei == n - 1 and deg[nei] == 0:
                        return ways[-1] % (10 ** 9 + 7)
                    heappush(q, (vis[nei], nei))
        
        return ways[-1]","class Solution {
 public:
  string findLexSmallestString(string s, int a, int b) {
    string ans = s;

    dfs(s, a, b, {}, ans);

    return ans;
  }

 private:
  void dfs(string s, int a, int b, unordered_set<string>&& seen, string& ans) {
    if (seen.count(s))
      return;

    seen.insert(s);
    ans = min(ans, s);

    dfs(add(s, a), a, b, move(seen), ans);
    dfs(rotate(s, b), a, b, move(seen), ans);
  }

  string add(string& s, int a) {
    for (int i = 1; i < s.length(); i += 2)
      s[i] = '0' + (s[i] - '0' + a) % 10;
    return s;
  }

  string rotate(const string& s, int b) {
    const int n = s.length();
    return s.substr(n - b, n) + s.substr(0, n - b);
  }
};"
"class Solution:
    def numberOfCombinations(self, num: str) -> int:
        n = len(num)
        lcs = [[0]*(n+1) for _ in range(n)]
        for i in reversed(range(n)): 
            for j in reversed(range(i+1, n)): 
                if num[i] == num[j]: lcs[i][j] = 1 + lcs[i+1][j+1]
        
        def cmp(i, j, d): 
            """"""Return True if """"""
            m = lcs[i][j]
            if m >= d: return True 
            return num[i+m] <= num[j+m]
        
        dp = [[0]*(n+1) for _ in range(n)]
        for i in range(n): 
            if num[i] != ""0"": 
                for j in range(i+1, n+1): 
                    if i == 0: dp[i][j] = 1
                    else: 
                        dp[i][j] = dp[i][j-1]
                        if 2*i-j >= 0 and cmp(2*i-j, i, j-i): dp[i][j] += dp[2*i-j][i]
                        if 2*i-j+1 >= 0 and not cmp(2*i-j+1, i, j-i-1): dp[i][j] += dp[2*i-j+1][i]
        return sum(dp[i][n] for i in range(n)) % 1_000_000_007","struct Player {
  int age;
  int score;
  Player(int age, int score) : age(age), score(score) {}
};

class Solution {
 public:
  int bestTeamScore(vector<int>& scores, vector<int>& ages) {
    const int n = scores.size();
    vector<Player> players;
    // dp[i] := max score of choosing players[0..i] w/ players[i] being selected
    vector<int> dp(n);

    for (int i = 0; i < n; ++i)
      players.emplace_back(ages[i], scores[i]);

    sort(begin(players), end(players), [](const auto& a, const auto& b) {
      return a.age == b.age ? a.score > b.score : a.age > b.age;
    });

    for (int i = 0; i < n; ++i) {
      // For each player, we choose it first
      dp[i] = players[i].score;
      // players[j].age >= players[i].age since we sort in descending order
      // So we only have to check that
      // players[j].score >= players[i].score
      for (int j = 0; j < i; ++j)
        if (players[j].score >= players[i].score)
          dp[i] = max(dp[i], dp[j] + players[i].score);
    }

    return *max_element(begin(dp), end(dp));
  }
};"
"class Solution:
    def findDifferentBinaryString(self, nums: List[str]) -> str:
        n = len(nums[0])
        for i in range(len(nums)):
            nums[i] = int(nums[i],2)
        for i in range(2**n):
            if i not in nums:
                return bin(i)[2:].zfill(n)","struct T {
  int i;
  int j;
  int d;
  T(int i, int j, int d) : i(i), j(j), d(d) {}
};

class Solution {
 public:
  int minimumEffortPath(vector<vector<int>>& heights) {
    const int m = heights.size();
    const int n = heights[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    auto compare = [](const T& a, const T& b) { return a.d > b.d; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    // diff[i][j] := max absolute difference to reach (i, j).
    vector<vector<int>> diff(m, vector<int>(n, INT_MAX));
    vector<vector<bool>> seen(m, vector<bool>(n));

    minHeap.emplace(0, 0, 0);
    diff[0][0] = 0;

    while (!minHeap.empty()) {
      const auto [i, j, d] = minHeap.top();
      minHeap.pop();
      if (i == m - 1 && j == n - 1)
        return d;
      seen[i][j] = true;
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        const int newDiff = abs(heights[i][j] - heights[x][y]);
        const int maxDiff = max(diff[i][j], newDiff);
        if (diff[x][y] > maxDiff) {
          diff[x][y] = maxDiff;
          minHeap.emplace(x, y, maxDiff);
        }
      }
    }

    throw;
  }
};"
"class Solution:
    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:
        mask = 0b1
        for row in mat: 
            temp = 0
            for x in row: temp |= mask << x
            mask = temp 
        
        for x in range(5000): 
            if mask >> (target+x) &amp; 1 or x <= target and mask >> (target-x) &amp; 1: return x","class Solution {
 public:
  int countVowelStrings(int n) {
    // dp[0] := # of lexicographically sorted strings ends with 'a'
    // dp[1] := # of lexicographically sorted strings ends with 'e'
    // dp[2] := # of lexicographically sorted strings ends with 'i'
    // dp[3] := # of lexicographically sorted strings ends with 'o'
    // dp[4] := # of lexicographically sorted strings ends with 'u'
    vector<int> dp(5, 1);

    for (int i = 2; i <= n; ++i) {
      vector<int> newDp(5);
      for (int j = 0; j < 5; ++j)
        for (int k = 0; k <= j; ++k)
          newDp[j] += dp[k];
      dp = move(newDp);
    }

    return accumulate(begin(dp), end(dp), 0);
  }
};"
"class Solution:
    def recoverArray(self, n: int, sums: List[int]) -> List[int]:
        sums.sort()
        ans = []
        for _ in range(n): 
            diff = sums[1] - sums[0]
            ss0, ss1 = [], []
            freq = defaultdict(int)
            on = False 
            for i, x in enumerate(sums): 
                if not freq[x]: 
                    ss0.append(x)
                    freq[x+diff] += 1
                    if x == 0: on = True 
                else: 
                    ss1.append(x)
                    freq[x] -= 1
            if on: 
                ans.append(diff)
                sums = ss0 
            else: 
                ans.append(-diff)
                sums = ss1
        return ans","class Solution {
 public:
  int furthestBuilding(vector<int>& heights, int bricks, int ladders) {
    priority_queue<int, vector<int>, greater<int>> minHeap;

    for (int i = 1; i < heights.size(); ++i) {
      const int diff = heights[i] - heights[i - 1];
      if (diff <= 0)
        continue;
      minHeap.push(diff);
      // When we run out of ladders, greedily use as less bricks as possible.
      if (minHeap.size() > ladders)
        bricks -= minHeap.top(), minHeap.pop();
      if (bricks < 0)
        return i - 1;
    }

    return heights.size() - 1;
  }
};"
"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        

        minimal=float('inf')
        
        counter=defaultdict(int)

        maximum=float('-inf')
        minimum=float('inf')
        sortedArray=[]
        for num in nums:
            counter[num]+=1
            maximum=max(num,maximum)
            minimum=min(num,minimum)

        for i in range(minimum, maximum+1):
            if i in counter:
                while counter[i]:
                    sortedArray.append(i)
                    counter[i]-=1

        first=0
        second=k-1
        
        while second < len(sortedArray):
            minimal=min(minimal,sortedArray[second]-sortedArray[first])
            first+=1
            second+=1
            
        return minimal","class Solution {
 public:
  int minDeletions(string s) {
    int ans = 0;
    vector<int> count(26);
    unordered_set<int> usedFreq;

    for (const char c : s)
      ++count[c - 'a'];

    for (int freq : count)
      while (freq > 0 && !usedFreq.insert(freq).second) {
        --freq;  // Delete ('a' + i).
        ++ans;
      }

    return ans;
  }
};"
"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        for i in range(len(nums)):
            nums[i] = int(nums[i])
        nums.sort()
        nums.reverse()
        return str(nums[k-1])","class Solution {
 public:
  bool closeStrings(string word1, string word2) {
    if (word1.length() != word2.length())
      return false;

    unordered_map<char, int> count1;
    unordered_map<char, int> count2;
    string s1;           // Unique chars in word1
    string s2;           // Unique chars in word2
    vector<int> freqs1;  // Freqs of unique chars in word1
    vector<int> freqs2;  // Freqs of unique chars in word2

    for (const char c : word1)
      ++count1[c];

    for (const char c : word2)
      ++count2[c];

    for (const auto& [c, freq] : count1) {
      s1 += c;
      freqs1.push_back(freq);
    }

    for (const auto& [c, freq] : count2) {
      s2 += c;
      freqs2.push_back(freq);
    }

    sort(begin(s1), end(s1));
    sort(begin(s2), end(s2));

    if (s1 != s2)
      return false;

    sort(begin(freqs1), end(freqs1));
    sort(begin(freqs2), end(freqs2));
    return freqs1 == freqs2;
  }
};"
"class Solution:
    def minSessions(self, tasks: List[int], sessionTime: int) -> int:
        n = len(tasks)

        @lru_cache(None)
        def dp(mask, t):
            if mask == (1 << n) - 1:
                return 0
            ans = n
            for i in range(n):
                if mask &amp; (1 << i): continue
                if tasks[i] > t:
                    ans = min(ans, 1 + dp(mask ^ (1 << i), sessionTime - tasks[i]))
                else:
                    ans = min(ans, dp(mask ^ (1 << i), t - tasks[i]))
            return ans

        return dp(0, 0)","class Solution {
 public:
  int waysToMakeFair(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    vector<int> even(n + 1);  // Sum of even-indexed nums[0..i)
    vector<int> odd(n + 1);   // Sum of odd-indexed nums[0..i)

    for (int i = 1; i <= n; ++i) {
      odd[i] = odd[i - 1];
      even[i] = even[i - 1];
      if (i % 2 == 0)
        even[i] += nums[i - 1];
      else
        odd[i] += nums[i - 1];
    }

    const int sum = even.back() + odd.back();

    for (int i = 0; i < n; ++i) {
      const int evenSum = even[i] + odd.back() - odd[i + 1];
      const int oddSum = sum - nums[i] - evenSum;
      if (evenSum == oddSum)
        ++ans;
    }

    return ans;
  }
};"
"class Solution:
    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
        f0 = f1 = 0
        for ch in binary: 
            if ch == ""0"": f0 += f1
            else: f1 += f0 + 1
        return (f0 + f1 + int(""0"" in binary)) % 1_000_000_007","class Solution {
 public:
  Node* flipBinaryTree(Node* root, Node* leaf) {
    return reroot(root, leaf, nullptr);
  }

 private:
  Node* reroot(Node* root, Node* node, Node* newParent) {
    Node* oldParent = node->parent;
    node->parent = newParent;

    // Clean up the child if it's the new parent
    if (node->left == newParent)
      node->left = nullptr;
    if (node->right == newParent)
      node->right = nullptr;

    // We meet the original root, so we're done
    if (node == root)
      return node;

    if (node->left)
      node->right = node->left;
    node->left = reroot(root, oldParent, node);

    return node;
  }
};"
"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        right = sum(nums)
        left = 0 
        for i in range(len(nums)):
            right -= nums[i]
            if left == right:
                return i
            left += nums[i]

        return -1","class Solution {
 public:
  int minimumMountainRemovals(vector<int>& nums) {
    vector<int> l = lengthOfLIS(nums);
    vector<int> r = reversed(lengthOfLIS(reversed(nums)));
    int maxMountainSeq = 0;

    for (int i = 0; i < nums.size(); ++i)
      if (l[i] > 1 && r[i] > 1)
        maxMountainSeq = max(maxMountainSeq, l[i] + r[i] - 1);

    return nums.size() - maxMountainSeq;
  }

 private:
  vector<int> lengthOfLIS(vector<int> nums) {
    // tail[i] := the minimum tail of all increasing subseqs having length i + 1
    // it's easy to see that tail must be an increasing array
    vector<int> tail;

    // dp[i] := Length of LIS ending at nums[i]
    vector<int> dp(nums.size());

    for (int i = 0; i < nums.size(); ++i) {
      const int num = nums[i];
      if (tail.empty() || num > tail.back()) {
        tail.push_back(num);
      } else {
        int l = 0;
        int r = tail.size();
        // Find the first index l in tail s.t. tail[l] >= num
        while (l < r) {
          const int m = (l + r) / 2;
          if (tail[m] >= num)
            r = m;
          else
            l = m + 1;
        }
        tail[l] = num;
      }
      dp[i] = tail.size();
    }

    return dp;
  }

  vector<int> reversed(const vector<int>& nums) {
    return {rbegin(nums), rend(nums)};
  }
};"
"class Solution:
def findFarmland(self, land: List[List[int]]) -> List[List[int]]:
    
    m=len(land)
    n=len(land[0])
    def dfs(i,j,ei,ej):
        nonlocal ex,ey
        if i<0 or j<0 or i>=m or j>=n or land[i][j]==0:
            return
        ex=max(i,ei)
        ey=max(j,ej)
        land[i][j]=0
        dfs(i+1,j,ex,ey)
        dfs(i,j+1,ex,ey)
        dfs(i,j-1,ex,ey)
        dfs(i-1,j,ex,ey)
        
    res=[]
    for x in range(m):
        for y in range(n):
            if land[x][y]==1:
                ex,ey = x,y
                dfs(x,y,ex,ey)
                res.append([x,y,ex,ey])
    
    return res","class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*>& nodes) {
    unordered_set<TreeNode*> nodesSet{begin(nodes), end(nodes)};
    return lca(root, nodesSet);
  }

 private:
  TreeNode* lca(TreeNode* root, unordered_set<TreeNode*>& nodesSet) {
    if (root == nullptr)
      return nullptr;
    if (nodesSet.count(root))
      return root;

    TreeNode* l = lca(root->left, nodesSet);
    TreeNode* r = lca(root->right, nodesSet);

    if (l && r)
      return root;
    return l ? l : r;
  }
};"
"class Solution:
    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

        cands = {}
        for x in range(1, 31):
            orig = x
            mask = 0
            for p in primes:
                if x % p: continue
                if p > x: break
                x //= p
                mask ^= (1 << p)
            if x == 1:
                cands[orig] = mask


        cnt = {k: v for k, v in Counter(nums).items() if k in cands}
        cnt_key = list(filter(lambda x: x> 1, sorted(cnt)))
        n = len(cnt_key)
        M = 10**9 + 7
        
        @lru_cache(None)
        def dp(i, mask):
            if i == n:
                return mask > 0
            ans = dp(i+1, mask)
            if mask &amp; cands[cnt_key[i]] == 0:
                ans += cnt[cnt_key[i]] * dp(i+1, mask ^ cands[cnt_key[i]])
            return ans % M
        
        return (dp(0, 0) * pow(2, cnt.get(1, 0))) % M","class Solution {
 public:
  int longestPalindromeSubseq(string s) {
    const int n = s.length();
    // dp[i][j][k] := LPS's length in s[i..j] w/ previous char = 'a' + k
    dp.resize(n, vector<vector<int>>(n, vector<int>(27)));
    return lps(s, 0, n - 1, 26);
  }

 private:
  vector<vector<vector<int>>> dp;

  int lps(const string& s, int i, int j, int k) {
    if (i >= j)
      return 0;
    if (dp[i][j][k] > 0)
      return dp[i][j][k];

    if (s[i] == s[j] && s[i] != 'a' + k)
      dp[i][j][k] = lps(s, i + 1, j - 1, s[i] - 'a') + 2;
    else
      dp[i][j][k] = max(lps(s, i + 1, j, k), lps(s, i, j - 1, k));

    return dp[i][j][k];
  }
};"
"class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        idx = defaultdict(list)
        for i, n in enumerate(nums):
            idx[n].append(i)
        
        count = 0 
        for i in range(len(nums)-3):
            for j in range(i+1, len(nums)-2):
                for k in range(j+1, len(nums)-1):
                    s = nums[i] + nums[j] + nums[k]
                    count += sum(l > k for l in idx[s])
                        
        return count","class Solution {
 public:
  int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {
    const int n = aliceValues.size();
    vector<vector<int>> values;
    int a = 0;
    int b = 0;

    for (int i = 0; i < n; ++i)
      values.push_back({aliceValues[i], bobValues[i]});

    sort(begin(values), end(values), [](const auto& a, const auto& b) {
      return a[0] + a[1] > b[0] + b[1];
    });

    for (int i = 0; i < n; ++i)
      if (i % 2 == 0)
        a += values[i][0];
      else
        b += values[i][1];

    return a > b ? 1 : a < b ? -1 : 0;
  }
};"
"class Solution:
    def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:
        if not properties:
            return 0
        
        properties.sort(key = lambda x: (x[0], -x[1]))
        
        stack = []
        size = len(properties)
        
        for i in range(size):
            defen = properties[i][-1]
            if not stack:
                stack.append(defen)
            else:
                while stack and defen > stack[-1]:
                    stack.pop()
                    
                stack.append(defen)
        
        return size - len(stack)","class Solution {
 public:
  int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes,
                    int maxWeight) {
    const int n = boxes.size();
    // dp[i] := min trips to deliver boxes[0..i) and return to the storage
    vector<int> dp(n + 1);
    int trips = 2;
    int weight = 0;

    for (int l = 0, r = 0; r < n; ++r) {
      weight += boxes[r][1];

      // Current box is different from previous one, need to make one more trip
      if (r > 0 && boxes[r][0] != boxes[r - 1][0])
        ++trips;

      while (r - l + 1 > maxBoxes || weight > maxWeight ||
             // Loading boxes[l] in the previous turn is always no bad than
             // Loading it in this turn
             (l < r && dp[l + 1] == dp[l])) {
        weight -= boxes[l][1];
        if (boxes[l][0] != boxes[l + 1][0])
          --trips;
        ++l;
      }

      //   min trips to deliver boxes[0..r]
      // = min trips to deliver boxes[0..l) + trips to deliver boxes[l..r]
      dp[r + 1] = dp[l] + trips;
    }

    return dp[n];
  }
};"
"class Solution:
    def firstDayBeenInAllRooms2(self, next_visit: List[int]) -> int:
        p = 10**9 + 7
        n = len(next_visit)
        dp = [0]*n

        for i in range(1,n):
            dp[i] = (2 * dp[i-1] - dp[next_visit[i-1]] + 2) % p

        return dp[-1]

    def firstDayBeenInAllRooms(self, next_visit: List[int]) -> int:
        p = 10**9 + 7
        n = len (next_visit)
        not_visited = set(range(n))

        visits = [0] * n
        last_day = [float('-inf')] * n

        def simulate (room, day):
            not_visited.discard(room)
            while not_visited:
                visits[room] += 1
                last_day[room] = day
                if visits[room] &amp; 1:
                    # This room has been visited an odd number of times.
                    day = (2*day - last_day[next_visit[room]] + 1) % p

                # This room has been visited an even number of times.
                day += 1
                room = (room + 1) % n
                not_visited.discard(room)

            return day

        return simulate (0, 0) % p","class Solution {
 public:
  int stoneGameVII(vector<int>& stones) {
    const int n = stones.size();
    // dp[i][j] := max score you can get more than your opponent in stones[i..j]
    dp.resize(n, vector<int>(n));
    prefix.resize(n + 1);

    partial_sum(begin(stones), end(stones), begin(prefix) + 1);
    return stoneGameVII(stones, 0, n - 1);
  }

 private:
  vector<vector<int>> dp;
  vector<int> prefix;

  int stoneGameVII(const vector<int>& stones, int i, int j) {
    if (i == j)
      return 0;
    if (dp[i][j] > 0)
      return dp[i][j];

    dp[i][j] =
        max({dp[i][j],
             // Remove stones[i], so get sum of stones[i + 1..j]
             prefix[j + 1] - prefix[i + 1] - stoneGameVII(stones, i + 1, j),
             // Remove stones[j], so get sum of stones[i..j - 1]
             prefix[j] - prefix[i] - stoneGameVII(stones, i, j - 1)});

    return dp[i][j];
  }
};"
"class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        
        idx = word.find(ch)
        if idx==-1:
            return word
        else:
            res = list(word)
            first = res[idx::-1]
            last = res[idx+1:]
            ans = first+last
            return ''.join(ans)","class Solution {
 public:
  int maxHeight(vector<vector<int>>& cuboids) {
    // For each cuboid, sort it so that c[0] <= c[1] <= c[2]
    for (vector<int>& c : cuboids)
      sort(begin(c), end(c));

    sort(begin(cuboids), end(cuboids));

    // dp[i] := max height w/ cuboids[i] in the bottom
    vector<int> dp(cuboids.size());

    for (int i = 0; i < cuboids.size(); ++i)
      dp[i] = cuboids[i][2];

    for (int i = 1; i < cuboids.size(); ++i)
      for (int j = 0; j < i; ++j)
        if (cuboids[j][0] <= cuboids[i][0] &&  //
            cuboids[j][1] <= cuboids[i][1] &&  //
            cuboids[j][2] <= cuboids[i][2])
          dp[i] = max(dp[i], dp[j] + cuboids[i][2]);

    return *max_element(begin(dp), end(dp));
  }
};"
"class Solution:
    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:
        counts = {}
        for i in range(len(rectangles)):
            rectangles[i] = rectangles[i][0]/rectangles[i][1]
            if rectangles[i] in counts:
                counts[rectangles[i]] += 1
            else:
                counts[rectangles[i]] = 1
        tc = 0
        for c in counts:
            tc += (counts[c]*(counts[c]-1))//2
        return tc","class Solution {
 public:
  int waysToDistribute(int n, int k) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j] := # of ways to distribute i candies to j bags
    // dp[i][j] = 0, if i < j
    //          = 1, if i == j
    //          = dp[i - 1][j - 1] (the new candy occupies a bag)
    //          + dp[i - 1][j] * j (the new candy is in any of j bags)
    vector<vector<long>> dp(n + 1, vector<long>(k + 1));

    for (int i = 0; i <= k; ++i)
      dp[i][i] = 1;

    for (int i = 1; i <= n; ++i)
      for (int j = 1; j <= k; ++j)
        dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] * j) % kMod;

    return dp[n][k];
  }
};"
"class Solution:
    def maxProduct(self, s: str) -> int:
        if len(s) < 2:
            return 0
        if len(s) == 2:
            return 1
        self.ans = -1
        visited = set()
        def dfs(arr1, arr2, idx):
            if tuple(sorted([arr1, arr2]) + [idx]) in visited:
                return
            visited.add(tuple(sorted([arr1, arr2]) + [idx]))
            if arr1 == arr1[::-1] and arr2 == arr2[::-1]:
                self.ans = max(self.ans, len(arr1) * len(arr2))
            if idx == len(s):
                return
            dfs(arr1+s[idx], arr2, idx+1)
            dfs(arr1, arr2+s[idx], idx+1)
            dfs(arr1, arr2, idx+1)
        dfs("""", """", 0)
        return self.ans","class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList,
                                         vector<vector<int>>& queries) {
    vector<bool> ans(queries.size());
    UnionFind uf(n);

    for (int i = 0; i < queries.size(); ++i)
      queries[i].push_back(i);

    sort(begin(queries), end(queries),
         [](const auto& a, const auto& b) { return a[2] < b[2]; });
    sort(begin(edgeList), end(edgeList),
         [](const auto& a, const auto& b) { return a[2] < b[2]; });

    int i = 0;  // i := edgeList's index
    for (const vector<int>& query : queries) {
      // Union edges whose distances < limit (query[2])
      while (i < edgeList.size() && edgeList[i][2] < query[2])
        uf.unionByRank(edgeList[i][0], edgeList[i++][1]);
      if (uf.find(query[0]) == uf.find(query[1]))
        ans[q.back()] = true;
    }

    return ans;
  }
};"
"class Solution:
    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
        ans = [1] * len(parents)
        if 1 in nums: 
            tree = {}
            for i, x in enumerate(parents): 
                tree.setdefault(x, []).append(i)
                
            k = nums.index(1)
            val = 1
            seen = set()
            
            while k != -1: 
                stack = [k]
                while stack: 
                    x = stack.pop()
                    seen.add(nums[x])
                    for xx in tree.get(x, []): 
                        if nums[xx] not in seen: 
                            stack.append(xx)
                            seen.add(nums[xx])
                while val in seen: val += 1
                ans[k] = val
                k = parents[k]
        return ans","class Solution {
 public:
  double averageWaitingTime(vector<vector<int>>& customers) {
    double wait = 0;
    double curr = 0;

    for (const vector<int>& c : customers) {
      curr = max(curr, 1.0 * c[0]) + c[1];
      wait += curr - c[0];
    }

    return 1.0 * wait / customers.size();
  }
};"
"class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        ans = 0 
        freq = defaultdict(int)
        for x in nums: 
            ans += freq[x - k] + freq[x + k]
            freq[x] += 1
        return ans","class Solution {
 public:
  string maximumBinaryString(string binary) {
    //     e.g. binary = ""100110""
    // Do Operation 2 -> ""100011""
    // Do Operation 1 -> ""111011""
    // So, the index of the only '0' is prefixOnes + zeros - 1.
    const int zeros = count(begin(binary), end(binary), '0');
    const int prefixOnes = binary.find('0');

    // Make the entire string as 1s.
    binary.assign(binary.length(), '1');

    // Make the only '0' if necessary.
    if (prefixOnes != string::npos)
      binary[prefixOnes + zeros - 1] = '0';
    return binary;
  }
};"
"class Solution:
    def findOriginalArray(self, changed: List[int]) -> List[int]:
        # first check if array is even
        # create counter map
        # sort the array and iterate from beginning by crossing off doubled value
        # Time: O(n log n)
        # Space: O(n)
        
        if len(changed) % 2 != 0:
            return []

        counter = defaultdict(int)
        for val in changed:
            counter[val] += 1
        
        changed.sort()
        ans = []
        for val in changed:
            if val in counter and counter[val] != 0:
                if val*2 not in counter or counter[val*2] == 0:
                    return []
                counter[val] -= 1
                counter[val*2] -= 1
                ans.append(val)
        return ans","class Solution {
 public:
  int minMoves(vector<int>& nums, int k) {
    vector<int> ones;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == 1)
        ones.push_back(i);

    // Returns median index of [i..i + k)
    auto getMedIndex = [&](int i) { return (i + (i + k - 1)) / 2; };

    // Calculate the first group: window[0] = A[0..k)
    const int median = ones[getMedIndex(0)];
    int moves = 0;
    for (int i = 0; i < k; ++i)
      moves += abs(ones[i] - median);

    int ans = moves;

    for (int i = 1; i <= ones.size() - k; ++i) {
      const int oldMedianIndex = ones[getMedIndex(i - 1)];
      const int newMedianIndex = ones[getMedIndex(i)];
      if (k & 1)
        moves += newMedianIndex - oldMedianIndex;
      moves -= newMedianIndex - ones[i - 1];
      moves += ones[i + k - 1] - newMedianIndex;
      ans = min(ans, moves);
    }

    auto nThSum = [&](int n) { return n * (n + 1) / 2; };
    return ans - nThSum((k - 1) / 2) - nThSum(k / 2);
  }
};"
"class Solution:
    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:

        rides_from_start = defaultdict(list)
        for start, end, tip in rides:
            rides_from_start[start].append((end, tip))
            
        @cache
        def recursive(actual_position):
            if actual_position == n: # We are at the end
                return 0
            elif actual_position in rides_from_start:
                maximum = 0
                # take any of the rides starting at actual_position
                for end, tip in rides_from_start[actual_position]:
                    maximum = max(maximum, end - actual_position + tip + recursive(end))
                    
                # dont take the ride and check the next position
                maximum = max(maximum, recursive(actual_position + 1))
                
                return maximum
            else:
                # check the next position
                return recursive(actual_position+1)
        
        return recursive(0)","class Solution {
 public:
  vector<int> findBall(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    // dp[i] := status of i-th column
    // -1 := empty, 0 := b0, 1 := b1, ...
    vector<int> dp(n);
    // ans[i] := i-th ball's final position
    vector<int> ans(n, -1);

    iota(begin(dp), end(dp), 0);

    for (int i = 0; i < m; ++i) {
      vector<int> newDp(n, -1);
      for (int j = 0; j < n; ++j) {
        // Out of bound
        if (j + grid[i][j] < 0 || j + grid[i][j] == n)
          continue;
        // Stuck
        if (grid[i][j] == 1 && grid[i][j + 1] == -1 ||
            grid[i][j] == -1 && grid[i][j - 1] == 1)
          continue;
        newDp[j + grid[i][j]] = dp[j];
      }
      dp = move(newDp);
    }

    for (int i = 0; i < n; ++i)
      if (dp[i] != -1)
        ans[dp[i]] = i;

    return ans;
  }
};"
"class Solution:
    def minOperations(self, nums: List[int]) -> int:
                
        n = len(nums)
        ans = n
        nums.sort()
        cnt = Counter(nums)
        
        # build key for repeated occurance
        repeat = sorted(k for k in cnt if cnt[k] > 1)
        
        # build prefix sum for repeated occurance need to be changed
        repeat_change = list(accumulate([cnt[x] - 1 for x in repeat], initial=0))


        for i in range(n):
            # numbers left side all need to be changed
            left = i
            
            # numbers right side all need to be changed
            loc = bisect.bisect(nums, nums[i] + n - 1)
            right = n - loc
            
            # calculate occurance of repeated number within [nums[i], nums[i] + n - 1]
            repeat_l = bisect.bisect_left(repeat, nums[i])
            repeat_r = bisect.bisect(repeat, nums[i] + n - 1)
            ans = min(ans, left + right + repeat_change[repeat_r] - repeat_change[repeat_l])
        
        return ans","class Solution {
 public:
  int waysToSplit(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    int ans = 0;
    vector<int> prefix(n);

    partial_sum(begin(nums), end(nums), begin(prefix));

    // Find the first index j s.t.
    // Mid = prefix[j] - prefix[i] >= left = prefix[i]
    auto firstGreaterEqual = [&](int i) {
      int l = i + 1;
      int r = n - 1;
      while (l < r) {
        const int m = (l + r) / 2;
        if (prefix[m] - prefix[i] >= prefix[i])
          r = m;
        else
          l = m + 1;
      }
      return l;
    };

    // Find the first index k s.t.
    // Mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k]
    auto firstGreater = [&](int i) {
      int l = i + 1;
      int r = n - 1;
      while (l < r) {
        const int m = (l + r) / 2;
        if (prefix[m] - prefix[i] > prefix.back() - prefix[m])
          r = m;
        else
          l = m + 1;
      }
      return l;
    };

    for (int i = 0; i < n - 2; ++i) {
      const int j = firstGreaterEqual(i);
      if (j == n - 1)
        break;
      const int mid = prefix[j] - prefix[i];
      const int right = prefix.back() - prefix[j];
      if (mid > right)
        continue;
      const int k = firstGreater(i);
      ans = (ans + k - j) % kMod;
    }

    return ans;
  }
};"
"class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        X=0
        for i in operations:
            X= X+1 if i[1]==""+""  else X-1
        return X","class Solution {
 public:
  int largestSubmatrix(vector<vector<int>>& matrix) {
    const int n = matrix[0].size();
    int ans = 0;
    vector<int> hist(n);

    for (const vector<int>& row : matrix) {
      // Accumulate the histogram if possible
      for (int i = 0; i < n; ++i)
        hist[i] = row[i] == 0 ? 0 : hist[i] + 1;

      // Get sorted histogram
      vector<int> sortedHist(hist);
      sort(begin(sortedHist), end(sortedHist));

      // Greedily calculate the answer
      for (int i = 0; i < n; ++i)
        ans = max(ans, sortedHist[i] * (n - i));
    }

    return ans;
  }
};"
"class Solution:
    def sumOfBeauties(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        maxPre = nums[0]
        minNums = nums[-1]
        minPost = [0]*(n-1)
        for i in range(n-2, 0, -1):
            minPost[i] = minNums
            if nums[i] < minNums:
                minNums = nums[i]
        for i in range(1, n-1):
            if nums[i] > maxPre and nums[i] < minPost[i]:
                ans += 2
            elif nums[i] > nums[i-1] and nums[i] < nums[i+1]:
                ans += 1
            if nums[i] > maxPre:
                maxPre = nums[i]
        return ans","class Solution {
 public:
  bool canMouseWin(vector<string>& grid, int catJump, int mouseJump) {
    m = grid.size();
    n = grid[0].size();
    int cat;    // cat's position
    int mouse;  // mouse's position

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        if (grid[i][j] != '#')
          ++nFloors;
        if (grid[i][j] == 'C')
          cat = hash(i, j);
        else if (grid[i][j] == 'M')
          mouse = hash(i, j);
      }

    // dp[i][j][k] := true if mouse can win w/
    // Cat on (i / 8, i % 8), mouse on (j / 8, j % 8), and turns = k
    dp.resize(m * n, vector<vector<int>>(m * n, vector<int>(nFloors * 2, -1)));
    return canMouseWin(grid, cat, mouse, 0, catJump, mouseJump);
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};
  int m;
  int n;
  int nFloors = 0;
  vector<vector<vector<int>>> dp;

  bool canMouseWin(const vector<string>& grid, int cat, int mouse, int turn,
                   const int& catJump, const int& mouseJump) {
    // We already search whole touchable grid
    if (turn == nFloors * 2)
      return false;
    if (dp[cat][mouse][turn] != -1)
      return dp[cat][mouse][turn];

    if (turn % 2 == 0) {
      // mouse's turn
      const int i = mouse / n;
      const int j = mouse % n;
      for (int k = 0; k < 4; ++k) {
        for (int jump = 0; jump <= mouseJump; ++jump) {
          const int x = i + dirs[k] * jump;
          const int y = j + dirs[k + 1] * jump;
          if (x < 0 || x == m || y < 0 || y == n)
            break;
          if (grid[x][y] == '#')
            break;
          if (grid[x][y] == 'F')  // Mouse eats the food, so mouse win
            return dp[cat][mouse][turn] = true;
          if (canMouseWin(grid, cat, hash(x, y), turn + 1, catJump, mouseJump))
            return dp[cat][mouse][turn] = true;
        }
      }
      // Mouse can't win, so mouse lose
      return dp[cat][mouse][turn] = false;
    } else {
      // cat's turn
      const int i = cat / n;
      const int j = cat % n;
      for (int k = 0; k < 4; ++k) {
        for (int jump = 0; jump <= catJump; ++jump) {
          const int x = i + dirs[k] * jump;
          const int y = j + dirs[k + 1] * jump;
          if (x < 0 || x == m || y < 0 || y == n)
            break;
          if (grid[x][y] == '#')
            break;
          if (grid[x][y] == 'F')  // Cat eats the food, so mouse lose
            return dp[cat][mouse][turn] = false;
          const int nextCat = hash(x, y);
          if (nextCat == mouse)  // Cat catches mouse, so mouse lose
            return dp[cat][mouse][turn] = false;
          if (!canMouseWin(grid, nextCat, mouse, turn + 1, catJump, mouseJump))
            return dp[cat][mouse][turn] = false;
        }
      }
      // Cat can't win, so mouse win
      return dp[cat][mouse][turn] = true;
    }
  }

  int hash(int i, int j) {
    return i * n + j;
  }
};"
"class Solution:
    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        def helper(subString, string):
            string = iter(string)
            return all(c in string for c in subString)
        
        counter = defaultdict(lambda: 0)
        
        for char in s: 
            counter[char] += 1
            
        chars = """"
        for key in counter: 
            if counter[key]//k: 
                chars += key*(counter[key]//k)
                
        for i in range(len(chars), 0, -1):
            possibilities = set()        
            for comb in combinations(chars, i):
                for perm in permutations(comb):                    
                    subString = """".join(perm)
                    possibilities.add(subString)
                    
            possibilities = sorted(possibilities, key = lambda item: (len(item), item), reverse = True)
        
            for pos in possibilities: 
                if helper(pos*k, s):
                    return pos
                    
        return """"","class Solution {
 public:
  int minCharacters(string a, string b) {
    const int m = a.length();
    const int n = b.length();
    vector<int> countA(128);
    vector<int> countB(128);

    for (const char c : a)
      ++countA[c];

    for (const char c : b)
      ++countB[c];

    int ans = INT_MAX;
    int prevA = 0;  // # of chars in a <= c
    int prevB = 0;  // # of chars in b <= c

    for (char c = 'a'; c <= 'z'; ++c) {
      // Condition 3
      ans = min(ans, m + n - countA[c] - countB[c]);
      // Condition 1 and 2
      if (c > 'a')
        ans = min({ans, m - prevA + prevB, n - prevB + prevA});
      prevA += countA[c];
      prevB += countB[c];
    }

    return ans;
  }
};"
"class Solution:
    
    def maximumDifference(self, nums: List[int]) -> int:
        
		# <2 elements in nums seq
		if not nums or len(nums) <= 1:
            return -1
		
		# initialize current min el (val, index) and max diff
        current_min = (float('inf'), -1)
        current_diff = nums[1]-nums[0] # min 2 el's in sequence
		
		# O(n) iterations
        for i in range(0, len(nums)):
		
            if nums[i] < current_min[0]:
                current_min = (min(nums[i], current_min[0]), i) # update min elem
			
            current_diff = max(current_diff, nums[i] - nums[current_min[1]]) # update max diff
        
		return current_diff if current_diff else -1","class Solution {
 public:
  int kthLargestValue(vector<vector<int>>& matrix, int k) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<vector<int>> xors(m + 1, vector<int>(n + 1));
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j) {
        xors[i][j] = xors[i - 1][j] ^ xors[i][j - 1] ^ xors[i - 1][j - 1] ^
                     matrix[i - 1][j - 1];
        minHeap.push(xors[i][j]);
        if (minHeap.size() > k)
          minHeap.pop();
      }

    return minHeap.top();
  }
};"
"class Solution:
def gridGame(self, grid: List[List[int]]) -> int:
    
    res = float('inf')
    top_right_sum = sum(grid[0][1:])
    bottom_left_sum = 0
    
    n =  len(grid[0])
    for i in range(n):
        res = min(res,max(top_right_sum,bottom_left_sum))
        if i+1<n:
            top_right_sum -= grid[0][i+1]
        bottom_left_sum += grid[1][i]
    
    return res","class Solution {
 public:
  int minimumBoxes(int n) {
    int nBoxes = 0;
    int nextTouchings = 0;   // J
    int currLevelBoxes = 0;  // 1 + 2 + ... + j

    // Find min j s.t. nBoxes = 1 + (1 + 2) + ... + (1 + 2 + ... + j) >= n
    while (nBoxes < n) {
      ++nextTouchings;
      currLevelBoxes += nextTouchings;
      nBoxes += currLevelBoxes;
    }

    // If nBoxes = n, the answer is currLevelBoxes = 1 + 2 + ... + j
    if (nBoxes == n)
      return currLevelBoxes;

    // Otherwise we need to remove boxes in current level and rebuild it
    nBoxes -= currLevelBoxes;
    currLevelBoxes -= nextTouchings;
    nextTouchings = 0;

    while (nBoxes < n) {
      ++nextTouchings;
      nBoxes += nextTouchings;
    }

    return currLevelBoxes + nextTouchings;
  }
};"
"class Solution:
    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:
        abc='abcdefghijklmnopqrstuvwxyz'
        n=len(board)
        m=len(board[0])
        def check(a,b):
            la=len(a)
            lb=len(b)
            b_=b[::-1]
            start=[]
            n=0
            for i in range(la):
                if i==0 and (a[i]=="" "" or a[i] in abc):
                    start.append(i)
                    n+=1
                elif i>0 and (a[i]=="" "" or a[i] in abc) and a[i-1]==""#"":
                    start.append(i)
                    n+=1
                elif i>0 and a[i]=='#' and (a[i-1]==' ' or a[i-1] in abc):
                    start.append(i)
                if i==la-1 and (a[i]==' ' or a[i] in abc):
                    start.append(i+1)
            for i in range(n):
                flag=0
                flag1=0
                if start[2*i+1]-start[2*i] == lb:
                    
                    for j in range(start[2*i],start[2*i+1]):
                        k=j-start[2*i]
                        if not (a[j]==' ' or a[j]==b[k]):
                            # print(a[j],b[k])
                            flag=1
                            break
                    for j in range(start[2*i],start[2*i+1]):
                        k=j-start[2*i]
                        if not (a[j]==' ' or a[j]==b_[k]):
                            # print(a[j],b[k])
                            flag1=1
                            break                   
                    if flag==0 or flag1==0:
                        return True
            return False                          
        new=[["""" for _ in range(n)] for _ in range(m)]
        for i in range(n):
            for j in range(m):
                new[j][i]=board[i][j]
        s=set()
        for i in range(n):
            s.add("""".join(board[i]))
        for i in range(m):
            s.add("""".join(new[i]))
        for i in s:
            if check(i,word):
                return True
        return False","class Solution {
 public:
  int findDistance(TreeNode* root, int p, int q) {
    TreeNode* lca = getLCA(root, p, q);
    return dist(lca, p) + dist(lca, q);
  }

 private:
  TreeNode* getLCA(TreeNode* root, int p, int q) {
    if (root == nullptr || root->val == p || root->val == q)
      return root;

    TreeNode* l = getLCA(root->left, p, q);
    TreeNode* r = getLCA(root->right, p, q);

    if (l && r)
      return root;
    return l ? l : r;
  }

  int dist(TreeNode* lca, int target) {
    if (lca == nullptr)
      return 10000;
    if (lca->val == target)
      return 0;
    return 1 + min(dist(lca->left, target), dist(lca->right, target));
  }
};"
"class Solution:
    def scoreOfStudents(self, s: str, answers: List[int]) -> int:
        @lru_cache(None)
        def allEval(x):
            lo = eval(x)
            if lo > 1000:
                return set()
            ans = set([lo])
            if '*' not in x or '+' not in x or lo==1000:
                return ans
            for pos, char in enumerate(x):
                if char not in ['+', '*']:
                    continue
                left, right = allEval(x[:pos]), allEval(x[pos+1:])
                if char == '+':
                    ans |= {a + b for a in left for b in right if a+b<=1000}
                if char == '*':
                    ans |= {a * b for a in left for b in right if a*b<=1000}
            return ans
        S = allEval(s)
        correct = eval(s)
        return sum(5 if x==correct else (2 if x in S else 0) for x in answers)","class Solution {
 public:
  vector<int> restoreArray(vector<vector<int>>& adjacentPairs) {
    vector<int> ans;
    unordered_map<int, vector<int>> numToAdjs;

    for (const vector<int>& pair : adjacentPairs) {
      const int u = pair[0];
      const int v = pair[1];
      numToAdjs[u].push_back(v);
      numToAdjs[v].push_back(u);
    }

    for (const auto& [num, adjs] : numToAdjs)
      if (adjs.size() == 1) {
        ans.push_back(num);
        ans.push_back(adjs[0]);
        break;
      }

    while (ans.size() < adjacentPairs.size() + 1) {
      const int tail = ans.back();
      const int prev = ans[ans.size() - 2];
      const vector<int>& adjs = numToAdjs[tail];
      if (adjs[0] == prev)
        ans.push_back(adjs[1]);
      else
        ans.push_back(adjs[0]);
    }

    return ans;
  }
};"
"class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        if m*n != len(original):
            return []
        a1 = []
        for i in range(0, m):
            a2 = []
            for j in range(0, n):
                a2.append(original[i*n + j])
            a1.append(a2)
        return a1","class Solution {
 public:
  vector<bool> canEat(vector<int>& candiesCount, vector<vector<int>>& queries) {
    const int n = candiesCount.size();
    vector<bool> ans;
    vector<long> prefix{0};

    for (int i = 0; i < n; ++i)
      prefix.push_back(prefix.back() + candiesCount[i]);

    for (const vector<int>& query : queries) {
      const int type = query[0];
      const int day = query[1];
      const int cap = query[2];
      // Min/max day required to eat
      const long minDay = prefix[type] / cap;
      const long maxDay = prefix[type + 1] - 1;
      ans.push_back(minDay <= day && day <= maxDay);
    }

    return ans;
  }
};"
"class Solution:
    def numOfPairs(self, nums: List[str], target: str) -> int:
        count=0
        for i in range(len(nums)):
            for j in range(len(nums)):
                if(i!=j):
                    if(nums[i] + nums[j] == target):
                        count+=1
        return count","class Solution {
 public:
  bool checkPartitioning(string s) {
    const int n = s.length();
    // dp[i][j] := true if s[i..j] is palindrome
    dp.resize(n, vector<int>(n, -1));

    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j)
        if (isPalindrome(s, 0, i) && isPalindrome(s, i + 1, j) &&
            isPalindrome(s, j + 1, n - 1))
          return true;

    return false;
  }

 private:
  vector<vector<int>> dp;

  // Returns 0 if s[i..j] is not a palindrome
  // Returns 1 if s[i..j] is a palindrome
  int isPalindrome(const string& s, int i, int j) {
    if (i > j)
      return 1;
    if (dp[i][j] != -1)
      return dp[i][j];
    if (s[i] == s[j])
      return dp[i][j] = isPalindrome(s, i + 1, j - 1);
    return dp[i][j] = 0;
  }
};"
"class Solution:
    def maxConsecutiveAnswers(self, nums: str, k: int) -> int:
        n = len(nums)
        
        def util(char, K):
            ans, l = 0, 0
            for r in range(n):
                if nums[r] == char:
                    if K == 0:
                        while nums[l] != char: 
                            l += 1
                        l += 1
                    else : 
                        K-= 1
                        
                ans = max(ans, r - l + 1)
            return ans
        
        return max(util('F', k), util('T', k))","class Solution {
 public:
  int maxValue(vector<vector<int>>& events, int k) {
    // dp[i][k] := max sum of events[i:] w/ max k # of attendance
    dp.resize(events.size(), vector<int>(k + 1, -1));
    sort(begin(events), end(events));
    return maxValue(events, 0, k);
  }

 private:
  vector<vector<int>> dp;

  int maxValue(const vector<vector<int>>& e, int i, int k) {
    if (k == 0 || i == e.size())
      return 0;
    if (dp[i][k] != -1)
      return dp[i][k];

    // Binary search events to find the first index j s.t. e[j][0] > e[i][1]
    const auto it =
        upper_bound(begin(e) + i, end(e), e[i][1],
                    [](int end, const auto& a) { return a[0] > end; });
    const int j = distance(begin(e), it);
    return dp[i][k] =
               max(e[i][2] + maxValue(e, j, k - 1), maxValue(e, i + 1, k));
  }
};"
"class Solution:
    def waysToPartition(self, nums: List[int], k: int) -> int:
        """"""This is a good problem. It's not difficult, but is quite complex.

        The idea is that once we change a position at i, for all the pivots at
        1...i, the sum of the left half stay the same whereas the sum of
        the right half changes by delta = k - nums[i]. Similarly, for all the
        pivots at i + 1...n - 1, the left half changes by delta, whereas the
        right half stay the same.

        We can pre-compute all the differences at each pivot position and make
        that into a diffs = [d1, d2, .... , dn-1]

        Then after a change at i, if we want the pivots at 1...i to form a good
        partition, we must have left - (right + delta) = 0 => delta = left - right
        In other words, the number of good partitions is the count of d1, d2, ...
        di that are equal to delta. Similarly, if we want the pivots at i + 1...
        n - 1 to form a good partition, we must have left + delta - right = 0
        => left - right = -delta. In other words, the number of good partitions
        is the count of di+1, ...., dn-1 that are equal to -delta.

        Based on this, we progressively build a left sum and right sum to
        compute the diffs array. And then progressively build a left counter
        and right counter to compute the number of matches to delta and -delta.

        The difficulty is in the implementation, especially with the indices.

        O(N), 7339 ms, faster than 32.20%
        """"""
        N = len(nums)
        diffs = []
        sl, sr = 0, sum(nums)
        for i in range(N - 1):
            sl += nums[i]
            sr -= nums[i]
            diffs.append(sl - sr)
        diffs.append(math.inf)  # to prevent error in the counter arithemtic
        
        cl, cr = Counter(), Counter(diffs)
        res = cl[0] + cr[0]
        for i in range(N):
            d = k - nums[i]
            res = max(res, cl[d] + cr[-d])
            cl[diffs[i]] += 1
            cr[diffs[i]] -= 1
        return res","class Solution {
 public:
  bool check(vector<int>& nums) {
    const int n = nums.size();
    int rotates = 0;

    for (int i = 0; i < n; ++i)
      if (nums[i] > nums[(i + 1) % n] && ++rotates > 1)
        return false;

    return true;
  }
};"
"class Solution:

    def safe_val_by_index(self, arr, start, end):
        try:
            val = arr[start:end]
        except IndexError:
            return []
        return val
    
    def minimumMoves(self, s: str) -> int:
        
        a = list(s)
        n = len(a)
        p = 'X'
        
        template = ['O']*3
        ans = 0
        
        idx = a.index(p) if p in a else -1
        
        while idx >= 0:
            
            # possible substring
            # idx-2 .. idx, idx-1 .. idx+1, idx .. idx + 2
            moves = [
                [(max(0, idx), min(len(a), idx+3)), -1],
                [(max(0, idx-1), min(len(a), idx+2)), -1],
                [(max(0, idx-2), min(len(a), idx+1)), -1]   
            ]
            
            # default
            best_move = moves[0]
            
            for move in moves:
                # find susbstring with the most 'X's
                move[1] = self.safe_val_by_index(a, *move[0]).count('X')
                if move[1] >= best_move[1]:
                    best_move = move
            
            a[best_move[0][0]:best_move[0][1]] = template   
            ans += 1
            
            idx = a.index(p) if p in a else -1
        
        return ans","class Solution {
 public:
  int maximumScore(int a, int b, int c) {
    // Max <= min + mid
    const int x = (a + b + c) / 2;
    // Max > min + mid
    const int y = a + b + c - max({a, b, c});
    return min(x, y);
  }
};"
"class Solution:
    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:
        #finding the equal distribution of remaining sum
        temp = mean*(n+len(rolls)) - sum(rolls)
        each = temp//n
        rem = temp%n
        
        #return empty if out of dice range
        if (not (1<=(each + 1)<=6) and rem>0) or not (1<=each<=6):
            return []
        
        res = [each]*n
        i = 0
        #adding the remainder to each possible
        while rem > 0 and i<n:
            res[i] += 1
            rem -= 1
            i += 1
            
        return res","class Solution {
 public:
  int minAbsDifference(vector<int>& nums, int goal) {
    const int n = nums.size() / 2;
    const vector<int> lNums(begin(nums), begin(nums) + n);
    const vector<int> rNums(begin(nums) + n, end(nums));
    int ans = INT_MAX;
    vector<int> lSums;
    vector<int> rSums;

    dfs(lNums, 0, 0, lSums);
    dfs(rNums, 0, 0, rSums);
    sort(begin(rSums), end(rSums));

    for (const int lSum : lSums) {
      const int i = firstGreaterEqual(rSums, goal - lSum);
      if (i < rSums.size())  // 2^n
        ans = min(ans, abs(goal - lSum - rSums[i]));
      if (i > 0)
        ans = min(ans, abs(goal - lSum - rSums[i - 1]));
    }

    return ans;
  }

 private:
  void dfs(const vector<int>& A, int i, int path, vector<int>& sums) {
    if (i == A.size()) {
      sums.push_back(path);
      return;
    }
    dfs(A, i + 1, path + A[i], sums);
    dfs(A, i + 1, path, sums);
  }

  int firstGreaterEqual(const vector<int>& A, int target) {
    return lower_bound(begin(A), end(A), target) - begin(A);
  }
};"
"class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        stones = [v % 3 for v in stones]
        
        d = defaultdict(int)
        for v in stones:
            d[v] += 1
        
        while d[1] >= 2 and d[2] >= 2:
            d[2] -= 1
            d[1] -= 1
        
        if d[0] % 2 == 0: # number of 0s will not influent the result
            if (d[1] == 1 and d[2] >= 1) or (d[2] == 1 and d[1] >= 1):
                return True
        else:
            if (d[1] == 0 and d[2] >= 3) or (d[2] == 0 and d[1] >= 3):
                return True
            if (d[1] == 1 and d[2] >= 4) or (d[2] == 1 and d[1] >= 4):
                return True

        return False","class Solution {
 public:
  vector<int> findBuildings(vector<int>& heights) {
    vector<int> stack;

    for (int i = 0; i < heights.size(); ++i) {
      while (!stack.empty() && heights[stack.back()] <= heights[i])
        stack.pop_back();
      stack.push_back(i);
    }

    return stack;
  }
};"
"class Solution:
    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:
        rest = sum(x == letter for x in s)
        stack = []
        for i, x in enumerate(s): 
            while stack and stack[-1] > x and len(stack) + len(s) - i > k and (stack[-1] != letter or repetition < rest): 
                if stack.pop() == letter: repetition += 1
            if len(stack) < k and (x == letter or len(stack) + repetition < k): 
                stack.append(x)
                if x == letter: repetition -= 1
            if x == letter: rest -= 1
        return """".join(stack)","class Solution {
 public:
  string mergeAlternately(string word1, string word2) {
    const int n = min(word1.length(), word2.length());
    string prefix;

    for (int i = 0; i < n; ++i) {
      prefix += word1[i];
      prefix += word2[i];
    }

    return prefix + word1.substr(n) + word2.substr(n);
  }
};"
"class Solution:
    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        return [v for v, c in Counter(itertools.chain(set(nums1), set(nums2), set(nums3))).items() if c >=2]","class Solution {
 public:
  vector<int> minOperations(string boxes) {
    vector<int> ans(boxes.length());

    for (int i = 0, count = 0, moves = 0; i < boxes.length(); ++i) {
      ans[i] += moves;
      count += boxes[i] - '0';
      moves += count;
    }

    for (int i = boxes.length() - 1, count = 0, moves = 0; i >= 0; --i) {
      ans[i] += moves;
      count += boxes[i] - '0';
      moves += count;
    }

    return ans;
  }
};"
"class Solution:
    def minOperations(self, grid: List[List[int]], x: int) -> int:
        m,n = len(grid),len(grid[0])
        count = 0
        li = []
        
        for i in range(m):
            for j in range(n):
                li.append(grid[i][j])
                
        li.sort()
        med = li[len(li)//2]
        
        for num in li:
            if num < med or num > med: 
                need = abs( (med - num)//x)
                if need == 0:
                    return -1
                count += need
        return count","class Solution {
 public:
  int maximumScore(vector<int>& nums, vector<int>& multipliers) {
    // dp[s][i] := max score of nums[s..e] and multipliers[i],
    dp.resize(multipliers.size(), vector<int>(multipliers.size(), -1));
    return maximumScore(nums, 0, multipliers, 0);
  }

 private:
  vector<vector<int>> dp;

  int maximumScore(const vector<int>& nums, int s,
                   const vector<int>& multipliers, int i) {
    if (i == multipliers.size())
      return 0;
    if (dp[s][i] != -1)
      return dp[s][i];

    // # of nums picked on the start side = s,
    // # of nums picked on the end side = i - s,
    // So e = n - (i - s) - 1
    const int e = nums.size() - (i - s) - 1;
    const int pickStart = nums[s] * multipliers[i] +
                          maximumScore(nums, s + 1, multipliers, i + 1);
    const int pickEnd = nums[e] * multipliers[i] +  //
                        maximumScore(nums, s, multipliers, i + 1);
    return dp[s][i] = max(pickStart, pickEnd);
  }
};"
"class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums) // 2;
        sum1, sum2 = sum(nums[:n]), sum(nums[n:]);
        psum1, psum2 = [{0}], [{0}];
        
        for ns, ps in zip([nums[:n], nums[n:]], [psum1, psum2]):
            for i, x in enumerate(ns):
                if len(ps) <= n//2: ps.append({s + x for s in ps[-1]});
                
                for j in range(len(ps) - 1, 0, -1):
                    ps[j] = ps[j].union({s + x for s in ps[j-1]});
                    
        target = sum1 - sum2;
        answer = abs(target);

        # 2p1 - 2p2 ~ sum1 - sum2
        
        for i in range(len(psum1)):
            p1, p2 = sorted(list(psum1[i])), sorted(list(psum2[i]));
            idx1, idx2 = 0, 0;
            len1, len2 = len(p1), len(p2);
            
            while idx1 < len1 and idx2 < len2:
                diff = p1[idx1] - p2[idx2];
                offset = 2 * diff - target;
                
                answer = min(answer, abs(offset));
                if offset < 0: idx1 += 1;
                else: idx2 += 1;
                    
        return answer;","class Solution {
 public:
  int longestPalindrome(string word1, string word2) {
    const string& s = word1 + word2;
    const int n = s.length();
    int ans = 0;
    // dp[i][j] := LPS's length in s[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j]) {
          dp[i][j] = 2 + dp[i + 1][j - 1];
          if (i < word1.length() && j >= word1.length())
            ans = max(ans, dp[i][j]);
        } else {
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        }
      }

    return ans;
  }
};"
"class Solution:
    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:
        seats = sorted(seats)
        students = sorted(students)
        count = 0
        for i in range(len(seats)):
            count += abs(seats[i] - students[i])
        return count","class Solution {
 public:
  vector<string> sortFeatures(vector<string>& features,
                              vector<string>& responses) {
    vector<string> ans;
    vector<pair<int, int>> featCount;  // {i: count[features[i]]}
    unordered_map<string, int> count;

    for (const string& res : responses) {
      istringstream iss(res);
      unordered_set<string> seen;
      for (string token; getline(iss, token, ' ');)
        seen.insert(token);
      for (const string& token : seen)
        ++count[token];
    }

    for (int i = 0; i < features.size(); ++i)
      featCount.emplace_back(i, count[features[i]]);

    sort(begin(featCount), end(featCount), [](const auto& a, const auto& b) {
      return a.second == b.second ? a.first < b.first : a.second > b.second;
    });

    for (const auto& [i, count] : featCount)
      ans.push_back(features[i]);

    return ans;
  }
};"
"class Solution:
    def winnerOfGame(self, arr: str) -> bool:
        n = len(arr)
        
        def count(char):
            i, j = 0, 0
            res = 0
            while j < n:
                temp = 0
                while j < n and arr[j] == char:
                    temp += 1
                    j += 1
                    
                res += (temp-2) if temp > 2 else 0
                j += 1
                i = j
            return res
        
        return count('A') > count('B')","class Solution {
 public:
  int countMatches(vector<vector<string>>& items, string ruleKey,
                   string ruleValue) {
    const int index = ruleKey == ""type"" ? 0 : ruleKey == ""color"" ? 1 : 2;
    return count_if(begin(items), end(items),
                    [index, &ruleValue](const auto& item) {
      return item[index] == ruleValue;
    });
  }
};"
"class Solution:
    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:
        graph = collections.defaultdict(list)
        for a, b in edges:                                       # build graph
            graph[a].append(b)
            graph[b].append(a)
        dq = collections.deque([(0, 0)])                         # prepare bfs using deque
        ans, n = 0, 1
        visited = set()
        while dq:
            for _ in range(n):
                cur, step = dq.popleft()
                n -= 1                                           # keep track of size of dq
                visited.add(cur)
                for nei in graph[cur]:
                    if nei in visited: continue
                    visited.add(nei)
                    n += 1
                    dq.append((nei, step+1))
                if cur:
                    time = step * 2                              # first msg round trip time    
                    mod = time % patience[cur]                   
                    finished = patience[cur] if not mod else mod # last msg finished moves
                    total = time + (time - finished)             # total time = time + last_msg_unfinished_moves
                    ans = max(ans, total)
        return ans + 1","class Solution {
 public:
  int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts,
                  int target) {
    int ans = INT_MAX;

    for (const int baseCost : baseCosts)
      dfs(toppingCosts, 0, target, baseCost, ans);

    return ans;
  }

 private:
  void dfs(const vector<int>& toppingCosts, int i, int target, int currCost,
           int& ans) {
    if (abs(currCost - target) < abs(ans - target))
      ans = currCost;
    if (i == toppingCosts.size() || currCost >= target)
      return;

    for (int k = 0; k < 3; ++k)
      dfs(toppingCosts, i + 1, target, currCost + k * toppingCosts[i], ans);
  }
};"
"class Solution:
    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:
        result = []
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                temp = nums1[i]*nums2[j]
                result.append(temp)
        result.sort()
        return result[k-1]","class Solution {
 public:
  int minOperations(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.size() * 6 < nums2.size() || nums2.size() * 6 < nums1.size())
      return -1;

    int sum1 = accumulate(begin(nums1), end(nums1), 0);
    int sum2 = accumulate(begin(nums2), end(nums2), 0);
    if (sum1 > sum2)
      return minOperations(nums2, nums1);

    int ans = 0;
    // Increases in nums1 & decreases in nums2
    vector<int> count(6);

    for (const int num : nums1)
      ++count[6 - num];

    for (const int num : nums2)
      ++count[num - 1];

    for (int i = 5; sum2 > sum1;) {
      while (count[i] == 0)
        --i;
      sum1 += i;
      --count[i];
      ++ans;
    }

    return ans;
  }
};"
"class Solution:
    def areNumbersAscending(self, s: str) -> bool:
        s = s.split(' ')
        last = float('-inf')
        
        for char in s:
            if char.isnumeric():
                if int(char) <= last:
                    return False
                else:
                    last = int(char)
                    
        return True","struct Car {
  int pos;
  int speed;
  double collisionTime;
  Car(int pos, int speed, double collisionTime)
      : pos(pos), speed(speed), collisionTime(collisionTime) {}
};

class Solution {
 public:
  vector<double> getCollisionTimes(vector<vector<int>>& cars) {
    vector<double> ans(cars.size());
    stack<Car> stack;

    for (int i = cars.size() - 1; i >= 0; --i) {
      const int pos = cars[i][0];
      const int speed = cars[i][1];
      while (!stack.empty() && (speed <= stack.top().speed ||
                                getCollisionTime(stack.top(), pos, speed) >=
                                    stack.top().collisionTime))
        stack.pop();
      if (stack.empty()) {
        stack.emplace(pos, speed, INT_MAX);
        ans[i] = -1;
      } else {
        const double collisionTime = getCollisionTime(stack.top(), pos, speed);
        stack.emplace(pos, speed, collisionTime);
        ans[i] = collisionTime;
      }
    }

    return ans;
  }

 private:
  double getCollisionTime(const Car& car, int pos, int speed) {
    return (car.pos - pos) / (double)(speed - car.speed);
  }
};"
"class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        len_nums = len(nums)
        max_val = 0
        count_max = 0
        for len_c in range(1, len_nums + 1):
            for comb in combinations(nums, len_c):
                val = 0
                for n in comb:
                    val |= n
                if val > max_val:
                    count_max = 1
                    max_val = val
                elif val == max_val:
                    count_max += 1
        return count_max","/**
 * // This is the GridMaster's API interface.
 * // You should not implement it, or speculate about its implementation
 * class GridMaster {
 *  public:
 *   bool canMove(char direction);
 *   void move(char direction);
 *   boolean isTarget();
 * };
 */

enum class Grid { kUnvisited, kStart, kTarget, kBlocked, kEmpty };

class Solution {
 public:
  int findShortestPath(GridMaster& master) {
    constexpr int m = 500;
    constexpr int startX = m;
    constexpr int startY = m;
    vector<vector<Grid>> grid(m * 2, vector<Grid>(m * 2, Grid::kUnvisited));

    // Build the grid information by dfs
    dfs(master, grid, startX, startY);

    int ans = 0;
    queue<pair<int, int>> q{{{startX, startY}}};
    grid[startX][startY] = Grid::kBlocked;

    // Find the steps by bfs
    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (grid[x][y] == Grid::kTarget)
            return ans;
          if (grid[x][y] == Grid::kBlocked)
            continue;
          grid[x][y] = Grid::kBlocked;
          q.emplace(x, y);
        }
      }
    }

    return -1;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};
  const vector<char> charTable{'R', 'D', 'L', 'U'};

  void dfs(GridMaster& master, vector<vector<Grid>>& grid, int i, int j) {
    if (grid[i][j] != Grid::kUnvisited)
      return;
    if (master.isTarget())
      grid[i][j] = Grid::kTarget;
    else
      grid[i][j] = Grid::kEmpty;

    for (int k = 0; k < 4; ++k) {
      const int x = i + dirs[k];
      const int y = j + dirs[k + 1];
      const char d = charTable[k];
      const char undoD = charTable[(k + 2) % 4];
      if (master.canMove(d)) {
        master.move(d);
        dfs(master, grid, x, y);
        master.move(undoD);
      } else {
        grid[x][y] = Grid::kBlocked;
      }
    }
  }
};"
"class Solution:
    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
        g = defaultdict(set)
        for u, v in edges:
            g[u].add(v)
            g[v].add(u)              
        
        q = deque([(1, 0)])
        # to store the two minimum node counts for each visited node
        vis = defaultdict(set, {0: {0}})
        minval = set()
        while q:
            node, cnt = q.popleft()
            if node == n:
                minval.add(cnt)
                if len(minval) == 2: break
            for nei in g[node]:
                if len(vis[nei]) > 1 and cnt + 1 >= max(vis[nei]): continue
                vis[nei] = {min(vis[nei])} | {cnt + 1} if vis[nei] else {cnt + 1}
                q.append((nei, cnt + 1))
        
        minval = sorted(minval)
        def helper(nodes):
            t = 0
            while nodes > 0:
                t += time
                nodes -= 1
                if nodes == 0: break
                # if current time exceeds change and change frequency is odd
                if t >= change and (t // change) % 2:
                    t = (t // change + 1) * change
            return t
        
        if len(minval) == 1:
            return helper(minval[0] + 2)
        
        # either use the 2nd minimum path or the 1st path add two more nodes (like example 2)
        return min(helper(minval[0]+2), helper(minval[1]))","class Solution {
 public:
  int nearestValidPoint(int x, int y, vector<vector<int>>& points) {
    int ans = -1;
    int minDist = INT_MAX;

    for (int i = 0; i < points.size(); ++i) {
      const int dx = x - points[i][0];
      const int dy = y - points[i][1];
      if (dx == 0 || dy == 0) {
        const int dist = abs(dx + dy);
        if (dist < minDist) {
          minDist = dist;
          ans = i;
        }
      }
    }

    return ans;
  }
};"
"class Solution:
    def countValidWords(self, sentence: str) -> int:
        valid = 0
        digits = set(string.digits)
        punctuation = set(['!', '.', ','])
        for token in sentence.split():
            ts = set(token)
            if digits &amp; ts:
                continue
            if p := punctuation &amp; set(ts):
                if len(p) > 1 or token[-1] not in punctuation:
                    continue
                if max(token.count(c) for c in punctuation) > 1:
                    continue
            if token.count('-') > 1:
                continue
            if token.count('-') == 1:
                idx = token.find('-')
                if idx == 0 or idx == len(token) - 1 or not token[idx-1].islower() or not token[idx+1].islower():
                    continue                
            valid += 1
        return valid","class Solution {
 public:
  bool checkPowersOfThree(int n) {
    while (n > 1) {
      const int r = n % 3;
      if (r == 2)
        return false;
      n /= 3;
    }

    return true;
  }
};"
"class Solution:
    def nextBeautifulNumber(self, n: int) -> int:

        def count(n):
            cnt = [0]*10
            while n:
                cnt[n%10] += 1
                n //= 10
            return cnt
        
        def valid(cnt):
            for i, c in enumerate(cnt):
                if c > 0 and c != i:
                    return False
            return True

        x = n+1
        while True:
            cnt = count(x)
            if valid(cnt):
                return x
            x += 1","class Solution {
 public:
  int beautySum(string s) {
    int ans = 0;

    for (int i = 0; i < s.length(); ++i) {
      vector<int> count(26);
      for (int j = i; j < s.length(); ++j) {
        ++count[s[j] - 'a'];
        ans += *max_element(begin(count), end(count)) - getMin(count);
      }
    }

    return ans;
  }

 private:
  int getMin(const vector<int>& count) {
    int mini = INT_MAX;
    for (const int c : count)
      if (c > 0)
        mini = min(mini, c);
    return mini;
  }
};"
"class Solution:
    def countHighestScoreNodes(self, parents: List[int]) -> int:
        hmap=defaultdict(list)
        n=len(parents)
        for i in range(n):
            hmap[i]=[]
        for i in range(1,n):
            hmap[parents[i]].append(i)
        self.childCount=[1 for i in range(n)]
        for i in hmap[0]:
            self.childCount[0]+=self.dfs(i,hmap)
        ans=0
        count=0
        for i in range(n):
            currProd=1
            currSum=0
            for j in hmap[i]:
                currProd*=self.childCount[j]
                currSum+=self.childCount[j]
            rem=(n-1)-(currSum)
            if rem>=1:
                currProd*=rem
            if ans==currProd:
                count+=1
            if ans<currProd:
                count=1
                ans=currProd
        return count
    def dfs(self,curr,hmap):
        if hmap[curr]==[]:
            return 1
        for it in hmap[curr]:
            self.childCount[curr]+=self.dfs(it,hmap)
        return self.childCount[curr]","class Solution {
 public:
  vector<int> countPairs(int n, vector<vector<int>>& edges,
                         vector<int>& queries) {
    vector<int> ans(queries.size());

    // count[i] := # of edges of node i
    vector<int> count(n + 1);

    // shared[i][j] := # of edges incident to i or j, where i < j
    vector<unordered_map<int, int>> shared(n + 1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      ++count[u];
      ++count[v];
      ++shared[min(u, v)][max(u, v)];
    }

    vector<int> sortedCount(count);
    sort(begin(sortedCount), end(sortedCount));

    int k = 0;
    for (const int query : queries) {
      for (int i = 1, j = n; i < j;)
        if (sortedCount[i] + sortedCount[j] > query)
          // sortedCount[i] + sortedCount[j] > query
          // sortedCount[i + 1] + sortedCount[j] > query
          // ...
          // sortedCount[j - 1] + sortedCount[j] > query
          // So, there are (j - 1) - i + 1 = j - i pairs > query
          ans[k] += (j--) - i;
        else
          ++i;
      for (int i = 1; i <= n; ++i)
        for (const auto& [j, sh] : shared[i])
          if (count[i] + count[j] > query && count[i] + count[j] - sh <= query)
            --ans[k];
      ++k;
    }

    return ans;
  }
};"
"class Solution:
    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        
        g = defaultdict(set)
        deg = defaultdict(int)
        for a, b in relations:
            deg[b-1] += 1
            g[a-1].add(b-1)
            
        cnt = 0
        
        # time to finish all prerequisites
        prev_max_t = defaultdict(int)
        
        q = [(time[x], x) for x in range(n) if deg[x] == 0]
        heapify(q)
        
        while q:
            t, course = heappop(q)
            cnt += 1
            if cnt == n:
                return t
            for nei in g[course]:
                deg[nei] -= 1
                prev_max_t[nei] = max(prev_max_t[nei], t)
                if deg[nei] == 0:
                    heappush(q, (prev_max_t[nei] + time[nei], nei))","class Solution {
 public:
  bool checkOnesSegment(string s) {
    return s.find(""01"") == string::npos;
  }
};"
"class Solution:
    def kthDistinct(self, arr: List[str], k: int) -> str: 
        unique = [v for v, count in Counter(arr).items() if count == 1]
        return unique[k-1] if k <= len(unique) else """"","class Solution {
 public:
  int minElements(vector<int>& nums, int limit, int goal) {
    const long sum = accumulate(begin(nums), end(nums), 0L);
    const double diff = abs(goal - sum);
    return ceil(diff / limit);
  }
};"
"class Solution:
    def maxTwoEvents(self, events: List[List[int]]) -> int:
        end_max = defaultdict(int)
        for start, end, val in events:
            end_max[end] = max(end_max[end], val)
        max_val = max(end_max.values())
        lst_ends = sorted(end_max.keys())
        for i in range(1, len(lst_ends)):
            end_max[lst_ends[i]] = max(end_max[lst_ends[i]],
                                       end_max[lst_ends[i - 1]])
        for start, end, val in events:
            idx = bisect_right(lst_ends, start)
            if idx > 0 and start > lst_ends[idx - 1]:
                max_val = max(max_val, end_max[lst_ends[idx - 1]] + val)
            elif idx > 1 and start > lst_ends[idx - 2]:
                max_val = max(max_val, end_max[lst_ends[idx - 2]] + val)
        return max_val","class Solution {
 public:
  int countRestrictedPaths(int n, vector<vector<int>>& edges) {
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0] - 1;
      const int v = edge[1] - 1;
      const int w = edge[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    return dijkstra(graph, 0, n - 1);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst) {
    constexpr int kMod = 1'000'000'007;
    // dist[i] := distanceToLastNode(i)
    vector<long long> dist(graph.size(), LLONG_MAX);
    // ways[i] := # of restricted path from i -> n
    vector<long long> ways(graph.size());
    using P = pair<long long, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[dst] = 0;
    ways[dst] = 1;
    minHeap.emplace(dist[dst], dst);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      if (d > dist[u])
        continue;
      for (const auto& [v, w] : graph[u]) {
        if (d + w < dist[v]) {
          dist[v] = d + w;
          minHeap.emplace(dist[v], v);
        }
        if (dist[v] < dist[u]) {
          ways[u] += ways[v];
          ways[u] %= kMod;
        }
      }
    }

    return ways[src];
  }
};"
"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        pref=[0]
		#prefix sum array for calculating *
        for x in s:
            if x=='*':
                pref.append(pref[-1]+1)
            else:
                pref.append(pref[-1])
        ans=[]
		#array for finding the next |
        nex=[0]*len(s)
        stack=[]
        for x in range(len(s)-1,-1,-1):
            if not stack:
                nex[x]=inf
            elif s[x]=='|':
                nex[x]=x
            else:
                nex[x]=stack[-1]
            if s[x]=='|':
                stack.append(x)
        #array for finding the previous |
		prev=[0]*len(s)
        for x in range(len(s)):
            if not stack:
                prev[x]=-inf
            elif s[x]=='|':
                prev[x]=x
            else:
                prev[x]=stack[-1]
            if s[x]=='|':
                stack.append(x)
            
        for x in queries:
			#if | from both ends coincide or cross
            if nex[x[0]]>=prev[x[1]]:
                ans.append(0)
            else:
                #find the next | and the previous | and calculate the * in between
                ans.append(pref[prev[x[1]]]-pref[nex[x[0]]])
        return ans","class Solution {
 public:
  int getNumberOfBacklogOrders(vector<vector<int>>& orders) {
    constexpr int kMod = 1'000'000'007;
    int ans = 0;
    priority_queue<vector<int>> buysMaxHeap;
    priority_queue<vector<int>, vector<vector<int>>, greater<>> sellsMinHeap;

    for (const vector<int>& order : orders) {
      if (order[2] == 0)
        buysMaxHeap.push(order);
      else
        sellsMinHeap.push(order);
      while (!buysMaxHeap.empty() && !sellsMinHeap.empty() &&
             buysMaxHeap.top()[0] >= sellsMinHeap.top()[0]) {
        const int minAmount = min(buysMaxHeap.top()[1], sellsMinHeap.top()[1]);
        vector<int> buysMaxHeapTop = buysMaxHeap.top();
        buysMaxHeap.pop();
        buysMaxHeapTop[1] -= minAmount;
        if (buysMaxHeapTop[1] > 0)
          buysMaxHeap.push(buysMaxHeapTop);

        vector<int> sellsMinHeapTop = sellsMinHeap.top();
        sellsMinHeap.pop();
        sellsMinHeapTop[1] -= minAmount;
        if (sellsMinHeapTop[1] > 0)
          sellsMinHeap.push(sellsMinHeapTop);
      }
    }

    while (!buysMaxHeap.empty()) {
      ans += buysMaxHeap.top()[1], buysMaxHeap.pop();
      ans %= kMod;
    }

    while (!sellsMinHeap.empty()) {
      ans += sellsMinHeap.top()[1], sellsMinHeap.pop();
      ans %= kMod;
    }

    return ans;
  }
};"
"class Solution:
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        n = len(pieces)
        mp = {""bishop"": ((-1, -1), (-1, 1), (1, -1), (1, 1)),
              ""queen"" : ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)), 
              ""rook""  : ((-1, 0), (0, -1), (0, 1), (1, 0))}
        
        dirs = [[]] # directions
        for piece in pieces: dirs = [x+[xx] for x in dirs for xx in mp[piece]]
        
        positions = tuple(map(tuple, positions))
        
        def fn(*args): 
            """"""Return possible moves along given direction.""""""
            stack = [((1<<n)-1, positions)]
            while stack: 
                mask, pos = stack.pop()
                ans.add(pos)
                m = mask
                while m: 
                    p = []
                    for i in range(n): 
                        if m &amp; (1 << i): 
                            p.append((pos[i][0] + args[i][0], pos[i][1] + args[i][1]))
                            if not (1 <= p[i][0] <= 8 and 1 <= p[i][1] <= 8): break 
                        else: p.append(pos[i])
                    else: 
                        cand = tuple(p)
                        if len(set(cand)) == len(cand) and m: stack.append((m, cand))
                    m = mask &amp; (m-1)

        ans = set()
        for d in dirs: fn(*d)
        return len(ans)","class Solution {
 public:
  int maxValue(int n, int index, int maxSum) {
    maxSum -= n;

    int l = 0;
    int r = maxSum;

    // Find the first value x s.t. if A[index] = x
    // Sum(A) >= maxSum
    while (l < r) {
      const int m = (l + r) / 2;
      if (getSum(n, index, m) >= maxSum)
        r = m;
      else
        l = m + 1;
    }

    return getSum(n, index, l) > maxSum ? l : l + 1;
  }

 private:
  // Minimum sum if nums[index] = x
  long getSum(int n, int index, int x) {
    long l = min(index, x - 1);
    long r = min(n - index, x);
    long lSum = ((x - 1) + (x - 1 - l + 1)) * l / 2;
    long rSum = (x + (x - r + 1)) * r / 2;
    return lSum + rSum;
  }
};"
"class Solution:
    def smallestEqual(self, nums: List[int]) -> int:
        for i, n in enumerate(nums):
            if n == i % 10:
                return i
        return -1","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int count = 0;
  TrieNode() : children(2) {}
};

class Solution {
 public:
  int countPairs(vector<int>& nums, int low, int high) {
    int ans = 0;

    for (const int num : nums) {
      ans += getCount(num, high + 1) - getCount(num, low);
      insert(num);
    }

    return ans;
  }

 private:
  static constexpr int kHeight = 14;
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(int num) {
    shared_ptr<TrieNode> node = root;
    for (int i = kHeight; i >= 0; --i) {
      const int bit = num >> i & 1;
      if (node->children[bit] == nullptr)
        node->children[bit] = make_shared<TrieNode>();
      node = node->children[bit];
      ++node->count;
    }
  }

  // # of nums < limit
  int getCount(int num, int limit) {
    int count = 0;
    shared_ptr<TrieNode> node = root;
    for (int i = kHeight; i >= 0; --i) {
      const int bit = num >> i & 1;
      const int bitLimit = limit >> i & 1;
      if (bitLimit == 1) {
        if (node->children[bit] != nullptr)
          count += node->children[bit]->count;
        node = node->children[bit ^ 1];
      } else {
        node = node->children[bit];
      }
      if (node == nullptr)
        break;
    }
    return count;
  }
};"
"class Solution:
    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:
        '''
        5->3->1->2->5->1->2
              C     C. C
        c = [2,4,5]
        '''
        if head.next.next is None:
            return [-1,-1]
        
        def calc(head):
            prev = head
            temp = head.next
            while temp:
                next_node = temp.next
                if next_node is not None:
                    if prev.val > temp.val < next_node.val or prev.val < temp.val > next_node.val:
                        break
                    prev,temp = temp,next_node
                else:
                    break
            
            max_dis = 0
            min_dis = pow(10,5)+1
            count = 0
            mi_count = pow(10,5)+1
            while temp:
                next_node = temp.next
                if next_node is not None:
                    if prev.val > temp.val < next_node.val or prev.val < temp.val > next_node.val:
                        max_dis = count
                        min_dis = min(min_dis,mi_count)
                        mi_count = 0
                    count += 1
                    mi_count += 1
                    prev,temp = temp,next_node
                else:
                    break
            
            if max_dis != 0 and min_dis != pow(10,5)+1:        
                return [min_dis,max_dis]
            return [-1,-1]
			
        return calc(head)","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int prefixCount = 0;
  int wordCount = 0;
  TrieNode() : children(26) {}
};

class Trie {
 public:
  void insert(string word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
      ++node->prefixCount;
    }
    ++node->wordCount;
  }

  int countWordsEqualTo(string word) {
    shared_ptr<TrieNode> node = find(word);
    return node ? node->wordCount : 0;
  }

  int countWordsStartingWith(string prefix) {
    shared_ptr<TrieNode> node = find(prefix);
    return node ? node->prefixCount : 0;
  }

  void erase(string word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      node = node->children[i];
      --node->prefixCount;
    }
    --node->wordCount;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  shared_ptr<TrieNode> find(const string& s) {
    shared_ptr<TrieNode> node = root;
    for (const char c : s) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        return nullptr;
      node = node->children[i];
    }
    return node;
  }
};"
"class Solution:
    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:
        nums.sort()
        q = collections.deque([(start, 0)])
        visited = set()
        
        while q:
            for _ in range(len(q)):
                x, step = q.popleft()
                if x == goal:
                    return step
                
                if x < 0 or x > 1000:
                    continue
                
                if x in visited:
                    continue
                visited.add(x)

                for num in nums:
                    q.append((x+num, step+1))
                    q.append((x-num, step+1))
                    q.append((x^num, step+1))
                    
        
        return -1","class Solution {
 public:
  int reinitializePermutation(int n) {
    int ans = 0;
    int i = 1;

    do {
      if (i < n / 2)
        i = i * 2;
      else
        i = (i - n / 2) * 2 + 1;
      ++ans;
    } while (i != 1);

    return ans;
  }
};"
"class Solution:
    def possiblyEquals(self, s1: str, s2: str) -> bool:
        
        def gg(s): 
            """"""Return possible length.""""""
            ans = {int(s)}
            for i in range(1, len(s)): 
                ans |= {x+y for x in gg(s[:i]) for y in gg(s[i:])}
            return ans
        
        @cache
        def fn(i, j, diff): 
            """"""Return True if s1[i:] matches s2[j:] with given differences.""""""
            if i == len(s1) and j == len(s2): return diff == 0
            if i < len(s1) and s1[i].isdigit(): 
                ii = i
                while ii < len(s1) and s1[ii].isdigit(): ii += 1
                for x in gg(s1[i:ii]): 
                    if fn(ii, j, diff-x): return True 
            elif j < len(s2) and s2[j].isdigit(): 
                jj = j 
                while jj < len(s2) and s2[jj].isdigit(): jj += 1
                for x in gg(s2[j:jj]): 
                    if fn(i, jj, diff+x): return True 
            elif diff == 0: 
                if i < len(s1) and j < len(s2) and s1[i] == s2[j]: return fn(i+1, j+1, 0)
            elif diff > 0: 
                if i < len(s1): return fn(i+1, j, diff-1)
            else: 
                if j < len(s2): return fn(i, j+1, diff+1)
            return False 
            
        return fn(0, 0, 0)","class Solution {
 public:
  string evaluate(string s, vector<vector<string>>& knowledge) {
    string ans;
    unordered_map<string, string> map;

    for (const vector<string>& list : knowledge)
      map[""("" + list[0] + "")""] = list[1];

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (c == '(') {
        const int j = s.find_first_of(')', i);
        const string& key = s.substr(i, j - i + 1);
        ans += map.count(key) ? map[key] : ""?"";
        i = j;
      } else {
        ans += c;
      }
    }

    return ans;
  }
};"
"class Solution:
    def countVowels(self, word: str) -> int:
        vowels = [""a"", ""e"", ""i"", ""o"", ""u""]
        res = []
        vowels_cop = set(vowels.copy())

        for j in range(len(word)):
            if word[j] not in vowels:
                continue
            string = """"
            for i in range(j, len(word)):
                flag = False
                if word[i] in vowels:
                    string += str(i)
                    vowels_cop.discard(word[i])
                    if not vowels_cop:
                        res.append(string)
                    flag = True
                if not flag:
                    string = """"
                    vowels_cop = set(vowels.copy())
            string = """"
            vowels_cop = set(vowels.copy())

        print(len(set(res)))","class Solution {
 public:
  int maxNiceDivisors(int primeFactors) {
    if (primeFactors <= 3)
      return primeFactors;
    if (primeFactors % 3 == 0)
      return myPow(3, primeFactors / 3) % kMod;
    if (primeFactors % 3 == 1)
      return 4L * myPow(3, (primeFactors - 4) / 3) % kMod;
    return 2L * myPow(3, (primeFactors - 2) / 3) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  int myPow(long x, int n) {
    if (n == 0)
      return 1;
    if (n & 1)
      return x * myPow(x, n - 1) % kMod;
    return myPow(x * x % kMod, n / 2);
  }
};"
"class Solution:
    def countVowels(self, word: str) -> int:
        vowels=""aeiou""
        n=len(word)
        prefix=[0]
        for s in word:
            prefix.append(prefix[-1]+ (s in vowels))
        prefix.pop(0)
        total=sum(prefix)
        diff=0
        res=total
        for i in range(1,n):
            diff+=prefix[i-1]
            res+=total-(n-i)*prefix[i-1]-diff
        
        return res","/**
 * // This is the GridMaster's API interface.
 * // You should not implement it, or speculate about its implementation
 * class GridMaster {
 *  public:
 *   bool canMove(char direction);
 *   int move(char direction);
 *   boolean isTarget();
 * };
 */

class Solution {
 public:
  int findShortestPath(GridMaster& master) {
    constexpr int m = 100;
    constexpr int startX = m;
    constexpr int startY = m;

    vector<int> target{m * 2, m * 2};
    vector<vector<int>> grid(m * 2, vector<int>(m * 2, -1));
    vector<vector<bool>> seen(m * 2, vector<bool>(m * 2));

    // Build the grid information by DFS.
    dfs(master, grid, startX, startY, target);

    priority_queue<vector<int>, vector<vector<int>>, greater<>> minHeap;
    minHeap.push({0, startX, startY});

    // Find the steps by BFS.
    while (!minHeap.empty()) {
      const vector<int> tuple = minHeap.top();
      const int cost = tuple[0];
      const int i = tuple[1];
      const int j = tuple[2];
      minHeap.pop();
      if (i == target[0] && j == target[1])
        return cost;
      if (seen[i][j])
        continue;
      seen[i][j] = true;
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == 2 * m || y < 0 || y == 2 * m)
          continue;
        if (seen[x][y] || grid[x][y] == -1)
          continue;
        const int nextCost = cost + grid[x][y];
        minHeap.push({nextCost, x, y});
      }
    }

    return -1;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};
  const vector<char> charTable{'R', 'D', 'L', 'U'};

  void dfs(GridMaster& master, vector<vector<int>>& grid, int i, int j,
           vector<int>& target) {
    if (master.isTarget()) {
      target[0] = i;
      target[1] = j;
    }

    for (int k = 0; k < 4; ++k) {
      const int x = i + dirs[k];
      const int y = j + dirs[k + 1];
      const char d = charTable[k];
      const char undoD = charTable[(k + 2) % 4];
      if (master.canMove(d) && grid[x][y] == -1) {
        grid[x][y] = master.move(d);
        dfs(master, grid, x, y, target);
        master.move(undoD);
      }
    }
  }
};"
"class Solution:
    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:
        left, right = 1, max(quantities)
        while left < right:
            middle = (left + right) // 2
            if sum(ceil(q / middle) for q in quantities) > n:
                left = middle + 1
            else:
                right = middle
        return right","class Solution {
 public:
  bool areSentencesSimilar(string sentence1, string sentence2) {
    if (sentence1.length() == sentence2.length())
      return sentence1 == sentence2;

    vector<string> words1 = split(sentence1);
    vector<string> words2 = split(sentence2);
    const int m = words1.size();
    const int n = words2.size();
    if (m > n)
      return areSentencesSimilar(sentence2, sentence1);

    int i = 0;  // words1's index
    while (i < m && words1[i] == words2[i])
      ++i;
    while (i < m && words1[i] == words2[i + n - m])
      ++i;

    return i == m;
  }

 private:
  vector<string> split(const string& sentence) {
    vector<string> words;
    istringstream iss(sentence);

    for (string s; iss >> s;)
      words.push_back(s);

    return words;
  }
};"
"class Solution:
    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:
        graph = defaultdict(list)
        dist = defaultdict(int)
        parent = defaultdict(int)
        R2Bpath = defaultdict(list)
        for u, v, w in edges:
            graph[u].append( (v, w) )
            graph[v].append( (u, w) )
        
        ## calc Djik: Q[ (time, node, parent) ]
        Q = [ (0, 0, -1) ]
        while Q:
            time, node, par = heapq.heappop(Q)
            if node not in dist:
                dist[node] = time
                parent[node] = par
                for v, w in graph[node]:
                    alt = time + w
                    heapq.heappush(Q, (alt, v, node) )
        
        ## get ancesters of each nodes
        for node in range(len(values)):
            if node in dist:
                curr = node
                while curr != -1:
                    R2Bpath[node].append(curr)
                    curr = parent[curr]
        
        
        def get_score(ancesters: List[int]) -> int:
            score = 0
            for node in set(ancesters):
                score += values[node]
            return score
        
        self.maxScore = 0
        def dfs(curr=0, cost=0, path=[0]):
            self.maxScore = max( self.maxScore, get_score(path+R2Bpath[curr]) )
            for v, time in graph[curr]:
                if cost+time+dist[v] <= maxTime:
                    dfs(v, cost+time, path+[v])
                        
        dfs()
        return self.maxScore","class Solution {
 public:
  int countNicePairs(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    unordered_map<int, long> count;

    for (const int num : nums)
      ++count[num - rev(num)];

    for (const auto& [_, freq] : count) {
      ans += freq * (freq - 1) / 2;
      ans %= kMod;
    }

    return ans;
  }

 private:
  int rev(int n) {
    int x = 0;
    while (n) {
      x = x * 10 + (n % 10);
      n /= 10;
    }
    return x;
  }
};"
"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        f1 = Counter(word1)
        f2 = Counter(word2)
        for ch in string.ascii_lowercase:
            if abs(f1[ch]-f2[ch]) > 3:
                return False
        return True","class Solution {
 public:
  int maxHappyGroups(int batchSize, vector<int>& groups) {
    int happy = 0;
    vector<int> freq(batchSize);

    for (int g : groups) {
      g %= batchSize;
      if (g == 0) {
        ++happy;
      } else if (freq[batchSize - g]) {
        --freq[batchSize - g];
        ++happy;
      } else {
        ++freq[g];
      }
    }

    return happy + dp(freq, 0, batchSize);
  }

 private:
  map<vector<int>, int> memo;

  // Max # of partitions you can form given
  // Current freq and current remainder r
  int dp(const vector<int>& freq, int r, const int& batchSize) {
    if (const auto it = memo.find(freq); it != cend(memo))
      return it->second;

    int ans = 0;

    if (any_of(begin(freq), end(freq), [](int f) { return f != 0; })) {
      for (int i = 0; i < freq.size(); ++i)
        if (freq[i]) {
          vector<int> newFreq(freq);
          --newFreq[i];
          ans = max(ans, dp(newFreq, (r + i) % batchSize, batchSize));
        }
      if (r == 0)
        ++ans;
    }

    return memo[freq] = ans;
  }
};"
"class Solution:
    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:
        class Node:
            def __init__(self, key, maximum):
                self.key = key
                self.maximum = maximum
                self.left = None
                self.right = None
        head = Node(items[0][0], items[0][1])
        for i in range(1, len(items)):
            node = head
            new_node = Node(items[i][0], items[i][1])
            while True:
                if new_node.key > node.key:
                    new_node.maximum = max(new_node.maximum, node.maximum)
                    if node.right:
                        node = node.right
                    else:
                        node.right = new_node
                        break
                elif new_node.key < node.key:
                    node.maximum = max(new_node.maximum, node.maximum)
                    if node.left:
                        node = node.left
                    else:
                        node.left = new_node
                        break
                else:
                    node.maximum = max(new_node.maximum, node.maximum)
                    break
            
        answer = []
        for query in queries:
            node = head
            maximum = 0
            while node:
                if query > node.key:
                    maximum = max(maximum, node.maximum)
                    node = node.right
                elif query < node.key:
                    node = node.left
                else:
                    maximum = max(maximum, node.maximum)
                    break
            answer.append(maximum)
        return answer","class Solution {
 public:
  string truncateSentence(string s, int k) {
    for (int i = 0; i < s.length(); ++i)
      if (s[i] == ' ' && --k == 0)
        return s.substr(0, i);
    return s;
  }
};"
"class Solution:
    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:
        
        from sortedcontainers import SortedList
        
        tasks.sort()
        workers.sort()
        
        def check_valid(ans):
            
            # _tasks = SortedList(tasks[:ans])
            _tasks = deque(tasks[:ans])
            _workers = workers[-ans:]
            remain_pills = pills
            
            for worker in _workers:
                task = _tasks[0]
                if worker >= task:
                    # the worker can finish the min task without pill, just move on
                    # _tasks.pop(0)
                    _tasks.popleft()
                elif worker + strength >= task and remain_pills:
                    # the worker cannot finish the min task without pill, but can solve it with pill
                    # remove the max task that the strengthened worker can finish instead
                    # remove_task_idx = _tasks.bisect_right(worker + strength)
                    remove_task_idx = bisect.bisect_right(_tasks, worker + strength)
                    # _tasks.pop(remove_task_idx - 1)
                    del _tasks[remove_task_idx - 1]
                    remain_pills -= 1
                else:
                    return False
            return True
        
        lo, hi = 0, min(len(workers), len(tasks))
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if check_valid(mid):
                lo = mid
            else:
                hi = mid - 1
        return lo","class Solution {
 public:
  vector<int> findingUsersActiveMinutes(vector<vector<int>>& logs, int k) {
    vector<int> ans(k);
    unordered_map<int, unordered_set<int>> idToTimes;

    for (const vector<int>& log : logs)
      idToTimes[log[0]].insert(log[1]);

    for (const auto& [_, mins] : idToTimes)
      ++ans[mins.size() - 1];

    return ans;
  }
};"
"class Solution:
    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        total = sum(tickets)
        n = len(tickets)
        idx = 0 
        days = 0     
        
        while total > 0:
            idx = idx % n 
            if tickets[idx] > 0:
                tickets[idx] -= 1
                days += 1
                total -= 1
                if idx == k and tickets[idx] == 0:
                    return days 
            idx += 1
        return days","class Solution {
 public:
  int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) {
    constexpr int kMod = 1'000'000'007;
    long sumDiff = 0;
    long maxDecrement = 0;
    set<int> sorted(begin(nums1), end(nums1));

    for (int i = 0; i < nums1.size(); ++i) {
      const long currDiff = abs(nums1[i] - nums2[i]);
      sumDiff += currDiff;
      const auto it = sorted.lower_bound(nums2[i]);
      if (it != begin(sorted))
        maxDecrement = max(maxDecrement, currDiff - abs(*prev(it) - nums2[i]));
      if (it != end(sorted))
        maxDecrement = max(maxDecrement, currDiff - abs(*it - nums2[i]));
    }

    return (sumDiff - maxDecrement) % kMod;
  }
};"
"class Solution:
    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:
        return self.helper(head, 1)
    
    def helper(self, head, size, lvl = 0):
        
        # check if we should reverse
        count, node = 0, head
        for _ in range(size):
            if not node:
                break
            count += 1
            node = node.next
        
        if count == 0:
            return head
        
        #print(lvl * 2 * ' ', count, size)

        
        if count % 2 == 1:
            # do not reverse
            node = head
            for _ in range(count - 1):
                node = node.next
            node.next = self.helper(node.next, size + 1, lvl + 1)
            return head
        else:
            # perform reverse
            prev, curr = None, head
            for _  in range(count):
                tmp = curr.next  # prepare
                
                curr.next = prev # link
                
                prev = curr     # move
                curr = tmp      # move

            head.next = self.helper(curr, size + 1, lvl + 1)
            return prev","class Solution {
 public:
  int countDifferentSubsequenceGCDs(vector<int>& nums) {
    const int maxNum = *max_element(begin(nums), end(nums));
    int ans = 0;
    // factor[i] := gcd of nums having factor i
    vector<int> factor(maxNum + 1);

    for (const int num : nums)
      for (int i = 1; i * i <= num; ++i)
        if (num % i == 0) {
          const int j = num / i;
          factor[i] = __gcd(factor[i], num);
          factor[j] = __gcd(factor[j], num);
        }

    for (int i = 1; i <= maxNum; ++i)
      if (factor[i] == i)
        ++ans;

    return ans;
  }
};"
"class Solution:
    def decodeCiphertext(self, et: str, rows: int) -> str:
        L = len(et)
        if not L: return et
        
        cols, ans, start = L//rows, et[0], 0
        i, j = 0, start
        while start < cols - 1:
            i, j = i + 1, j + 1
            if i == rows or j == cols:
                start += 1
                i, j = 0, start
                ans += et[start]
                continue
            
            ans += et[cols*i + j]
                    
        return ans.rstrip()","class Solution {
 public:
  int maximumInvitations(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;
    vector<int> mate(n, -1);  // girl's mate

    for (int i = 0; i < m; ++i)
      if (canInvite(grid, i, vector<bool>(n), mate))
        ++ans;

    return ans;
  }

 private:
  // Returns true if boy i can make an invitation.
  bool canInvite(const vector<vector<int>>& grid, int i, vector<bool>&& seen,
                 vector<int>& mate) {
    // Boy i ask each girl.
    for (int j = 0; j < seen.size(); ++j) {
      if (!grid[i][j] || seen[j])
        continue;
      seen[j] = true;
      if (mate[j] == -1 || canInvite(grid, mate[j], move(seen), mate)) {
        mate[j] = i;  // Match girl j w/ boy i.
        return true;
      }
    }

    return false;
  }
};"
"class Solution:
    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        
        result = [False for _ in requests]
        
        connected_components = [{i} for i in range(n)]
        
        connected_comp_dict = {}
        for i in range(n):
            connected_comp_dict[i] = i
        
        banned_by_comps = [set() for i in range(n)]
        for res in restrictions:
            banned_by_comps[res[0]].add(res[1])
            banned_by_comps[res[1]].add(res[0])
        for i,r in enumerate(requests):
            n1, n2 = r[0], r[1]
            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]
            if c1 == c2:
                result[i] = True
            else:
                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):
                    connected_components[c1].update(connected_components[c2])
                    banned_by_comps[c1].update(banned_by_comps[c2])
                    for node in connected_components[c2]:
                        connected_comp_dict[node] = c1
                    result[i] = True
                
        return result","class Solution {
 public:
  int arraySign(vector<int>& nums) {
    int sign = 1;

    for (const int num : nums) {
      if (num == 0)
        return 0;
      if (num < 0)
        sign = -sign;
    }

    return sign;
  }
};"
"class Solution:
    def maxDistance(self, colors: List[int]) -> int:
        n = len(colors)
        for i in range(n - 1, 0, -1):
            for j in range(n - i):
                if colors[j] != colors[j + i]:
                    return i","class Solution {
 public:
  int findTheWinner(int n, int k) {
    // friends[i] := true if i-th friend is left.
    vector<bool> friends(n);

    int friendCount = n;
    int fp = 0;  // friends' pointer

    while (friendCount > 1) {
      for (int i = 0; i < k; ++i, ++fp)
        while (friends[fp % n])  // The friend is not there.
          ++fp;                  // Point to the next one.
      friends[(fp - 1) % n] = true;
      --friendCount;
    }

    const auto it =
        find_if(begin(friends), end(friends), [](int f) { return !f; });
    return distance(begin(friends), it) + 1;
  }
};"
"class Solution:
    def wateringPlants(self, arr: List[int], capacity: int) -> int:
        n = len(arr)
        cur = capacity
        steps = 0
        
        for i in range(n):
            if arr[i] <= cur:
                steps += 1
            else:
                steps += (2*i+1)  #including forward and return steps
                cur = capacity
                
            cur -= arr[i]
            
        return steps","class Solution {
 public:
  int minSideJumps(vector<int>& obstacles) {
    constexpr int kInf = 1e6;

    // dp[i] := min jump to reach lane i
    vector<int> dp{kInf, 1, 0, 1};

    for (const int obstacle : obstacles) {
      if (obstacle > 0)
        dp[obstacle] = kInf;
      for (int i = 1; i <= 3; ++i)  // Current
        if (i != obstacle)
          for (int j = 1; j <= 3; ++j)  // Prev
            dp[i] = min({dp[i], dp[j] + (i == j ? 0 : 1)});
    }

    return *min_element(begin(dp), end(dp));
  }
};"
"class Solution:
    def kMirror(self, k: int, n: int) -> int:
        
        # start from single digit base k
        cands = [str(i) for i in range(1, k)]
        ans = 0
        
        while n > 0:
            # check current canddiates to see if base 10 is also mirroring
            for cand in cands:
                b10 = str(int(cand, k))
                if b10 == b10[::-1]:
                    ans += int(b10)
                    n -= 1
                    if n == 0: return ans

            # construct new candidates 
            # if previous cand length is even just insert number between 0 and k - 1 into the middle
            # if previous cand length is odd just insert number after len//2+1 and should be the same with left part end digit
            new_cands = []
            for cand in cands:
                m = len(cand)
                for i in range(k):
                    if m % 2 == 0:
                        new_cands.append(cand[:m//2] + str(i) + cand[m//2:])
                    else:
                        left, right = cand[:m//2+1], cand[m//2+1:]
                        if str(i) == left[-1]:
                            new_cands.append(left + str(i) + right)
            cands = new_cands

            
        
        return ans","class Solution {
 public:
  int badSensor(vector<int>& sensor1, vector<int>& sensor2) {
    const bool oneDefect = canReplace(sensor2, sensor1);
    const bool twoDefect = canReplace(sensor1, sensor2);
    if (oneDefect && twoDefect)
      return -1;
    if (!oneDefect && !twoDefect)
      return -1;
    return oneDefect ? 1 : 2;
  }

 private:
  bool canReplace(const vector<int>& A, const vector<int>& B) {
    int i = 0;  // A's index
    int j = 0;  // B's index
    int droppedValue = -1;

    while (i < A.size())
      if (A[i] == B[j]) {
        ++i;
        ++j;
      } else {
        droppedValue = A[i];
        ++i;
      }

    return j == B.size() - 1 && B[j] != droppedValue;
  }
};"
"class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        w1 = set(w for w, c in Counter(words1).items() if c == 1)
        w2 = set(w for w, c in Counter(words2).items() if c == 1)
        return  len(w1 &amp; w2)","class Solution {
 public:
  int minOperations(vector<int>& nums) {
    int ans = 0;
    int last = 0;

    for (const int num : nums) {
      ans += max(0, last - num + 1);
      last = max(num, last + 1);
    }

    return ans;
  }
};"
"class Solution:
    def minimumBuckets(self, street: str) -> int:
        l=list(street.strip())
        c=0
        n=len(street)
        i=1
        while i < len(street)-1:#fill the buckets containg houses on both sides and change H to T
            if l[i-1]==""H"" and l[i+1]==""H"" and l[i]==""."":
                l[i-1]=""T""
                l[i+1]=""T""
                l[i]=""B""
                c+=1

            i+=1
        i=0
        while i<len(street):#fill buckets for remaining houses
            if i-1>=0:
                if l[i-1]==""H"":
                    if l[i]==""."":
                        c+=1
                        l[i-1]=""T""
                        l[i]=""B""
            if i+1<len(l):
                if l[i+1]==""H"":
                    if l[i]==""."":
                        c+=1
                        l[i]=""B""
                        l[i+1]=""T""
            i+=1
        if ""H"" in l:
            return -1
        return c","class Solution {
 public:
  vector<int> countPoints(vector<vector<int>>& points,
                          vector<vector<int>>& queries) {
    vector<int> ans;

    for (const vector<int>& query : queries) {
      const int xj = query[0];
      const int yj = query[1];
      const int rj = query[2];
      int count = 0;
      for (const vector<int>& point : points) {
        const int xi = point[0];
        const int yi = point[1];
        if (squared(xi - xj) + squared(yi - yj) <= squared(rj))
          ++count;
      }
      ans.push_back(count);
    }

    return ans;
  }

 private:
  int squared(int x) {
    return x * x;
  }
};"
"class Solution:
    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:
        
        rm=0
        lm=0
        rm=startPos[0]-homePos[0]# number of ups or downs
        lm=startPos[1]-homePos[1] # number of lefts or rights
        ans=0
        if rm<0:#we need to down
            a=startPos[0]
            while rm!=0:
                rm+=1
                ans+=rowCosts[a+1]#add costs according to the row numbers
                a+=1
        elif rm>0:#up
            a=startPos[0]
            while rm!=0:
                rm-=1
                ans+=rowCosts[a-1]
                a-=1
        if lm<0:#left
            a=startPos[1]
            while lm!=0:
                lm+=1
                ans+=colCosts[a+1]
                a+=1
        elif lm>0:#right
            a=startPos[1]
            while lm!=0:
                lm-=1
                ans+=colCosts[a-1]
                a-=1
        return ans","class Solution {
 public:
  vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {
    const int max = (1 << maximumBit) - 1;
    vector<int> ans;
    int xors = 0;

    for (const int num : nums) {
      xors ^= num;
      ans.push_back(xors ^ max);
    }

    reverse(begin(ans), end(ans));
    return ans;
  }
};"
"class Solution:
    def countPyramids(self, grid: List[List[int]]) -> int:
        m, n, res = len(grid), len(grid[0]), 0
        dp = [row[:] for row in grid]
		
        for i, j in product(range(m-2,-1,-1), range(1, n-1)):
            if grid[i][j]:
                dp[i][j] = min(dp[i+1][k] for k in range(j-1, j+2))+1
                res += dp[i][j]-1
				
        dp[0] = grid[0][:]
        for i, j in product(range(1, m), range(1, n-1)):
            if grid[i][j]:
                dp[i][j] = min(dp[i-1][k] for k in range(j-1, j+2))+1
                res += dp[i][j]-1
        return res","class Solution {
 public:
  bool checkIfPangram(string sentence) {
    return unordered_set(begin(sentence), end(sentence)).size() == 26;
  }
};"
"class Solution:
    def targetIndices(self, nums: List[int], target: int) -> List[int]:
        nums.sort()
        output = []
        for idx in range(len(nums)):
            if nums[idx] == target:
                output.append(idx)
        return output","class Solution {
 public:
  int maxIceCream(vector<int>& costs, int coins) {
    sort(begin(costs), end(costs));

    for (int i = 0; i < costs.size(); ++i)
      if (coins >= costs[i])
        coins -= costs[i];
      else
        return i;

    return costs.size();
  }
};"
"class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:
        output = [-1] * len(nums)
        running = 0
        for idx, i in enumerate(nums):
            running += i
            if idx >= k*2:
                output[idx - k] = running // (k*2+1)
                running -= nums[idx - k*2]
                
        return output","class Solution {
 public:
  vector<int> getOrder(vector<vector<int>>& tasks) {
    const int n = tasks.size();

    // Add index information
    for (int i = 0; i < tasks.size(); ++i)
      tasks[i].push_back(i);

    vector<int> ans;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;
    int i = 0;      // tasks' pointer
    long time = 0;  // Current time

    sort(begin(tasks), end(tasks));
    while (i < n || !minHeap.empty()) {
      if (minHeap.empty())
        time = max(time, static_cast<long>(tasks[i][0]));
      while (i < n && time >= tasks[i][0]) {
        minHeap.emplace(tasks[i][1], tasks[i][2]);
        ++i;
      }
      const auto [procTime, index] = minHeap.top();
      minHeap.pop();
      time += procTime;
      ans.push_back(index);
    }

    return ans;
  }
};"
"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        min_arr = max_arr = nums[0]
        min_i = max_i = 0
        n = len(nums)
        
		# finding max and min indices
        for i in range(1, n):
            if nums[i] > max_arr:
                max_arr = nums[i]
                max_i = i
                
            if nums[i] < min_arr:
                min_arr = nums[i]
                min_i = i
                
		# checking possibilities
        if min_i <= max_i:
            return min(min_i+1+n-max_i, max_i+1, n-min_i)
        else:
            return min(max_i+1+n-min_i, min_i+1, n-max_i)","class Solution {
 public:
  int getXORSum(vector<int>& arr1, vector<int>& arr2) {
    const int xors1 = accumulate(begin(arr1), end(arr1), 0, bit_xor<>());
    const int xors2 = accumulate(begin(arr2), end(arr2), 0, bit_xor<>());
    return xors1 & xors2;
  }
};"
"class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        secretHolders = set()
        secretHolders.add(0)
        secretHolders.add(firstPerson)
        
        tupleMeetings = {}
        for meeting in meetings:
            time = meeting[2]
            if(time in tupleMeetings):
                tupleMeetings[time].append((meeting[0], meeting[1]))
            else:
                tupleMeetings[time] = [(meeting[0], meeting[1])]
        
        #print(tupleMeetings)
        for key in sorted (tupleMeetings):
            edgeList = tupleMeetings[key]
            adjacencyList = {}
            for edge in edgeList:
                if(edge[0] not in adjacencyList):
                    adjacencyList[edge[0]] = set()
                adjacencyList[edge[0]].add(edge[1])
                if(edge[1] not in adjacencyList):
                    adjacencyList[edge[1]] = set()
                adjacencyList[edge[1]].add(edge[0])
            
            frontier = set()
            for edgeNode in adjacencyList:
                if(edgeNode in secretHolders):
                    frontier.add(edgeNode)

            while(len(frontier) > 0):
                newFrontier = set()
                for item in frontier:
                    if(item in adjacencyList):
                        for neighbor in adjacencyList[item]:
                            if(neighbor not in secretHolders):
                                secretHolders.add(neighbor)
                                newFrontier.add(neighbor)
                frontier = newFrontier
        return list(secretHolders)","class Solution {
 public:
  ListNode* deleteDuplicatesUnsorted(ListNode* head) {
    ListNode dummy(0, head);
    unordered_map<int, int> count;

    for (ListNode* curr = head; curr; curr = curr->next)
      ++count[curr->val];

    ListNode* curr = &dummy;

    while (curr) {
      while (curr->next && count.count(curr->next->val) &&
             count[curr->next->val] > 1)
        curr->next = curr->next->next;
      curr = curr->next;
    }

    return dummy.next;
  }
};"
"class Solution:
    def findEvenNumbers(self, digits: List[int]) -> List[int]:
        n = len(digits)
        res = []
        
        for i in range(n):
            if digits[i] != 0:
                for j in range(n):
                    if j != i:
                        for k in range(n):
                            if digits[k] % 2 == 0 and k not in (i, j):
                                res.append(digits[i]*100+digits[j]*10+digits[k])
                            
        res = list(set(res))
        res.sort()
        return res","class Solution {
 public:
  int sumBase(int n, int k) {
    int ans = 0;

    while (n) {
      ans += n % k;
      n /= k;
    }

    return ans;
  }
};"
"class Solution:
    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None:
            return head
        if head.next == None:
            return head.next
        node = head
        n = 0
        while(node != None):
            n+=1
            node = node.next
        mid = n//2
        print(mid)
        n = 0
        node = head
        while(node != None):
            if(n == mid-1):
                node.next = node.next.next
                break
            n += 1
            node = node.next  
        return head","class Solution {
 public:
  int maxFrequency(vector<int>& nums, int k) {
    int ans = 0;
    long sum = 0;

    sort(begin(nums), end(nums));

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      sum += nums[r];
      while (sum + k < static_cast<long>(nums[r]) * (r - l + 1))
        sum -= nums[l++];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};"
"class Solution:
    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
        graph = defaultdict(set) # from.val -> (dest_node, 'L')
        
        que = deque([root])

        while que:
            size = len(que)
            for _ in range(size):
                node = que.popleft()
                if node.left:
                    que.append(node.left)
                    graph[node.val].add((node.left, 'L'))
                    graph[node.left.val].add((node, 'U'))
                if node.right:
                    que.append(node.right)
                    graph[node.val].add((node.right, 'R'))
                    graph[node.right.val].add((node, 'U'))
        
        
        
        que = deque([(startValue, '')])
        visited = set([startValue])
        while que:
            cnt, path = que.popleft()
            
            if cnt == destValue:
                return path
            
            for nei, label in graph[cnt]:
                if nei.val in visited:
                    continue
                que.append([nei.val, path + label])
                visited.add(nei.val)","class Solution {
 public:
  int longestBeautifulSubstring(string word) {
    int ans = 0;
    int count = 1;

    for (int l = 0, r = 1; r < word.length(); ++r) {
      const char curr = word[r];
      const char prev = word[r - 1];
      if (curr >= prev) {
        if (curr > prev)
          ++count;
        if (count == 5)
          ans = max(ans, r - l + 1);
      } else {
        count = 1;
        l = r;
      }
    }

    return ans;
  }
};"
"class Solution:
    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:
        
        # in degree table for each node
        in_degree = defaultdict(int)
        
        # out degree table for each node
        out_degree = defaultdict(int)
        
        # adjacency matrix for each node
        adj_matrix = defaultdict(list)
        
        
        # update table with input edge pairs
        for src, dst in pairs:
            
            in_degree[dst] += 1
            out_degree[src] += 1
            adj_matrix[src].append(dst)
            
        
        ## Case_#1:
        # There is eular circuit in graph, any arbitrary node can be start point, here we use source node of first edge just for convenience
        start_node_idx = pairs[0][0]
        
        
        ## Case_#2
        # There is no eular circuit. But there is eular path, find the start node by indegree and outdegree relation
        for node in adj_matrix:
            
			# find the node whose outdegree is one more than indegree
            if out_degree[node] - in_degree[node] == 1:
                start_node_idx = node
                break
        
        # ------------------------------------------------
        def eular_path( adjMatrix, path, cur_node):
            
            # Keep traverse to next node in DFS until all edges of current node are visited
            while adjMatrix[cur_node]:
                
                # pop one edge and get next visit node
                next_visit_node = adjMatrix[cur_node].pop()
                
                eular_path( adjMatrix, path, next_visit_node )
                
                # post-order style
                # current explorer is finished, record current edge pair 
                path.append([cur_node, next_visit_node])
                
                
        # ------------------------------------------------
        record = []
        eular_path(adj_matrix, record, start_node_idx)
        
        # reversed of post-order record is the answer of eular path        
        return reversed(record)","class Solution {
 public:
  int maxBuilding(int n, vector<vector<int>>& restrictions) {
    vector<vector<int>> A(restrictions);

    A.push_back({1, 0});
    A.push_back({n, n - 1});
    sort(begin(A), end(A));

    for (int i = 1; i < A.size(); ++i) {
      const int dist = A[i][0] - A[i - 1][0];
      A[i][1] = min(A[i][1], A[i - 1][1] + dist);
    }

    for (int i = A.size() - 2; i >= 0; --i) {
      const int dist = A[i + 1][0] - A[i][0];
      A[i][1] = min(A[i][1], A[i + 1][1] + dist);
    }

    int ans = 0;

    for (int i = 1; i < A.size(); ++i) {
      const int l = A[i - 1][0];
      const int r = A[i][0];
      const int hL = A[i - 1][1];
      const int hR = A[i][1];
      ans = max(ans, max(hL, hR) + (r - l - abs(hL - hR)) / 2);
    }

    return ans;
  }
};"
"class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)

        window = nums[:k]

        for i in range(k,n):
            curr_min = min(window)
            
            if nums[i] > curr_min:
                window.remove(curr_min)
                window.append(nums[i])

        return window","class Solution {
 public:
  string nextPalindrome(string num) {
    const int n = num.length();
    vector<int> A(n / 2);

    for (int i = 0; i < A.size(); ++i)
      A[i] = num[i] - '0';

    if (!nextPermutation(A))
      return """";

    string s;

    for (const int a : A)
      s += '0' + a;

    if (n & 1)
      return s + num[n / 2] + string(rbegin(s), rend(s));
    return s + string(rbegin(s), rend(s));
  }

 private:
  // Returns true if nums has next permutation
  bool nextPermutation(vector<int>& nums) {
    const int n = nums.size();

    // From back to front, find the first num < nums[i + 1]
    int i;
    for (i = n - 2; i >= 0; --i)
      if (nums[i] < nums[i + 1])
        break;

    if (i < 0)
      return false;

    // From back to front, find the first num > nums[i], swap it with nums[i]
    for (int j = n - 1; j > i; --j)
      if (nums[j] > nums[i]) {
        swap(nums[i], nums[j]);
        break;
      }

    // Reverse nums[i + 1..n - 1]
    reverse(nums, i + 1, n - 1);
    return true;
  }

  void reverse(vector<int>& nums, int l, int r) {
    while (l < r)
      swap(nums[l++], nums[r--]);
  }
};"
"class Solution:
    def goodDaysToRobBank(self, sec: List[int], time: int) -> List[int]:
        result = []
        
        n = len(sec) - 1
        
        if time == 0:
            copied = sec
            copied.sort()
            if copied == sec:
                return list(range(n+1))
        
        if n <= time:
            return
        
        else:
            t = time
            while t - time >= 0 and t + time <= n:
                temp = time
                s = t - time
                u = t + time
                flag = True
				
                while temp:
                    if sec[s] < sec[s+1]:
                        flag = False
                        break
                    else:
                        s += 1
        
                    if sec[u] < sec[u-1]:
                        flag = False
                        break
                    else:
                        u -= 1
						
                    temp -= 1
					
                if flag == True:
                    result.append(t)
                t += 1
        
        return result","class Solution {
 public:
  string replaceDigits(string s) {
    for (int i = 0; i < s.length(); ++i)
      s[i] += s[i - 1] - '0';
    return s;
  }
};"
"class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        graph = defaultdict(set)
        for i, (x, y, r) in enumerate(bombs):
            for j, (a, b, _) in enumerate(bombs):
                if i != j and pow(x - a, 2) + pow(y - b, 2) <= r * r:
                    graph[i].add(j)
        max_bombs = 1
        for start in graph:
            detonated = set()
            layer = {start}
            while layer:
                new_layer = set()
                for current_bomb in layer:
                    if current_bomb not in detonated:
                        detonated.add(current_bomb)
                        if current_bomb in graph:
                            new_layer.update(graph[current_bomb])
                layer = new_layer
            max_bombs = max(max_bombs, len(detonated))
        return max_bombs","class Solution {
 public:
  int maximumElementAfterDecrementingAndRearranging(vector<int>& arr) {
    sort(begin(arr), end(arr));
    arr[0] = 1;

    for (int i = 1; i < arr.size(); ++i)
      arr[i] = min(arr[i], arr[i - 1] + 1);

    return arr.back();
  }
};"
"class Solution:
    def countPoints(self, rings: str) -> int:
        colors = {'R': 0, 'G': 1, 'B': 2}
        result = 0
        rods = [0] * 10 
        for i in range(0, len(rings), 2):
            color = rings[i]
            rod = int(rings[i+1])
            if rods[rod] != 7:
                rods[rod] |= 1 << colors[color]
                if rods[rod] == 7:
                    result += 1
                    
        return result","class Solution {
 public:
  vector<int> closestRoom(vector<vector<int>>& rooms,
                          vector<vector<int>>& queries) {
    vector<int> ans(queries.size());
    set<int> roomIds;

    for (int i = 0; i < queries.size(); ++i)
      queries[i].push_back(i);

    auto descSize = [](const auto& a, const auto& b) { return a[1] > b[1]; };
    sort(begin(rooms), end(rooms), descSize);
    sort(begin(queries), end(queries), descSize);

    int i = 0;  // rooms' pointer
    for (const vector<int>& query : queries) {
      while (i < rooms.size() && rooms[i][1] >= query[1])
        roomIds.insert(rooms[i++][0]);
      ans[query[2]] = searchClosestRoomId(roomIds, query[0]);
    }

    return ans;
  }

 private:
  int searchClosestRoomId(set<int>& roomIds, int preferred) {
    const auto it = roomIds.lower_bound(preferred);
    const int id1 = it == cbegin(roomIds) ? -1 : *(prev(it));
    const int id2 = it == cend(roomIds) ? -1 : *it;
    if (id1 == -1)
      return id2;
    if (id2 == -1)
      return id1;
    if (abs(preferred - id1) <= abs(preferred - id2))
      return id1;
    return id2;
  }
};"
"class Solution:
    def subArrayRanges(self, nums: List[int]) -> int:
        result = 0
        n = len(nums)
        for i in range(n) :
            Min, Max = nums[i], nums[i]
            
            for j in range(i, n, 1) :
                Min = min(Min, nums[j])
                Max = max(Max, nums[j])
                result -= Max - Min
            
        return abs(result)","class Solution {
 public:
  int getMinDistance(vector<int>& nums, int target, int start) {
    int ans = INT_MAX;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == target)
        ans = min(ans, abs(i - start));

    return ans;
  }
};"
"class Solution:
    def minimumRefill(self, nums: List[int], capacityA: int, capacityB: int) -> int:
        
        
        n = len(nums)
        
        i = 0
        j = n-1
        
        canA = capacityA
        canB = capacityB
        
        count = 0
        
        while(i<j):
    
            # water the left plant
            if canA < nums[i]:
                canA = capacityA   
                count += 1
            canA -= nums[i]
            i += 1
            
            # water the right plant
            if canB < nums[j]:
                canB = capacityB
                count += 1
            canB -= nums[j]
            j -= 1
        
        # if both point to same plant in cases (it'll only happen if n is odd)
        if i==j:
            if canA > canB:
                if canA < nums[i]:
                    canA = capacityA    
                    count += 1
                canA -= nums[i]
            else:
                if canB < nums[j]:
                    canB = capacityB 
                    count += 1
                canB -= nums[j]
                
        
        return count","class Solution {
 public:
  bool splitString(string s) {
    return isValid(s, 0, -1, 0);
  }

 private:
  bool isValid(const string& s, int start, long prev, int segment) {
    if (start == s.length() && segment > 1)
      return true;

    long curr = 0;
    for (int i = start; i < s.length(); ++i) {
      curr = curr * 10 + s[i] - '0';
      if (curr > 9999999999L)
        return false;
      if ((prev == -1 || curr == prev - 1) &&
          isValid(s, i + 1, curr, segment + 1)) {
        return true;
      }
    }

    return false;
  }
};"
"class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        
        f = [0] * (2 * 10**5 + 1)
        for a, b in fruits:
            f[a] = b

        f_acc = list(accumulate(f, initial=0))
        n = len(f_acc)
        
        startPos += 1
        left_only = f_acc[startPos] - f_acc[max(0, startPos - k - 1)]
        right_only = f_acc[min(n - 1, startPos + k)] - f_acc[startPos - 1]
        ans = max(left_only, right_only)
        
        # turn left and then right
        for i in range(1, (k - 1) // 2 + 1):
            
            first_left = f_acc[startPos] - f_acc[max(0, startPos - i - 1)]
            then_right = f_acc[min(n - 1, startPos + k-2*i)] - f_acc[startPos]
        
            first_right = f_acc[min(n - 1, startPos + i)] - f_acc[startPos - 1]
            then_left = f_acc[startPos - 1] - f_acc[max(0, startPos - (k - 2*i) - 1)]
            ans = max(ans, first_left + then_right, first_right + then_left)
        
        return ans","class Solution {
 public:
  int getMinSwaps(string num, int k) {
    string perm = num;

    while (k--)
      next_permutation(begin(perm), end(perm));

    return countSteps(num, perm);
  }

 private:
  int countSteps(const string& A, string& B) {
    int count = 0;

    for (int i = 0, j = 0; i < A.length(); ++i) {
      j = i;
      while (A[i] != B[j])
        ++j;
      while (i < j) {
        swap(B[j], B[j - 1]);
        --j;
        ++count;
      }
    }

    return count;
  }
};"
"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for word in words:
            if word == word[::-1]: return word
        return """"","struct T {
  int size;
  int right;
  T(int size, int right) : size(size), right(right) {}
};

class Solution {
 public:
  vector<int> minInterval(vector<vector<int>>& intervals,
                          vector<int>& queries) {
    vector<int> ans(queries.size(), -1);
    auto compare = [](const T& a, const T& b) { return a.size > b.size; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    vector<vector<int>> qs;

    for (int i = 0; i < queries.size(); ++i)
      qs.push_back({queries[i], i});

    sort(begin(intervals), end(intervals));
    sort(begin(qs), end(qs));

    int i = 0;  // intervals' pointer
    for (const vector<int>& q : qs) {
      while (i < intervals.size() && intervals[i][0] <= q[0]) {
        minHeap.emplace(intervals[i][1] - intervals[i][0] + 1, intervals[i][1]);
        ++i;
      }
      while (!minHeap.empty() && minHeap.top().right < q[0])
        minHeap.pop();
      if (!minHeap.empty())
        ans[q[1]] = minHeap.top().size;
    }

    return ans;
  }
};"
"class Solution:
    def addSpaces(self, s: str, spaces: List[int]) -> str:
        outpur=""""
        rest=0
        for k in range(len(s)):
            if rest<len(spaces) and k == spaces[rest]:
                outpur=outpur+"" ""
                rest=rest+1
            outpur=outpur+s[k]
        return(outpur)","class Solution {
 public:
  int maxDistance(vector<int>& nums1, vector<int>& nums2) {
    int ans = 0;
    int i = 0;
    int j = 0;

    while (i < nums1.size() && j < nums2.size())
      if (nums1[i] > nums2[j])
        ++i;
      else
        ans = max(ans, j++ - i);

    return ans;
  }
};"
"class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        lastPrice = None
        counter = 0
        seen = 0
        
        for price in prices:
            if lastPrice and lastPrice - price == 1:
                counter += 1 + seen
                seen += 1
            else:
                seen = 0
                
            counter += 1
            lastPrice = price
            
        return counter","class Solution {
 public:
  int maxSumMinProduct(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    stack<int> stack;
    vector<long> prefix(nums.size() + 1);

    for (int i = 0; i < nums.size(); ++i)
      prefix[i + 1] = prefix[i] + nums[i];

    for (int i = 0; i <= nums.size(); ++i) {
      while (!stack.empty() &&
             (i == nums.size() || nums[stack.top()] > nums[i])) {
        const int minVal = nums[stack.top()];
        stack.pop();
        const long sum =
            stack.empty() ? prefix[i] : prefix[i] - prefix[stack.top() + 1];
        ans = max(ans, minVal * sum);
      }
      stack.push(i);
    }

    return ans % kMod;
  }
};"
"class Solution:
    def kIncreasing(self, arr: List[int], k: int) -> int:
        n = len(arr)
        
        def lis(nums):
            '''
            Patience sort
            Time: O(NlogN)
            Space: O(N)
            '''
            n = len(nums)
            if n <= 1:
                return n
            # num, pointer
            c = []
            size = 0

            for x in nums:
			    # bisect as it is non-decreasing
                l = bisect.bisect_right(c, x)
                if l < size:
                    c[l] = x
                else:
                    c.append(x)
                    size = max(size, l+1)

            return size
        
        ans = 0
        for i in range(k):
            sub = []
            for j in range(i, n, k):
                sub.append(arr[j])
            ans += len(sub) - lis(sub)
        
        return ans","class Solution {
 public:
  int largestPathValue(string colors, vector<vector<int>>& edges) {
    const int n = colors.length();
    int ans = 0;
    int processed = 0;
    vector<vector<int>> graph(n);
    vector<int> inDegree(n);
    queue<int> q;
    vector<vector<int>> count(n, vector<int>(26));

    // Build graph
    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      ++inDegree[v];
    }

    // Topology
    for (int i = 0; i < n; ++i)
      if (inDegree[i] == 0)
        q.push(i);

    while (!q.empty()) {
      const int out = q.front();
      q.pop();
      ++processed;
      ans = max(ans, ++count[out][colors[out] - 'a']);
      for (const int in : graph[out]) {
        for (int i = 0; i < 26; ++i)
          count[in][i] = max(count[in][i], count[out][i]);
        if (--inDegree[in] == 0)
          q.push(in);
      }
    }

    return processed == n ? ans : -1;
  }
};"
"class Solution:
    def mostWordsFound(self, sentences: List[str]) -> int: 
        c=0
        m=0
        for i in range(len(sentences)):
            c=sentences[i].count(' ')
            if c+1>m:
                m=c+1
        return m","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  bool isWord = false;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  string longestWord(vector<string>& words) {
    string ans;

    for (const string& word : words)
      insert(word);

    for (const string& word : words) {
      if (!allPrefixed(word))
        continue;
      if (ans.length() < word.length() ||
          (ans.length() == word.length() && ans > word))
        ans = word;
    }

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->isWord = true;
  }

  bool allPrefixed(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      node = node->children[i];
      if (!node->isWord)
        return false;
    }
    return true;
  }
};"
"class Solution:
    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        available_ingredients=[]
        
        cook={}
        for ing in supplies:
            available_ingredients.append(ing)
        
        for rec in range(len(recipes)):
            cook[recipes[rec]]=ingredients[rec]
        
        def canCook(recipe,waiting):
            
            
            needed_ingrediants=cook[recipe]
            
            count=0
            for ing in needed_ingrediants:
                if ing in waiting:
                    return False
                if ing in available_ingredients:
                    count+=1
                elif ing in recipes:
                    waiting.append(ing)
                    if canCook(ing,waiting):
                        available_ingredients.append(ing)
                        count+=1
                    
                
            return count==len( needed_ingrediants)
            
        
        result=[]
        for recipe in recipes:

            if canCook(recipe,[]):
                result.append(recipe)
        
        return result","class Solution {
 public:
  string sortSentence(string s) {
    vector<string> words;
    istringstream iss(s);
    string word;

    while (iss >> word)
      words.push_back(word);

    sort(begin(words), end(words),
         [](const auto& a, const auto& b) { return a.back() < b.back(); });

    string ans = trim(words[0]);

    for (int i = 1; i < words.size(); ++i)
      ans += "" "" + trim(words[i]);

    return ans;
  }

 private:
  string trim(const string& s) {
    return s.substr(0, s.length() - 1);
  }
};"
"class Solution:
    def canBeValid(self, s: str, locked: str) -> bool:
        if len(s) % 2 == 1:
            return False
        
        # Left to right, try to balance "")""
        balance = 0
        for i in range(len(s)):
            if s[i] == ""("" or locked[i] == ""0"":
                balance += 1
            else:
                balance -= 1
            if balance < 0:
                return False
                
        # Right to left, try to balance ""(""
        balance = 0
        for i in range(len(s) - 1, -1, -1):
            if s[i] == "")"" or locked[i] == ""0"":
                balance += 1
            else:
                balance -= 1
            if balance < 0:
                return False
        
        return True","class Solution {
 public:
  vector<vector<char>> rotateTheBox(vector<vector<char>>& box) {
    const int m = box.size();
    const int n = box[0].size();
    vector<vector<char>> ans(n, vector<char>(m, '.'));

    for (int i = 0; i < m; ++i)
      for (int j = n - 1, k = n - 1; j >= 0; --j)
        if (box[i][j] != '.') {
          if (box[i][j] == '*')
            k = j;
          ans[k--][m - i - 1] = box[i][j];
        }

    return ans;
  }
};"
"class Solution:
    def abbreviateProduct(self, left: int, right: int) -> str:
        ans = 1                                                                  //Initialise the product with 1
        while left <= right:                                               // Start the multiplying numbers in
            if left == right:                                                 // Exception case when left is right else the number will be multiplied 2 times
                ans *= left                                                   //then only multiply either left or right
            else:
                ans *= left * right                                        // Else multiply left and right numbers and multiply with ans
            left += 1                                                         // Increment left by one
            right -= 1                                                        //Decrement right by 1
        count = 0                                                           // Initialise count of trailing zeroes
        ans = str(ans)                                                    // Converting integer to string
        i = len(ans) - 1                                                  // Start the pointer with end of string
        while i >= 0 and ans[i] == '0':                          // Decrement pointer by one while the value at pointer is 0
            count += 1                                                   //and increase the count of trailing zeroes
            i -= 1
        fans = ''                                                            //Empty string which will store the number without the trailing zeroes
        for j in range(i+1):                                            // will use the i pointer which stored the last location of the trailing zero
            fans += ans[j]                                              //store each character until the trailing zero isn't reached
        final = ''                                                           //Final ans which will give the required result 
        if len(fans) > 10:                                              //If the length of the number without the trailing zeroes has a length greater than 10
            temp1 = ''                                                   //Will store the first 5 character of the number
            for j in range(5):                                          // Adding the first 5 characters
                temp1 += fans[j]
            temp2 = ''                                                   //Will store the last 5 characters of the number
            for j in range(-5,0):                                      // Add the last 5 characters
                temp2 += fans[j]
            final = temp1 + '...' + temp2 + 'e' + str(count)           //Final ans with first 5 character, last 5 characters + e + count of trailing zeroes
        else:                                                                    //If length of the number is less than 10
            final = fans + 'e' + str(count)                         // Final ans with number without trailing zeroes + e + count of trailing zeroes
        return final                                                      //Return the final string","class Solution {
 public:
  int sumOfFlooredPairs(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int kMax = *max_element(begin(nums), end(nums));
    long ans = 0;
    // count[i] := # of nums <= i
    vector<int> count(kMax + 1);

    for (const int num : nums)
      ++count[num];

    for (int i = 1; i <= kMax; ++i)
      count[i] += count[i - 1];

    for (int i = 1; i <= kMax; ++i)
      if (count[i] > count[i - 1]) {
        long sum = 0;
        for (int j = 1; i * j <= kMax; ++j) {
          const int lo = i * j - 1;
          const int hi = i * (j + 1) - 1;
          sum += (count[min(hi, kMax)] - count[lo]) * j;
        }
        ans += sum * (count[i] - count[i - 1]);
        ans %= kMod;
      }

    return ans;
  }
};"
"class Solution:
    def isSameAfterReversals(self, num: int) -> bool:
        return num == 0 or num % 10","class Solution {
 public:
  int subsetXORSum(vector<int>& nums) {
    return dfs(nums, 0, 0);
  }

 private:
  int dfs(const vector<int>& nums, int i, int xors) {
    if (i == nums.size())
      return xors;

    const int x = dfs(nums, i + 1, xors);
    const int y = dfs(nums, i + 1, nums[i] ^ xors);
    return x + y;
  }
};"
"class Solution:
    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:
        grid = [[0]*n for _ in range(n)]
        directions = {'R':(0,1),'L':(0,-1),'U':(-1,0),'D':(1,0)}
        l = len(s)
        ans = [0]*l
        temp = startPos.copy()
        for i in range(l):
            step = 0
            startPos = temp.copy()
            for j in range(i,l):
                d = directions[s[j]]
                new_start  = [startPos[0]+d[0],startPos[1]+d[1]]
                if 0<=new_start[0]<n and 0<=new_start[1]<n :
                    step += 1
                    startPos = new_start
                else:
                    break
            ans[i] = step
        
        return ans","class Solution {
 public:
  int minSwaps(string s) {
    const int ones = count(begin(s), end(s), '1');
    const int zeros = s.length() - ones;
    if (abs(ones - zeros) > 1)
      return -1;
    if (ones > zeros)
      return countSwaps(s, '1');
    if (zeros > ones)
      return countSwaps(s, '0');
    return min(countSwaps(s, '1'), countSwaps(s, '0'));
  }

 private:
  int countSwaps(const string& s, char curr) {
    int swaps = 0;
    for (const char c : s) {
      if (c != curr)
        ++swaps;
      curr ^= 1;
    }
    return swaps / 2;
  }
};"
"class Solution:
    def getDistances(self, arr: List[int]) -> List[int]:
        indices = defaultdict(list)
        prefsum = {}
        for i, a in enumerate(arr):
            indices[a].append(i)
            if a not in prefsum:
                prefsum[a] = [i]
            else:
                prefsum[a].append(i + prefsum[a][-1])
        res = []
        for i, a in enumerate(arr):
            idx = bisect_right(indices[a], i) - 1
            # count of smaller, count of larger
            sc, lc = idx, len(indices[a]) - idx - 1
            ss = prefsum[a][idx - 1] if idx > 0 else 0  # sum of smaller
            ls = prefsum[a][-1] - prefsum[a][idx]  # sum of larger
            res.append(i * sc - ss + ls - i * lc)
        return res","class Solution {
 public:
  long rearrangeSticks(int n, int k) {
    if (n == k)
      return 1;
    if (k == 0)
      return 0;
    if (dp[n][k])
      return dp[n][k];
    return dp[n][k] = (rearrangeSticks(n - 1, k - 1) +
                       rearrangeSticks(n - 1, k) * (n - 1)) %
                      kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<vector<int>> dp = vector<vector<int>>(1001, vector<int>(1001));
};"
"class Solution:
    def recoverArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        n = len(nums)
        
        def check(k):
            cnt = defaultdict(int)
            ans = []
            for x in nums:
                if cnt[x - 2*k] > 0:
                    cnt[x - 2*k] -= 1
                    ans.append(x - k)
                else:
                    cnt[x] += 1
            if len(ans) == n // 2: return ans
            return []
                       
	    # maximum k should not exceed half of the array
        cand_k = sorted(set((nums[i] - nums[0]) // 2 for i in range(1, n // 2 + 1) if (nums[i] - nums[0]) % 2 == 0))
        for k in cand_k:
            if k == 0: continue
            ans = check(k)
            if ans: return ans","class Solution {
 public:
  vector<vector<int>> findRLEArray(vector<vector<int>>& encoded1,
                                   vector<vector<int>>& encoded2) {
    vector<vector<int>> ans;
    int i = 0;  // encoded1's index
    int j = 0;  // encodes2's index

    while (i < encoded1.size() && j < encoded2.size()) {
      const int mult = encoded1[i][0] * encoded2[j][0];
      const int minFreq = min(encoded1[i][1], encoded2[j][1]);
      if (!ans.empty() && mult == ans.back()[0])
        ans.back()[1] += minFreq;
      else
        ans.push_back({mult, minFreq});
      encoded1[i][1] -= minFreq;
      encoded2[j][1] -= minFreq;
      if (encoded1[i][1] == 0)
        ++i;
      if (encoded2[j][1] == 0)
        ++j;
    }

    return ans;
  }
};"
"class Solution:
    def checkString(self, s: str) -> bool:
        return ""ba"" not in s","class Solution {
 public:
  bool checkZeroOnes(string s) {
    int longestOnes = 0;
    int longestZeros = 0;
    int currentOnes = 0;
    int currentZeros = 0;

    for (const char c : s)
      if (c == '0') {
        currentOnes = 0;
        longestZeros = max(longestZeros, ++currentZeros);
      } else {
        currentZeros = 0;
        longestOnes = max(longestOnes, ++currentOnes);
      }

    return longestOnes > longestZeros;
  }
};"
"class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        prev, res = 0, 0
        for i in range(len(bank)):
            ones = bank[i].count(""1"")
            if ones == 0: continue  #we can ignore rows without any ""1""
            
            if prev > 0:  #if we have some 1's in prev row we multiply with current ones to get number of lasers
                res += prev * ones
            prev = ones  #storing curr 1's to find lasers from current to next row
            
        return res","class Solution {
 public:
  bool canReach(string s, int minJump, int maxJump) {
    int count = 0;
    vector<bool> dp(s.length());
    dp[0] = true;

    for (int i = minJump; i < s.length(); ++i) {
      count += dp[i - minJump];
      if (i - maxJump > 0)
        count -= dp[i - maxJump - 1];
      dp[i] = count && s[i] == '0';
    }

    return dp.back();
  }
};"
"class Solution:
    def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -> bool:
      asteroids.sort()
      while asteroids:
        ind = bisect.bisect_right(asteroids, mass)
        if ind == len(asteroids): return True
        elif ind == 0: return False
        else:
          #it can collide with all asteroids before this index
          mass += sum(asteroids[:ind])
          asteroids = asteroids[ind:]","class Solution {
 public:
  int stoneGameVIII(vector<int>& stones) {
    const int n = stones.size();
    vector<int> prefix(n);
    // dp[i] := max score diff the current player can get when the game starts
    // At i, i.e., stones[0..i] are merged whose value is prefix[i]
    vector<int> dp(n, INT_MIN);

    partial_sum(begin(stones), end(stones), begin(prefix));

    // Must take all when there're only two stones left
    dp[n - 2] = prefix.back();

    for (int i = n - 3; i >= 0; --i)
      dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1]);

    return dp[0];
  }
};"
"class Solution:
    def maximumInvitations(self, favorite: List[int]) -> int:
        n = len(favorite)
        graph = [[] for _ in range(n)]
        for i, x in enumerate(favorite): graph[x].append(i)
        
        def bfs(x, seen): 
            """"""Return longest arm of x.""""""
            ans = 0 
            queue = deque([x])
            while queue: 
                for _ in range(len(queue)): 
                    u = queue.popleft()
                    for v in graph[u]: 
                        if v not in seen: 
                            seen.add(v)
                            queue.append(v)
                ans += 1
            return ans 
        
        ans = 0 
        seen = [False]*n
        for i, x in enumerate(favorite): 
            if favorite[x] == i and not seen[i]: 
                seen[i] = seen[x] = True 
                ans += bfs(i, {i, x}) + bfs(x, {i, x})
                
        dp = [0]*n
        for i, x in enumerate(favorite): 
            if dp[i] == 0: 
                ii, val = i, 0
                memo = {}
                while ii not in memo: 
                    if dp[ii]: 
                        cycle = dp[ii]
                        break
                    memo[ii] = val
                    val += 1
                    ii = favorite[ii]
                else: cycle = val - memo[ii]
                for k in memo: dp[k] = cycle
        return max(ans, max(dp))","class Solution {
 public:
  int minProductSum(vector<int>& nums1, vector<int>& nums2) {
    int ans = 0;

    sort(begin(nums1), end(nums1));
    sort(begin(nums2), end(nums2), greater<>());

    for (int i = 0; i < nums1.size(); ++i)
      ans += nums1[i] * nums2[i];

    return ans;
  }
};"
"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li=title.split()
        ans=[]
        for i in range(0,len(li)):
            if len(li[i])==1 or len(li[i])==2:
                li[i]=li[i].lower()
            else:
                li[i]=li[i].capitalize()

        return "" "".join(li)","class Solution {
 public:
  int countGoodSubstrings(string s) {
    int ans = 0;

    for (int i = 0; i + 2 < s.length(); ++i) {
      const char a = s[i];
      const char b = s[i + 1];
      const char c = s[i + 2];
      if (a == b || a == c || b == c)
        continue;
      ++ans;
    }

    return ans;
  }
};"
"class Solution:
    def _findMid(self, head):
        prev = None
        fast = slow = head
        while fast and fast.next:
            prev, slow, fast = slow, slow.next, fast.next.next
        if prev: prev.next = None
        return slow
    
    def _revList(self, head):
        prev = None
        while head:
            head.next, prev, head = prev, head, head.next
        return prev
            
    
    def pairSum(self, head: Optional[ListNode]) -> int:
        # Find 2nd middle node
        mid = self._findMid(head)
        #Reverse list from mid
        tail = self._revList(mid)
        mx = 0
        while head:
            mx = max(mx, head.val + tail.val)
            head, tail = head.next, tail.next
        return mx","class Solution {
 public:
  int minPairSum(vector<int>& nums) {
    int ans = 0;

    sort(begin(nums), end(nums));

    for (int i = 0, j = nums.size() - 1; i < j;)
      ans = max(ans, nums[i++] + nums[j--]);

    return ans;
  }
};"
"class Solution:
    def longestPalindrome(self, words: List[str]) -> int:
        
        palindromicPairsFinder = collections.Counter(); count = 0
        for word in words:
            reversedWord = word[::-1]
            if palindromicPairsFinder[reversedWord] > 0:
                count += 1
                palindromicPairsFinder[reversedWord] -= 1
            else:
                palindromicPairsFinder[word] += 1

        return 2 * (2 * count + any(word[0] == word[1] for word in palindromicPairsFinder if palindromicPairsFinder[word] > 0))","class Solution {
 public:
  int minimumXORSum(vector<int>& nums1, vector<int>& nums2) {
    return dfs(nums1, nums2, vector<int>(1 << nums2.size(), INT_MAX), 0, 0);
  }

 private:
  int dfs(const vector<int>& A, const vector<int>& B, vector<int>&& dp, int i,
          int mask) {
    if (i == A.size())
      return 0;
    if (dp[mask] < INT_MAX)
      return dp[mask];

    for (int j = 0; j < B.size(); ++j)
      if (!(mask >> j & 1))
        dp[mask] = min(dp[mask], (A[i] ^ B[j]) +
                                     dfs(A, B, move(dp), i + 1, mask | 1 << j));

    return dp[mask];
  }
};"
"class Solution:
    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:
        m, n = len(grid), len(grid[0])
        prefix = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m):
            for j in range(n): 
                prefix[i+1][j+1] = grid[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]
        
        seen = [[0]*n for _ in range(m)]
        for i in range(m-stampHeight+1): 
            for j in range(n-stampWidth+1): 
                diff = prefix[i+stampHeight][j+stampWidth] - prefix[i+stampHeight][j] - prefix[i][j+stampWidth] + prefix[i][j]
                if diff == 0: seen[i][j] = 1
                    
        prefix = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m): 
            for j in range(n): 
                prefix[i+1][j+1] = seen[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]
                
        for i in range(m):
            ii = max(0, i-stampHeight+1)
            for j in range(n): 
                jj = max(0, j-stampWidth+1)
                if grid[i][j] == 0 and prefix[i+1][j+1] - prefix[i+1][jj] - prefix[ii][j+1] + prefix[ii][jj] == 0: return False 
        return True","class Solution {
 public:
  string maxValue(string n, int x) {
    bool isNegative = n[0] == '-';

    for (int i = 0; i < n.length(); ++i)
      if (!isNegative && n[i] - '0' < x || isNegative && n[i] - '0' > x)
        return n.substr(0, i) + (char)('0' + x) + n.substr(i);

    return n + (char)('0' + x);
  }
};"
"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        n=len(matrix)
        
        return all(len(set(row))==n for row in matrix) and all(len(set(col))==n for col in zip(*matrix))","struct T {
  int weight;
  int index;
  int freeTime;
  T(int weight, int index, int freeTime)
      : weight(weight), index(index), freeTime(freeTime) {}
};

class Solution {
 public:
  vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {
    const int n = servers.size();
    const int m = tasks.size();
    vector<int> ans(m);
    auto compareFree = [](const T& a, const T& b) {
      return a.weight == b.weight ? a.index > b.index : a.weight > b.weight;
    };
    auto compareUsed = [](const T& a, const T& b) {
      if (a.freeTime != b.freeTime)
        return a.freeTime > b.freeTime;
      if (a.weight != b.weight)
        return a.weight > b.weight;
      return a.index > b.index;
    };
    priority_queue<T, vector<T>, decltype(compareFree)> free(compareFree);
    priority_queue<T, vector<T>, decltype(compareUsed)> used(compareUsed);

    for (int i = 0; i < n; ++i)
      free.emplace(servers[i], i, 0);

    for (int i = 0; i < m; ++i) {  // I := current time
      const int executionTime = tasks[i];
      // Pop all servers that'll be free at time i
      while (!used.empty() && used.top().freeTime <= i) {
        const T curr = used.top();
        used.pop();
        free.push(curr);
      }
      if (free.empty()) {
        T server = used.top();
        used.pop();
        ans[i] = server.index;
        server.freeTime += executionTime;
        used.push(server);
      } else {
        T server = free.top();
        free.pop();
        ans[i] = server.index;
        server.freeTime = i + executionTime;
        used.push(server);
      }
    }

    return ans;
  }
};"
"class Solution:
    def minSwaps(self, nums: List[int]) -> int:

        cntone = 0
        
		# First, compute how many 1s here
        for n in nums:
            if n == 1:
                cntone += 1
    
        l, res = 0, float('inf')
		
		# Doing this for circular array
        nums.extend(nums)
        
        need = {0:0, 1:0}
		
		# Start sliding window
        for r, val in enumerate(nums):
            need[val] += 1
             
			# our window should group all 1 together 
            if need[0] + need[1] == cntone:
                res = min(res, need[0])
                need[nums[l]] -= 1
                l += 1
                
        return res if res != float('inf') else 0","class Solution {
 public:
  int minSkips(vector<int>& dist, int speed, int hoursBefore) {
    constexpr double kInf = 1e7;
    constexpr double kEps = 1e-9;
    const int n = dist.size();
    // dp[i][j] := min time w/ prev i-th road and j skips
    vector<vector<double>> dp(n + 1, vector<double>(n + 1, kInf));
    dp[0][0] = 0;

    for (int i = 1; i <= n; ++i) {
      const double d = dist[i - 1];
      dp[i][0] = ceil(dp[i - 1][0] + d / speed - kEps);
      for (int j = 1; j <= i; ++j)
        dp[i][j] = min(dp[i - 1][j - 1] + d / speed,
                       ceil(dp[i - 1][j] + d / speed - kEps));
    }

    for (int j = 0; j <= n; ++j)
      if (dp[n][j] <= hoursBefore)
        return j;

    return -1;
  }
};"
"class Solution:
    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:
        # turns word into binary string
        # i.e., 'ab' -> b11
        # 'ac' -> b101
        # 'ad' -> b1001
        # a-z -> b11111111111111111111111111
        def bin_word(word):
            num = 0
            for c in word:
                cn = ord(c) - ord('a')
                mask = 1 << cn
                num ^= mask
            return num
        
        # take out a letter from a binary string
        def bin_take_out(word, letter):
            cn = ord(letter) - ord('a')
            mask = 1 << cn
            return word ^ mask

        starts = set([bin_word(w) for w in startWords])
            
        count = 0
        for t in targetWords:
            t_b = bin_word(t)
            for c in t:
                # try taking out each letter in t
                # and see if the resulting binary
                # in starts
                if bin_take_out(t_b, c) in starts:
                    count += 1
                    break
        return count","class Solution {
 public:
  int twoEggDrop(int n) {
    return superEggDrop(2, n);
  }

 private:
  vector<vector<int>> dp;

  int superEggDrop(int k, int N) {
    // dp[k][n] := min # of moves to know F with k eggs and n floors
    dp.resize(k + 1, vector<int>(N + 1, -1));
    return drop(k, N);
  }

  int drop(int k, int n) {
    if (k == 0)  // No eggs -> done
      return 0;
    if (k == 1)  // One egg -> drop from 1-th floor to n-th floor
      return n;
    if (n == 0)  // No floor -> done
      return 0;
    if (n == 1)  // One floor -> drop from that floor
      return 1;
    if (dp[k][n] != -1)
      return dp[k][n];

    //   broken[i] := drop(k - 1, i - 1) is increasing w/ i
    // unbroken[i] := drop(k,     n - i) is decreasing w/ i
    // dp[k][n] := 1 + min(max(broken[i], unbroken[i])), 1 <= i <= n
    // Find the first index i s.t broken[i] >= unbroken[i],
    // Which minimizes max(broken[i], unbroken[i])

    int l = 1;
    int r = n + 1;

    while (l < r) {
      const int m = (l + r) / 2;
      const int broken = drop(k - 1, m - 1);
      const int unbroken = drop(k, n - m);
      if (broken >= unbroken)
        r = m;
      else
        l = m + 1;
    }

    return dp[k][n] = 1 + drop(k - 1, l - 1);
  }
};"
"class Solution:
    def earliestFullBloom(self, plantTime, growTime):
        PLANT, GROW = 0,1
        #create array of (plant, grow) tuples
        times = list(zip(plantTime, growTime))

        #sort by grow time
        times.sort(key=lambda i:i[GROW], reverse=True)

        prev_plant = prev_bloom = 0
        for time in times:
            cur_bloom = time[PLANT]+time[GROW]

            #get the time of the last bloom
            prev_bloom = max(prev_bloom, prev_plant+cur_bloom)

            prev_plant += time[PLANT]

        return prev_bloom","class Solution {
 public:
  long long countPairs(vector<int>& nums1, vector<int>& nums2) {
    long long ans = 0;
    vector<int> A(nums1.size());

    for (int i = 0; i < A.size(); ++i)
      A[i] = nums1[i] - nums2[i];

    sort(begin(A), end(A));

    for (int i = 0; i < A.size(); ++i) {
      const auto it = lower_bound(begin(A) + i + 1, end(A), -A[i] + 1);
      ans += cend(A) - it;
    }

    return ans;
  }
};"
"class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        
		# s = ""abcdefghij"", k = 3, fill = ""x""
		
        res = []
        for i in range(0, len(s), k):
            res.append(s[i:i+k])
            # print(res) ['abc', 'def', 'ghi', 'j']
            
            while len(res[-1]) < k:
                    res[-1] += fill
        return res","class Solution {
 public:
  bool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {
    for (int i = 0; i < 4; ++i) {
      if (mat == target)
        return true;
      rotate(mat);
    }
    return false;
  }

 private:
  void rotate(vector<vector<int>>& M) {
    reverse(begin(M), end(M));
    for (int i = 0; i < M.size(); ++i)
      for (int j = i + 1; j < M.size(); ++j)
        swap(M[i][j], M[j][i]);
  }
};"
"class Solution:
    def minMoves(self, target: int, maxDoubles: int) -> int:
        step = 0
        while target != 1  :
            if target % 2 == 1:
                if maxDoubles == 0:
                    step += target -1
                    target = 1
                else:
                    target -= 1
                    step +=1
            else:
                if maxDoubles > 0:
                    target = target/ 2
                    step +=1
                    maxDoubles -=1
                else:
                    step +=1
                    target -=1
        return int(step)","class Solution {
 public:
  int reductionOperations(vector<int>& nums) {
    int ans = 0;

    sort(begin(nums), end(nums));

    for (int i = nums.size() - 1; i > 0; --i)
      if (nums[i] != nums[i - 1])
        ans += nums.size() - i;

    return ans;
  }
};"
"class Solution:
    def mostPoints(self, questions: List[List[int]]) -> int:
        n = len(questions)
        
        # set dp array
        dp = [0]*n
        
        # start from last
        dp [-1] = questions[-1][0]
        
        # start setting the rest
        for i in reversed(range(n-1)):
            points, skip = questions[i]
            
            # dp formula
            if i + skip + 1 < n : dp[i] = max(dp[i+1], points + dp[i + skip + 1])
            else: dp [i] = max(points, dp[i+1])
    
        return dp[0]","class Solution {
 public:
  int minFlips(string s) {
    const int n = s.length();
    // count[0][0] := # of '0' in even indices
    // count[0][1] := # of '0' in odd  indices
    // count[1][0] := # of '1' in even indices
    // count[1][1] := # of '1' in odd  indices
    vector<vector<int>> count(2, vector<int>(2));

    for (int i = 0; i < n; ++i)
      ++count[s[i] - '0'][i % 2];

    // Min(make all '0' in even indices + make all '1' in odd indices,
    //     make all '1' in even indices + make all '0' in odd indices)
    int ans = min(count[1][0] + count[0][1], count[0][0] + count[1][1]);

    for (int i = 0; i < n; ++i) {
      --count[s[i] - '0'][i % 2];
      ++count[s[i] - '0'][(n + i) % 2];
      ans = min({ans, count[1][0] + count[0][1], count[0][0] + count[1][1]});
    }

    return ans;
  }
};"
"class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        l, h = min(batteries), sum(batteries)
        
        batteries.sort()
        cands = batteries[-n:]
        rest = sum(batteries[:-n])
        
        def bs(t):
            tmp = rest
            for x in cands:
			    # all rest batteries on computer can run more than t time
                if x >= t: return True
				# need t - x batteries to fill
                tmp -= t - x
				if tmp < 0: return False
            return True
            
        
        while l < h:
            mid = l + (h - l + 1) // 2
            if bs(mid):
                l = mid
            else:
                h = mid  - 1
        
        return l","class Solution {
 public:
  int minWastedSpace(vector<int>& packages, vector<vector<int>>& boxes) {
    constexpr int kMod = 1'000'000'007;
    constexpr long kInf = 1e11;
    const long packagesSum = accumulate(begin(packages), end(packages), 0L);
    long minBoxesSum = kInf;

    sort(begin(packages), end(packages));

    for (auto& box : boxes) {
      sort(begin(box), end(box));
      if (box.back() < packages.back())
        continue;
      long accu = 0;
      long i = 0;
      for (const int b : box) {
        const long j = firstGreaterEqual(packages, b + 1);
        accu += b * (j - i);
        i = j;
      }
      minBoxesSum = min(minBoxesSum, accu);
    }

    return minBoxesSum == kInf ? -1 : (minBoxesSum - packagesSum) % kMod;
  }

 private:
  int firstGreaterEqual(const vector<int>& A, int target) {
    return lower_bound(begin(A), end(A), target) - begin(A);
  }
};"
"class Solution:
    def minimumCost(self, cost: List[int]) -> int:
        cost.sort(reverse=True)
        res = sum(cost)
        i = 2
        while i < len(cost):
            res -= cost[i]
            i += 3 #skip every 2 elements to eliminate the max possible price
            
        return res","class Solution {
 public:
  int maxLength(vector<int>& ribbons, int k) {
    int l = 1;
    int r = accumulate(begin(ribbons), end(ribbons), 0L) / k + 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (!isCutPossible(ribbons, m, k))
        r = m;
      else
        l = m + 1;
    }

    return l - 1;
  }

 private:
  bool isCutPossible(const vector<int>& ribbons, int length, int k) {
    int count = 0;
    for (const int ribbon : ribbons)
      count += ribbon / length;
    return count >= k;
  }
};"
"class Solution:
    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int: 
        total_sequences = 0
        sequence = [lower] 
        
        for j in range(len(differences)):
            x = sequence[j] + differences[j]
            sequence.append(x)
        
        minn, maxx = min(sequence), max(sequence)
        
        if lower <= minn <= upper and lower <= maxx <= upper: total_sequences += 1
            
        for i in range(lower + 1, upper+1):
            minn = minn + 1
            maxx = maxx + 1
            
            if lower <= minn <= upper and lower <= maxx <= upper: total_sequences += 1
            
        return total_sequences","class Solution {
 public:
  int chalkReplacer(vector<int>& chalk, int k) {
    k %= accumulate(begin(chalk), end(chalk), 0L);
    if (k == 0)
      return 0;

    for (int i = 0; i < chalk.size(); ++i) {
      k -= chalk[i];
      if (k < 0)
        return i;
    }

    throw;
  }
};"
"class Solution:
    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:
        q = deque([tuple(start)])
        m, n = len(grid), len(grid[0])
        lower, upper = pricing[0], pricing[1]
        ranked_arr = []
        visited = {tuple(start)}
        adj = [(-1, 0), (0, -1), (0, 1), (1, 0)]
        while q:
            next_q = []
            for _ in range(len(q)):
                cur = q.popleft()
                x, y = cur
                if lower <= grid[x][y] <= upper:
                    ranked_arr.append(list(cur))
                
                for dx, dy in adj:
                    if ((x + dx, y + dy) in visited or
                        not (0 <= x + dx < m and 0 <= y + dy < n) or
                        grid[x + dx][y + dy] == 0
                    ):
                        continue
                    next_q.append((x + dx, y + dy))
                    visited.add((x + dx, y + dy))
            next_q.sort(key=lambda xy: xy[1])
            next_q.sort(key=lambda xy: xy[0])
            next_q.sort(key=lambda xy: grid[xy[0]][xy[1]])
            q = deque(next_q)
        return ranked_arr[:k]","class Solution {
 public:
  bool makeEqual(vector<string>& words) {
    vector<int> count(26);

    for (const string& word : words)
      for (const char c : word)
        ++count[c - 'a'];

    return all_of(begin(count), end(count),
                  [&](const int c) { return c % words.size() == 0; });
  }
};"
"class Solution:
    def numberOfWays(self, corridor: str) -> int:
        n = len(corridor)
        if n==1:
            return 0
        d = defaultdict(int)
        numS = 0
        
        for i in range(n):
            if (numS==0 or numS%2==1) and corridor[i]=='P':
                continue
            if corridor[i]=='P':
                d[numS//2] += 1
            else:
                numS += 1

        if numS==0 or numS%2:
            return 0
        if corridor[-1]=='P':
            d[numS//2] = 0

        ret = 1
        for v in d.values():
            ret *= (v+1)
        return ret%(10**9+7)","class Solution {
 public:
  int maximumRemovals(string s, string p, vector<int>& removable) {
    int l = 0;
    int r = removable.size() + 1;

    while (l < r) {
      const int m = (l + r) / 2;
      const string removed = remove(s, removable, m);
      if (isSubsequence(p, removed))
        l = m + 1;
      else
        r = m;
    }

    return l - 1;
  }

 private:
  string remove(const string& s, const vector<int>& removable, int k) {
    string removed(s);
    for (int i = 0; i < k; ++i)
      removed[removable[i]] = '*';
    return removed;
  }

  bool isSubsequence(const string& p, const string& s) {
    int i = 0;  // p's index
    for (int j = 0; j < s.length(); ++j)
      if (p[i] == s[j])
        if (++i == p.length())
          return true;
    return false;
  }
};"
"class Solution:
    def countElements(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return 0
        # sort the num
        nums.sort()
        i = 1
        j = len(nums)-2
        while i < len(nums) and nums[i] == nums[i-1]:
            i+=1
        while j >= 0 and nums[j] == nums[j+1]:
            j-=1
        return max(0,j-i+1)","class Solution {
 public:
  bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {
    vector<int> merged(target.size());

    for (auto& t : triplets)
      if (equal(begin(t), end(t), begin(target),
                [](int a, int b) { return a <= b; }))
        transform(begin(t), end(t), begin(merged), begin(merged),
                  [](int a, int b) { return max(a, b); });

    return merged == target;
  }
};"
"class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        a=[0]*len(nums)
        p=0
        n=1
        for i in nums:
            if i<0:
                a[n]=i
                n+=2
            else:
                a[p]=i
                p+=2
        return a","class Solution {
 public:
  vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {
    dp.resize(n + 1, vector<vector<P>>(n + 1, vector<P>(n + 1)));
    const auto [a, b] = solve(firstPlayer, n - secondPlayer + 1, n);
    return {a, b};
  }

 private:
  typedef pair<int, int> P;
  // dp[i][j][k] := (earliest, latest) pair w/ firstPlayer is i-th player from
  // Front, secondPlayer is j-th player from end, and there're k people
  vector<vector<vector<P>>> dp;

  P solve(int l, int r, int k) {
    if (l == r)
      return {1, 1};
    if (l > r)
      swap(l, r);
    if (dp[l][r][k] != pair<int, int>(0, 0))
      return dp[l][r][k];

    int a = INT_MAX;
    int b = INT_MIN;

    // Enumerate all possible positions
    for (int i = 1; i <= l; ++i)
      for (int j = l - i + 1; j <= r - i; ++j) {
        if (i + j > (k + 1) / 2 || i + j < l + r - k / 2)
          continue;
        const auto [x, y] = solve(i, j, (k + 1) / 2);
        a = min(a, x + 1);
        b = max(b, y + 1);
      }

    return dp[l][r][k] = {a, b};
  }
};"
"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        d = {}
        for num in nums:
            d[num] = d.get(num, 0) + 1
        
        ans = []
        for num in nums:
            if d[num] == 1 and (num-1) not in d and (num+1) not in d:
                ans.append(num)
        
        return ans","class Solution {
 public:
  vector<int> findPeakGrid(vector<vector<int>>& mat) {
    int l = 0;
    int r = mat.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (*max_element(begin(mat[m]), end(mat[m])) >=
          *max_element(begin(mat[m + 1]), end(mat[m + 1])))
        r = m;
      else
        l = m + 1;
    }

    return {l, getMaxIndex(mat[l])};
  }

 private:
  int getMaxIndex(const vector<int>& A) {
    pair<int, int> res{0, A[0]};
    for (int i = 1; i < A.size(); ++i)
      if (A[i] > res.second)
        res = {i, A[i]};
    return res.first;
  }
};"
"class Solution:
    def maximumGood(self, s: List[List[int]]) -> int:
        """"""
        brute force: try if all N people are good, if not, try N-1 etc.
        """"""
        N = len(s)
        
        gooddict = defaultdict(set)
        baddict = defaultdict(set)
        
        for r in range(N):
            for c in range(N):
                if s[r][c]==1: 
                    gooddict[r].add(c)
                elif s[r][c] == 0:
                    baddict[r].add(c)
     
        def valid(good):
            bad = set(x for x in range(N) if x not in good)
            for g in good:
                for gg in gooddict[g]:
                    if gg not in good:
                        return False
                for gb in baddict[g]:
                    if gb not in bad:
                        return False
            return True
        
        for t in range(len(s),0,-1):
            choices = set(itertools.combinations(range(N), t))
            for c in choices:
                if valid(c):
                    return t
                
        return 0","class Solution {
 public:
  int maxDepthBST(vector<int>& order) {
    int ans = 1;
    map<int, int> map;  // {val: depth}
    map[order[0]] = 1;

    for (int i = 1; i < order.size(); ++i) {
      const int val = order[i];
      const auto l = map.upper_bound(val);  // Min > val
      const auto r = map.lower_bound(val);  // Min >= val
      const int leftDepth = l == cbegin(map) ? 0 : prev(l)->second;
      const int rightDepth = r == cend(map) ? 0 : r->second;
      const int depth = max(leftDepth, rightDepth) + 1;
      ans = max(ans, depth);
      map[val] = depth;
    }

    return ans;
  }
};"
"class Solution:
    def findFinalValue(self, nums: List[int], x: int) -> int:
        nums = set(nums)
        while True:
            if x in nums:
                x *= 2
            else:
                break
        return x","class Solution {
 public:
  string largestOddNumber(string num) {
    for (int i = num.length() - 1; i >= 0; --i)
      if ((num[i] - '0') & 1)
        return num.substr(0, i + 1);
    return """";
  }
};"
"class Solution:
    def maxScoreIndices(self, nums: List[int]) -> List[int]:
	
        t1 = [0]                                                              #Initialise array for prefix sum
        t2 = [0]*(len(nums)+1)                                      #Initialise array for suffix sum
		
		#Create preffix sum
        for i in nums:
            if not t1:
                t1.append(0)
            else:
                if i == 0:
                    t1.append(t1[-1]+1)
                else:
                    t1.append(t1[-1])
					
		#Create suffix sum
        for i in range(len(nums) - 1, -1, -1):
            t2[i] = nums[i]+t2[i+1]
        ans = []
		
		#Assign score to each index
        for i in range(len(t1)):
            ans.append((t1[i]+t2[i], i))
			
		#Sort in reverse order
        ans.sort(reverse = True)
		
		#Take the max score
        ans1 = ans[0][0]
        t = []
		
		#Check for indexes having the max score
        for i in ans:
            if i[0] == ans1:
                t.append(i[1])
        return t","class Solution {
 public:
  int numberOfRounds(string startTime, string finishTime) {
    const int start = getMinutes(startTime);
    int finish = getMinutes(finishTime);
    if (start > finish)
      finish += 60 * 24;
    return max(0, finish / 15 - (start + 14) / 15);
  }

 private:
  int getMinutes(const string& s) {
    return 60 * stoi(s.substr(0, 2)) + stoi(s.substr(3));
  }
};"
"class Solution:
    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:
        sol = 0
        powr = 1
        
        for i in range(0, k, 1):
            sol += (ord(s[i]) - ord('a') + 1) * powr
            powr = powr * power
        if sol % modulo == hashValue: 
            return s[:k]
        
        powr = powr // power
        for i in range(1, len(s) - k + 1, 1):
            sol = ((sol - (ord(s[i - 1]) - ord('a') + 1)) // power) + ((ord(s[i + k - 1]) - ord('a') + 1) * powr)
            if (sol % modulo == hashValue):
                return s[i:i + k]
            
        return """"","class Solution {
 public:
  int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {
    int ans = 0;

    for (int i = 0; i < grid2.size(); ++i)
      for (int j = 0; j < grid2[0].size(); ++j)
        if (grid2[i][j] == 1)
          ans += dfs(grid1, grid2, i, j);

    return ans;
  }

 private:
  int dfs(const vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i,
          int j) {
    if (i < 0 || i == grid1.size() || j < 0 || j == grid2[0].size())
      return 1;
    if (grid2[i][j] != 1)
      return 1;

    grid2[i][j] = 2;  // Mark 2 as visited

    return dfs(grid1, grid2, i + 1, j) & dfs(grid1, grid2, i - 1, j) &
           dfs(grid1, grid2, i, j + 1) & dfs(grid1, grid2, i, j - 1) &
           grid1[i][j];
  }
};"
"class Solution:
    def minimumSum(self, num: int) -> int:
        string = str(num)
        arr = [char for char in string]
        arr.sort()
        
        # two possible combination
        result1 = int(arr[0]+ arr[2]) + int(arr[1] + arr[3])
        result2 = int(arr[1]+ arr[2]) + int(arr[0] + arr[3])
        
        return min(result1, result2)","class Solution {
 public:
  vector<int> minDifference(vector<int>& nums, vector<vector<int>>& queries) {
    vector<vector<int>> numToIndices(101);

    for (int i = 0; i < nums.size(); ++i)
      numToIndices[nums[i]].push_back(i);

    if (numToIndices[nums[0]].size() == nums.size())
      return vector<int>(queries.size(), -1);

    vector<int> ans;

    for (const vector<int>& query : queries) {
      const int l = query[0];
      const int r = query[1];
      int prevNum = -1;
      int minDiff = 101;
      for (int num = 1; num <= 100; ++num) {
        const auto& indices = numToIndices[num];
        const auto it = lower_bound(begin(indices), end(indices), l);
        if (it == cend(indices) || *it > r)
          continue;
        if (prevNum != -1)
          minDiff = min(minDiff, num - prevNum);
        prevNum = num;
      }
      ans.push_back(minDiff == 101 ? -1 : minDiff);
    }

    return ans;
  }
};"
"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lessthan = []
        for i in nums:
            if i < pivot:
                lessthan.append(i)
        equal = []
        for i in nums:
            if i == pivot:
                equal.append(i)
        great = []
        for i in nums:
            if i > pivot:
                great.append(i)
        return lessthan + equal + great","class Solution {
 public:
  bool canBeIncreasing(vector<int>& nums) {
    bool removed = false;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i - 1] >= nums[i]) {
        if (removed)
          return false;
        removed = true;  // Remove nums[i - 1]
        if (i > 1 && nums[i - 2] >= nums[i])
          nums[i] = nums[i - 1];  // Remove nums[i] instead
      }

    return true;
  }
};"
"class Solution:
    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:   
        mins = targetSeconds // 60
        secs = targetSeconds % 60
        min_cost = math.inf
        
        if mins <= 99:
            cost1 = cost(mins, secs, startAt, moveCost, pushCost)
            min_cost = min(min_cost, cost1)
        if secs <= 39:
            cost2 = cost(mins - 1, secs + 60, startAt, moveCost, pushCost)
            min_cost = min(min_cost, cost2)
            
        return min_cost
        
def cost(mins, secs, startAt, moveCost, pushCost):
    cost = 0
    has_prev = False
    
    for digit in [mins // 10, mins % 10, secs // 10, secs % 10]:
        if has_prev or digit != 0:
            if digit != startAt:
                cost += moveCost
                startAt = digit
            cost += pushCost
            has_prev = True
    
    return cost","class Solution {
 public:
  string removeOccurrences(string s, string part) {
    const int n = s.length();
    const int k = part.length();

    string t(n, ' ');
    int j = 0;  // t's index

    for (int i = 0; i < n; ++i) {
      t[j++] = s[i];
      if (j >= k && t.substr(j - k, k) == part)
        j -= k;
    }

    return t.substr(0, j);
  }
};"
"class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums)//3
        pq0 = [-x for x in nums[:n]]
        pq1 = nums[-n:]
        
        heapify(pq0)
        heapify(pq1)
        
        ans = -sum(pq0) - sum(pq1)
        prefix = [0]
        for i in range(n, 2*n): 
            prefix.append(prefix[-1])
            if nums[i] < -pq0[0]: 
                prefix[-1] += nums[i] + pq0[0]
                heapreplace(pq0, -nums[i])
        extra = prefix[-1]
        suffix = 0 
        for i in reversed(range(n, 2*n)): 
            if nums[i] > pq1[0]: 
                suffix += pq1[0] - nums[i]
                heapreplace(pq1, nums[i])
            extra = min(extra, prefix[i-n] + suffix)
        return ans + extra","class Solution {
 public:
  long long maxAlternatingSum(vector<int>& nums) {
    long even = 0;  // Max alternating sum ending with a even index
    long odd = 0;   // Max alternating sum ending with a odd index

    for (const int num : nums) {
      even = max(even, odd + num);
      odd = even - num;
    }

    return even;
  }
};"
"class Solution:
    def sortEvenOdd(self, nums: List[int]) -> List[int]:
        return reduce(add, zip_longest(sorted([nums[i] for i in range(0,len(nums),2)]), sorted([nums[i] for i in range(1,len(nums),2)])[::-1]))[:len(nums)]","class Solution {
 public:
  int maxProductDifference(vector<int>& nums) {
    int max1 = INT_MIN;
    int max2 = INT_MIN;
    int min1 = INT_MAX;
    int min2 = INT_MAX;

    for (const int num : nums) {
      if (num > max1) {
        max2 = max1;
        max1 = num;
      } else if (num > max2) {
        max2 = num;
      }
      if (num < min1) {
        min2 = min1;
        min1 = num;
      } else if (num < min2) {
        min2 = num;
      }
    }

    return max1 * max2 - min1 * min2;
  }
};"
"class Solution:
    def smallestNumber(self, num: int) -> int:
        if num//10==0:
            return num
        if num<0:
            sign=-1
        else:
            sign=1
        num=abs(num)    
        if sign==-1:
            s=sorted(str(num),reverse=True)
            return sign*int("""".join(s))
        else:
            s=sorted(str(num))
            zeros=s.count('0')
            if zeros!=0:
                s[0],s[zeros]=s[zeros],s[0]
            return sign*int("""".join(s))","class Solution {
 public:
  vector<vector<int>> rotateGrid(vector<vector<int>>& grid, int k) {
    const int m = grid.size();
    const int n = grid[0].size();
    int t = 0;      // Top
    int l = 0;      // Left
    int b = m - 1;  // Bottom
    int r = n - 1;  // Right

    while (t < b && l < r) {
      const int elementInThisLayer = 2 * (b - t + 1) + 2 * (r - l + 1) - 4;
      const int netRotations = k % elementInThisLayer;
      for (int rotate = 0; rotate < netRotations; ++rotate) {
        const int topLeft = grid[t][l];
        for (int j = l; j < r; ++j)
          grid[t][j] = grid[t][j + 1];
        for (int i = t; i < b; ++i)
          grid[i][r] = grid[i + 1][r];
        for (int j = r; j > l; --j)
          grid[b][j] = grid[b][j - 1];
        for (int i = b; i > t; --i)
          grid[i][l] = grid[i - 1][l];
        grid[t + 1][l] = topLeft;
      }
      ++t;
      ++l;
      --b;
      --r;
    }

    return grid;
  }
};"
"class Solution:
    def minimumTime(self, s: str) -> int:
        costL2R = [None]*len(s)
        cost = 0 if s[0]=='0' else 1
        costL2R[0]=cost
        for i in range(1,len(s)):
            if s[i]=='1':
                cost = min(cost+2,i+1)
            costL2R[i]=cost           
                
        costR2L = [None]*len(s)
        cost = 0 if s[-1]=='0' else 1
        costR2L[-1] = cost
        for i in range(len(s)-2,-1,-1):
            if s[i]=='1':
                cost = min(cost+2,len(s) - (i+1)+1)
            costR2L[i] = cost
        costR2L.append(0)
            
        minCost = len(s)
        for i in range(len(s)):
            minCost = min(minCost,costL2R[i]+costR2L[i+1])
        return minCost","class Solution {
 public:
  long long wonderfulSubstrings(string word) {
    long long ans = 0;
    int prefix = 0;           // Binary prefix
    vector<int> count(1024);  // Binary prefix count
    count[0] = 1;             // Empty string """"

    for (const char c : word) {
      prefix ^= 1 << c - 'a';
      ans += count[prefix];         // All chars occur even times
      for (int i = 0; i < 10; ++i)  // ('a' + i) occurs odd times
        ans += count[prefix ^ 1 << i];
      ++count[prefix];
    }

    return ans;
  }
};"
"class Solution:
    def countOperations(self, num1: int, num2: int) -> int:
        count = 0
        while num1 > 0 and num2 > 0:
            if num1 >= num2:
                num1 -= num2
            else:
                num2 -= num1
            count += 1
        return count","class Solution {
 public:
  vector<int> buildArray(vector<int>& nums) {
    const int n = nums.size();

    for (int i = 0; i < n; ++i)
      nums[i] += n * (nums[nums[i]] % n);

    for (int i = 0; i < n; ++i)
      nums[i] /= n;

    return nums;
  }
};"
"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        x,y={},{}
        for i in range(0,len(nums),2):         # count the occurence of number 
            x[nums[i]]=x.get(nums[i],0)+1
        for i in range(1,len(nums),2):          # count the occurence of number
            y[nums[i]]=y.get(nums[i],0)+1
        sum1=sum(x.values())                  # count the total occurence of number
        sum2=sum(y.values())                   # count the occurence of number
        l1=[(k,x[k]) for k in x.keys()]           # make list 
        l2=[(k,y[k]) for k in y.keys()]           # make list
        l1=sorted(l1,key=lambda x:x[1],reverse=True)     # sort in reverse order
        l2=sorted(l2,key=lambda x:x[1],reverse=True)
        for i in l1:
            for j in l2:
                if i[0]!=j[0]:        # check the given condition
                    return sum1-i[1]+sum2-j[1]      # convert list into nums[i-1] and nums[i]
        return min(sum1,sum2)     # return minimum occurance","class Solution {
 public:
  int eliminateMaximum(vector<int>& dist, vector<int>& speed) {
    const int n = dist.size();
    vector<int> arrivalTime(n);

    for (int i = 0; i < n; ++i)
      arrivalTime[i] = (dist[i] - 1) / speed[i];

    sort(begin(arrivalTime), end(arrivalTime));

    for (int i = 0; i < n; ++i)
      if (i > arrivalTime[i])
        return i;

    return n;
  }
};"
"class Solution:
    def minimumRemoval(self, beans: List[int]) -> int:
        #sort the array
        beans = sorted(beans)
        #create array for dynamic programming
        dp = [0] * len(beans)
        #prefix sum
        for i in range(len(beans)):
            dp[i] = dp[i-1] + beans[i]
        #find the minimum number looping through the dp array 
        res = (dp[-1] - dp[0]) - beans[0] * (len(beans) - 1)
        for i in range(1, len(beans)):
            res = min(res, (dp[-1] - dp[i]) - beans[i] * (len(beans) - i - 1) + dp[i-1] )
        return res","class Solution {
 public:
  int countGoodNumbers(long long n) {
    return myPow(4 * 5, n / 2) * (n & 1 ? 5 : 1) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long myPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n & 1)
      return x * myPow(x, n - 1) % kMod;
    return myPow(x * x % kMod, n / 2);
  }
};"
"class Solution:
    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:
        
        @lru_cache(None)
        def dp(i, m1, m2):
            if i == len(nums):
                return 0

            ans = float('-inf')
            for j in range(numSlots):
                if m1 &amp; (1 << j):
                    ans = max(ans, (nums[i] &amp; (j + 1)) + dp(i + 1, m1 ^ (1 << j), m2))
                elif m2 &amp; (1 << j):
                    ans = max(ans, (nums[i] &amp; (j + 1)) + dp(i + 1, m1, m2 ^ (1 << j)))
            return ans

        return dp(0, (1<<numSlots)-1, (1<<numSlots)-1)","class Solution {
 public:
  int countTriples(int n) {
    int ans = 0;
    unordered_set<int> squared;

    for (int i = 1; i <= n; ++i)
      squared.insert(i * i);

    for (const int a : squared)
      for (const int b : squared)
        if (squared.count(a + b))
          ++ans;

    return ans;
  }
};"
"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        count=0
        n=len(nums)
        for i in range(n):
            for j in range(i+1,n):
                if nums[i]==nums[j] and (i*j)%k==0:
                    count+=1
        
        return count","class Solution {
 public:
  int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
    const int m = maze.size();
    const int n = maze[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = 0;
    queue<pair<int, int>> q{{{entrance[0], entrance[1]}}};
    vector<vector<bool>> seen(m, vector<bool>(n));
    seen[entrance[0]][entrance[1]] = true;

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (seen[x][y] || maze[x][y] == '+')
            continue;
          if (x == 0 || x == m - 1 || y == 0 || y == n - 1)
            return ans;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
    }

    return -1;
  }
};"
"class Solution:
    def sumOfThree(self, num: int) -> List[int]:
        rightHandSide = num - 3
        if rightHandSide % 3 != 0:
            return []
        firstNumber = rightHandSide // 3
        
        return [firstNumber, firstNumber + 1, firstNumber + 2]","class Solution {
 public:
  bool sumGame(string num) {
    const int n = num.length();
    double ans = 0.0;

    for (int i = 0; i < n / 2; ++i)
      ans += getExpectation(num[i]);

    for (int i = n / 2; i < n; ++i)
      ans -= getExpectation(num[i]);

    return ans != 0.0;
  }

 private:
  double getExpectation(char c) {
    return c == '?' ? 4.5 : c - '0';
  }
};"
"class Solution:
    def maximumEvenSplit(self, f: int) -> List[int]:
        if f%2!=0:      # if odd then return 
            return []
        count= (-1 + sqrt(1 + 4 * f)) // 2        # find x
        ans=[]
        i=2
        while len(ans)!=count:
            ans.append(i)          # add even integers in list 
            i=i+2
        if sum(ans)==f:         # check if sum is euqal to finalSum
            return ans
        ans[-1]=ans[-1]+(f-sum(ans))     # else add difference in the last element
        return ans","class Solution {
 public:
  int minCost(int maxTime, vector<vector<int>>& edges,
              vector<int>& passingFees) {
    const int n = passingFees.size();
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int w = edge[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    return dijkstra(graph, 0, n - 1, maxTime, passingFees);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst,
               int maxTime, const vector<int>& passingFees) {
    // cost[i] := min cost to reach cities[i]
    vector<int> cost(graph.size(), INT_MAX);
    // dist[i] := min time to reach cities[i]
    vector<int> dist(graph.size(), maxTime + 1);
    using T = tuple<int, int, int>;  // (cost[u], dist[u], u)
    priority_queue<T, vector<T>, greater<>> minHeap;

    cost[src] = passingFees[0];
    dist[src] = 0;
    minHeap.emplace(cost[src], dist[src], src);

    while (!minHeap.empty()) {
      const auto [currCost, d, u] = minHeap.top();
      minHeap.pop();
      for (const auto& [v, w] : graph[u]) {
        if (d + w > maxTime)
          continue;
        // Go from u -> v.
        if (currCost + passingFees[v] < cost[v]) {
          cost[v] = currCost + passingFees[v];
          dist[v] = d + w;
          minHeap.emplace(cost[v], dist[v], v);
        } else if (d + w < dist[v]) {
          dist[v] = d + w;
          minHeap.emplace(currCost + passingFees[v], dist[v], v);
        }
      }
    }

    return cost[dst] == INT_MAX ? -1 : cost[dst];
  }
};"
"class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        N = len(nums1)
        BIT = [0] * (N+1)
        nums = [0] * N
        num1 = [0] * N
        num2 = [0] * N
        for i, n in enumerate(nums1):
            num1[n]=i
        for i, n in enumerate(nums2):
            num2[n]=i
        for i, n in enumerate(num1):
            nums[n] = num2[i]
        def lowbit(i):
            return i&amp;(-i)
        def add(i):
            i+=1
            while i <= N:
                BIT[i]+=1
                i+=lowbit(i)
        def query(i):
            i += 1
            re = 0
            while i:
                re += BIT[i]
                i -= lowbit(i)
            return re
        smaller = []
        bigger = []
        for i, n in enumerate(nums):
            smaller.append(query(n))
            bigger.append(N-1-i-n+smaller[-1])
            add(n)
        return sum(i*j for i, j in zip(smaller, bigger))
		```","class Solution {
 public:
  vector<int> getConcatenation(vector<int>& nums) {
    const int n = nums.size();

    for (int i = 0; i < n; ++i)
      nums.push_back(nums[i]);

    return nums;
  }
};"
"class Solution:
    def countEven(self, num: int) -> int:
        count = 0
        for i in range(1, num + 1):
            summetion = 0
            for digit in str(i):
                summetion += int(digit)
                
            if summetion % 2 == 0 :
                count += 1
                
        return count","class Solution {
 public:
  int countPalindromicSubsequence(string s) {
    int ans = 0;
    vector<int> first(26, s.length());
    vector<int> last(26);

    for (int i = 0; i < s.length(); ++i) {
      const int index = s[i] - 'a';
      first[index] = min(first[index], i);
      last[index] = i;
    }

    for (int i = 0; i < 26; ++i)
      if (first[i] < last[i])
        ans += unordered_set<int>(begin(s) + first[i] + 1, begin(s) + last[i])
                   .size();

    return ans;
  }
};"
"class Solution:
    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        temp=head.next
        s=0
        
        newHead=dummy=ListNode(-1)
        
        while temp:
            if temp.val==0:
                newHead.next=ListNode(s)
                newHead=newHead.next
                s=0
            else:
                s+=temp.val
            
            temp=temp.next
            
        
        return dummy.next","class Solution {
 public:
  int colorTheGrid(int m, int n) {
    this->m = m;
    this->n = n;
    return dp(0, 0, 0, 0);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  int m;
  int n;
  vector<vector<int>> memo = vector<vector<int>>(1000, vector<int>(1024));

  int dp(int r, int c, int prevColMask, int currColMask) {
    if (c == n)
      return 1;
    if (memo[c][prevColMask])
      return memo[c][prevColMask];
    if (r == m)
      return dp(0, c + 1, currColMask, 0);

    int ans = 0;

    // 1 := red, 2 := green, 3 := blue
    for (int color = 1; color <= 3; ++color) {
      if (getColor(prevColMask, r) == color)
        continue;
      if (r > 0 && getColor(currColMask, r - 1) == color)
        continue;
      ans += dp(r + 1, c, prevColMask, setColor(currColMask, r, color));
      ans %= kMod;
    }

    if (r == 0)
      memo[c][prevColMask] = ans;

    return ans;
  }

  // E.g. __ __ __ __ __
  //      01 10 11 11 11
  //      R  G  B  B  B
  // GetColor(0110111111, 3) -> G
  int getColor(int mask, int r) {
    return mask >> r * 2 & 3;
  }

  int setColor(int mask, int r, int color) {
    return mask | color << r * 2;
  }
};"
"class Solution:
    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:
        # MaxHeap method
        arr = [0] * 26
        result = """"
        
        # count the num of each char
        for char in s:
            arr[ord(char) - ord('a')] += 1
        
        # in the maxHeap, the largest char is on the top
        maxHeap = []
        for i in range(26):
            if arr[i] != 0:
                maxHeap.append((-i, arr[i]))
        
        heapq.heapify(maxHeap)
        
        while maxHeap:
            # pop out the largest char
            largestChar, times = heapq.heappop(maxHeap)
            # to make sure we didn't add the same char in the next iteration
            if result and result[-1] == chr(-largestChar + ord('a')):
                return result                         
            if times > repeatLimit:
                result += repeatLimit * chr(-largestChar + ord('a'))
                if maxHeap:
                    SecondLargestChar, times2 = heapq.heappop(maxHeap)
                    result += chr(-SecondLargestChar + ord('a'))
                    if times2 > 1:
                        heapq.heappush(maxHeap, (SecondLargestChar, times2-1))
                heapq.heappush(maxHeap, (largestChar, times-repeatLimit))
            else:
                result += times * chr(-largestChar + ord('a'))
            
            if len(result) == len(s):
                return result","class Solution {
 public:
  TreeNode* canMerge(vector<TreeNode*>& trees) {
    unordered_map<int, TreeNode*> valToNode;  // {val: node}
    unordered_map<int, int> count;            // {val: freq}

    for (TreeNode* tree : trees) {
      valToNode[tree->val] = tree;
      ++count[tree->val];
      if (tree->left)
        ++count[tree->left->val];
      if (tree->right)
        ++count[tree->right->val];
    }

    for (TreeNode* tree : trees)
      if (count[tree->val] == 1) {
        if (isValidBST(tree, nullptr, nullptr, valToNode) &&
            valToNode.size() <= 1)
          return tree;
        return nullptr;
      }

    return nullptr;
  }

 private:
  bool isValidBST(TreeNode* tree, TreeNode* minNode, TreeNode* maxNode,
                  unordered_map<int, TreeNode*>& valToNode) {
    if (tree == nullptr)
      return true;
    if (minNode && tree->val <= minNode->val)
      return false;
    if (maxNode && tree->val >= maxNode->val)
      return false;
    if (!tree->left && !tree->right && valToNode.count(tree->val)) {
      const int val = tree->val;
      tree->left = valToNode[val]->left;
      tree->right = valToNode[val]->right;
      valToNode.erase(val);
    }

    return isValidBST(tree->left, minNode, tree, valToNode) &&
           isValidBST(tree->right, tree, maxNode, valToNode);
  }
};"
"class Solution:
    def coutPairs(self, nums: List[int], k: int) -> int:
        for i in range(len(nums)):
            g = gcd(nums[i], k)
            nums[i] = g if g != k else 0
        
        c = Counter(nums)
        r = 0
		
		# 0 to other number
        for i in c:
            if i == 0: continue
            r += c[i]
        r *= c[0]
		
		# 0 to 0
        r += (c[0] * (c[0]-1)) // 2
        
        del c[0]  # 0 is dealt with
        del c[1]  # 1 is useless
        
		# brute-force check for key pairs
        ckeys = list(c.keys())
        for a in range(len(ckeys)):
            i = ckeys[a]
            for b in range(a, len(ckeys)):
                j = ckeys[b]
                if (i * j) % k: continue
                if j != i:
                    r += c[i] * c[j]
                else:
                    r += (c[i] * (c[i]-1)) // 2
                
        return r","class Solution {
 public:
  int canBeTypedWords(string text, string brokenLetters) {
    int ans = 0;
    istringstream iss(text);
    vector<bool> broken(26);

    for (const char c : brokenLetters)
      broken[c - 'a'] = true;

    for (string word; iss >> word;)
      ans += canBeTyped(word, broken);

    return ans;
  }

 private:
  bool canBeTyped(const string& word, const vector<bool>& broken) {
    for (const char c : word)
      if (broken[c - 'a'])
        return false;
    return true;
  }
};"
"class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        res = 0
        for i in words:
            if i.startswith(pref):
                res += 1
        return res","class Solution {
 public:
  int addRungs(vector<int>& rungs, int dist) {
    int ans = 0;
    int prev = 0;

    for (const int rung : rungs) {
      ans += (rung - prev - 1) / dist;
      prev = rung;
    }

    return ans;
  }
};"
"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        count_s=Counter(s)
        count_t=Counter(t)
        count=0
        
        for i in count_t:
            if i not in count_s:
                count+=count_t[i]
                count_s[i]=count_t[i]
            elif count_t[i]>count_s[i]:
                count+=count_t[i]-count_s[i]
                count_s[i]+=count_t[i]-count_s[i]
                count_s[i]=count_t[i]
            elif count_t[i]<count_s[i]:
                count+=count_s[i]-count_t[i]
                count_t[i]+=count_s[i]-count_t[i]
                count_t[i]=count_s[i]
                
        for i in count_s:
            if i not in count_t:
                count+=count_s[i]
                count_t[i]=count_s[i]
            else:
                count+=abs(count_t[i]-count_s[i])
                count_t[i]=count_t[i]+abs(count_t[i]-count_s[i])
        return count","class Solution {
 public:
  long long maxPoints(vector<vector<int>>& points) {
    const int n = points[0].size();
    // dp[j] := max # points you can have if points[i][j] is the most recent
    // Cell you picked
    vector<long long> dp(n);

    for (const vector<int>& row : points) {
      vector<long long> leftToRight(n);
      long long runningMax = 0;

      for (int j = 0; j < n; ++j) {
        runningMax = max(runningMax - 1, dp[j]);
        leftToRight[j] = runningMax;
      }

      vector<long long> rightToLeft(n);
      runningMax = 0;

      for (int j = n - 1; j >= 0; --j) {
        runningMax = max(runningMax - 1, dp[j]);
        rightToLeft[j] = runningMax;
      }

      for (int j = 0; j < n; ++j)
        dp[j] = max(leftToRight[j], rightToLeft[j]) + row[j];
    }

    return *max_element(begin(dp), end(dp));
  }
};"
"class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        def condition(mid,nums,totalTrips):
            ans=0
            for num in nums:
                ans+=mid//num
            if ans>=totalTrips:
                return True
            return False
        
        lo=0 #minimum time any truck can take
        hi=totalTrips*min(time)  #maximum time any truck can take
        
        while lo<=hi:
            mid=lo+(hi-lo)//2
            if condition(mid, time,totalTrips):
                hi=mid-1
            else:
                lo=mid+1
        return lo","struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int count = 0;
  TrieNode() : children(2) {}
};

class Trie {
 public:
  void update(int num, int val) {
    shared_ptr<TrieNode> node = root;
    for (int i = kHeight; i >= 0; --i) {
      const int bit = (num >> i) & 1;
      if (node->children[bit] == nullptr)
        node->children[bit] = make_shared<TrieNode>();
      node = node->children[bit];
      node->count += val;
    }
  }

  int query(int num) {
    int ans = 0;
    shared_ptr<TrieNode> node = root;
    for (int i = kHeight; i >= 0; --i) {
      const int bit = (num >> i) & 1;
      const int targetBit = bit ^ 1;
      if (node->children[targetBit] && node->children[targetBit]->count) {
        ans += 1 << i;
        node = node->children[targetBit];
      } else {
        node = node->children[targetBit ^ 1];
      }
    }
    return ans;
  }

 private:
  static constexpr int kHeight = 17;
  shared_ptr<TrieNode> root = make_shared<TrieNode>();
};

class Solution {
 public:
  vector<int> maxGeneticDifference(vector<int>& parents,
                                   vector<vector<int>>& queries) {
    const int n = parents.size();
    vector<int> ans(queries.size());
    int rootVal = -1;
    vector<vector<int>> tree(n);
    // {node: (index, val)}
    unordered_map<int, vector<pair<int, int>>> nodeToQueries;
    Trie trie;

    for (int i = 0; i < parents.size(); ++i)
      if (parents[i] == -1)
        rootVal = i;
      else
        tree[parents[i]].push_back(i);

    for (int i = 0; i < queries.size(); ++i) {
      const int node = queries[i][0];
      const int val = queries[i][1];
      nodeToQueries[node].emplace_back(i, val);
    }

    dfs(rootVal, trie, tree, nodeToQueries, ans);
    return ans;
  }

 private:
  void dfs(int node, Trie& trie, const vector<vector<int>>& tree,
           const unordered_map<int, vector<pair<int, int>>>& nodeToQueries,
           vector<int>& ans) {
    trie.update(node, 1);

    if (const auto it = nodeToQueries.find(node); it != cend(nodeToQueries))
      for (const auto& [i, val] : it->second)
        ans[i] = trie.query(val);

    for (const int child : tree[node])
      dfs(child, trie, tree, nodeToQueries, ans);

    trie.update(node, -1);
  }
};"
"class Solution:
    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:
        @cache
        def lapTime(tire,x):
            f,r = tire
            return f*(r**(x-1))
        
        best_laps = {}
        
        for tire in tires:
            tire = tuple(tire)
            time = 0
            # stop at max time for a tire without changing
            for i in range(1,1001):
                currtime = lapTime(tire,i)
                if currtime >= lapTime(tire,1)+changeTime:
                    break
                time += currtime
                
                # update dictionary
                if i in best_laps:
                    best_laps[i] = min(best_laps[i],time+changeTime)
                else:
                    best_laps[i] = time+changeTime
        
        # dynamic programming
        dp = [float('inf') for _ in range(numLaps)]
        for i in range(numLaps):
            # if could get lap i using a single tire
            if i+1 in best_laps:
                dp[i] = best_laps[i+1]
                
            # or get lap i changing from last tire
            for k,v in best_laps.items():
                if i-k>=0:
                    dp[i] = min(dp[i], dp[i-k]+v)
        
		# subtract change time because first tire doesn't need to change
        return dp[numLaps-1] - changeTime","class Solution {
 public:
  int smallestChair(vector<vector<int>>& times, int targetFriend) {
    int nextUnsatChair = 0;
    priority_queue<int, vector<int>, greater<>> emptyChairs;
    using P = pair<int, int>;  // (leaving, chair)
    priority_queue<P, vector<P>, greater<>> occupied;

    for (int i = 0; i < times.size(); ++i)
      times[i].push_back(i);

    sort(begin(times), end(times));

    for (const vector<int>& time : times) {
      const int arrival = time[0];
      const int leaving = time[1];
      const int i = time[2];
      while (!occupied.empty() && occupied.top().first <= arrival)
        emptyChairs.push(occupied.top().second), occupied.pop();
      if (i == targetFriend)
        return emptyChairs.empty() ? nextUnsatChair : emptyChairs.top();
      if (emptyChairs.empty())
        occupied.emplace(leaving, nextUnsatChair++);
      else
        occupied.emplace(leaving, emptyChairs.top()), emptyChairs.pop();
    }

    throw;
  }
};"
"class Solution:
    def mostFrequent(self, nums: List[int], key: int) -> int:
        d={}
        for i in range(len(nums)-1):
            if nums[i]==key:
                if nums[i+1] in d:
                    d[nums[i+1]]+=1
                else:
                    d[nums[i+1]]=1
        m=-1
        for j in d:
            m=max(m,d[j])
        for key, value in d.items():
            if m == value:
                return key","class Solution {
 public:
  vector<vector<long long>> splitPainting(vector<vector<int>>& segments) {
    vector<vector<long long>> ans;
    int prevIndex = 0;
    long long runningMix = 0;
    map<int, long long> timeline;

    for (const vector<int>& segment : segments) {
      const int start = segment[0];
      const int end = segment[1];
      const int color = segment[2];
      timeline[start] += color;
      timeline[end] -= color;
    }

    for (const auto& [i, mix] : timeline) {
      if (runningMix > 0)
        ans.push_back({prevIndex, i, runningMix});
      runningMix += mix;
      prevIndex = i;
    }

    return ans;
  }
};"
"class Solution:
    def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:
        def getMappedNum(num):
            s = str(num)
            mappedNum = """"
            for c in s:
                mappedNum = mappedNum + str(mapping[int(c)])
            return int(mappedNum)

        sortedNums = []
        for num in nums:
            sortedNums.append((getMappedNum(num), num))
            
        sortedNums.sort(key=lambda x: x[0])
        
        for i, (_, num) in enumerate(sortedNums):
            nums[i] = num
            
        return nums","class Solution {
 public:
  vector<int> canSeePersonsCount(vector<int>& heights) {
    const int n = heights.size();
    vector<int> ans(n);
    stack<int> stack;

    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && heights[stack.top()] <= heights[i])
        ++ans[stack.top()], stack.pop();
      if (!stack.empty())
        ++ans[stack.top()];
      stack.push(i);
    }

    return ans;
  }
};"
"class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        
        result = []
        
        hashmap = collections.defaultdict(set)
        parent = collections.defaultdict(set)
        # indegree = collections.defaultdict(int)
        
        for a, b in edges:
            hashmap[a].add(b)
            parent[b].add(a)
            # indegree[b] += 1
        
        roots = set()
        leafs = set()
        
        for node in range(n):
            if node not in parent:
                roots.add(node)
            
            if node not in hashmap:
                leafs.add(node)
        
        # print(roots)
        # print(leafs)
        
        # ancestors = collections.defaultdict(set)
        
        @cache
        def find_parent(node):
            parents = set()
            if node in parent:
                for p in parent[node]:
                    parents.add(p)
                    parents |= find_parent(p)
            return parents
            
        
        for node in range(n):
            result.append(sorted(list(find_parent(node))))
        
        return result","class Solution {
 public:
  string maximumNumber(string num, vector<int>& change) {
    bool mutated = false;

    for (char& c : num) {
      const int d = c - '0';
      c = '0' + max(d, change[d]);
      if (mutated && d > change[d])
        return num;
      if (d < change[d])
        mutated = true;
    }

    return num;
  }
};"
"class Solution:
    @lru_cache(None)
    def minMovesToMakePalindrome(self, s: str) -> int:
        n = len(s)
        if n<=1:
            return 0
        if s[0] == s[-1]:
            return self.minMovesToMakePalindrome(s[1:-1])
        i = 1
        while s[i]!=s[-1]:
            i+=1
        j = n - 2
        while s[j]!=s[0]:
            j-=1
        if i <= n - 1 - j:
            return i + self.minMovesToMakePalindrome(s[:i]+s[i+1:-1])
        else:
            return n - 1 - j + self.minMovesToMakePalindrome(s[1:j]+s[j+1:])","class Solution {
 public:
  int maxCompatibilitySum(vector<vector<int>>& students,
                          vector<vector<int>>& mentors) {
    int ans = 0;
    dfs(students, mentors, 0, /*score=*/0, vector<bool>(students.size()), ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& students,
           const vector<vector<int>>& mentors, int i, int scoreSum,
           vector<bool>&& used, int& ans) {
    if (i == students.size()) {
      ans = max(ans, scoreSum);
      return;
    }
    for (int j = 0; j < students.size(); ++j) {
      if (used[j])
        continue;
      used[j] = true;  // mentors[j] is used.
      dfs(students, mentors, i + 1,
          scoreSum + getScore(students[i], mentors[j]), move(used), ans);
      used[j] = false;
    }
  }

  int getScore(const vector<int>& student, const vector<int>& mentor) {
    int score = 0;
    for (int i = 0; i < student.size(); ++i)
      if (student[i] == mentor[i])
        ++score;
    return score;
  }
};"
"class Solution:
    def minimalKSum(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        result = 0
        
        if nums[0] > k:
            return self.calSum(0, k+1)
        
        if nums[0] != 1:
            k -= (nums[0] - 1)
            result += self.calSum(0, nums[0])
        
        for i in range(n-1):
            numOfCandidates = nums[i+1] - nums[i] -1
            if numOfCandidates >= 1:
                if numOfCandidates >= k:
                    result += self.calSum(nums[i], nums[i] + k +1)
                    k = 0
                    return result

                elif numOfCandidates < k:
                    k -= numOfCandidates
                    result += self.calSum(nums[i], nums[i+1])
        
        if k > 0:
            result += self.calSum(nums[-1], nums[-1] +k+1)
        
        return result
                      
    # calculate the sum between start and end, both exclude
    def calSum(self, start, end):
        return int((end + start) / 2 * (end -start -1))","struct TrieNode {
  unordered_map<string, shared_ptr<TrieNode>> children;
  bool deleted = false;
};

class Solution {
 public:
  vector<vector<string>> deleteDuplicateFolder(vector<vector<string>>& paths) {
    vector<vector<string>> ans;
    vector<string> path;
    unordered_map<string, vector<shared_ptr<TrieNode>>> subtreeToNodes;

    sort(begin(paths), end(paths));

    for (const vector<string>& path : paths) {
      shared_ptr<TrieNode> node = root;
      for (const string& s : path) {
        if (!node->children.count(s))
          node->children[s] = make_shared<TrieNode>();
        node = node->children[s];
      }
    }

    buildSubtreeToRoots(root, subtreeToNodes);

    for (const auto& [_, nodes] : subtreeToNodes)
      if (nodes.size() > 1)
        for (shared_ptr<TrieNode> node : nodes)
          node->deleted = true;

    constructPath(root, path, ans);
    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  string buildSubtreeToRoots(
      shared_ptr<TrieNode> node,
      unordered_map<string, vector<shared_ptr<TrieNode>>>& subtreeToNodes) {
    string subtree = ""("";
    for (const auto& [s, child] : node->children)
      subtree += s + buildSubtreeToRoots(child, subtreeToNodes);
    subtree += "")"";
    if (subtree != ""()"")
      subtreeToNodes[subtree].push_back(node);
    return subtree;
  }

  void constructPath(shared_ptr<TrieNode> node, vector<string>& path,
                     vector<vector<string>>& ans) {
    for (const auto& [s, child] : node->children)
      if (!child->deleted) {
        path.push_back(s);
        constructPath(child, path, ans);
        path.pop_back();
      }
    if (!path.empty())
      ans.push_back(path);
  }
};"
"class Solution:
    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:
        node_dict = defaultdict(TreeNode)
        ins = defaultdict(int)
        for p, c, isleft in descriptions:
            ins[p] = ins[p]
            ins[c] += 1
            node_dict.setdefault(p, TreeNode(p))
            node_dict.setdefault(c, TreeNode(c))
            if isleft:
                node_dict[p].left = node_dict[c]
            else:
                node_dict[p].right = node_dict[c]
        
        return node_dict[min((indegree, node) for node, indegree in ins.items())[1]]","class Solution {
 public:
  // Similar to 1950. Maximum of Minimum Values in All Subarrays
  vector<int> findMaximums(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n);
    // prevMin[i] := index k s.t. nums[k] is the prev min in nums[:i]
    vector<int> prevMin(n, -1);
    // nextMin[i] := index k s.t. nums[k] is the next min in nums[i + 1:]
    vector<int> nextMin(n, n);
    stack<int> stack;

    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && nums[stack.top()] > nums[i]) {
        const int index = stack.top();
        stack.pop();
        nextMin[index] = i;
      }
      if (!stack.empty())
        prevMin[i] = stack.top();
      stack.push(i);
    }

    // For each nums[i], let l = nextMin[i] + 1 and r = nextMin[i] - 1.
    // nums[i] is the minimun in nums[l..r].
    // So, the ans[r - l + 1] will be at least nums[i].
    for (int i = 0; i < n; ++i) {
      const int sz = nextMin[i] - prevMin[i] - 1;
      ans[sz - 1] = max(ans[sz - 1], nums[i]);
    }

    // ans[i] should always >= ans[i + 1:].
    for (int i = n - 2; i >= 0; --i)
      ans[i] = max(ans[i], ans[i + 1]);

    return ans;
  }
};"
"class Solution:
    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:
        if len(nums) == 1: return nums
        
        @cache
        def compute_gcd(x, y) -> int:
            while y:
                x, y = y, x % y
            return x

        @cache
        def compute_lcm(x, y) -> int:
            r = (x*y)//compute_gcd(x,y)
            return r
    
        i, j = 0, 1
        while j < len(nums):
            if compute_gcd(min(nums[i],nums[j]), max(nums[i],nums[j])) != 1:
                nums[i]=compute_lcm(min(nums[i],nums[j]), max(nums[i],nums[j]))
                nums.pop(j)
                if i != 0:
                    i-=1
                    j-=1
            else:
                i+=1
                j+=1
        return nums","class Solution {
 public:
  long long numberOfWeeks(vector<int>& milestones) {
    // The best strategy is to pick ""max, nonMax, max, nonMax, ..."".
    const int max = *max_element(begin(milestones), end(milestones));
    const long long sum = accumulate(begin(milestones), end(milestones), 0LL);
    const long long nonMax = sum - max;
    return min(sum, 2 * nonMax + 1);
  }
};"
"class Solution:
    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        # Time: O(nk) which at the worst case could be O(n^2)
        # Space: O(n) because result will never exceed N values
		res = set()
        for index, num in enumerate(nums):
            if num == key:
                for i in range(max(0, index - k), min(len(nums), index + k + 1)):
                    res.add(i)
        return list(res)","class Solution {
 public:
  long long minimumPerimeter(long long neededApples) {
    long long l = 1;
    long long r = 100'000;  // \sqrt [3] {10^{15}}

    while (l < r) {
      const long long m = (l + r) / 2;
      if (numApples(m) >= neededApples)
        r = m;
      else
        l = m + 1;
    }

    return l * 8;
  }

 private:
  // Returns the # of apples at k-th level.
  //    k := the level making perimeter = 8k
  // p(k) := # of apples at k-th level on the perimeter
  // n(k) := # of apples at k-th level not no the perimeter
  //
  // p(1) =             1 + 2
  // p(2) =         3 + 2 + 3 + 4
  // p(3) =     5 + 4 + 3 + 4 + 5 + 6
  // p(4) = 7 + 6 + 5 + 4 + 5 + 6 + 7 + 8
  // p(k) = k + 2(k+1) + 2(k+2) + ... + 2(k+k-1) + 2k
  //      = k + 2k^2 + 2*k(k-1)/2
  //      = k + 2k^2 + k^2 - k = 3k^2
  //
  // n(k) = p(1) + p(2) + p(3) + ... + p(k)
  //      = 3*1  + 3*4  + 3*9  + ... + 3*k^2
  //      = 3 * (1 + 4 + 9 + ... + k^2)
  //      = 3 * k(k+1)(2k+1)/6 = k(k+1)(2k+1)/2
  // So, the # of apples at k-th level should be
  //   k(k+1)(2k+1)/2 * 4 = 2k(k+1)(2k+1)
  long long numApples(long long k) {
    return 2 * k * (k + 1) * (2 * k + 1);
  }
};"
"class Solution:
    def digArtifacts(self, n: int, artifact: List[List[int]], dig: List[List[int]]) -> int:
        dig_set = set()
        for i in dig:
            dig_set.add(tuple(i))
            
        count = 0
        for afact in artifact:
            flag = True
            r1,c1,r2,c2 = afact
            for i in range(r1,r2+1):
                for j in range(c1,c2+1):
                    if (i,j) not in dig_set:
                        flag = False
                        break
                        
            if(flag == True):
                count += 1
                
        return count","class Solution {
 public:
  int countSpecialSubsequences(vector<int>& nums) {
    // dp[i][j] := # of special subseqs of nums[i:] and prev + 1 = j
    dp.resize(nums.size(), vector<int>(4, -1));
    return countSpecialSubsequences(nums, 0, -1);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<vector<int>> dp;

  int countSpecialSubsequences(const vector<int>& nums, int i, int prev) {
    if (i == nums.size())
      return prev == 2;
    if (dp[i][prev + 1] != -1)
      return dp[i][prev + 1];

    long ans = 0;

    // Not include nums[i]
    ans += countSpecialSubsequences(nums, i + 1, prev);

    // Include nums[i]
    if (nums[i] == prev)
      ans += countSpecialSubsequences(nums, i + 1, prev);
    if (prev == -1 && nums[i] == 0)
      ans += countSpecialSubsequences(nums, i + 1, 0);
    if (prev == 0 && nums[i] == 1)
      ans += countSpecialSubsequences(nums, i + 1, 1);
    if (prev == 1 && nums[i] == 2)
      ans += countSpecialSubsequences(nums, i + 1, 2);

    ans %= kMod;
    return dp[i][prev + 1] = ans;
  }
};"
"class Solution:
    def maximumTop(self, nums: List[int], k: int) -> int:
        if len(nums) <= 1 and k &amp; 1: return -1       # Case 1: triggered
        end = min(k-1, len(nums))                    # If k is greater than len(nums), end = len(nums), because Case 2 is triggered, else case 3 is triggered, we still need to find max till k-1
        maxi = max(nums[:end]) if k > 1 else 0       # we calculated the max element based on our end. k > 1 I have given to save from error, beacuse if k <= 1, spliced list will be empty.
        kplusOne = nums[k % len(nums)]               # this is for case 3, finding the k + 1 element, k +1 can give array index out of bound exception, so i did %
        return max(maxi, kplusOne)                   # Case 3, we have to decide either we choose to put the max from removed or (k+1) element","class Solution {
 public:
  bool checkMove(vector<vector<char>>& board, int rMove, int cMove,
                 char color) {
    const vector<pair<int, int>> dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};

    for (const auto& [dx, dy] : dirs) {
      int cellsCount = 2;
      int i = rMove + dx;
      int j = cMove + dy;
      while (0 <= i && i < 8 && 0 <= j && j < 8) {
        // No free cells in between.
        if (board[i][j] == '.')
          break;
        // Need >= 3 cells.
        if (cellsCount == 2 && board[i][j] == color)
          break;
        // >= 3 cells.
        if (board[i][j] == color)
          return true;
        i += dx;
        j += dy;
        ++cellsCount;
      }
    }

    return false;
  }
};"
"class Solution:
  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:
    graph,regra = defaultdict(list),defaultdict(list)
    for x,y,d in edges:
      graph[x].append((y,d))
      regra[y].append((x,d))
    for x in graph.keys():
      graph[x].sort(key=lambda p: p[1])
    for x in regra.keys():
      regra[x].sort(key=lambda p: p[1])
    pathfromdest = [float('inf') for _ in range(n)]
    psrcjeden = [float('inf') for _ in range(n)]
    psrcdwa = [float('inf') for _ in range(n)]
    ##
    def expdes(nod,d):
      if d < pathfromdest[nod]:
        pathfromdest[nod] = d
        for som,da in regra[nod]:
          expdes(som,d+da)
          
    
          
    def expsje(nod,d):
      if d < psrcjeden[nod]:
        psrcjeden[nod] = d
        for som,da in graph[nod]:
          expsje(som,d+da)
          
    def expesdwa(nod,d):
      if d < psrcdwa[nod]:
        psrcdwa[nod] = d
        for som,da in graph[nod]:
          expesdwa(som,d+da)
        
    
    expdes(dest,0)
    if pathfromdest[src1] == float('inf') or pathfromdest[src2] == float('inf'): return -1
    expsje(src1,0)
    expesdwa(src2,0)
    ##
    # q = [dest]
    # cu = 0
    # while cu < len(q):
    #   m = q[cu]
    #   cu += 1
    #   for som,d in regra[m]:
    #     if pathfromdest[m] + d < pathfromdest[som]:
    #       pathfromdest[som] = pathfromdest[m] + d
    #       q.append(som)
    # ##
    # q = [src1]
    # cu = 0
    # while cu < len(q):
    #   m = q[cu]
    #   cu += 1
    #   for som,d in graph[m]:
    #     if psrcjeden[m] + d < psrcjeden[som]:
    #       psrcjeden[som] = psrcjeden[m] + d
    #       q.append(som)
    # ##
    # q = [src2]
    # cu = 0
    # while cu < len(q):
    #   m = q[cu]
    #   cu += 1
    #   for som,d in graph[m]:
    #     if psrcdwa[m] + d < psrcdwa[som]:
    #       psrcdwa[som] = psrcdwa[m] + d
    #       q.append(som)
    ##
    ans = min(pathfromdest[ii]+psrcjeden[ii]+psrcdwa[ii] for ii in range(n))
    if ans == float('inf'): return -1
    else: return ans","class Solution {
 public:
  int minSpaceWastedKResizing(vector<int>& nums, int k) {
    // dp[i][k] := min space wasted for nums[i:] if you can resize k times
    dp.resize(nums.size(), vector<int>(k + 1, -1));
    return minSpaceWasted(nums, 0, k);
  }

 private:
  static constexpr int kMax = 200'000'000;
  vector<vector<int>> dp;

  int minSpaceWasted(const vector<int>& nums, int i, int k) {
    if (i == nums.size())
      return 0;
    if (k == -1)
      return kMax;
    if (dp[i][k] != -1)
      return dp[i][k];

    int ans = kMax;
    int sum = 0;
    int maxNum = nums[i];

    for (int j = i; j < nums.size(); ++j) {
      sum += nums[j];
      maxNum = max(maxNum, nums[j]);
      const int wasted = maxNum * (j - i + 1) - sum;
      ans = min(ans, minSpaceWasted(nums, j + 1, k - 1) + wasted);
    }

    return dp[i][k] = ans;
  }
};"
"class Solution:
    def divideArray(self, nums: List[int]) -> bool:
        return not any(v % 2 for v in Counter(nums).values())","class Solution {
 public:
  long long maxProduct(string s) {
    const int n = s.length();
    long long ans = 1;
    // l[i] := max length of palindromes in s[0..i)
    vector<int> l = manacher(s, n);
    // r[i] := max length of palindromes in s[i..n)
    vector<int> r = manacher(string(rbegin(s), rend(s)), n);
    reverse(begin(r), end(r));

    for (int i = 0; i + 1 < n; ++i)
      ans = max(ans, (long long)l[i] * r[i + 1]);

    return ans;
  }

 private:
  vector<int> manacher(const string& s, int n) {
    vector<int> maxExtends(n);
    vector<int> l2r(n, 1);
    int center = 0;

    for (int i = 0; i < n; ++i) {
      const int r = center + maxExtends[center] - 1;
      const int mirrorIndex = center - (i - center);
      int extend = i > r ? 1 : min(maxExtends[mirrorIndex], r - i + 1);
      while (i - extend >= 0 && i + extend < n &&
             s[i - extend] == s[i + extend]) {
        l2r[i + extend] = 2 * extend + 1;
        ++extend;
      }
      maxExtends[i] = extend;
      if (i + maxExtends[i] >= r)
        center = i;
    }

    for (int i = 1; i < n; ++i)
      l2r[i] = max(l2r[i], l2r[i - 1]);

    return l2r;
  }
};"
"class Solution:
    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:
        a, b = pattern[0], pattern[1]
        counter = Counter(text)
        def num_subseq():
            rc = Counter(text) # counter for text[i:]
            ans = 0
            for c in text:
                rc[c] -= 1
                if c == a:
                    ans += rc[b]
            return ans

        return num_subseq() + max(counter[a], counter[b])","class Solution {
 public:
  int minStoneSum(vector<int>& piles, int k) {
    int ans = accumulate(begin(piles), end(piles), 0);
    priority_queue<int> maxHeap;

    for (const int pile : piles)
      maxHeap.push(pile);

    for (int i = 0; i < k; ++i) {
      const int maxPile = maxHeap.top();
      maxHeap.pop();
      maxHeap.push(maxPile - maxPile / 2);
      ans -= maxPile / 2;
    }

    return ans;
  }
};"
"class Solution:
def halveArray(self, nums: List[int]) -> int:
    import heapq
    target = sum(nums) / 2
    arr = [-i for i in nums]
    heapq.heapify(arr)
    res = 0
    
    while target > 0: # everything will be negative over here, so we will add the halved value
        n = heapq.heappop(arr) / 2
        target += n
        res += 1
        heapq.heappush(arr,n)
    return res","class Solution {
 public:
  int minSwaps(string s) {
    // Cancel out all the matched pairs, then we'll be left with ""]]]..[[["".
    // The answer is ceil(# of unmatched pairs / 2).
    int unmatched = 0;

    for (const char c : s)
      if (c == '[')
        ++unmatched;
      else if (unmatched > 0)  // c == ']' and there's a match.
        --unmatched;

    return (unmatched + 1) / 2;
  }
};"
"class Solution:
    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:
        
        # get all locations for white
        loc = [i for i in range(len(floor)) if floor[i] == '1']
        if not loc: return 0        
        
        
        @lru_cache(None)
        # calculate maximum white tiles covered
        def dp(i, numCarpets):
            # if no carpets or reached the end of loc
            if numCarpets == 0 or i >= len(loc):
                return 0

            # if remaining caprets could cover till the end of loc
            if loc[i] + numCarpets * carpetLen - 1 >= loc[-1]:
                return len(loc) - i
            
            ans = -float('inf')
            # maximum carpets required to reach the next loc
            required = math.ceil((loc[i+1] - loc[i]) / carpetLen)
            
            
            for k in range(min(required, numCarpets)+1):
                new_i = bisect.bisect(loc, loc[i] + k*carpetLen - 1)
                ans = max(ans, new_i - i + dp(max(i+1, new_i), numCarpets - k))
            return ans

        return len(loc) - dp(0, numCarpets)","class Solution {
 public:
  vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {
    vector<int> ans;
    // tail[i] := the minimum tail of all increasing subseqs having length i + 1
    // it's easy to see that tail must be an increasing array
    vector<int> tail;

    for (const int obstacle : obstacles)
      if (tail.empty() || obstacle >= tail.back()) {
        tail.push_back(obstacle);
        ans.push_back(tail.size());
      } else {
        const int index = firstGreater(tail, obstacle);
        tail[index] = obstacle;
        ans.push_back(index + 1);
      }

    return ans;
  }

 private:
  // Find the first index l s.t A[l] > target
  // Returns A.size() if can't find
  int firstGreater(const vector<int>& A, int target) {
    return upper_bound(begin(A), end(A), target) - begin(A);
  }
};"
"class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        count, new = 0, [nums[0]]
        
        # Create a new array with non-consecutive values
        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]:
                new.append(nums[i])

        for i in range(1, len(new)-1):
            count += 1 if (new[i-1] < new[i] > new[i+1] or new[i-1] > new[i] < new[i+1]) else 0

        return count","class Solution {
 public:
  int binarySearchableNumbers(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    // prefixMaxs[i] := max(nums[0:i])
    vector<int> prefixMaxs(n);
    // suffixMins[i] := min(nums[i + 1:])
    vector<int> suffixMins(n);

    // Fill `prefixMaxs`.
    prefixMaxs[0] = INT_MIN;
    for (int i = 1; i < n; ++i)
      prefixMaxs[i] = max(prefixMaxs[i - 1], nums[i - 1]);

    // Fill `suffixMins`.
    suffixMins[n - 1] = INT_MAX;
    for (int i = n - 2; i >= 0; --i)
      suffixMins[i] = min(suffixMins[i + 1], nums[i + 1]);

    for (int i = 0; i < n; ++i)
      if (prefixMaxs[i] < nums[i] && nums[i] < suffixMins[i])
        ++ans;

    return ans;
  }
};"
"class Solution:
    def countCollisions(self, directions: str) -> int:
        count = 0
        stack = []
        
        for char in directions:
			# if the stack is empty, and the direction is left, we just continue
            if not stack and char == 'L':
                continue
            # otherwise we add the direction in the stack ('S' or 'R') because they might lead to collisions
            elif not stack and char != 'L':
                stack.append(char)
			# stack is not empty
            else:
				# the top element in the stack
                cur = stack[-1]
				# cases that will not lead to collisions
                if char == cur or cur == 'S' and char == 'R' or cur == 'L' and char == 'S' or cur == 'L' and char == 'R':
                    stack.append(char)
				# collision happen but the top of the stack is already 'S' no need to append
                elif cur == 'S' and char == 'L':
                    count += 1
				# collision happen, append a 'S' at the top
                elif cur == 'R' and char == 'S':
                    count += 1
                    stack.pop()
                    stack.append('S')
				# collision happen, append a 'S' at the top
                elif cur == 'R' and char == 'L':
                    count += 2
                    stack.pop()
                    stack.append('S')
        # here, the stack only contains 'R' and 'S'
		# we only need to deal with the 'R' before 'S' case
        n = len(stack)
        i = 0  
        while i < n:
            rs = 1
            if stack[i] == 'S':
                i += 1
            elif stack[i] == 'R':
                if i == n-1:
                    return count                
                elif stack[i] != stack[i+1]:
                    count += 1
                    i += 1     
                else:   
                    while i < n-1 and stack[i] == 'R' and stack[i] == stack[i+1]:
                        rs += 1
                        i += 1
                    if i == n-1:
                        return count
                    else:
                        count += rs
                        i += 1
        return count","class Solution {
 public:
  vector<int> rearrangeArray(vector<int>& nums) {
    sort(begin(nums), end(nums));
    for (int i = 1; i < nums.size(); i += 2)
      swap(nums[i], nums[i - 1]);
    return nums;
  }
};"
"class Solution:
    def __init__(self):
        self.mem = {}  # {(scoring_section,remaining_arrow_count)} = mask
    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:
        (mask,score) = self.dp(numArrows,0,len(aliceArrows)-1,0,aliceArrows)
        # print(""mask:"",mask)
        r = []
        zeroTarget = numArrows
        for i in range(1,len(aliceArrows)):
            if mask &amp; 1<<i :
                zeroTarget -= aliceArrows[i]+1
                r.append(aliceArrows[i]+1)
            else :
                r.append(0)
        r = [zeroTarget] + r
        return r
    def dp(self,numArrows: int, mask , scoring_section  , score ,aliceArrows: List[int]) -> (int,int):
        if numArrows <= 0 :
            return (mask,score)
        if scoring_section <= 0:
            return (mask,score)
        if (scoring_section,numArrows) in self.mem:
            return self.mem[(scoring_section,numArrows)]
        
        score1 = 0
        if numArrows- (aliceArrows[scoring_section]+1) >= 0:
            mask1,score1 = self.dp(numArrows- (aliceArrows[scoring_section]+1) , mask , scoring_section-1 , score , aliceArrows[:-1])
            mask1 |= 1<<scoring_section
            score1 += scoring_section
        else :
            mask1 = mask
        mask2,score2 = self.dp(numArrows , mask , scoring_section-1 , score , aliceArrows[:-1])
        
        if score1 >= score2 :
            self.mem[(scoring_section,numArrows)] = (mask1,score1)
        else :
            self.mem[(scoring_section,numArrows)] = (mask2,score2)

        return self.mem[(scoring_section,numArrows)]","class Solution {
 public:
  int minNonZeroProduct(int p) {
    // Can always turn [1..2^p - 1] to [1, 1, ..., 2^p - 2, 2^p - 2, 2^p - 1].
    const long n = 1L << p;
    const long halfCount = n / 2 - 1;
    return myPow(n - 2, halfCount) * ((n - 1) % kMod) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long myPow(long x, long n) {
    if (n == 0)
      return 1L;
    x %= kMod;
    if (n & 1)
      return x * myPow(x, n - 1) % kMod;
    return myPow(x * x, n / 2) % kMod;
  }
};"
"class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        nums1, nums2 = list(set(nums1)), list(set(nums2)) # Converting to set to ensure only unique values remain
        
        new1, new2 = [], [] # New list we'll be adding to
        
        for x in nums1: # Compares first list
            if x not in nums2:
                new1.append(x)
        
        for y in nums2: # Compares second list
            if y not in nums1:
                new2.append(y)
        
        return [new1, new2] # Combines the two","class Solution {
 public:
  int latestDayToCross(int row, int col, vector<vector<int>>& cells) {
    int ans = 0;
    int l = 1;
    int r = cells.size() - 1;

    while (l <= r) {
      const int m = (l + r) / 2;
      if (canWalk(m, row, col, cells)) {
        ans = m;
        l = m + 1;
      } else {
        r = m - 1;
      }
    }

    return ans;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};

  bool canWalk(int day, int row, int col, const vector<vector<int>>& cells) {
    vector<vector<int>> matrix(row, vector<int>(col));
    for (int i = 0; i < day; ++i) {
      const int x = cells[i][0] - 1;
      const int y = cells[i][1] - 1;
      matrix[x][y] = 1;
    }

    queue<pair<int, int>> q;

    for (int j = 0; j < col; ++j)
      if (matrix[0][j] == 0) {
        q.emplace(0, j);
        matrix[0][j] = 1;
      }

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == row || y < 0 || y == col)
          continue;
        if (matrix[x][y] == 1)
          continue;
        if (x == row - 1)
          return true;
        q.emplace(x, y);
        matrix[x][y] = 1;
      }
    }

    return false;
  }
};"
"class Solution:
    def minDeletion(self, nums: List[int]) -> int:
        res = 0
        for i in range(len(nums)):
		    # if res % 2 == 0, check even indexes
			# if res % 2 == 1, check odd indexes
            if (i + (res % 2)) % 2 == 0 and i + 1 < len(nums) and nums[i] == nums[i + 1]:
                res += 1
        return res + (len(nums) - res) % 2","struct T {
  long long sum;
  int count;
};

class Solution {
 public:
  int equalToDescendants(TreeNode* root) {
    return dfs(root).count;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return T{.sum = 0, .count = 0};
    T left = dfs(root->left);
    T right = dfs(root->right);
    return T{.sum = root->val + left.sum + right.sum,
             .count = left.count + right.count +
                      (root->val == left.sum + right.sum ? 1 : 0)};
  }
};"
"class Solution:
    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:
        def nthPalindrome(n, k):
            half_len = k // 2 - 1 if k % 2 == 0 else k // 2  
            left = str(10 ** half_len + n - 1)
            right = (left if k % 2 == 0 else left[:-1])[::-1]
            res_str = left + right
            return int(res_str) if len(res_str) == intLength else -1
        return [nthPalindrome(query,intLength) for query in queries]","class Solution {
 public:
  long long maxMatrixSum(vector<vector<int>>& matrix) {
    long long absSum = 0;
    int minAbs = INT_MAX;
    int oddNeg = 0;  // 0 := even neg, 1 := odd neg

    for (const vector<int>& row : matrix)
      for (const int num : row) {
        absSum += abs(num);
        minAbs = min(minAbs, abs(num));
        if (num < 0)
          oddNeg ^= 1;
      }

    return absSum - oddNeg * minAbs * 2;
  }
};"
"class Solution:
    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:
        # sort by the maximum prefix sum
        p = sorted([list(accumulate(x[:k], initial=0)) for x in piles], key=lambda x: -x[-1])
        
        @lru_cache(None)
        def dp(i, k):
            if i == len(p):
                return 0
            ans = 0
            for j in range(min(len(p[i]), k+1)):
                ans = max(ans, p[i][j] + dp(i+1, k-j))
            return ans

        return dp(0, k)","class Solution {
 public:
  int countPaths(int n, vector<vector<int>>& roads) {
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& road : roads) {
      const int u = road[0];
      const int v = road[1];
      const int w = road[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    return dijkstra(graph, 0, n - 1);
  }

 private:
  // Similar to 1786. Number of Restricted Paths From First to Last Node
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst) {
    constexpr int kMod = 1'000'000'007;
    vector<long long> dist(graph.size(), LLONG_MAX);
    vector<long long> ways(graph.size());
    using P = pair<long long, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[src] = 0;
    ways[src] = 1;
    minHeap.emplace(dist[src], src);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      if (d > dist[u])
        continue;
      for (const auto& [v, w] : graph[u])
        if (d + w < dist[v]) {
          dist[v] = d + w;
          ways[v] = ways[u];
          minHeap.emplace(dist[v], v);
        } else if (d + w == dist[v]) {
          ways[v] += ways[u];
          ways[v] %= kMod;
        }
    }

    return ways[dst];
  }
};"
"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        bstart=bin(start).replace(""0b"","""")
        bgoal=bin(goal).replace(""0b"","""")
      
        diff=len(str(bstart))-len(str(bgoal))
        for i in range(abs(diff)):
            if diff<0:
                bstart='0'+bstart
            elif diff>0:
                bgoal='0'+bgoal
        
        counter=0
        for i in range(len(bstart)):
            if bstart[i]!=bgoal[i]:
                counter+=1
        
        return counter","class Solution {
 public:
  string findDifferentBinaryString(vector<string>& nums) {
    const int bitSize = nums[0].length();
    const int maxNum = 1 << bitSize;
    unordered_set<int> numsSet;

    for (const string& num : nums)
      numsSet.insert(stoi(num, nullptr, 2));

    for (int num = 0; num < maxNum; ++num)
      if (!numsSet.count(num))
        return std::bitset<16>(num).to_string().substr(16 - bitSize);

    throw;
  }
};"
"class Solution:
    def triangular_sum(self, nums: List[int]) -> int:
        nums1 = nums
        while len(nums1) > 1:
            nums2 = []
            for i in range(len(nums1) - 1):
                nums2 += [(nums1[i] + nums1[i + 1]) % 10]
            nums1 = nums2
        return nums1[0]","class Solution {
 public:
  int minimizeTheDifference(vector<vector<int>>& mat, int target) {
    const int minSum = getMinSum(mat);
    if (minSum >= target)  // No need to consider any larger combination.
      return minSum - target;

    const int maxSum = getMaxSum(mat);
    dp.resize(mat.size(), vector<int>(maxSum + 1, -1));
    return minimizeTheDifference(mat, 0, 0, target);
  }

 private:
  vector<vector<int>> dp;

  int minimizeTheDifference(const vector<vector<int>>& mat, int i, int sum,
                            int target) {
    if (i == mat.size())
      return abs(sum - target);
    if (dp[i][sum] != -1)
      return dp[i][sum];
    int ans = INT_MAX;
    for (const int num : mat[i])
      ans = min(ans, minimizeTheDifference(mat, i + 1, sum + num, target));
    return dp[i][sum] = ans;
  }

  int getMinSum(const vector<vector<int>>& mat) {
    return accumulate(begin(mat), end(mat), 0,
                      [](int subtotal, const vector<int>& row) {
      return subtotal + *min_element(begin(row), end(row));
    });
  }

  int getMaxSum(const vector<vector<int>>& mat) {
    return accumulate(begin(mat), end(mat), 0,
                      [](int subtotal, const vector<int>& row) {
      return subtotal + *max_element(begin(row), end(row));
    });
  }
};"
"class Solution:
    def numberOfWays(self, s: str) -> int:
        def find_subsequence_count(S, T):
            m = len(T)
            n = len(S)
            if m > n:
                return 0
            mat = [[0 for _ in range(n + 1)]
                   for __ in range(m + 1)]
            for i in range(1, m + 1):
                mat[i][0] = 0
            for j in range(n + 1):
                mat[0][j] = 1
            for i in range(1, m + 1):
                for j in range(1, n + 1):
                    if T[i - 1] != S[j - 1]:
                        mat[i][j] = mat[i][j - 1]
                    else:
                        mat[i][j] = (mat[i][j - 1] +
                                     mat[i - 1][j - 1])
            return mat[m][n]
        x = find_subsequence_count(s, '101')
        y = find_subsequence_count(s, '010')
        return x + y","class Solution {
 public:
  vector<int> recoverArray(int n, vector<int>& sums) {
    sort(begin(sums), end(sums));
    return recover(sums);
  }

 private:
  vector<int> recover(const vector<int>& sums) {
    if (sums.size() == 1)  // sums[0] must be 0.
      return {};

    // Either num or -num must be in the final array.
    //  num + sumsExcludingNum = sumsIncludingNum
    // -num + sumsIncludingNum = sumsExcludingNum
    unordered_map<int, int> count;
    for (const int sum : sums)
      ++count[sum];

    const int num = sums[1] - sums[0];
    vector<int> sumsExcludingNum;
    vector<int> sumsIncludingNum;
    bool chooseSumsIncludingNum = false;

    for (const int sum : sums) {
      if (count[sum] == 0)
        continue;
      --count[sum];
      --count[sum + num];
      sumsExcludingNum.push_back(sum);
      sumsIncludingNum.push_back(sum + num);
      if (sum + num == 0)
        chooseSumsIncludingNum = true;
    }

    // Choose `sumsExludingNum` by default since we want to gradually strip
    // `num` from each sum in `sums` to have the final array. However, we should
    // always choose the group of sums with 0 since it's a must-have.
    vector<int> recovered =
        recover(chooseSumsIncludingNum ? sumsIncludingNum : sumsExcludingNum);
    recovered.push_back(chooseSumsIncludingNum ? -num : num);
    return recovered;
  }
};"
"class Solution:
    def sumScores(self, s: str) -> int:
        n, l, r = len(s), 0, 0
        z = [0] * n
        for i in range(1, n):
            if i <= r:
                z[i] = min(r - i + 1, z[i - l])
            while i + z[i] < n and s[z[i]] == s[i + z[i]]:
                z[i] += 1
            if i + z[i] - 1 > r:
                l, r = i, i + z[i] - 1
        return sum(z)+len(s)","class Solution {
 public:
  int widestPairOfIndices(vector<int>& nums1, vector<int>& nums2) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums1.size(); ++i) {
      prefix += nums1[i] - nums2[i];
      if (const auto it = prefixToIndex.find(prefix); it != cend(prefixToIndex))
        ans = max(ans, i - it->second);
      else
        prefixToIndex[prefix] = i;
    }

    return ans;
  }
};"
"class Solution:
    def convertTime(self, current: str, correct: str) -> int:
        count = 0
        
        hour_start = int(current.split("":"")[0])
        hour_end = int(correct.split("":"")[0])
        minute_start = int(current.split("":"")[1])
        minute_end = int(correct.split("":"")[1])
    
        total_start = hour_start * 60 + minute_start
        total_end = hour_end * 60 + minute_end 
        print(total_start,total_end)
        
        while total_start < total_end:
            if abs(total_start - total_end) >= 60 :
                total_start += 60
            elif abs(total_start - total_end) >= 15:
                total_start += 15
            elif abs(total_start - total_end) >= 5 :
                total_start += 5
            elif abs(total_start - total_end) >= 1 :
                total_start += 1
            count += 1
            
        return count","class Solution {
 public:
  // Similar to 215. Kth Largest Element in an Array
  string kthLargestNumber(vector<string>& nums, int k) {
    auto compare = [](const string& a, const string& b) {
      return a.length() == b.length() ? a > b : a.length() > b.length();
    };
    priority_queue<string, vector<string>, decltype(compare)> minHeap(compare);

    for (const string& num : nums) {
      minHeap.push(num);
      if (minHeap.size() > k)
        minHeap.pop();
    }

    return minHeap.top();
  }
};"
"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        lose_dict = defaultdict(list)
        players = set()
        answer = [[],[]]
        
        for winner, loser in matches:
            lose_dict[loser].append(winner)
            players.add(winner)
            players.add(loser)
        
        # find the list of all players that have not lost any matches
        for player in players:
            if player not in lose_dict:
                answer[0].append(player)
        
        # answer[1] is a list of all players that have lost exactly one match
        for player in lose_dict.keys():
            if len(lose_dict[player]) == 1:
                answer[1].append(player)
        
        answer[0].sort()
        answer[1].sort()
        
        return answer","class Solution {
 public:
  int minSessions(vector<int>& tasks, int sessionTime) {
    for (int numSessions = 1; numSessions <= tasks.size(); ++numSessions)
      if (dfs(tasks, 0, vector<int>(numSessions), sessionTime))
        return numSessions;
    throw;
  }

  // Returns true if we can assign tasks[s:] to `sessions`. Note that `sessions`
  // may be occupied by some tasks.
  bool dfs(const vector<int>& tasks, int s, vector<int>&& sessions,
           const int& sessionTime) {
    if (s == tasks.size())
      return true;

    for (int& session : sessions) {
      // Can't assign tasks[s] to this session.
      if (session + tasks[s] > sessionTime)
        continue;
      // Assign tasks[s] to this session.
      session += tasks[s];
      if (dfs(tasks, s + 1, move(sessions), sessionTime))
        return true;
      // Backtracking.
      session -= tasks[s];
      // If it's the first time we assign tasks[s] to this session. Then, future
      // `session`s can't satisfy either.
      if (session == 0)
        return false;
    }

    return false;
  }
};"
"class Solution:
    def maximumCandies(self, candies: List[int], k: int) -> int:
        if sum(candies) < k:
            return 0
        
        hi = sum(candies) // k                  
        lo = 1                                  # Because sum(candies) >= k, kids can gain at least 1 candy
        
        def can_allo(candies, num, k):          # To determine whether candies can be allocate to at least k piles when pile == num
            count = 0
            for c in candies:
                count += c // num
            return count >= k
        
        while hi > lo:                          # binary search until hi == lo
            mid = (hi + lo) // 2
            if can_allo(candies, mid, k):
                lo = mid + 1
            else:
                hi = mid
        
        if can_allo(candies, hi, k):            # if hi can be allocated: just return hi
            return hi
        else:
            return hi - 1                       # else: it must be hi - 1","class Solution {
 public:
  // Similar to 940. Distinct Subsequences II
  int numberOfUniqueGoodSubsequences(string binary) {
    constexpr int kMod = 1'000'000'007;
    // endsWith[i] := # of subseqs ends with '0' + i
    vector<int> endsWith(2);

    for (const char c : binary) {
      endsWith[c - '0'] = (endsWith[0] + endsWith[1]) % kMod;
      // Don't cound '0' since we want to avoid the leading zeros case.
      // However, we can always count '1'.
      if (c == '1')
        ++endsWith[1];
    }

    // Count '0' in the end.
    return (endsWith[0] + endsWith[1] +
            (binary.find('0') == string::npos ? 0 : 1)) %
           kMod;
  }
};"
"class Solution:
    def largestInteger(self, num: int) -> int:
        arr = [n for n in str(num)]
        n = len(arr)
        
        for i in range(n):
            for j in range(i+1, n):
                if int(arr[i]) % 2 == 0 and int(arr[j]) % 2 == 0 and int(arr[j]) > int(arr[i]):
                    arr[i], arr[j] = arr[j], arr[i]
                
                elif int(arr[i]) % 2 == 1 and int(arr[j]) % 2 == 1 and int(arr[j]) > int(arr[i]):
                    arr[i], arr[j] = arr[j], arr[i]
        
        return int("""".join(arr))","class Solution {
 public:
  int catchMaximumAmountofPeople(vector<int>& team, int dist) {
    int ans = 0;
    int i = 0;  // 0's index
    int j = 0;  // 1's index

    while (i < team.size() && j < team.size())
      if (i + dist < j || team[i] != 0) {
        // Find the next 0 that can be caught by 1.
        ++i;
      } else if (j + dist < i || team[j] != 1) {
        // Find the next 1 that can catch 0.
        ++j;
      } else {
        // team[j] catches team[i], so move both.
        ++ans;
        ++i;
        ++j;
      }

    return ans;
  }
};"
"class Solution:
    def minimizeResult(self, expression: str) -> str:
        int1, int2 = expression.split('+')
        arr1, tmp1 = [char for char in int1], [char for char in int1]
        arr2, tmp2 = [char for char in int2], [char for char in int2]
        min_res = int(int1) + int(int2)
        res = '(' + expression + ')'
        first_limit = len(int1)
        sec_limit = len(int2)

        for i in range(0, first_limit):
            for j in range(1, sec_limit + 1):
                if i == 0 and j != sec_limit:
                    cur_res = (int(int1[i:]) + int(int2[:j])) * int(int2[j:])
                elif i != 0 and j == sec_limit:
                    cur_res = int(int1[:i]) * (int(int1[i:]) + int(int2[:j]))
                elif i == 0 and j == sec_limit:
                    continue
                else:
                    cur_res = int(int1[:i]) * (int(int1[i:]) + int(int2[:j])) * int(int2[j:])
                    
                if cur_res < min_res:
                    min_res = cur_res
                    arr1.insert(i, '(')
                    arr2.insert(j, ')')
                    res = """".join(arr1) + '+' + """".join(arr2)
                    arr1 = tmp1[:]
                    arr2 = tmp2[:]
        
        return res","class Solution {
 public:
  vector<vector<int>> findFarmland(vector<vector<int>>& land) {
    vector<vector<int>> ans;

    for (int i = 0; i < land.size(); ++i)
      for (int j = 0; j < land[0].size(); ++j)
        if (land[i][j] == 1) {
          int x = i;
          int y = j;
          dfs(land, i, j, x, y);
          ans.push_back({i, j, x, y});
        }

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& land, int i, int j, int& x, int& y) {
    if (i < 0 || i == land.size() || j < 0 || j == land[0].size())
      return;
    if (land[i][j] != 1)
      return;
    land[i][j] = 2;  // Mark as visited.
    x = max(x, i);
    y = max(y, j);
    dfs(land, i + 1, j, x, y);
    dfs(land, i, j + 1, x, y);
  }
};"
"class Solution:
    def maximumProduct(self, nums: List[int], k: int) -> int:
        count=Counter(nums) # Get the frequencies of each element
        a=min(count.keys()) # Start with minimum key
        m=1000000007
        p=1 # To store the answer
        while k:
            c=count[a]
            if c<=k:
                count[a]-=c # Reduce it by the number of times the smallest element is encountered
                count[a+1]+=c # Inrease the count by the same magnitude 
                if count[a]==0: # Check if current numbers count reduces to zero
                    a+=1 # If yes then move onto next minimum number
                k-=c # reduce k
                continue
            if c>k: # if count of the smallest element is greater than the number of operations k then
                count[a]-=k # reduce the count of the smallest number by k 
                count[a+1]+=k # increase the count of smallest_num+1 by k
                k=0 # and reduce k to zero
        for key, val in count.items():
            if val: # if val of keys is greater than 0 then use them in result
                p=p*(key**val)%m #Use modulus to reduce the run time
        return p","class Solution {
 public:
  int numberOfGoodSubsets(vector<int>& nums) {
    const vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
    const int n = 1 << primes.size();
    const int maxNum = *max_element(begin(nums), end(nums));
    vector<long> dp(n);
    vector<int> count(maxNum + 1);

    dp[0] = 1;

    for (const int num : nums)
      ++count[num];

    for (int num = 2; num <= maxNum; ++num) {
      if (count[num] == 0)
        continue;
      if (num % 4 == 0 || num % 9 == 0 || num % 25 == 0)
        continue;
      const int numPrimesMask = getPrimesMask(num, primes);
      for (int primesMask = 0; primesMask < n; ++primesMask) {
        if ((primesMask & numPrimesMask) > 0)
          continue;
        const int nextPrimesMask = primesMask | numPrimesMask;
        dp[nextPrimesMask] += dp[primesMask] * count[num];
        dp[nextPrimesMask] %= kMod;
      }
    }

    return myPow(2, count[1]) *
           (accumulate(begin(dp) + 1, end(dp), 0L) % kMod) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  int getPrimesMask(int num, const vector<int>& primes) {
    int primesMask = 0;
    for (int i = 0; i < primes.size(); ++i)
      if (num % primes[i] == 0)
        primesMask |= 1 << i;
    return primesMask;
  }

  int myPow(long x, int n) {
    if (n == 0)
      return 1;
    if (n & 1)
      return x * myPow(x, n - 1) % kMod;
    return myPow(x * x % kMod, n / 2);
  }
};"
"class Solution:
    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:
        totf = 0
        for i,f in enumerate(flowers):
            if f>target:
                flowers[i] = target
            totf += min(f,target)
        flowers.sort(reverse=True)
		
		# if newFlowers can make all garden 'full'
        n = len(flowers)
        if n*target - totf<=newFlowers:
            maxscore = n*full # score if all garden 'full'
            if flowers[-1]<target: # score if all garden but one 'full'
                maxscore = max(maxscore,(n-1)*full+(target-1)*partial) 
            return maxscore
        
		# if newFlowers can not make all garden 'full'
        tofill = 0 # no garden full, n gardens to fill
        level = (totf+newFlowers) // (n-tofill) # try fill all n garden
        while level<flowers[tofill]: # not plausible
            totf -= flowers[tofill] # exclude the next garden
            tofill += 1
            level = (totf+newFlowers) // (n-tofill) # try again
        maxscore = level*partial # score if no garden 'full'
        for i in range(len(flowers)): # (i+1) 'garden full'
            newFlowers -= target - flowers[i] 
            if newFlowers<0: # cannot fill any more garden
                break
            score = (i+1)*full # score from (i+1) 'full' garden
            if tofill==i:
                totf -= flowers[i]
                tofill = i+1
            level = (totf+newFlowers) // (n-tofill) # try fill the rest of the gardens
            while level<flowers[tofill]: # not plausible
                totf -= flowers[tofill] # exclude the next garden
                tofill += 1
                level = (totf+newFlowers) // (n-tofill)
            score = score + level * partial # score from partial gardens
            if score>maxscore:
                maxscore = score
        return maxscore","class Solution {
 public:
  int numberOfWeakCharacters(vector<vector<int>>& properties) {
    // Sort properties by attack descendingly, then by defense ascendingly
    sort(begin(properties), end(properties),
         [](const vector<int>& a, const vector<int>& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] > b[0];
    });

    int ans = 0;
    int maxDefense = 0;

    for (const vector<int>& property : properties) {
      const int defense = property[1];
      if (defense < maxDefense)
        ++ans;
      maxDefense = max(maxDefense, defense);
    }

    return ans;
  }
};"
"class Solution:
    def sum(self, num1: int, num2: int) -> int:
        return num1 + num2","class Solution {
 public:
  int firstDayBeenInAllRooms(vector<int>& nextVisit) {
    constexpr int kMod = 1'000'000'007;
    const int n = nextVisit.size();
    // dp[i] := # of days to visit room i for first time
    vector<int> dp(n);

    // Whenever we visit i, visit times of room[0..i - 1] are all even.
    // Therefore, rooms before i can be seen as reset and we can safely reuse
    // dp[0..i - 1] as first-time visit to get second-time visit
    for (int i = 1; i < n; ++i)
      // The total days to visit room[i] is the sum of
      //   * dp[i - 1]: 1st-time visit room[i - 1]
      //   * 1: visit room[nextVisit[i - 1]]
      //   * dp[i - 1] - dp[nextVisit[i - 1]]: 2-time visit room[i - 1]
      //   * 1: visit room[i]
      dp[i] = (2L * dp[i - 1] - dp[nextVisit[i - 1]] + 2 + kMod) % kMod;

    return dp.back();
  }
};"
"class Solution:
    def checkTree(self, root: Optional[TreeNode]) -> bool:
        return (root.left.val + root.right.val) == root.val
          

# time O(1)
# space O(1)","class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  bool gcdSort(vector<int>& nums) {
    const int maxNum = *max_element(begin(nums), end(nums));
    const vector<int> minPrimeFactor = sieveEratosthenes(maxNum + 1);
    UnionFind uf(maxNum + 1);

    for (const int num : nums)
      for (const int primeFactor : getPrimeFactors(num, minPrimeFactor))
        uf.unionByRank(num, primeFactor);

    vector<int> sortedNums(nums);
    sort(begin(sortedNums), end(sortedNums));

    for (int i = 0; i < nums.size(); ++i)
      // Can't swap nums[i] with sortedNums[i].
      if (uf.find(nums[i]) != uf.find(sortedNums[i]))
        return false;

    return true;
  }

 private:
  // Gets min prime factor of i, where 1 < i <= n.
  vector<int> sieveEratosthenes(int n) {
    vector<int> minPrimeFactor(n + 1);
    iota(begin(minPrimeFactor) + 2, end(minPrimeFactor), 2);
    for (int i = 2; i * i < n; ++i)
      if (minPrimeFactor[i] == i)  // `i` is prime.
        for (int j = i * i; j < n; j += i)
          minPrimeFactor[j] = min(minPrimeFactor[j], i);
    return minPrimeFactor;
  }

  vector<int> getPrimeFactors(int num, const vector<int>& minPrimeFactor) {
    vector<int> primeFactors;
    while (num > 1) {
      const int divisor = minPrimeFactor[num];
      primeFactors.push_back(divisor);
      while (num % divisor == 0)
        num /= divisor;
    }
    return primeFactors;
  }
};"
"class Solution:
    def findClosestNumber(self, nums: List[int]) -> int:
        result = nums[0]
        for n in nums:
            if abs(n) < abs(result):
                result = n
            elif n == -result  and n > 0:
                result = n

        return result","class Solution {
 public:
  int findInteger(int k, int digit1, int digit2) {
    const int minDigit = min(digit1, digit2);
    const int maxDigit = max(digit1, digit2);
    const vector<int> digits = minDigit == maxDigit
                                   ? vector<int>{minDigit}
                                   : vector<int>{minDigit, maxDigit};
    queue<int> q;

    for (const int digit : digits)
      q.push(digit);

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      if (u > k && u % k == 0)
        return u;
      if (u == 0)
        continue;
      for (const int digit : digits) {
        const long nextNum = u * 10L + digit;
        if (nextNum > INT_MAX)
          continue;
        q.push(nextNum);
      }
    }

    return -1;
  }
};"
"class Solution:
    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:
        p = total // cost1
        ways = 0
        
        for i in range(p + 1):
            t = total - i * cost1
            ways += (t // cost2) + 1
           
        return ways",
"class Solution:
    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
      
      connection = {}
      
      for source, target in edges:
        if source not in connection: connection[source] = [target]
        else: connection[source].append(target)
          
        if target not in connection: connection[target] = [source]
        else: connection[target].append(source)
          
      res = -1
      
      max_dict = {}
      for key, value in connection.items():
        max1, max2, max3 = -sys.maxsize, -sys.maxsize, -sys.maxsize
        n1, n2, n3 = None, None, None
        for element in value:
          if scores[element] > max1:
            max1, max2, max3 = scores[element], max1, max2
            n1, n2, n3 = element, n1, n2
          elif scores[element] > max2:
            max2, max3 = scores[element], max2
            n2, n3 = element, n2
          elif scores[element] > max3:
            max3 = scores[element]
            n3 = element
        max_dict[key] = []
        if n1 != None: max_dict[key].append(n1)
        if n2 != None: max_dict[key].append(n2)
        if n3 != None: max_dict[key].append(n3)
             
      for source, target in edges:
        base = scores[source] + scores[target]
        
        n_s = max_dict[source]
        n_t = max_dict[target]
        if len(n_s) == 1 or len(n_t) == 1:
          pass
        else:
          new_n_s = [x for x in n_s if x != target]
          new_n_t = [x for x in n_t if x != source]
          if new_n_s[0] != new_n_t[0]:
            res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[0]])
          else:
            if len(new_n_s) > 1:
              res = max(res, base + scores[new_n_s[1]] + scores[new_n_t[0]])
            if len(new_n_t) > 1:
              res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[1]])      
    
      return res",
"class Solution(object):
    def digitSum(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: str
        """"""
        while len(s)>k:
            t = """"
            x = 0
            a = 0
            for i in range(len(s)):
                if x==k:
                    x = 1
                    t+=str(a)
                    a = int(s[i])
                else:
                    x+=1
                    a+=int(s[i])
            t+=str(a)
            print(t)
            s = t
        return s",
"lass Solution(object):
    def minimumRounds(self, tasks):
        """"""
        :type tasks: List[int]
        :rtype: int
        """"""
        d = {}
        for i in tasks:
            if i not in d:
                d[i] = 1
            else:
                d[i]+=1
        ans = 0
        for i in d:
            if d[i]<2:
                return -1
            else:
                if d[i]%3==0:
                    ans+=d[i]//3 
                else:
                    ans += d[i]//3 +1
        return ans",
"class Solution:
    def maxTrailingZeros(self, grid: List[List[int]]) -> int:
        def check(grid, row_order=1, col_order=1):
            above = [[0, 0] for i in range(len(grid[0]))]
            ans = 0
            for row in grid[::row_order]:
                this_row = [0, 0]
                for i, v in enumerate(row[::col_order]):
                    c2 = c5 = 0
                    while v % 2 == 0:
                        c2 += 1
                        v /= 2
                    while v % 5 == 0:
                        c5 += 1
                        v /= 5
                    this_row[0] += c2
                    this_row[1] += c5
                    ans = max(ans, min(this_row[0] + above[i][0], this_row[1] + above[i][1]))
                    above[i][0] += c2
                    above[i][1] += c5
            return ans
        return max(check(grid, ro, co) for ro in [-1, 1] for co in [-1, 1])",
"class Solution(object):
    def longestPath(self, parent, s):
        """"""
        :type parent: List[int]
        :type s: str
        :rtype: int
        """"""
        self.child = {i:[] for i in range(len(parent))}
        for i in range(1,len(parent)):
            self.child[parent[i]].append(i)
        self.m = 0 
        def ser(i,p):
            if len(self.child[i])==0:
                if p==s[i]:
                    return 0 
                self.m = max(self.m,1)
                return 1
            a = []
            for j in self.child[i]:
                a.append(ser(j,s[i]))
            a.sort()
            x = a[-1]
            y = 0  
            if len(a)>1:
                y = a[-2]
            self.m = max(self.m,x+y+1)
            if s[i]==p:
                return 0 
            return x+1 
        ser(0,"""")
        return self.m",
"class Solution:
    def intersection(self, nums: List[List[int]]) -> List[int]:
        return sorted(reduce(lambda x,y: set(x)&amp;set(y), nums))",
"class Solution:
    def countLatticePoints(self, circles: List[List[int]]) -> int:
        result = set()
        
        for circle in circles:
            x, y, r = circle
            for i in range(x - r, x + r + 1):
                for j in range(y - r, y + r + 1):
                    if (i - x) * (i - x) + (j - y) * (j - y) <= r * r:
                        result.add((i, j))
                        
        return len(result)",
"class Solution:
    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:
      
      rectangles.sort(key = lambda x : x[0])
      
      for i in range(len(points)):
        points[i] += [i]

      points.sort(key = lambda x : x[0])
      
      data_x = [x[0] for x in rectangles]
      data_y = []
      prev_ind = len(rectangles)
      
      res = [0]*len(points)
      
      for i in range(len(points)-1, -1, -1):
        q_x, q_y, loc = points[i]
        ind = bisect.bisect_left(data_x, q_x)
        for t in range(ind, prev_ind):
          bisect.insort(data_y, rectangles[t][1])
        prev_ind = ind
        res[loc] = len(data_y) - bisect.bisect_left(data_y, q_y)
      
      return res",
"class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]:
        fakePerson = [[x, 0, i] for i, x in enumerate(persons)]
        flow = []
        for start, end in flowers:
            flow.append([start, -float('inf')])
            flow.append([end, float('inf')])
        flow += fakePerson
        flow.sort()
        cur = 0
        n = len(persons)
        res = [0] * n
        for item in flow:
            if len(item) == 2:
                if item[1] == -float('inf'):
                    cur += 1
                else:
                    cur -= 1
            else:
                _, _, idx = item
                res[idx] = cur
        return res
		```",
"class Solution:
    def countPrefixes(self, words: List[str], s: str) -> int:
        return sum(1 for word in words if s.startswith(word))",
"class Solution:
    def minimumAverageDifference(self, nums: List[int]) -> int:
      total_sum = sum(nums)
      start = 0
      prefix_sum = []
      for element in nums:
        start += element
        prefix_sum.append(start)
      mini = sys.maxsize
      res = None
      size_t = len(nums)
      for i in range(len(nums)-1):
        diff = abs(floor(prefix_sum[i]/(i+1)) - floor((total_sum - prefix_sum[i])/(size_t - i - 1)))
        if diff < mini:
          mini = diff
          res = i
      last_diff = abs(floor(total_sum/size_t))
      if last_diff < mini: mini = last_diff; res = size_t - 1
      return res",
"class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
      grid = [[0]*n for _ in range(m)]
      for x, y in guards:
        grid[x][y] = 'G'
      for x, y in walls:
        grid[x][y] = 'W'
        
      grid2 = [[0]*n for _ in range(m)]
      for x, y in guards:
        grid2[x][y] = 'G'
      for x, y in walls:
        grid2[x][y] = 'W'
        
      for i in range(m):
        cache = []
        has_G = False
        for j in range(n):
          if grid[i][j] == 0:
            cache.append(j)
          elif grid[i][j] == 'G':
            if cache:
              for k in cache:
                grid[i][k] = 'O'
              cache = []
            has_G = True
          else:
            if has_G:
              if cache:
                for k in cache:
                  grid[i][k] = 'O'
                  cache = []
              has_G = False
            else:
              cache = []
        if cache:
          if has_G:
            for k in cache:
                grid[i][k] = 'O'
      
      for j in range(n):
        cache = []
        has_G = False
        for i in range(m):
          if grid2[i][j] == 0:
            cache.append(i)
          elif grid2[i][j] == 'G':
            if cache:
              for k in cache:
                grid2[k][j] = 'O'
              cache = []
            has_G = True
          else:
            if has_G:
              if cache:
                for k in cache:
                  grid2[k][j] = 'O'
                  cache = []
              has_G = False
            else:
              cache = []
        if cache:
          if has_G:
            for k in cache:
                grid2[k][j] = 'O'
      
      res = 0
      for i in range(m):
        for j in range(n):
          if grid[i][j] == 0 and grid2[i][j] == 0: res += 1
      return res",
"class Solution:
    def maximumMinutes(self, grid: List[List[int]]) -> int:
        R, C = len(grid), len(grid[0])
        lo = 0
        hi = 1000000000
        fire = [[float('inf')] * C for _ in range(R)]
        q = deque()
        for r in range(R):
            for c in range(C):
                if grid[r][c] == 1:
                    fire[r][c] = 0
                    q.appendleft((r, c))
        step = 0
        while q:
            nq = deque()
            while q:
                r, c = q.pop() 
                for dr, dc in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                    rr, cc = r + dr, c + dc
                    if 0 <= rr < R and 0 <= cc < C and grid[rr][cc] == 0 and fire[rr][cc] == float('inf'):
                        nq.appendleft((rr, cc))
                        fire[rr][cc] = min(fire[rr][cc], step + 1)
            step += 1
            q = nq
        def check(mid):
            q = deque([(0, 0)])
            v = {(0, 0): mid} 
            while q:
                r, c = q.pop()
                step = v[r, c] 
                if r == R - 1 and c == C - 1:
                    return True
                for dr, dc in  [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                    rr, cc = dr + r, c + dc
                    if 0 <= rr < R and 0 <= cc < C and grid[rr][cc] == 0 and (rr, cc) not in v and \
                        (step + 1 < fire[rr][cc] or (rr, cc) == (R - 1, C - 1) and step + 1 <= fire[rr][cc] ):
                        q.appendleft((rr, cc))
                        v[rr, cc] = step + 1
            return False
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if check(mid):
                lo = mid
            else:
                hi = mid - 1
        if check(lo):
            return lo 
        return -1",
"class Solution:
    def removeDigit(self, number: str, digit: str) -> str:
        res_nums = set()
        pos = 0
        for i in range(number.count(digit)):
            ind = number.index(digit, pos, len(number))
            res = number[:ind] + number[ind+1:]
            if int(res) not in res_nums:
                res_nums.add(int(res))
            pos = ind + 1
        return str(max(res_nums))",
"class Solution:
    def minimumCardPickup(self, cards: List[int]) -> int:
        dic = defaultdict(int)
        min_num = float('inf')
        
        for i, num in enumerate(cards):
            if num not in dic:
                dic[num] = i
            else:
                min_num = min(min_num, i - dic[num] + 1)
                dic[num] = i
        
        if min_num == float('inf'):
            return -1
        else:
            return min_num",
"class Solution:
    def countDistinct(self, nums: List[int], k: int, p: int) -> int:
        result = set()
        N = len(nums)
        K = k
        for i in range(N):
            k = K
            for j in range(i,N):
                if k>0:
                    if nums[j] % p == 0:
                        k -= 1
                    s = str(nums[i:j+1])
                    if s not in result:
                        result.add(s)
                elif nums[j] % p != 0:
                    s = str(nums[i:j+1])
                    if s not in result:
                        result.add(s)
                else: 
                    break
        return len(result)",
"class Solution:
    def appealSum(self, s: str) -> int:
        seen_char_at_idx = defaultdict(int)
        total_appeal = 0
        prev_round_added = 0
        for idx in range(len(s)):
            appeal_supposed_to_add = idx + 1
            this_round_adding = prev_round_added + appeal_supposed_to_add
            if s[idx] in seen_char_at_idx:
                this_round_adding -= seen_char_at_idx[s[idx]] + 1
            
            total_appeal += this_round_adding
            prev_round_added = this_round_adding
            seen_char_at_idx[s[idx]] = idx # refreshing last seen index
        return total_appeal",
"class Solution:
  def largestGoodInteger(self, num: str) -> str:
    letter = """"
    
    i = 0
    while i != len(num) :
      j = i + 1
      while j != len(num) and num[i] == num[j]: j += 1
      if j - i > 2 and letter < num[i]        : letter = num[i]
      
      i = j
    
    return letter * 3",
"class Solution:
    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:
        res = 0
        def averageOfSubtreeInner(node):
            nonlocal res
            if not node:
                return (0, 0)
            
            l_cnt, l_sum = averageOfSubtreeInner(node.left)
            r_cnt, r_sum = averageOfSubtreeInner(node.right)
            
            tot_sum = l_sum + r_sum + node.val
            tot_cnt = 1 + l_cnt + r_cnt
            avg = tot_sum//tot_cnt
            if avg == node.val:
                res+=1
            return (tot_cnt, tot_sum)
            
        averageOfSubtreeInner(root)
        return res",
"class Solution:
    def countTexts(self, pressedKeys: str) -> int:
      res = 0
      
      grid = [0]*(len(pressedKeys)+1)
      
      grid[0] = 1
      
      set1 = {'2', '3', '4', '5', '6', '8'}
      
      for t in range(1,len(grid)):
        target = pressedKeys[t-1]
        res = grid[t-1]
        if target in set1:
          if t >= 2 and pressedKeys[t-2] == target:
            res += grid[t-2]
          if t >= 3 and pressedKeys[t-2] == target and pressedKeys[t-3] == target:
            res += grid[t-3]
        else:
          if t >= 2 and pressedKeys[t-2] ==  target:
            res += grid[t-2]
          if t >= 3 and pressedKeys[t-2] == target and pressedKeys[t-3] == target:
            res += grid[t-3]
          if t >= 4 and pressedKeys[t-2] == target and pressedKeys[t-3] == target and pressedKeys[t-4] == target:
            res += grid[t-4]
            
        grid[t] = res % (10**9 + 7)
      return grid[-1] % (10**9 + 7)",
"class Solution:
    def hasValidPath(self, grid: List[List[str]]) -> bool:
      m, n = len(grid), len(grid[0])
      
      if grid[0][0] == ')': return False
      else:
        
        @lru_cache(None)
        def helper(x, y, acc):
          if x == m-1 and y == n-1:
            if grid[x][y] == ')':
              if acc == 1: return True
              else: return False
          else:
            if grid[x][y] == ')':
              if acc == 0: return False
              else:
                if x < m-1:
                  res = helper(x+1, y, acc-1)
                  if res: return True
                if y < n-1:
                  res = helper(x, y+1, acc-1)
                  if res: return True
                return False
            else:
              acc += 1
              if x < m-1:
                res = helper(x+1, y, acc)
                if res: return True
              if y < n-1:
                res = helper(x, y+1, acc)
                if res: return True
              return False
          
        return helper(0, 0, 0)",
"class Solution:
    def divisorSubstrings(self, num: int, k: int) -> int:
        num_str = str(num)
        n = len(num_str)
        
        count = 0
        for i in range(n - k + 1):
            sub_num = int(num_str[i:i+k])
            if sub_num == 0 or num % sub_num != 0:
                continue
                
            count += 1
            
        return count",
"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        running_sum = []
        total = 0
        for i, num in enumerate(nums):
            total += num
            running_sum.append(total)
        
        total = sum(nums)
        splits = 0
        n = len(nums)
        for i in range(n-1):
            if running_sum[i] >= total-running_sum[i]:
                splits += 1
        
        return splits",
"class Solution:
    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:
        if not carpetLen or not tiles: return 0
        def get_next(itl, lf, rt):
            if itl < lf - 1:
                next_itr = lf - 1
            elif itl == lf - 1:
                next_itr = lf
            elif lf <= itl < rt:
                next_itr = rt
            elif itl == rt:
                next_itr = rt + 1
            else:
                next_itr = itl + 1
            return next_itr
        tiles.sort()
        itl = -1
        itr = 0
        iwl = iwr = 0
        nw = 0
        max_w = 0
        max_iter = tiles[-1][1]
        prev_itr = -1
        while itr  < (tiles[-1][1] + 1):
            itl = itr - carpetLen
            njump = itr - prev_itr
            
            if njump == 1:
                while itr > tiles[iwr][1] and iwr < len(tiles) - 1:
                    iwr += 1
                lf, rt = tiles[iwr]
                if lf <= itr <= rt:
                    nw += 1

                next_itr = get_next(itr, lf, rt)
                if itl >= 0:
                    while itl > tiles[iwl][1] and iwl < len(tiles) - 1:
                        iwl += 1
                    lf, rt = tiles[iwl]
                    if lf <= itl <= rt:
                        nw -= 1
                    next_itr2 = get_next(itl, lf, rt) + carpetLen
                else:
                    next_itr2 = math.inf
                prev_itr = itr
                itr = min(next_itr, next_itr2)
            else:
                lf, rt = tiles[iwr]
                if lf <= prev_itr <= rt:
                    nw += itr - prev_itr
                if prev_itr - carpetLen >= 0:
                    lf, rt = tiles[iwl]
                    if lf <= prev_itr - carpetLen <= rt:
                        nw -= itr - prev_itr   
                prev_itr = itr
                itr += 1
            max_w = max(max_w, nw)
        return max_w",
"class Solution:
    def largestVariance(self, s: str) -> int:
        counter = Counter(s)
        res = 0
        
        for a, b in permutations(counter, 2):
            count_a, count_b = 0, 0
            remain_b = counter[b]
            for ch in s:
                if ch not in {a, b}:
                    continue
                if ch == a:
                    count_a += 1
                elif ch == b:
                    count_b += 1
                    remain_b -= 1
                # Kadane's Algorithm, modified
                if count_a < count_b and remain_b > 0:
                    count_a, count_b = 0, 0
                if count_b > 0:
                    res = max(res, count_a - count_b) 

        return res",
"class Solution:
    def removeAnagrams(self, words: List[str]) -> List[str]:
        new = [words[0]]
        for i in range(1, len(words)):
            if Counter(words[i - 1]) == Counter(words[i]):
                continue
            else:
                new.append(words[i])
                
        return new",
"class Solution:
    def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:
        aug = [bottom-1] + sorted(special) + [top+1]
        return max(aug[i]-aug[i-1]-1 for i in range(1, len(aug)))",
"class Solution:
    def largestCombination(self, candidates: List[int]) -> int:
        lst, n = [], len(str(bin(max(candidates)))[2:])
        for x in candidates:
            lst.append(str(bin(x))[2:].zfill(n))

        counter = Counter()
        for x in lst:
            for i, y in enumerate(x):
                if y == ""1"":
                    counter[i] += 1
					
        return max(counter.values())",
"class Solution:
    def percentageLetter(self, s: str, letter: str) -> int:
        c=0
        for i in letter:
            if i in s:
                c+=s.count(i)
        return c*100//len(s)",
"class Solution:
    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:
        heap = []
        answer = 0
        n = len(rocks)

        for i in range(n):
            heappush(heap, (
                capacity[i] - rocks[i],
                i
            ))

        while heap:
            remainingCapacity, index  = heappop(heap)
            if remainingCapacity == 0:
                answer += 1

            if 0 < remainingCapacity <= additionalRocks and additionalRocks > 0:
                heappush(heap, (
                    0,
                    index
                ))
                additionalRocks -= remainingCapacity


        return answer",
"class Solution:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        if len(stockPrices) == 1 :
            return 0
        if len(stockPrices) == 2:
            return 1
        number = 1
        stockPrices.sort()
        for i in range(2, len(stockPrices)):
            if int((stockPrices[i][1]-stockPrices[i-1][1])*(stockPrices[i-1][0]-stockPrices[i-2][0])) !=\
               int((stockPrices[i-1][1]-stockPrices[i-2][1])*(stockPrices[i][0]-stockPrices[i-1][0])):
                number = number + 1
                
        return number
		```",
"class Solution:
    def totalStrength(self, strength: List[int]) -> int:
        ans = 0 
        stack = []
        prefix = list(accumulate(accumulate(strength), initial=0))
        for i, x in enumerate(strength + [0]): 
            while stack and stack[-1][1] >= x: 
                mid = stack.pop()[0]
                lo = stack[-1][0] if stack else -1 
                left = prefix[mid] - prefix[max(lo, 0)]
                right = prefix[i] - prefix[mid]
                ans = (ans + strength[mid]*(right*(mid-lo) - left*(i-mid))) % 1_000_000_007
            stack.append((i, x))
        return ans",
"class Solution:
    def digitCount(self, num: str) -> bool:
        for i in range(len(num)):
            if int(num[i]) != num.count(str(i)):
                return False
        return True",
"class Solution:
    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:
        d,res,s = {},-1,""""
        for i in range(len(senders)):
            sender = senders[i]
            message_count = len(messages[i].split("" ""))
            d[sender] = d.get(sender,0) + message_count
            if d[sender] > res:
                res = d[sender]
                s = sender
            elif d[sender] == res:
                s = max(sender,s)
            
        return s",
"class Solution:
    def maximumImportance(self, n: int, roads: List[List[int]]) -> int:
        dict1={}
        for i in roads:
            if i[0] not in dict1:dict1[i[0]]=1
            else:dict1[i[0]]+=1
            if i[1] not in dict1:dict1[i[1]]=1
            else:dict1[i[1]]+=1
        sorted_dict = {}
        sorted_keys = sorted(dict1, key=dict1.get)  

        for w in sorted_keys:
            sorted_dict[w] = dict1[w]
        
        items = list(sorted_dict.items())
        sorted_dict = {k: v for k, v in reversed(items)}
        
        ans=0
        for i in sorted_dict:
            sorted_dict[i]=n
            n-=1
            
        print(sorted_dict)
        for i in roads:
            hold=sorted_dict[i[0]]+sorted_dict[i[1]]
            ans+=hold
        
        return ans",
"class Solution:
   def rearrangeCharacters(self, s: str, target: str) -> int:
       c1=Counter(s)
       c2=Counter(target)
       cnt=0
       while (c2&amp;c1)==c2:
           cnt+=1
           c1=c1-c2
       return (cnt)",
"class Solution:
    def discountPrices(self, sentence: str, discount: int) -> str:
        strings = sentence.split(' ')
        result = []
        
        for string in strings:
            if string[0] == '$': tmp = string[1:] tmp.replace('.', '') if tmp.isdigit(): new = (float)(string[1:]) * ((100 - discount) / 100) new = ""$"" + ""{:.2f}"".format(new)
                    result.append(new)
                else:
                    result.append(string)
            else:
                result.append(string)
        
        return "" "".join(result)",
"class Solution:
    def totalSteps(self, nums: List[int]) -> int:
        ans = 0 
        stack = []
        for x in nums: 
            val = 1
            while stack and stack[-1][0] <= x: val = max(val, stack.pop()[1]+1)
            if not stack: val = 0
            stack.append((x, val))
            ans = max(ans, val)
        return ans",
"class Solution:
    def minMaxGame(self, nums: List[int]) -> int:
        
        x = 0 
        while len(nums)>1:
            a = []
            while nums:
                if x:
                    a.append(max(nums[0],nums[1]))
                    nums.pop(0)
                    nums.pop(0)
                    x = 0
                else:
                    a.append(min(nums[0],nums[1]))
                    nums.pop(0)
                    nums.pop(0)
                    x = 1 
            nums = a 
        return nums[0]",
"class Solution:
    def partitionArray(self, nums: List[int], k: int) -> int:
        answer = 0
        nums.sort()

        while nums:
            smallestNumber = nums.pop(0)
            while nums and smallestNumber <= nums[0] and nums[0] - smallestNumber <= k:
                nums.pop(0)

            answer += 1

        return answer",
"class Solution:
    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:
        hashmap = {}

        for i, number in enumerate(nums):
            hashmap[number] = i

        for start, end in operations:
            if start in hashmap:
                nums[hashmap[start]] = end
                hashmap[end] = hashmap[start]

        return nums",
"class Solution:
    def strongPasswordCheckerII(self, S: str) -> bool:
        if len(S)<8:
            return False
        num=0
        upper=0
        lower=0
        spec=0
        char=""!@#$%^&amp;*()-+""
        for i in range(len(S)):
            if i>0 and S[i]==S[i-1]:
                return False
            if S[i].isdigit():
                num+=1
            if S[i].isupper():
                upper+=1
            if S[i].islower():
                lower+=1
            if S[i] in char:
                spec+=1
        if num>0 and upper >0 and lower>0 and spec>0 :
            return True
        return False",
"class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        potions.sort()
        m = len(potions)  
        return [m - bisect.bisect_left(potions, math.ceil(success / spell))
                for spell in spells]",
"class Solution:
    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:
        
#         maintain a map to know which letters can be changed
        d = defaultdict(set)

        for i,j in mappings:
            d[i].add(j)
        
        
        k = len(sub)
        
#         iterate over all possibilities of size len(sub)
        for i in range(len(s)-k+1):
            st = s[i:i+k]
            fl = 0
#          iterate greedily and try if we can replace cur character or not if not we break
            for j in range(k):
                if sub[j] != st[j]: 
                    if st[j] not in d[sub[j]]: 
                        fl = 1
                        break
            if fl ==0: return True
        return False",
"class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        res = 0
        left = 0
        windowSum = 0
        
        for right, num in enumerate(nums):
            windowSum += num
            windowLength = right - left + 1
            while windowSum * windowLength >= k:
                windowSum -= nums[left]
                left += 1
                windowLength -= 1
            
            res += windowLength
        
        return res",
"class Solution:
    def calculateTax(self, brackets: List[List[int]], income: int) -> float:
        
        ans = 0

        n = len(brackets)
        if income <= brackets[0][0]:
            return income * brackets[0][1] * 0.01

        # brackets[k - 1] < income < brackets[k]
        k = 0
        
        for i in range(n):
            if income > brackets[i][0]:
                k += 1

        j = 1
        ans += brackets[0][0] * brackets[0][1] * 0.01
        while j < k:
            ans += (brackets[j][0] - brackets[j - 1][0]) * brackets[j][1] * 0.01
            j += 1

        ans += (income - brackets[j - 1][0]) * brackets[j][1] * 0.01
        
        return ans",
"class Solution:
    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        dic = defaultdict(list)
        lastRow = set(grid[-1])
        
        for i in range(m*n):
            for j in range(n):
                if i in lastRow:
                    continue
                else:
                    # (cost, dest_col)
                    dic[i].append((moveCost[i][j], j))
                    
        dp = [[float('inf')] * n for _ in range(m)]
        
        for i in range(n):
            dp[0][i] = grid[0][i]
        
        for i in range(m-1):
            for j in range(n):
                start = grid[i][j]
                for cost, dest_col in dic[start]:
                    dp[i + 1][dest_col] = min(dp[i + 1][dest_col], dp[i][j] + cost + grid[i + 1][dest_col])
        
        return min(dp[-1])",
"class Solution:
    def distributeCookies(self, cookies: List[int], k: int) -> int:
        ans = sum(cookies)
        N = len(cookies)
        total = [0]*k
        
        def backtrack(i, total):
            nonlocal ans
            if i == N:
                ans = min(ans, max(total))
                return
            
            if max(total) >= ans:
                return
            
            for j in range(k):
                total[j] += cookies[i]
                backtrack(i+1, total)
                total[j] -= cookies[i]
        

        backtrack(0, total)
        return ans",
"class Solution:
    def distinctNames(self, ideas: List[str]) -> int:
        seen = set(ideas)
        freq = Counter()
        letters = {x[0] for x in ideas}
        for idea in ideas: 
            for ch in letters: 
                if ch + idea[1:] not in seen: freq[idea[0], ch] += 1 
        ans = 0 
        for idea in ideas: 
            for ch in letters: 
                if ch + idea[1:] not in seen: ans += freq[ch, idea[0]]
        return ans",
"class Solution:
    def greatestLetter(self, s: str) -> str:
        d = {}
        ans = """"
        for i in s:
            if i in d:
                ans = max(ans,i.upper())
            else:
                if i.islower():
                    d[i.upper()] = i 
                else:
                    d[i.lower()] = i 
        return ans",
"class Solution:
    
    
    def minimumNumbers(self, num: int, k: int) -> int:
        if num==0:
            return 0
        if num<k:
            
            return -1
        nums=[]
        
        while k<=num:
            
            nums.append(k)
            k+=10
        
    
        amount=num
        n=len(nums)

        dp=[[10**9]*(num+1)for _ in range(n)]
        for i in range(n):
            dp[i][0]=0
        if nums[0]<=amount:
            if nums[0]!=0 and amount%nums[0]==0:
                dp[0][nums[0]]=amount//nums[0]
                
            
        for i in range(n):
            for j in range(1,num+1):
                take=10**9
                if nums[i]<=j:
                    take=1+dp[i][j-nums[i]]
                not_take=dp[i-1][j]
                
                dp[i][j]=min(take,not_take)
                ans=dp[i][j]
                    
        if ans!=10**9:
            return ans
        
        return -1",
"class Solution:
    def longestSubsequence(self, s: str, k: int) -> int:
        # count all '0' first
        # traverse the s from back to front, try each digit '1'
        
        target = bin(k)[2:]
        result = s.count('0')
        n = len(s)
        cur_sum = 0
        
        for i in range(n-1, -1, -1):
            char = s[i]
            
            if char == '1':
                cur_num = 2 ** ((n-1)-i)
                cur_sum += cur_num
                
                if cur_sum > k:
                    return result
                else:
                    result += 1
        
        return result",
"class Solution:
    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:
        mp = {(h, w) : p for h, w, p in prices}
        
        @cache
        def fn(m, n): 
            """"""Return max money of a mxn piece of wood.""""""
            if m == 0 or n == 0: return 0
            ans = 0 
            if (m, n) in mp: ans = mp[m, n]
            if m > 1: ans = max(ans, max(fn(i, n) + fn(m-i, n) for i in range(1, m//2+1)))
            if n > 1: ans = max(ans, max(fn(m, j) + fn(m, n-j) for j in range(1, n//2+1)))
            return ans 
        
        return fn(m, n)",
"class Solution:
    def countAsterisks(self, s: str) -> int:
        
        result = 0
        
        for i, chunk in enumerate(s.split(""|"")):
            if i % 2 == 0:
                result += chunk.count(""*"")
        
        return result",
"class Solution:
    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        g = collections.defaultdict(list)
        seen = set()
        res = []
        
        # generate an adjacency list from edges
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)
        
        # count nodes in each disjoint graph segments
        def dfs(node):
            if node in seen:
                return
            
            self.count += 1
            seen.add(node)
            for nei in g[node]:
                dfs(nei)
                
            return
        
        for i in range(n):
            self.count = 0
            if i not in seen:
                dfs(i)
                
            res.append(self.count) 
            self.count = 0
                
        # returning sum of product all unique pairs 
        # (a1+a2+a3+...)^2 = (a1^2 + a2^2 + ...) + 2*(a1.a2 + a2.a3 + ...)
        # using above formula we can return the desired result
        return (sum(res)**2 - sum(num**2 for num in res))//2",
"class Solution:
    def maximumXOR(self, nums: List[int]) -> int:
        return reduce(lambda x,y:x|y, nums)",
"class Solution:
    def distinctSequences(self, n: int) -> int:
        MOD = 10**9 + 7
        @cache
        def dfs(i, prev, prev_prev):
            if i >= n:
                return 1
            result = 0
            for dice in range(1, 7):
                if dice == prev or dice == prev_prev:
                    continue
                if dice % 2 == 0 and prev % 2 == 0:
                    continue
                if dice % 3 == 0 and prev % 3 == 0:
                    continue
                result += dfs(i + 1, dice, prev)
            return result % MOD
        return dfs(0, -1, -1)",
"class Solution:
    def checkXMatrix(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        
        for i in range(n):
            for j in range(n):
                if i == j or i == n - j - 1:
                    if grid[i][j] == 0:
                        return False
                else:
                    if grid[i][j] != 0:
                        return False
                    
        return True",
"class Solution:
    def countHousePlacements(self, n: int) -> int:
        mod = 1000000007
        if n==1:
            return 4
      
        
        count_end = 1
        count_space = 1
        
        for i in range(2,n+1):
            prev_end = count_end
            prev_space = count_space
            
            count_space = prev_end + prev_space
            count_end  =prev_space
            
        ways = count_end + count_space
        
        return (ways*ways)%mod",
"class Solution:
    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:
        v1 = v2 = m1 = m2 = 0
        for x1, x2 in zip(nums1, nums2): 
            v1 = max(0, v1+x2-x1)
            v2 = max(0, v2+x1-x2)
            m1 = max(m1, v1)
            m2 = max(m2, v2)
        return max(sum(nums1)+m1, sum(nums2)+m2)",
"class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        tree = [set() for _ in range(n)]
        for e in edges:
            tree[e[0]].add(e[1])
            tree[e[1]].add(e[0])

        def make_tree(i, parent):
            ancestors[i].add(parent)
            for j in ancestors[parent]:
                ancestors[i].add(j)
            tree[i].remove(parent)
            for child in tree[i]:
                make_tree(child, i)
                xor[i] ^= xor[child]

        xor = [nums[i] for i in range(n)]
        ancestors = [set() for _ in range(n)]
        for child in tree[0]:
            make_tree(child, 0)
            xor[0] ^= xor[child]

        ans = 2 ** 31 - 1
        for i in range(1, n - 1):
            for j in range(i + 1, n):
                if i in ancestors[j]:
                    parts = [xor[0] ^ xor[i], xor[i] ^ xor[j], xor[j]]
                elif j in ancestors[i]:
                    parts = [xor[0] ^ xor[j], xor[i], xor[i] ^ xor[j]]
                else:
                    parts = [xor[0] ^ xor[i] ^ xor[j], xor[i], xor[j]]
                ans = min(ans, max(parts) - min(parts))
        return ans",
"class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        i = 97
        encMap = {' ': ' '}
        for c in key:
            if c not in encMap:
                encMap[c] = chr(i)
                i += 1
        
        res = []
        for c in message:
            res.append(encMap[c])
        
        return ''.join(res)",
"class Solution:
    def spiralMatrix(self, rows: int, cols: int, head: Optional[ListNode]) -> List[List[int]]:
        ans = [[-1] * cols for _ in range(rows)]
        rows1, cols1 = rows - 1, cols - 1
        min_layers = min(rows, cols) // 2
        for i in range(min_layers):
            for c in range(i, cols1 - i):
                ans[i][c] = head.val
                head = head.next
                if not head:
                    return ans
            col = cols1 - i
            for r in range(i, rows1 - i):
                ans[r][col] = head.val
                head = head.next
                if not head:
                    return ans
            row = rows1 - i
            for c in range(cols1 - i, i, -1):
                ans[row][c] = head.val
                head = head.next
                if not head:
                    return ans
            for r in range(rows1 - i, i, -1):
                ans[r][i] = head.val
                head = head.next
                if not head:
                    return ans
        if rows <= cols and rows % 2:
            for c in range(min_layers, cols - min_layers):
                ans[min_layers][c] = head.val
                head = head.next
                if not head:
                    return ans
        elif cols % 2:
            for r in range(min_layers, rows - min_layers):
                ans[r][min_layers] = head.val
                head = head.next
                if not head:
                    return ans
        return ans",
"class Solution:
    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        
        '''
        Time: O(n)
        Space: O(n)
        '''
        # record the newly pepole who know the secret on the given day
        dp = [0]*(n+1)
        dp[1] = 1
        share = 0
        MOD = 10**9 + 7
        for i in range(2, n+1):
            # newly people who know the secret today is the sum of days(forget:delay]
            dp[i] = share = (share + dp[i - delay] - dp[i - forget]) % MOD

        # return the sum of days where people not forget the secret yet
        return sum(dp[n-forget+1:]) % MOD",
"class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:
        '''
        time, space: O(m*n)
        similar to : https://leetcode.com/problems/longest-increasing-path-in-a-matrix/
        '''
        R, C = len(grid), len(grid[0])
        memo = {}
        MOD = 10**9 + 7
        
        def dfs(i, j, R, C, memo):
            if (i, j) in memo:
                return memo[(i,j)]
            
            res = 1
            for di,dj in [(1,0), (0,1), (-1,0), (0,-1)]:
                ni, nj = i+di, j+dj
                if 0<=ni<R and 0<=nj<C and grid[ni][nj] > grid[i][j]:
                    # res = max(res, dfs(ni, nj, R, C, memo))
                    res += dfs(ni, nj, R, C, memo)
            memo[(i, j)] = res % MOD
            return memo[(i, j)]
            
            
        ans = 0
        for i in range(R):
            for j in range(C):
                #ans = max(ans, dfs(i, j, R, C, memo))
                ans += dfs(i, j, R, C, memo) % MOD
                
        return ans % MOD",
"class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        if root.left is None:
            return root.val
        if root.val==2:
            return self.evaluateTree(root.left) or self.evaluateTree(root.right)
        else:
            return self.evaluateTree(root.left) and self.evaluateTree(root.right)",
"class Solution:
    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:
        buses = sorted(buses)
        passengers = deque(sorted(passengers))
        res = buses[-1]
        
        s = set(passengers)
        prev = passengers[0]
        
        for i, bus in enumerate(buses):
            cap = capacity
            while cap and passengers and passengers[0] <= bus:
                val = passengers.popleft()
                prev = val
                cap -= 1
                if val-1 not in s:
                    res = val-1
                
            if cap:
                for k in range(bus, prev, -1):
                    if k not in s:
                        res = k
                        break
        
        return res",
"class Solution:
    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:
        
        nums = [abs(a - b) for a, b in zip(nums1, nums2) if a != b]
        if k1 + k2 >= sum(nums): return 0

        cnt = Counter(nums)
                
        q = []
        for k in cnt:
            heappush(q, -k)        
        
        tot = sum(pow(x, 2) for x in nums)        
        k = k1 + k2
        # ops on largest diff
        while k > 0 and q:
            cur = -heappop(q)
            diff = cur + q[0] if q else cur
            # reduce current diff to next smaller diff
            if diff * cnt[cur] <= k:
                k -= diff * cnt[cur]
                cnt[-q[0]] += cnt[cur]
                tot += (pow(-q[0], 2) - pow(cur, 2)) * cnt[cur] 
            # apply all remaining ops
            else:
                a, b = divmod(k, cnt[cur])
                tot += (pow(cur - a - 1, 2) * b + pow(cur - a, 2) * (cnt[cur] - b)) - pow(cur, 2) * cnt[cur]
                k = 0                   
            
        
        return tot",
"class Solution:
    def validSubarraySize(self, nums: List[int], threshold: int) -> int:
        nums.append(0)
        stack = [(0, -1)]
        for i, v in enumerate(nums):
            while len(stack) > 1 and v <= stack[-1][0]:
                if stack[-1][0] > threshold / (i - 1 - stack[-2][1]):
                    return i - 1 - stack[-2][1]
                stack.pop()
            stack.append((v, i))
        return -1",
"class Solution:
    def fillCups(self, amount: List[int]) -> int:
        amount.sort()
        a = amount[-1]
        b = amount[0] + amount[1]
        if b>a: 
            if (b-a)%2==0:
                return a + (b-a)//2
            else:
                return a + 1 + (b-a)//2
        return a",
"class Solution:
    def canChange(self, start: str, target: str) -> bool:
        d = {}
        e = {}
        for i in range(len(start)):
            if start[i] not in d:
                d[start[i]] = [i]
                e[start[i]] = i
            else:
                d[start[i]].append(i)
        if ""L"" not in e:
            e[""L""] = -1
            d[""L""] = []
        if ""R"" not in e:
            e[""R""] = -1
            d[""R""] = []
        a = target.count(""L"")
        b = target.count(""R"")
        if a!=len(d[""L""]) or b!=len(d[""R""]):
            return False
        for i in range(len(target)):
            if target[i]==""L"":
                if e[""L""]>=i and ((e[""R""]!=-1 and e[""R""]>e[""L""]) or e[""R""]==-1):
                    if d[""L""]:
                        d[""L""].pop(0)
                        if d[""L""]:
                            e[""L""] = d[""L""][0]
                        else:
                            e[""L""] = -1 
                    else:
                        return False
                else:
                    return False 
            elif target[i]==""R"":
                if e[""R""]<=i and ((e[""L""]!=-1 and (e[""L""]>i)) or e[""L""]==-1):
                    if d[""R""]:
                        d[""R""].pop(0)
                        if d[""R""]:
                            e[""R""] = d[""R""][0]
                        else:
                            e[""R""] = -1 
                    else:
                        False
                else:
                    return False
        return True",
"class Solution:
    def __init__(self):
        self.MOD = 1000000007
        self.memo = {0: 1}
        self.fact = [1 for i in range(10100)]
        
    def inv(self, x):
        if x>1: return self.inv(self.MOD%x)*(self.MOD-self.MOD//x)%self.MOD 
        else: return x
        
    def choose(self, n, k):
        return ((self.fact[n] * self.inv(self.fact[n-k]) ) % self.MOD )* self.inv(self.fact[k]) %self.MOD
    
    def factors(self, x):
        a = []
        i = 2
        while x > 1:
            re = 0
            while x % i == 0:
                re += 1
                x //= i
            if re: a.append(re)
            i += 1
        return a   
    
    def h(self, v):
        if v in self.memo: return self.memo[v]
        self.memo[v] = self.choose(v+self.c, self.c)
        return self.memo[v]
        
    def idealArrays(self, n: int, maxValue: int) -> int:
        s = 0
        self.c = n-1
        
        for i in range(2,10100):
            self.fact[i] = self.fact[i-1] * i % self.MOD

        for i in range(1, maxValue+1):
            cur = 1
            fa = self.factors(i)
            for f in fa: cur = (cur*self.h(f))%self.MOD
            s = (s+cur)%self.MOD
        return s",
"class Solution:
    def numberOfPairs(self, nums: List[int]) -> List[int]:
        answer = [0, 0]
        mydict = defaultdict(int)
        for num in nums:
            mydict[num] += 1
        for key in mydict:
            answer[0] += mydict[key] // 2
            answer[1] += mydict[key] % 2
        return answer",
"class Solution:
    def maximumSum(self, nums: List[int]) -> int:
        hmap = collections.defaultdict(list)
        
        for n in nums:
            total = sum([int(i) for i in str(n)])
            
            hmap[total] = hmap[total] +[n]
            hmap[total] = sorted(hmap[total], reverse=True)[:2]
        
        result = -1
        for k, v in hmap.items():
            if len(v) == 2:
                result = max(result, sum(v))
        return result",
"class Solution:
    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:
        A = list(enumerate(nums)) # (1)
        res = []
        for k, t in queries:
            A.sort(key=lambda x: (int(x[1][len(x[1]) - t:]), x[0])) # (2)
            res.append(A[k - 1][0]) # (3)
        return res",
"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        GCD = reduce(lambda x,y: gcd(x,y), numsDivide)
        nums.sort()
        
        for idx, num in enumerate(nums):
            if(GCD % num == 0):
                return idx 
        return -1",
"class Solution:
    def bestHand(self, ranks: List[int], suits: List[str]) -> str:
        r = collections.Counter(ranks)
        s = collections.Counter(suits)
        for i in s:
            if s[i] >= 5:
                return ""Flush""
        for i in r:
            if r[i] >= 3:
                return ""Three of a Kind""
        for i in r:
            if r[i] >= 2:
                return ""Pair""
        return ""High Card""",
"class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:
        temp = [0] * (len(nums) + 1)
        for index, num in enumerate(nums, start=1):
            if num == 0:
                temp[index] = 1 + temp[index - 1]

        return sum(temp)",
"class Solution:
    def shortestSequence(self, rolls: List[int], k: int) -> int:
        res = 0
        s = set()
        for i in range(len(rolls)):
            num = rolls[i]
            if num not in s:
                s.add(num)
                if len(s) == k:
                    res+=1
                    s = set()
        return res+1",
"class Solution:
    def repeatedCharacter(self, s: str) -> str:
        l = []
        for i in s:
            if i in l:
                return i
            else:
                l.append(i)",
"class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        root = {}
        n = len(grid)
        for i in range(n):
            tmp = root
            for j in range(n):
                if grid[i][j] not in tmp:
                    tmp[grid[i][j]] = {}
                tmp = tmp[grid[i][j]]
            if '#' in tmp:
                tmp['#'] += 1
            else:
                tmp['#'] = 1
        
        numPair = 0
        for j in range(n):
            tmp = root
            for i in range(n):
                if grid[i][j] not in tmp:
                    break
                tmp = tmp[grid[i][j]]
            if '#' in tmp:
                numPair += tmp['#']
        
        return numPair",
"class Solution:
    def countExcellentPairs(self, nums: List[int], k: int) -> int:
        freq = Counter(map(int.bit_count, set(nums)))
        return sum(v1*v2 for k1, v1 in freq.items() for k2, v2 in freq.items() if k1+k2 >= k)",
"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        nums.sort()
        count = 0 
        while nums.count(0) != len(nums) : 
            count += 1 
            nums.sort()
            flag, min_num = True, 0
            for i in range(len(nums)) : 
                if (nums[i] != 0) and flag :
                    min_num = nums[i]
                    flag = False 
                nums[i] -= min_num
        return count",
"class Solution:
    def maximumGroups(self, grades: List[int]) -> int:
        if len(grades) <= 2 : 
            return 1 
        else : 
            grades.sort()
            dict_group ={}
            group_len = 1 
            i = 0
            end = 0
            while end < len(grades) :
                start, end = i, i + group_len
                # if end >= len(grades) : 
                #     break 
                if group_len != 1 :
                    if (sum(grades[start: end]) > sum(dict_group[group_len - 1])) and (len(grades[start: end]) == (end - start)) :
                        # print(start, end)
                        dict_group[group_len] = grades[start: end] 
                    else : 
                        return len(dict_group)
                else : 
                    dict_group[group_len] = grades[start: end] 
                    
                group_len += 1 
                i = end 
                # print(dict_group)
            return len(dict_group)",
"class Solution:
    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:
        ## RC ##
        ## APPROACH: GRAPH ##
        ## LOGIC ##
        ## 1. Typical Graph problem, just do what the question asks
        ## 2. Watch out for race conditions, a) when no common node b) multiple paths for the same node
        graph = collections.defaultdict(list)
        for u, v in enumerate(edges):
            if v != -1:
                graph[u].append(v)
        
        res = float('inf')
        ans = -1
        visited1 = {}
        def dfs1(node, d):
            nonlocal res
            nonlocal ans
            if node == node2:
                res=min(res, d)
                ans=node
            if node in visited1:
                if visited1[node] > d:
                    visited1[node] = d
                return
            visited1[node] = d
            if node in graph:    
                dfs1(graph[node][0], d +1)
        
        dfs1(node1, 0)
        
        visited2 = {}
        def dfs2(node, d):
            nonlocal res
            nonlocal ans
            if node == node1:
                if res > d:         # if already found in first node, then check for max distance
                    res = d
                    ans=node
            if node in visited2:
                if visited2[node] > d:
                    visited2[node] = d
                return
            visited2[node] = d
            if node in graph:    
                dfs2(graph[node][0], d +1)
        
        dfs2(node2, 0)
        for node in sorted(visited1.keys()):
            if node in visited2:
                if max(visited1[node], visited2[node]) < res:
                    res = max(visited1[node], visited2[node])
                    ans = node
        return ans",
"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        
        ans = -1
        
        def checkLoop(start):
            temp = {}
            count = 0
            while start != -1:
                if start in temp:
                    return count - temp[start]
                elif start in visited:
                    return -1
                
                visited.add(start)
                temp[start] = count
                count += 1
                start = edges[start]
            return -1
                
        visited = set()
        
        for value in edges:
            if value in visited:
                continue
            else:
                ans = max(ans, checkLoop(value))
        
        return ans",
"class Solution:
    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:
        weight = {} # or defaultdict(int)
        values, weights = zip(*items1, *items2)
        for val, wt in zip(values, weights):
            weight[val] = weight.get(val, 0) + wt
        return sorted(weight.items())",
"class Solution:
    def countBadPairs(self, nums: List[int]) -> int:
        k = len(nums)
        res = k * (k - 1) // 2 # (1)
        c = Counter([i - n for i, n in enumerate(nums)]) # (2) and (3)
        for n in c.values():
            res -= n * (n - 1) // 2 # (4)
        return res",
"class Solution:
    def taskSchedulerII(self, tasks: List[int], space: int) -> int:
        ld={}
        d=0
        for t in tasks:
            ld[t]=0
        for t in tasks:
            if ld[t]==0:
                d+=1
                ld[t]=d
            else:
                nd=ld[t]+space
                ld[t]=max(nd+1,d+1)
                d=ld[t]
        return d",
"class Solution:
    def minimumReplacement(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        
        def helper(n, to_deal):                 # return (times needed to divide, biggest left-most num)
            if n <= to_deal:
                return (0, n)
            if n % to_deal == 0:                # For example: [9, 3]
                return (n//to_deal - 1, to_deal)
            else:
                times = n // to_deal            # For example: [10, 4], it should at least deivide (n1 // to_deal) times
                x = n // (times+1)              # Since we know 10 must divided into 3 num, the biggest left-most num will be 10//3 = 3
                return (times, x)
                
        to_deal = nums[-1]                      
        res = 0
        i = len(nums) - 2                       # Iterate from the second-last element. 
        
        while i >= 0:
            times, left_most_num = helper(nums[i], to_deal)
            res += times
            to_deal = left_most_num             # Update to_deal to the left_most_num .
            i -= 1
        
        return res",
"class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        ans = 0 
        seen = set()
        for x in nums: 
            if x-diff in seen and x-2*diff in seen: ans += 1
            seen.add(x)
        return ans",
"class Solution:
    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:
        g = defaultdict(list)
        restrict = set(restricted)
        
        for u, v in edges:
            g[u].append(v)
            g[v].append(u)
            
        seen = set()
        stack = [0]
        res = 0

        while stack:
            node = stack.pop()

            if node not in seen:
                res += 1
                seen.add(node)

            for adj in g[node]:
                if adj not in seen and adj not in restrict:
                    stack.append(adj)
                    
        return res",
"class Solution:
    def validPartition(self, nums: List[int]) -> bool:
        dp = [False]*(len(nums)+1)
        dp[-1] = True 
        for i in range(len(nums)-1, -1, -1): 
            if i+1 < len(nums) and dp[i+2] and nums[i] == nums[i+1] \
            or i+2 < len(nums) and dp[i+3] and (nums[i] == nums[i+1] == nums[i+2] or nums[i]+2 == nums[i+1]+1 == nums[i+2]): dp[i] = True
        return dp[0]",
"class Solution:
    def longestIdealString(self, s: str, k: int) -> int:
        
        s = [ord(c) - ord('a') for c in s]
        
        m = 0
        
        hm = {}
        
        for i,v in enumerate(s) :
            
            m = 1
            for h in hm:
                if abs(v - h) <= k:
                    m = max(m, hm[h] +1)
            
            hm[v] = m
        
        return max(hm.values())",
"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        edge_cnts = defaultdict(int)
        max_idx, max_val = 0, 0
        
        for inp, out in enumerate(edges):
            edge_cnts[out] += inp
            
        for idx in range(len(edges)):
            if edge_cnts[idx] > max_val:
                max_idx, max_val = idx, edge_cnts[idx]
                
        return max_idx",
"class Solution:
    def smallestNumber(self, pattern: str) -> str:
        
        
        l = len(pattern)
        
        sol = """"
        
        visited = set([1,2,3,4,5,6,7,8,9])
        
        def backtrack(cur, i ):
            nonlocal l
            nonlocal sol
            
            if len(cur) == l+1:
                sol = cur
                return True

            for j in visited:
                k = int(cur[-1]) 
                if pattern[i] == 'I' and j <= k:
                    continue
                if pattern[i] == 'D' and j >= k:
                    continue
                
                visited.remove(j)
                if backtrack(cur + str(j), i+1):
                    return True
                visited.add(j)
            
            return False

        for j in visited:
            visited.remove(j)
            if backtrack(str(j), 0):
                return sol
            visited.add(j)",
"class Solution:
    def countSpecialNumbers(self, n: int) -> int:
        vals = list(map(int, str(n)))
        
        @cache
        def fn(i, m, on): 
            """"""Return count at index i with mask m and profile flag (True/False)""""""
            ans = 0 
            if i == len(vals): return 1
            for v in range(vals[i] if on else 10 ): 
                if m &amp; 1<<v == 0: 
                    if m or v: ans += fn(i+1, m ^ 1<<v, False)
                    else: ans += fn(i+1, m, False)
            if on and m &amp; 1<<vals[i] == 0: ans += fn(i+1, m ^ 1<<vals[i], True)
            return ans 
        
        return fn(0, 0, True)-1",
"class Solution:
    def minimumRecolors(self, blocks: str, k: int) -> int:
        start_index = 0
        length = len(blocks)
        res = float(""inf"")
        count = 0
        for i in range(start_index, k):
            if blocks[i] == ""W"":
                count += 1
        res = min(res, count)
        
        for i in range(k, length):
            if blocks[start_index] == ""W"":
                count -= 1
            if blocks[i] == ""W"":
                count += 1
            
            res = min(res, count)
            start_index += 1
        return res",
"class Solution:
    def secondsToRemoveOccurrences(self, s: str) -> int:
        
        seconds = 0
        my_list = [*s]
        my_string = s
        
        while '01' in my_string:
            i = 0
            while i < len(my_list) - 1:
                if my_list[i] == '0' and my_list[i + 1] == '1':
                    my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]
                    i += 2
                else:
                    i += 1

            my_string = ''.join(my_list)
            seconds += 1
            
        return seconds",
"class Solution:
    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:
        ops = [0]*(len(s)+1)
        
        for start, end, direction in shifts:
            ops[start] +=  1 if direction == 1 else -1
            ops[end+1] += -1 if direction == 1 else  1
        
        runningDelta = 0
        w = []
        
        for ind, letter in enumerate(s):
            runningDelta += ops[ind]
            newLetter = chr( (ord(letter) - ord('a') + runningDelta) % 26 + ord('a'))
            w.append(newLetter)
            
        return """".join(w)",
"class Solution:
    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        running, sum_before = 0, []
        for num in nums:
            running += num
            sum_before.append(running)
        sum_before.append(0) # [-1]
            
        def get_sum(start, end):
            return sum_before[end] - sum_before[start - 1]
        
        removed, res = [-1, len(nums)], []
        max_seg_sums = [float('-inf'), sum(nums)]
        
        for i in removeQueries:
            ins = bisect_left(removed, i)
            before, after = removed[ins - 1], removed[ins]
            
            to_del = bisect_left(max_seg_sums, get_sum(before + 1, after - 1))
            del max_seg_sums[to_del]
            
            new_l, new_r = get_sum(before + 1, i - 1), get_sum(i + 1, after - 1)
            res.append(max(max_seg_sums[-1], new_l, new_r))
            
            bisect.insort(removed, i)
            bisect.insort(max_seg_sums, new_l)
            bisect.insort(max_seg_sums, new_r)
        
        return res",
"class Solution:
    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:
        #Approach: Do a single traversal and for every ith opponent, compare your current energy and exp to opponent
        #and adjust so you always win! How much you have to adjust will be number of hours of training you have to invest
        #before you compete!
        
        #At the end, return answer!
        ans = 0
        
        cenergy = initialEnergy
        cexp = initialExperience
        #n = number of opponents to face!
        n = len(energy)
        for i in range(n):
            if(cenergy <= energy[i]):
                ans += (energy[i] - cenergy + 1)
                cenergy = 1
                #if current player has lower exp, then he needs to make it up for it!
                #difference + 1 wil take his current exp to next exp value from opp so he can win!
                #but also, in doing so, he needs to already be 1 ahead! -> set cexp to opponent's exp + 1!
                #Regardless, since he won, he needs to get ith opponents exp added!
                if(cexp <= experience[i]):
                    ans += (experience[i] - cexp + 1)
                    cexp = experience[i] + 1
                #regardless, current experience only goes up!
                cexp += (experience[i])
                continue
                
                
            else:
                cenergy -= energy[i]
                if(cexp <= experience[i]):
                    ans += (experience[i] - cexp + 1)
                    cexp = experience[i] + 1
                cexp += (experience[i])
                
        
        return ans",
"class Solution:
    def largestPalindromic(self, num: str) -> str:
        
        counter = Counter(num)
        
        l = [(-int(n), c) for n, c in counter.items()]
        heapq.heapify(l)
        
        left, right = [], []
        mid = None

        while l:
            n, c = heapq.heappop(l)
            n = -n 
            
            if c % 2 == 0:
                left = left + [n] * (c // 2)
                right = [n] * (c // 2) + right
            else:
                if c - 1 > 0:
                    heapq.heappush(l, (-n, c - 1))
                if mid is None:
                    mid = n
    
        if mid is None and l:
            mid = -l[0][0]
        
        while right and right[-1] == 0:
            right.pop()

        res = left[:len(right)] + [mid] + right if mid is not None else left[:len(right)] + right
        
        if not res:
            return ""0""

        return ''.join([str(i) for i in res])",
"class Solution:
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
		### building the map, see for each node who it touches ###
        queue = [(root, None)]
        mapping = {}
        while (queue):
            curr, parent = queue.pop()
            touches = []
            if (curr.left):
                touches.append(curr.left.val)
                queue.append((curr.left, curr))
            if (curr.right):
                touches.append(curr.right.val)
                queue.append((curr.right, curr))
            if (parent):
                touches.append(parent.val)
            mapping[curr.val] = touches
        
		
		### do a simulation kinda ###
        time = 0
        current_wave = [start]
        next_wave = []
        seen = set()
        seen.add(start)
        
        while (current_wave):
            node_id = current_wave.pop()
            for touch in mapping[node_id]:
                if touch not in seen:
                    next_wave.append(touch)
                    seen.add(touch)
            
            if (len(current_wave) == 0):
                if (len(next_wave) == 0):
                    return time
                else:
                    time += 1
                    current_wave = next_wave
                    next_wave = []
        
        return 0",
"class Solution:
    def kSum(self, nums: List[int], k: int) -> int:
        m = sum(x for x in nums if x > 0)
        pq = [(-m, 0)] 
        vals = sorted(abs(x) for x in nums)
        for _ in range(k): 
            x, i = heappop(pq)
            if i < len(vals): 
                heappush(pq, (x+vals[i], i+1))
                if i: heappush(pq, (x-vals[i-1]+vals[i], i+1))
        return -x",
"class Solution:
    def answerQueries(self, nums: List[int], q: List[int]) -> List[int]:
        nums.sort()
        pref=[]
        pref.append(nums[0])
        for i in nums[1:]:
            pref.append(i+pref[-1])
        
        ans=[]
        for i in q:
            ans.append(bisect.bisect(pref, i))
        
        return ans",
"class Solution:
#Time-Complexity: O(N^2)
#Space-Complexity:O(1)
#Space-Complexity:O(
    def removeStars(self, s: str) -> str:
        #Brute-Force approach: As long as star character appears in string input s, continously simulate!
        #while ""*"" in s:
            #iterate from left to right char by char until you hit star! then update s to subsequence!
            #for i in range(len(s)):
             #   cur_char = s[i]
             #   if(cur_char == '*'):
                    #reupdate s!
              #      s = s[:i-1] + s[i+1:]
               #     break
        
        #return s
        
        #optimized version: Simply traverse linearly using single pointer in linear time
        #by taking advantage of fact that the star char you see when you traverse from L to R is s.t. the last char
        #in built up string will be one char to be removed along with star char per operation!
        
        ans = """"
        
        for i in range(len(s)):
            cur_char = s[i]
            if(cur_char == '*'):
                #pop off last char!
                ans = ans[:len(ans)-1]
                continue
            else:
                ans += cur_char
        
        return ans",
"class Solution:
    #If I let n = travel.length and m = garbage.length...
    #Time-Complexity: O(travel.length + garbage.length*10 + 3*garbage.length) -> O(n + m)
    #Space-Complexity: O(3m + (n+1)) ->O(m + n)
    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:
        
        #Approach: First, traverse through garbage array and identify the count as well as the index position of houses
        #each type of garbage is at!
        
        #Utilize 3 hashmaps: one for metal , one for glass , and one for paper!
        #key: index pos -> count: number of garbage at index pos house of that particular type!
        
        metal = {}
        paper = {}
        glass = {}
        
        #need to allocate another array that describes time cost to reach ith index house!
        travel_cost = []
        travel_cost.append(0)
        cur_cost = 0
        
        for e in travel:
            cur_cost += e
            travel_cost.append(cur_cost)
            
        for i in range(len(garbage)):
            for c in garbage[i]:
                if(c == 'M'):
                    if(i not in metal):
                        metal[i] = 1
                    else:
                        metal[i] += 1
                elif(c == 'P'):
                    if(i not in paper):
                        paper[i] = 1
                    else:
                        paper[i] += 1
                else:
                    if(i not in glass):
                        glass[i] = 1
                    else:
                        glass[i] += 1
        
        #once hashmaps are updated, handle 3 types of garbage collection!
        
        #1. Metal
        metal_cost = 0
        pre = 0
        metal_keys = sorted(metal.keys())
        for mk in metal_keys:
            metal_cost += metal[mk]
            metal_cost += (travel_cost[mk] - travel_cost[pre])
            pre = mk
        
        #2. Paper
        paper_cost = 0
        pre2 = 0
        paper_keys = sorted(paper.keys())
        for pk in paper_keys:
            paper_cost += paper[pk]
            paper_cost += (travel_cost[pk] - travel_cost[pre2])
            pre2 = pk
        
        #3. glass
        glass_cost = 0
        pre3 = 0
        glass_keys = sorted(glass.keys())
        for gk in glass_keys:
            glass_cost += glass[gk]
            glass_cost += (travel_cost[gk] - travel_cost[pre3])
            pre3 = gk
        
        return metal_cost + paper_cost + glass_cost",
"class Solution:
    def buildMatrix(self, k: int, rowCond: List[List[int]], colCond: List[List[int]]) -> List[List[int]]:
        # topological sort:
        # For rows, in other words ""above"" should be put on the rows with index smaller than ""after""
        # so if we could form an k-length result array with the order restricted by rowCondition
        # then we know we should put the numbers to the rows accordingly 
        
        # For example, as for example 1,
        # if we get [3, 1, 2] as one of the topological sorted result array,
        # we know that 3 should be put in the first row (idx = 0), 1 in the second row (idx = 1), 2 in the third row(idx = 2)
        # so we get the row index for each number in [1, k]
        # We could get the col index similarily 
        
        def topo(cond):
            G = defaultdict(list)
            indegree = [0] * (k + 1)
            # build graph, above_edge -> below_edge, or left -> right
            for a, b in cond:
                G[a].append(b)
                indegree[b] += 1
                
            queue = deque([i for i in range(1, k + 1) if indegree[i] == 0])
            res = []
            while queue:
                cur = queue.popleft()
                res.append(cur)
                for nxt in G[cur]:
                    indegree[nxt] -= 1
                    if indegree[nxt] == 0:
                        queue.append(nxt)
            return res 
                
        rows, cols = topo(rowCond), topo(colCond)
        
        # can not form a solution with exact k value sorted in topological order
        if len(rows) != k or len(cols) != k:
            return []
        
        # build num -> idx mp for easier queries 
        mp1, mp2 = {}, {}
        for i, r in enumerate(rows):
            mp1[r] = i
        
        for i, c in enumerate(cols):
            mp2[c] = i
        
        res = [[0] * k for _ in range(k)]
        for num in range(1, k + 1):
            ri, ci = mp1[num], mp2[num]
            res[ri][ci] = num
        return res",
"class Solution:
    def findSubarrays(self, nums: List[int]) -> bool:
        subSum = 0
        p1 = 0
        count = defaultdict(int)
        
        for p2, num in enumerate(nums):
            subSum += num
            ln = p2 - p1 + 1
            if(ln < 2):
                continue
            elif(ln > 2):
                subSum -= nums[p1] 
                p1 += 1
            count[subSum] += 1
            if(count[subSum] == 2):
                return True
            
        return False",
"class Solution:
    def isStrictlyPalindromic(self, n: int) -> bool:
        return False",
"class Solution:
    def maximumRows(self, mat: List[List[int]], cols: int) -> int:
        m, n = len(mat), len(mat[0])
        masks = []
        for i in range(m): 
            mask = reduce(xor, (1<<j for j in range(n) if mat[i][j]), 0)
            masks.append(mask)
        ans = 0 
        for x in range(1<<n): 
            if x.bit_count() <= cols: 
                ans = max(ans, sum(mask &amp; x == mask for mask in masks))
        return ans",
"class Solution:
    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:
        ii = rsm = 0
        qq = deque()
        for i, (ct, rc) in enumerate(zip(chargeTimes, runningCosts)): 
            rsm += rc 
            while qq and qq[-1][0] <= ct: qq.pop()
            qq.append((ct, i))
            if chargeTimes[qq[0][1]] + (i - ii + 1) * rsm > budget: 
                if qq[0][1] == ii: qq.popleft()
                rsm -= runningCosts[ii]
                ii += 1
        return len(chargeTimes)-ii",
"class Solution:
    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:
        if abs(startPos - endPos) > k:
            return 0
        
        @cache
        def dp(currentPosition: int = startPos, stepsAvailable: int = k) -> int:
            if stepsAvailable == 0:
                return 1 if currentPosition == endPos else 0
                
            numWays = dp(currentPosition + 1, stepsAvailable - 1) + dp(currentPosition - 1, stepsAvailable - 1)
            return numWays % (10 ** 9 + 7)
        
        return dp()",
"class Solution:
    def longestNiceSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        last = -1
        ror = 0
        for first in range(n):
            if first > last:
                last = first
                ror = nums[first]
            else:
                ror = nums[first]
                for i in range(first + 1, last + 1):
                    ror = ror | nums[i]
            while last+1<=n-1 and (ror &amp; nums[last+1] == 0):
                ror = ror | nums[last+1]
                last = last + 1
            ans = max(ans, last - first + 1)
            # print((first, last), ror, ans)
        return ans",
"class Solution:
    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
        number_of_meetings_in_room = [0] * n
        room_is_available          = [0] * n
        meetings.sort()
        heap = []
        for meeting_start, meeting_end in meetings:
            meeting_length = meeting_end - meeting_start
            while heap and heap[0][0] <= meeting_start:
                end_time, room_number = heapq.heappop(heap)
                # MAKE SURE TO MAKE ROOM AVAILABLE AFTER!!
                room_is_available[room_number] = 0
            if len(heap) < n:
                for room_number, available in enumerate(room_is_available):
                    if available == 0:
                        number_of_meetings_in_room[room_number] += 1
                        room_is_available[room_number] = meeting_start + meeting_length
                        heapq.heappush(heap, (meeting_start + meeting_length, room_number))
                        break
            else:
                end_time, room_number = heapq.heappop(heap)
                heapq.heappush(heap, (end_time + meeting_length, room_number))
                number_of_meetings_in_room[room_number] += 1
        return -max((meetings, -index) for index, meetings in enumerate(number_of_meetings_in_room))[1]",
"class Solution:
    def mostFrequentEven(self, nums: List[int]) -> int:
        freq = -1
        ans = -1
        for i in sorted(set(nums)):
            if i%2 == 0 and nums.count(i) > freq:
                freq = nums.count(i)
                ans = i
        return ans",
"class Solution:
    def partitionString(self, s: str) -> int:
        count=1
        word=""""
        for i in s:
            if i in word:
                count+=1
                word=i
            else:
                word+=i
        return count",
"class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        line = []
        for x, y in intervals: 
            line.append((x, 1))
            line.append((y+1, 0))
        ans = prefix = 0 
        for x, k in sorted(line): 
            if k: prefix += 1
            else: prefix -= 1
            ans = max(ans, prefix)
        return ans",
"class Solution:
    def lengthOfLIS(self, nums: List[int], k: int) -> int:
        """"""
        """"""
        ##############
        # Range Minimum Query using Segment Tree
        ##############
        def init(tree, value, k, left, right):
            if len(tree)<k+1:
                tree.extend([None] * (k+1-len(tree)))

            if right - left == 1:
                tree[k] = value
                return

            mid = (left + right)//2
            init(tree, value, 2*k, left, mid)
            init(tree, value, 2*k+1, mid, right)
            tree[k] = max(tree[2*k], tree[2*k+1])

        def update(tree, value, pos, k, left, right):
            if right - left == 1: # only 1 elements
                tree[k] = value
                return

            mid = (left + right)//2
            if pos<mid:
                update(tree, value, pos, 2*k, left, mid)
            else:
                update(tree, value, pos, 2*k+1, mid, right)
            tree[k] = max(tree[2*k], tree[2*k+1])

        def query(tree, l, r, k, left, right):
            if l>=r:
                return None
            elif l<=left and right<=r:
                return tree[k]

            mid = (left + right)//2
            v1 = query(tree, l, min(mid, r), 2*k, left, mid)
            v2 = query(tree, max(l, mid), r, 2*k+1, mid, right)
            v = [v for v in [v1, v2] if v is not None]
            ret = None if len(v) == 0 else max(v)
            return ret
        ##############
        
        n = len(nums)
        # print(nums, k)
        # print(len(nums), max(nums), k)

        segt = []
        sizet = max(nums) + 1
        # init(segt, float(""-inf""), 1, 0, sizet)
        segt = [float(""-inf"")] * (4 * sizet)
        
        dp = [1] * n
        update(segt, dp[0], nums[0], 1, 0, sizet)
        
        for i in range(1, n):
            dpj = query(segt, nums[i]-k, nums[i], 1, 0, sizet)
            if dpj is None:
                dp[i] = 1
            else:
                dp[i] = max(dpj + 1, 1)
            update(segt, dp[i], nums[i], 1, 0, sizet)
            pass
        
        ans = max(dp)
        # print(""ans:"", ans)
        # print(""="" * 20)
        return ans
    
# print = lambda *a, **aa: ()",
"class Solution:
    def countDaysTogether(self, aa: str, la: str, ab: str, lb: str) -> int:

        aa = aa.split('-')
        la = la.split('-')
        ab = ab.split('-')
        lb = lb.split('-')
        
        start1 = date(2013,int(aa[0]),int(aa[1]))
        end1 = date(2013,int(la[0]),int(la[1]))
        start2 = date(2013,int(ab[0]),int(ab[1]))
        end2 = date(2013,int(lb[0]),int(lb[1]))
        
        overlaps = start1 <= end2 and end1 >= start2
        if not overlaps:
            return 0
        return abs(max(start1, start2)-min(end1, end2)).days +1",
"class Solution:
    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:
        players.sort(reverse=True)
        trainers.sort(reverse=True)
        tot = 0
        while trainers and players:
            if trainers[-1] >= players[-1]:
                tot += 1
                players.pop()
            trainers.pop()
        
        return tot",
"class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        n=len(nums)
        lastVal=[0 for i in range(32)]
        ans=[0 for i in range(n)]
        for i in range(n-1,-1,-1):
            maxVal=0
            for j in range(32):
                if nums[i]&amp;(1<<j):
                    lastVal[31-j]=0
                else:
                    lastVal[31-j]=lastVal[31-j]+1 if i<n-1 else -float('inf')
                maxVal=max(maxVal,lastVal[31-j])
            ans[i]=max(ans[i],maxVal)+1
        return ans",
"class Solution:
    def minimumMoney(self, transactions: List[List[int]]) -> int:
        ans = val = 0 
        for cost, cashback in transactions: 
            ans += max(0, cost - cashback)
            val = max(val, min(cost, cashback))
        return ans + val",
"class Solution:
    def smallestEvenMultiple(self, n: int) -> int:
        return n if n % 2 == 0 else 2 * n",
"class Solution:
    def longestContinuousSubstring(self, s: str) -> int:
        cnt = 1
        res = 0
        
        for i in range(1, len(s)):
            if ord(s[i]) - ord(s[i-1]) == 1:
                cnt += 1
                res = max(res, cnt)
            else:
                cnt = 1
                    
        return max(res, cnt)",
"class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        
        def reverseLevel(nodes: List[Optional[TreeNode]]) -> None:
            for i in range(len(nodes) // 2):
                nodes[i].val, nodes[~i].val = nodes[~i].val, nodes[i].val
        
        levels = defaultdict(list)
        nodeQueue = [(root, 0)]
        while nodeQueue:
            node, level = nodeQueue.pop()
            if level % 2 == 1:
                levels[level].append(node)
            for child in [node.left, node.right]:
                if child is not None:
                    nodeQueue.append((child, level + 1))
        
        for level in levels.values():
            reverseLevel(level)
            
        return root",
"class Solution:
    def sumPrefixScores(self, words: List[str]) -> List[int]:
        cnter = defaultdict(int)
        res = []
        
        #Adding all prefixes to counter
        for word in words:
            for idx in range(1, len(word) + 1):
                cnter[word[:idx]] += 1
        
        #Adding up occurrences
        for word in words:
            cnt = 0
            for idx in range(1, len(word) + 1):
                cnt += cnter[word[:idx]]
                    
            res.append(cnt)
                    
        return res",
"class Solution:
    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:
        return [n for _, n in sorted((-h, n) for h, n in zip(heights, names))]",
"class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        mx=max(nums)
        ans=0
        v=0
        for i in range(len(nums)):
            if nums[i]==mx:
                v+=1
                ans=max(ans,v)
            else:
                v=0
        return ans",
"class Solution:
    def goodIndices(self, nums: List[int], k: int) -> List[int]:
        n=len(nums)
        left=[False for i in range(n)]
        right=[False for i in range(n)]
        ls,rs=-1,n
        for i in range(1,n):
            if i>=k:
                if i-ls>k:
                    left[i]=True
            if nums[i]>nums[i-1]:
                ls=i-1
        for j in range(n-2,-1,-1):
            if j<n-k:
                if rs-j>k:
                    right[j]=True
            if nums[j]>nums[j+1]:
                rs=j+1
        ans=[]
        for i in range(n):
            if left[i] and right[i]:
                ans.append(i)
        return ans",
"class Solution:    
    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:
        n = len(vals)
        
        nodes = {}
        for i in range(n):
            nodes[vals[i]] = nodes.get(vals[i], set([]))
            nodes[vals[i]].add(i)
        # print(nodes)
        
        adj = [set([]) for _ in range(n)]
        for ai, bi in edges:
            adj[ai].add(bi)
            adj[bi].add(ai)
        # print(adj)
        
        def bfs(s, chk): 
            ret = [s]
            q = [s]
            chk[s] = True
            while len(q)>0:
                u = q.pop(0)
                for v in adj[u]:
                    if chk[v]==False and vals[s]>=vals[v]:
                        q.append(v)
                        chk[v] = True
                        if vals[v]==vals[s]:
                            ret.append(v)
            return ret
        
        keys = sorted(nodes.keys(), key = lambda x: x)

        chk = [False] * n
        ans = len(vals)
        for k in keys:
            qq = nodes[k]

            print(""++ "", k, len(qq))
            sys.stdout.flush()
            
            while len(qq)>0:
                v = qq.pop()
                ret = bfs(v, chk)
                nr = len(ret)
                ans = ans + (nr * (nr-1)) // 2
                for t in ret:
                    qq.discard(t)
            
        return ans

print = lambda *a, **aa: ()",
"class Solution:
    def equalFrequency(self, word: str) -> bool:
        
        c = Counter(word)
        
        m = c.values()
        
        for l in c:
            c[l] -= 1
            
            s = set(c.values())
            if 0 in s:
                s.remove(0)
            if  len(s) == 1:
                return True
            
            c[l] += 1
        
        return False",
"class Solution:
    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        m=len(nums2)
        ans=0
        if(m%2==0):
            if(n%2==0):
                return 0
            else:
                ans=nums2[0]
                for i in range(1,m):
                    ans^=nums2[i]
                return ans
        else:
            if(n%2==0):
                ans=nums1[0]
                for i in range(1,n):
                    ans^=nums1[i]
                return ans
            else:
                ans=nums1[0]
                for i in range(1,n):
                    ans^=nums1[i]
                for i in range(m):
                    ans^=nums2[i]
                return ans",
"class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        ans = 0
        n = len(nums1)
        nums = [nums1[i] - nums2[i] for i in range(n)]
        vis = []
        for i in range(n - 1, -1, -1):
            if not vis:
                vis.append(nums[i] + diff)
            else:
                pos = bisect.bisect_left(vis, nums[i])
                ans += len(vis) - pos
                bisect.insort(vis, nums[i] + diff)
        return ans",
"class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        GCD = gcd(a, b)
        
        commonFactors = 1
        for i in range(2, floor(GCD) + 1):
            if GCD % i == 0:
                commonFactors += 1
                
        return commonFactors",
"class Solution:
    def maxSum(self, grid: List[List[int]]) -> int:
        m = len(grid); n = len(grid[0])
        
        def hourglassSum(i: int, j: int) -> int:
            return sum(grid[i - 1][j - 1:j + 2]) + grid[i][j] + sum(grid[i + 1][j - 1:j + 2])
        
        maxSum = 0
        for i, j in product(range(1, m - 1), range(1, n - 1)):
            maxSum = max(maxSum, hourglassSum(i, j))
            
        return maxSum",
"class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:        
        bits2 = bin(num2)[2:].count(""1"")
        bin1 = bin(num1)[2:]

        if len(bin1) <= bits2:
            return (1 << bits2) - 1
        
        ans = 0
        for i in range(len(bin1)):
            if bin1[i] == ""1"":
                ans |= 1 << (len(bin1) - i - 1)
                bits2 -= 1
            if bits2 == 0:
                return ans
        
        for i in range(len(bin1)):
            if bin1[~i] == ""0"":
                ans |= 1 << i
                bits2 -= 1
            if bits2 == 0:
                return ans",
"class Solution:
    def deleteString(self, s: str) -> int:
        n = len(s)

        if len(set(s)) == 1:
            return n
        
        @cache
        def dp(i: int = 0) -> int:
            if i == n - 1:
                return 1
            maxOperations = 0
            for l in range(1, (n - i) // 2 + 1):
                if s[i : i + l] == s[i + l:i + 2 * l]:
                    maxOperations = max(maxOperations, dp(i + l))
            return maxOperations + 1
        
        return dp()",
"class Solution:
    def findArray(self, pref: List[int]) -> List[int]:
        ans = [pref[0]]
        mx = pref[0]
        for i in range(1,len(pref)):
            a = pref[i]^mx 
            ans.append(a)
            mx = mx^a
        return ans",
"class Solution:
    def robotWithString(self, s: str) -> str:
        t= []
        res = []
		#counter would tell if there is any smaller character on the right
        counter = [0]*26
        for char in s:
            counter[ord(char)-97] += 1
        for idx, char in enumerate(s):
            t.append(char)
            counter[ord(char)-97] -= 1

            while len(t) != 0:
                    value = ord(t[-1])-97
                    ifc = False
                    for i in range(value):
                        if counter[i] > 0:
                            ifc = True
                            break
                    if ifc:
                        break
                    res.append(t[-1])
                    t.pop()

        return """".join(res)",
"class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        import copy
        hm = defaultdict(list)
        
        m, n = len(grid), len(grid[0])
        
        def dfs(r, c):
            if r >= len(grid) or c >= len(grid[0]):
                return []
            if r == m - 1 and c == n - 1:
                hm[(r, c)] = {grid[r][c] : 1}
                return
            if (r, c) not in hm:
                dfs(r + 1, c)
                dfs(r, c + 1)
                it = defaultdict(int)
                if (r + 1, c) in hm:
                    for i in hm[(r + 1, c)]:
                        it[(grid[r][c] + i) % k] += hm[(r + 1, c)][i]
                if (r, c + 1) in hm:
                    for i in hm[(r, c + 1)]:
                        it[(grid[r][c] + i) % k] += hm[(r, c + 1)][i]
                hm[(r, c)] = it
            return
        dfs(0, 0)
        res = 0
        for i in hm[(0, 0)]:
            if i % k == 0:
                res += hm[(0, 0)][i]
                res %= (10 ** 9 + 7)
        return res",
"class Solution:
    def countTime(self, time: str) -> int:
        if '?' not in time: return 1
        hh,mm=time.split(':')
        tH,th=hh
        tM,tm=mm
        answ=0
        d='0123456789'
        for H in d:
            for h in d:
                for M in d:
                    for m in d:
                        Hh=int(H+h)
                        Mm=int(M+m)
                        if Hh<24 and Mm<60:
                            if H!=tH!='?' or h!=th!='?' or M!=tM!='?' or m!=tm!='?': continue
                            answ+=1
                            
        return answ",
"class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        def min_arr(x):
            k = bin(x)[2:]
            k = k[::-1]
            ans = []
            for i in range(0, len(k)):
                if (k[i] == '1'):
                    ans.append(2**i)
            return ans
        nums = min_arr(n)
        prod = [1]
        for i in range(len(nums)):
            k = (prod[-1]*nums[i])
            prod.append(k)
        res = []
        for i in range(len(queries)):
            b = prod[queries[i][1]+1]
            a = prod[queries[i][0]]
            res.append((b//a))
            res[i] = res[i]%(10**9 + 7)
        return res",
"class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        n = len(nums)
        pr = [0]
        for i in range(n):
            pr.append(pr[-1] + nums[i])
            
        dp = [0] * n
        dp[0] = nums[0]
        
        for i in range(1, n):
            if nums[i] < dp[i - 1]:
                dp[i] = dp[i - 1]
            else:
                dp[i] = max(dp[i - 1], math.ceil(pr[i + 1] / (i + 1)))
        return dp[-1]",
"class Solution:
    def getFactors(self, x):
        factors = []
        for i in range(1, int(sqrt(x)) + 1):
            if x % i != 0: continue
            factors.append(i)
            if x // i != i: factors.append(x // i)
        return factors

    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        graph = defaultdict(list)
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)

        self.cntRemainZero = 0
        def dfs(u, p, sumPerComponent): # return remain of the subtree with root `u`
            remain = nums[u]
            for v in graph[u]:
                if v == p: continue
                remain += dfs(v, u, sumPerComponent)
                
            remain %= sumPerComponent
            if remain == 0:
                self.cntRemainZero += 1
                
            return remain
        
        def isGood(sumPerComponent, expectedNumOfComponents):
            self.cntRemainZero = 0
            dfs(0, -1, sumPerComponent)
            return self.cntRemainZero == expectedNumOfComponents
        
        sumAllNodes, maxNum = sum(nums), max(nums)
        for sumPerComponent in sorted(self.getFactors(sumAllNodes)):
            if sumPerComponent < maxNum: continue  # at least maxNum
            expectedNumOfComponents = sumAllNodes // sumPerComponent
            if isGood(sumPerComponent, expectedNumOfComponents):
                return expectedNumOfComponents - 1 # Need to cut `numOfComponent - 1` edges to make `numOfComponent` connected component
            
        return 0",
"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums.sort()
        i = len(nums) - 1
        
        while i >= 0:
            tmp = nums[i]
            if -tmp in nums:
                return tmp
            else:
                i -= 1

        return -1",
"class Solution:
    def countDistinctIntegers(self, nums: List[int]) -> int:
        tmp = []
        
        for num in nums:
            tmp.append(int(str(num)[::-1]))
        
        return len(set(nums+tmp))",
"class Solution:
    def sumOfNumberAndReverse(self, total: int) -> bool:
        for num in range(total // 2, total + 1):
            if num + int(str(num)[::-1]) == total:
                return True
            
        return False",
"class Solution:
    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        i =  0 # left index
        j = 0  # right index
        ans = 0
        
        minn = [] # store the indices of minK in a window which have no element less than minK and greater than maxK 
        maxx = [] # store the indices of maxK in a window which have no element less than minK and greater than maxK
        
        while j<len(nums):
            if nums[j]==minK:
                minn.append(j)
            if nums[j]==maxK:
                maxx.append(j)

            if nums[j]<minK or nums[j]>maxK: # conflict
                a,b = 0,0 # indices of minn and maxx array
                while a<len(minn) and b<len(maxx):
                    m = max(minn[a],maxx[b])  # max index which should keep in subbarray necessarily
                    ans+=j-m                  # add how many subarray can create such that they start from nums[i]
                    if nums[i]==minK:
                        a+=1
                    if nums[i]==maxK:
                        b+=1
                    i+=1 
                # there is a conflict on indix j so clear minn and maxx array    
                minn.clear()
                maxx.clear()
                
                i = j+1 # set left pointer to j+1 (searching for new window which can start from j+1)
                
            j+=1        
                
        # after reaching j on last indix check if there is a window which is already created       
        a,b = 0,0
        while a<len(minn) and b<len(maxx):
            m = max(minn[a],maxx[b])
            ans+=j-m

            if nums[i]==minK:
                a+=1
            if nums[i]==maxK:
                b+=1
             
            i+=1        
                        
        return ans",
"class Solution:
    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:
        if event1[1][0:2]==event2[0][0:2]:
            if event1[1][3:5]>=event2[0][3:5]:
                return True
            else:
                return False
        else:
            if event1[1][0:2]<event2[0][0:2] or event2[1][0:2]<event1[0][0:2]:
                return False
            elif event1[1][0:2]>event2[0][0:2]:
                return True",
"class Solution:
    def subarrayGCD(self, nums: List[int], k: int) -> int:
        def gcd(n1, n2):
            if n2==0:
                return n1
            return gcd(n2, n1%n2)
        
        ans = 0
        n = len(nums)
        for i in range(n):
            curr_gcd = 0
            for j in range(i, n):
                curr_gcd = gcd(curr_gcd, nums[j])
                if  curr_gcd == k:
                    ans += 1
        
        return ans",
"class Solution:
    def minCost(self, nums: List[int], cost: List[int]) -> int:
        nums, cost = zip(*sorted(zip(nums, cost)))
        total = sum(cost)
        prefix = 0 
        for i, x in enumerate(cost): 
            prefix += x
            if prefix > total//2: break 
        return sum(c*abs(x-nums[i]) for x, c in zip(nums, cost))",
"class Solution:
    def makeSimilar(self, nums: List[int], target: List[int]) -> int:
        ne = sorted(x for x in nums if not x&amp;1)
        no = sorted(x for x in nums if x&amp;1)
        te = sorted(x for x in target if not x&amp;1)
        to = sorted(x for x in target if x&amp;1)
        return (sum(abs(x-y) for x, y in zip(ne, te)) + sum(abs(x-y) for x, y in zip(no, to)))//4",
"class Solution:
    def oddString(self, words: List[str]) -> str:
        a=""abcdefghijklmnopqrstuvwxyz""
        l=[]
        for i in range(0,len(words)):
            w=words[i]
            ans=[]
            for j in range(1,len(w)):
                s=a.index(w[j])-a.index(w[j-1])
                ans.append(s)

            l.append(ans)
        for i in l:
            if l.count(i)==1:
                return words[l.index(i)]",
"class Solution:
    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:
        
        n = len(queries[0])
        ans = []
        
        for i in range(len(queries)):
            for j in range(len(dictionary)):
                count = 0
                for k in range(n):
                    if(dictionary[j][k] != queries[i][k]):
                        count += 1
                    if(count > 2):
                        break
                if(count <= 2):
                    ans.append(queries[i])
                    break
        return ans",
"class Solution:
    def destroyTargets(self, nums: List[int], space: int) -> int:
        hmap=defaultdict(list)
        for i in nums:
            if i%space in hmap:
                occ,val=hmap[i%space]
                hmap[i%space]=[occ+1,min(val,i)]
            else:
                hmap[i%space]=[1,i]
        value=-float('inf')
        ans=-1
        for i,j in hmap.items():
            if j[0]>value:
                value=j[0]
                ans=j[1]
            if j[0]==value:
                ans=min(ans,j[1])
        return ans",
"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        st1,st2=[],[]
        heapify(st2)
        ans=[-1 for i in range(len(nums))]
        for i in range(len(nums)):
            while st2 and nums[-st2[0]]<nums[i]:
                ans[-heappop(st2)]=nums[i]
            while st1 and nums[st1[-1]]<nums[i]:
                heappush(st2,-st1.pop())
            st1.append(i)
        return ans",
"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        sum, count = 0,0
        for n in nums:
            if n % 3 == 0 and n % 2 == 0:
                sum += n
                count += 1
        if count == 0: return 0
        return int(sum/count)",
"class Solution:
    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:
        total_views = {}
        first_max_view = {}
        
        for i in range(len(creators)):
            total_views[creators[i]] = total_views.get(creators[i], 0)+views[i]
            
            if creators[i] in first_max_view:
                if views[i] > views[first_max_view[creators[i]]]: #update value with highest view id
                    first_max_view[creators[i]] = i
                elif views[i] == views[first_max_view[creators[i]]]: #if views of some video are equal update with lexicographically smallest id.
                    if ids[i] < ids[first_max_view[creators[i]]]:
                        first_max_view[creators[i]] = i
            else:
                first_max_view[creators[i]] = i
        
        max_views = max(total_views.values())
        ans = []
        
        for name in total_views:
            if total_views[name] == max_views: #select most popular video creators
                ans.append([name, ids[first_max_view[name]]])
                
        return ans",
"class Solution:
    def makeIntegerBeautiful(self, n: int, target: int) -> int:
        
		#function to get sum of digits
        def sumofc(num):
            s = 0
            while num != 0:
                s += num % 10
                num = int(num/10)
            return s
        
        sumc = sumofc(n)
        ans = 0
        tmpn = n
        multp = 1
		#keep making last digit zero till sum of digits is less than target
        while sumc > target:
            lastn = tmpn % 10
            tmpn = int(tmpn/10) + 1
            ans = ans + multp * (10 - lastn)
            sumc = sumofc(tmpn)
            multp = multp * 10
         
        return ans",
"class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        depth = {}
        height = {0 : 0}
        
        def fn(node, d): 
            if not node: return 0 
            depth[node.val] = d
            height[node.val] = 1 + max(fn(node.left, d+1), fn(node.right, d+1))
            return height[node.val]
        
        h = fn(root, 0)
        level = [[0, 0] for _ in range(h)]
        for k, v in depth.items(): 
            if height[k] >= height[level[v][0]]: level[v] = [k, level[v][0]]
            elif height[k] > height[level[v][1]]: level[v][1] = k
        ans = []
        for q in queries: 
            d = depth[q]
            if q == level[d][0]: ans.append(h-1-height[q]+height[level[d][1]])
            else: ans.append(h-1)
        return ans",
"class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        ans = []
        for i, x in enumerate(nums): 
            if i+1 < len(nums) and nums[i] == nums[i+1]: 
                nums[i] *= 2
                nums[i+1] = 0 
            if nums[i]: ans.append(nums[i])
        return ans + [0]*(len(nums)-len(ans))",
"class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        left, right = 0,0
        max_sum = 0
        n = len(nums)
        seen = {}
        current_sum = 0
        while right<n:
            seen[nums[right]] = seen.get(nums[right], 0)+1
            current_sum += nums[right]
            if right-left+1 == k:
                if len(seen) == k:
                    max_sum = max(max_sum, current_sum)
                if seen[nums[left]]>1:
                    seen[nums[left]]-=1
                else:
                    del seen[nums[left]]
                current_sum-=nums[left]
                left+=1
            right+=1
        
        return max_sum",
"class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        n = len(costs)
        first = []
        last = []
        res = 0
        l = 0
        r = len(costs) - 1
        for i in range(candidates):
            heapq.heappush(first, costs[l])
            heapq.heappush(last, costs[r])
            l += 1
            r -= 1
            if l + 1 > r:
                break
        for i in range(k):
            if not last or (first and first[0] <= last[0]):
                res += heapq.heappop(first)
                if l <= r:
                    heapq.heappush(first, costs[l])
                    l += 1
            elif not first or (last and last[0] < first[0]):
                res += heapq.heappop(last)
                if r >= l:
                    heapq.heappush(last, costs[r])
                    r -= 1
        return res

class Solution {
    public long totalCost(int[] costs, int k, int candidates) {
        int n  = costs.length;
        Queue<Integer> first = new PriorityQueue<>();
        Queue<Integer> last = new PriorityQueue<>();
        long res = 0;
        int l = 0;
        int r = n - 1;
        for (int i = 0; i < candidates; i ++) {
            first.offer(costs[l]);
            last.offer(costs[r]);
            l ++;
            r --;
            if (l + 1 > r) {
                break;
            }
        }
        for (int i = 0; i < k; i ++) {
            if (last.isEmpty() || (!first.isEmpty() &amp;&amp; first.peek() <= last.peek())) {
                res += (long)first.poll();
                if (l <= r) {
                    first.offer(costs[l]);
                    l ++;
                }
            } else if (first.isEmpty() || (!last.isEmpty() &amp;&amp; last.peek() < first.peek())) {
                res += (long)last.poll();
                if (r >= l) {
                    last.offer(costs[r]);
                    r --;
                }
            }
        }
        return res;
    }
}",
"class Solution:
    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:
        
        @cache
        def dfs(i, j, k):
            if j == 0: #no robot available
                return 0
            if i == 0: #no factory available
                return float('inf')
            if k == 0: #the ith factory has 0 spot to use
                if i == 1: #if there'ls only one factory left
                    return float('inf')
                return dfs(i - 1, j, factory[i - 2][1]) #since the ith factory has no spot, we have to not use it

            
            result1 = dfs(i - 1, j, factory[i - 2][1]) if i >= 2 else float('inf') #condition 1: don't use the ith factory
            result2 = dfs(i, j - 1, k - 1) + abs(robot[j - 1] - factory[i - 1][0])#condition 2: use the ith factory
            result = min(result1, result2)
            return result
                
        
        
        m, n = len(robot), len(factory)
        robot.sort()
        factory.sort()
        result = dfs(n, m, factory[n - 1][1])
        return result",
"class Solution:
    def distinctAverages(self, nums: List[int]) -> int:
        
        ans = set()
        nums.sort()
        queue = deque(nums)
        
        while queue:
            low = queue.popleft()
            high = queue.pop()
            ans.add((low+high)/2)
        
        return len(ans)",
"class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        dp = [0]*(high+1)
        dp[zero] += 1
        dp[one] += 1
        mod = (10**9)+7
        for i in range(min(zero,one)+1,high+1):
            if i-zero>=0:
                dp[i]+=dp[i-zero]
            if i-one>=0:
                dp[i]+=dp[i-one]
        s = 0
        for i in range(low,high+1):
            s+=dp[i]
        return s%mod",
"class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        graph = defaultdict(list)
        
        for edge in edges:
            graph[edge[0]].append(edge[1])
            graph[edge[1]].append(edge[0])
        
        def bob_dfs(curr_node, prev_node, count):
            if curr_node == 0:
                return count
            if prev_node != None and len(graph[curr_node]) == 1 and curr_node != 0:
                return -1
            
            for node in graph[curr_node]:
                if node == prev_node:
                    continue
                res = bob_dfs(node, curr_node, count + 1)
                if res != -1:
                    if count < (res + 1) // 2:
                        amount[curr_node] = 0
                    if res % 2 == 0 and res // 2 == count:
                        amount[curr_node] /= 2
                    return res
            return -1  
        
        bob_dfs(bob, None, 0)
        leafs_res = []
        
        def sum_dfs(curr_node, curr_sum, prev_node):
            if len(graph[curr_node]) == 1 and curr_node != 0:
                leafs_res.append(curr_sum + amount[curr_node])
            
            for node in graph[curr_node]:
                if node == prev_node:
                    continue
                sum_dfs(node, curr_sum + amount[curr_node], curr_node)
        
        sum_dfs(0, 0, None)
        
        res = max(leafs_res)
        if res % 1 == 0:
            return int(res)
        else:
            return res",
"class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        n = len(message)
        best = math.inf
        def check(x):
            avail = 0
            start = 1
            while start <= x:
                next_start = start * 10
                suffix = f""<{start}/{x}>""
                if len(suffix) > limit:
                    return False
                avail += (min(next_start - 1, x) - start + 1) * (limit - len(suffix))
                start = next_start
            last_suffix = f""<{x}/{x}>""
            return avail >= n >= avail - (limit - len(last_suffix))
        
        for n_part in range(1, n + 1):
            if check(n_part):
                break
        else:
            return []
        
        ans = []
        start = 0
        for i in range(1, n_part + 1):
            suffix = f""<{i}/{n_part}>""
            next_start = start + limit - len(suffix)
            ans.append(message[start:next_start] + suffix)
            start = next_start
        return ans",
"class Solution:
    def convertTemperature(self, celsius: float) -> List[float]:
        return [celsius + 273.15, celsius * 1.80 + 32.00]",
"class Solution:
    def subarrayLCM(self, nums: List[int], k: int) -> int:
        num_subarray = 0
        n = len(nums)
        for i in range(n):
            lcm = nums[i]
            for j in range(i, n):
                lcm = math.lcm(lcm, nums[j])
                if lcm > k:
                    break
                else:
                    num_subarray += (lcm == k)
        return num_subarray",
"class Solution:
    def countswaps(self, arr):
        count = 0
        temp = sorted(arr)
        h = {}
        
        for i in range(len(arr)):
            h[arr[i]] = i
        
        for i in range(len(arr)):
            if arr[i] != temp[i]:
                count += 1
                
                # swap to correct place
                j = h[temp[i]]
                
                h[arr[i]], h[arr[j]] = j, i
                arr[i], arr[j] = arr[j], arr[i]
        
        return count
        
    
    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        q = collections.deque()
        q.append(root)
        ans = 0
        
        while q:
            size = len(q)
            level = []
            for _ in range(size):
                temp = q.popleft()
                level.append(temp.val)
                
                if temp.left:
                    q.append(temp.left)
                if temp.right:
                    q.append(temp.right)

            ans += self.countswaps(level)
            
        return ans",
"class Solution:
    def maxPalindromes(self, s: str, k: int) -> int:
        n = len(s)
        vals = [1]*n
        for i in range(2*n-1): 
            lo, hi = i//2, (i+1)//2
            while 0 <= lo <= hi < n and s[lo] == s[hi]: 
                if vals[lo] < k: vals[lo] = max(vals[lo], hi-lo+1)
                lo -= 1
                hi += 1
        dp = [0]*(n+1)
        for i in range(n-1, -1, -1): 
            dp[i] = dp[i+1]
            if vals[i] >= k: dp[i] = max(dp[i], 1+dp[i+vals[i]])
        return dp[0]",
"class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        n = len(nums)
        res = 0
        for i in range(n - 2):
            for j in range(i + 1, n - 1):
                for k in range(j + 1, n):
                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:
                        res += 1
        return res



class Solution {
    public int unequalTriplets(int[] nums) {
        int n = nums.length;
        int res = 0;
        for (int i = 0; i < n - 2; i ++) {
            for (int j = i + 1; j < n - 1; j ++) {
                for (int k = j + 1; k < n; k ++) {
                    if (nums[i] != nums[j] &amp;&amp; nums[i] != nums[k] &amp;&amp; nums[j] != nums[k]) {
                        res ++;
                    }
                }
            }
        }
        return res;
    }
}",
"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        d = defaultdict(list)
        q = deque([])
        c = Counter()
        c_acc = Counter()
        
        for x, y in roads:
            d[x].append(y)
            d[y].append(x)
            c[x] += 1
            c[y] += 1        
        
        for k, v in c.items():
            if v == 1 and k!=0:
                q.append(k)
                c_acc[k] += 1
                        
        res = 0        
        while q:
            node = q.popleft()
            p = c_acc[node]                                    
            res += ceil(p/seats)            
            for nei in d[node]:
                c_acc[nei] += p
                c[nei] -= 1
                
                if c[nei] == 1 and nei != 0:
                    c_acc[nei] += 1
                    q.append(nei)
        return res",
"class Solution:
    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
        s=list(s)
        l0=len(s)
        prime={'2', '3', '5', '7'}
        for i in range(l0):
            s[i]=s[i] in prime
        if not s[0]:
            return 0
        if s[-1]:
            return 0
        p=10**9+7
        stops=[0]
        for i in range(l0-1):
            if (not s[i]) and s[i+1]:
                stops.append(i+1)
        l1=len(stops)

        def bp(i, k):
            if l0-stops[i]<k*minLength:
                return 0
            if k==1:
                return 1                    
            i1=i+1
            while i1<l1 and stops[i1]<stops[i]+minLength:
                i1+=1
            return sm[i1]%p

        for j in range(1, k+1):
            table=[bp(i, j) for i in range(l1)]
            sm=[]
            tmp=0
            for t in table:
                sm.append(tmp)
                tmp+=t
            sm.append(tmp)
            for i in range(l1+1):
                sm[i]=tmp-sm[i]
        
        return table[0]",
